/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 39:
/***/ (function(__unused_webpack_module, exports) {

!function(t,e){ true?e(exports):0}(this,function(t){"use strict";function e(){}function n(t){this.message=t||""}function i(t){this.message=t||""}function r(t){this.message=t||""}function o(){}function s(t){return null===t?Mt:t.color}function a(t){return null===t?null:t.parent}function u(t,e){null!==t&&(t.color=e)}function l(t){return null===t?null:t.left}function c(t){return null===t?null:t.right}function p(){this.root_=null,this.size_=0}function h(){}function f(){this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0])}function g(){}function d(t){this.message=t||""}function y(){this.array_=[]}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(t){if(void 0===this||null===this)throw new TypeError(this+" is not an object");var e=Object(this),n=Math.max(Math.min(e.length,9007199254740991),0)||0,i=1 in arguments?parseInt(Number(arguments[1]),10)||0:0;i=i<0?Math.max(n+i,0):Math.min(i,n);var r=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:n;for(r=r<0?Math.max(n+arguments[2],0):Math.min(r,n);i<r;)e[i]=t,++i;return e},writable:!0}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!=t},Math.trunc=Math.trunc||function(t){return t<0?Math.ceil(t):Math.floor(t)};var _=function(){};_.prototype.interfaces_=function(){return[]},_.prototype.getClass=function(){return _},_.prototype.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n};var m=function(t){function e(e){t.call(this,e),this.name="IllegalArgumentException",this.message=e,this.stack=(new t).stack}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),v=function(){},I={MAX_VALUE:{configurable:!0}};v.isNaN=function(t){return Number.isNaN(t)},v.doubleToLongBits=function(t){return t},v.longBitsToDouble=function(t){return t},v.isInfinite=function(t){return!Number.isFinite(t)},I.MAX_VALUE.get=function(){return Number.MAX_VALUE},Object.defineProperties(v,I);var E=function(){},x=function(){},N=function(){},C=function t(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)this.x=0,this.y=0,this.z=t.NULL_ORDINATE;else if(1===arguments.length){var e=arguments[0];this.x=e.x,this.y=e.y,this.z=e.z}else 2===arguments.length?(this.x=arguments[0],this.y=arguments[1],this.z=t.NULL_ORDINATE):3===arguments.length&&(this.x=arguments[0],this.y=arguments[1],this.z=arguments[2])},S={DimensionalComparator:{configurable:!0},serialVersionUID:{configurable:!0},NULL_ORDINATE:{configurable:!0},X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0}};C.prototype.setOrdinate=function(t,e){switch(t){case C.X:this.x=e;break;case C.Y:this.y=e;break;case C.Z:this.z=e;break;default:throw new m("Invalid ordinate index: "+t)}},C.prototype.equals2D=function(){if(1===arguments.length){var t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!_.equalsWithTolerance(this.x,e.x,n)&&!!_.equalsWithTolerance(this.y,e.y,n)}},C.prototype.getOrdinate=function(t){switch(t){case C.X:return this.x;case C.Y:return this.y;case C.Z:return this.z}throw new m("Invalid ordinate index: "+t)},C.prototype.equals3D=function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||v.isNaN(this.z))&&v.isNaN(t.z)},C.prototype.equals=function(t){return t instanceof C&&this.equals2D(t)},C.prototype.equalInZ=function(t,e){return _.equalsWithTolerance(this.z,t.z,e)},C.prototype.compareTo=function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},C.prototype.clone=function(){},C.prototype.copy=function(){return new C(this)},C.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"},C.prototype.distance3D=function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},C.prototype.distance=function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},C.prototype.hashCode=function(){var t=17;return t=37*t+C.hashCode(this.x),t=37*t+C.hashCode(this.y)},C.prototype.setCoordinate=function(t){this.x=t.x,this.y=t.y,this.z=t.z},C.prototype.interfaces_=function(){return[E,x,e]},C.prototype.getClass=function(){return C},C.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=v.doubleToLongBits(t);return Math.trunc((e^e)>>>32)}},S.DimensionalComparator.get=function(){return L},S.serialVersionUID.get=function(){return 0x5cbf2c235c7e5800},S.NULL_ORDINATE.get=function(){return v.NaN},S.X.get=function(){return 0},S.Y.get=function(){return 1},S.Z.get=function(){return 2},Object.defineProperties(C,S);var L=function(t){if(this._dimensionsToTest=2,0===arguments.length);else if(1===arguments.length){var e=arguments[0];if(2!==e&&3!==e)throw new m("only 2 or 3 dimensions may be specified");this._dimensionsToTest=e}};L.prototype.compare=function(t,e){var n=t,i=e,r=L.compare(n.x,i.x);if(0!==r)return r;var o=L.compare(n.y,i.y);if(0!==o)return o;if(this._dimensionsToTest<=2)return 0;return L.compare(n.z,i.z)},L.prototype.interfaces_=function(){return[N]},L.prototype.getClass=function(){return L},L.compare=function(t,e){return t<e?-1:t>e?1:v.isNaN(t)?v.isNaN(e)?0:-1:v.isNaN(e)?1:0};var b=function(){};b.prototype.create=function(){},b.prototype.interfaces_=function(){return[]},b.prototype.getClass=function(){return b};var w=function(){},O={INTERIOR:{configurable:!0},BOUNDARY:{configurable:!0},EXTERIOR:{configurable:!0},NONE:{configurable:!0}};w.prototype.interfaces_=function(){return[]},w.prototype.getClass=function(){return w},w.toLocationSymbol=function(t){switch(t){case w.EXTERIOR:return"e";case w.BOUNDARY:return"b";case w.INTERIOR:return"i";case w.NONE:return"-"}throw new m("Unknown location value: "+t)},O.INTERIOR.get=function(){return 0},O.BOUNDARY.get=function(){return 1},O.EXTERIOR.get=function(){return 2},O.NONE.get=function(){return-1},Object.defineProperties(w,O);var T=function(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1},R=function(){},P={LOG_10:{configurable:!0}};R.prototype.interfaces_=function(){return[]},R.prototype.getClass=function(){return R},R.log10=function(t){var e=Math.log(t);return v.isInfinite(e)?e:v.isNaN(e)?e:e/R.LOG_10},R.min=function(t,e,n,i){var r=t;return e<r&&(r=e),n<r&&(r=n),i<r&&(r=i),r},R.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],o=arguments[2];return i<r?r:i>o?o:i}},R.wrap=function(t,e){return t<0?e- -t%e:t%e},R.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3],u=r;return o>u&&(u=o),s>u&&(u=s),a>u&&(u=a),u}},R.average=function(t,e){return(t+e)/2},P.LOG_10.get=function(){return Math.log(10)},Object.defineProperties(R,P);var D=function(t){this.str=t};D.prototype.append=function(t){this.str+=t},D.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},D.prototype.toString=function(t){return this.str};var M=function(t){this.value=t};M.prototype.intValue=function(){return this.value},M.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},M.isNaN=function(t){return Number.isNaN(t)};var A=function(){};A.isWhitespace=function(t){return t<=32&&t>=0||127===t},A.toUpperCase=function(t){return t.toUpperCase()};var F=function t(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var e=arguments[0];this.init(e)}else if(arguments[0]instanceof t){var n=arguments[0];this.init(n)}else if("string"==typeof arguments[0]){var i=arguments[0];t.call(this,t.parse(i))}}else if(2===arguments.length){var r=arguments[0],o=arguments[1];this.init(r,o)}},G={PI:{configurable:!0},TWO_PI:{configurable:!0},PI_2:{configurable:!0},E:{configurable:!0},NaN:{configurable:!0},EPS:{configurable:!0},SPLIT:{configurable:!0},MAX_PRINT_DIGITS:{configurable:!0},TEN:{configurable:!0},ONE:{configurable:!0},SCI_NOT_EXPONENT_CHAR:{configurable:!0},SCI_NOT_ZERO:{configurable:!0}};F.prototype.le=function(t){return(this._hi<t._hi||this._hi===t._hi)&&this._lo<=t._lo},F.prototype.extractSignificantDigits=function(t,e){var n=this.abs(),i=F.magnitude(n._hi),r=F.TEN.pow(i);(n=n.divide(r)).gt(F.TEN)?(n=n.divide(F.TEN),i+=1):n.lt(F.ONE)&&(n=n.multiply(F.TEN),i-=1);for(var o=i+1,s=new D,a=F.MAX_PRINT_DIGITS-1,u=0;u<=a;u++){t&&u===o&&s.append(".");var l=Math.trunc(n._hi);if(l<0)break;var c=!1,p=0;l>9?(c=!0,p="9"):p="0"+l,s.append(p),n=n.subtract(F.valueOf(l)).multiply(F.TEN),c&&n.selfAdd(F.TEN);var h=!0,f=F.magnitude(n._hi);if(f<0&&Math.abs(f)>=a-u&&(h=!1),!h)break}return e[0]=i,s.toString()},F.prototype.sqr=function(){return this.multiply(this)},F.prototype.doubleValue=function(){return this._hi+this._lo},F.prototype.subtract=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},F.prototype.equals=function(){if(1===arguments.length){var t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}},F.prototype.isZero=function(){return 0===this._hi&&0===this._lo},F.prototype.selfSubtract=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},F.prototype.getSpecialNumberString=function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},F.prototype.min=function(t){return this.le(t)?this:t},F.prototype.selfDivide=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,o=null,s=null,a=null,u=null,l=null,c=null,p=null;return u=this._hi/n,l=F.SPLIT*u,r=l-u,p=F.SPLIT*n,r=l-r,o=u-r,s=p-n,c=u*n,s=p-s,a=n-s,p=r*s-c+r*a+o*s+o*a,l=(this._hi-c-p+this._lo-u*i)/n,p=u+l,this._hi=p,this._lo=u-p+l,this}},F.prototype.dump=function(){return"DD<"+this._hi+", "+this._lo+">"},F.prototype.divide=function(){if(arguments[0]instanceof F){var t=arguments[0],e=null,n=null,i=null,r=null,o=null,s=null,a=null,u=null;n=(o=this._hi/t._hi)-(e=(s=F.SPLIT*o)-(e=s-o)),u=e*(i=(u=F.SPLIT*t._hi)-(i=u-t._hi))-(a=o*t._hi)+e*(r=t._hi-i)+n*i+n*r,s=(this._hi-a-u+this._lo-o*t._lo)/t._hi;return new F(u=o+s,o-u+s)}if("number"==typeof arguments[0]){var l=arguments[0];return v.isNaN(l)?F.createNaN():F.copy(this).selfDivide(l,0)}},F.prototype.ge=function(t){return(this._hi>t._hi||this._hi===t._hi)&&this._lo>=t._lo},F.prototype.pow=function(t){if(0===t)return F.valueOf(1);var e=new F(this),n=F.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),(i/=2)>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n},F.prototype.ceil=function(){if(this.isNaN())return F.NaN;var t=Math.ceil(this._hi),e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new F(t,e)},F.prototype.compareTo=function(t){var e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0},F.prototype.rint=function(){if(this.isNaN())return this;return this.add(.5).floor()},F.prototype.setValue=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},F.prototype.max=function(t){return this.ge(t)?this:t},F.prototype.sqrt=function(){if(this.isZero())return F.valueOf(0);if(this.isNegative())return F.NaN;var t=1/Math.sqrt(this._hi),e=this._hi*t,n=F.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)},F.prototype.selfAdd=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,o=null,s=null,a=null;return r=this._hi+e,s=r-this._hi,o=r-s,o=e-s+(this._hi-o),a=o+this._lo,n=r+a,i=a+(r-n),this._hi=n+i,this._lo=i+(n-this._hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],c=null,p=null,h=null,f=null,g=null,d=null,y=null;f=this._hi+u,p=this._lo+l,g=f-(d=f-this._hi),h=p-(y=p-this._lo);var _=(c=f+(d=(g=u-d+(this._hi-g))+p))+(d=(h=l-y+(this._lo-h))+(d+(f-c))),m=d+(c-_);return this._hi=_,this._lo=m,this}},F.prototype.selfMultiply=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,o=null,s=null,a=null,u=null,l=null;r=(u=F.SPLIT*this._hi)-this._hi,l=F.SPLIT*n,r=u-r,o=this._hi-r,s=l-n;var c=(u=this._hi*n)+(l=r*(s=l-s)-u+r*(a=n-s)+o*s+o*a+(this._hi*i+this._lo*n)),p=l+(r=u-c);return this._hi=c,this._lo=p,this}},F.prototype.selfSqr=function(){return this.selfMultiply(this)},F.prototype.floor=function(){if(this.isNaN())return F.NaN;var t=Math.floor(this._hi),e=0;return t===this._hi&&(e=Math.floor(this._lo)),new F(t,e)},F.prototype.negate=function(){return this.isNaN()?this:new F(-this._hi,-this._lo)},F.prototype.clone=function(){},F.prototype.multiply=function(){if(arguments[0]instanceof F){var t=arguments[0];return t.isNaN()?F.createNaN():F.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return v.isNaN(e)?F.createNaN():F.copy(this).selfMultiply(e,0)}},F.prototype.isNaN=function(){return v.isNaN(this._hi)},F.prototype.intValue=function(){return Math.trunc(this._hi)},F.prototype.toString=function(){var t=F.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()},F.prototype.toStandardNotation=function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(i<0)r="0."+F.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var o=i-n.length;r=n+F.stringOfChar("0",o)+".0"}return this.isNegative()?"-"+r:r},F.prototype.reciprocal=function(){var t=null,e=null,n=null,i=null,r=null,o=null,s=null,a=null;e=(r=1/this._hi)-(t=(o=F.SPLIT*r)-(t=o-r)),n=(a=F.SPLIT*this._hi)-this._hi;var u=r+(o=(1-(s=r*this._hi)-(a=t*(n=a-n)-s+t*(i=this._hi-n)+e*n+e*i)-r*this._lo)/this._hi);return new F(u,r-u+o)},F.prototype.toSciNotation=function(){if(this.isZero())return F.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=F.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new Error("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var o=n.charAt(0)+"."+r;return this.isNegative()?"-"+o+i:o+i},F.prototype.abs=function(){return this.isNaN()?F.NaN:this.isNegative()?this.negate():new F(this)},F.prototype.isPositive=function(){return(this._hi>0||0===this._hi)&&this._lo>0},F.prototype.lt=function(t){return(this._hi<t._hi||this._hi===t._hi)&&this._lo<t._lo},F.prototype.add=function(){if(arguments[0]instanceof F){var t=arguments[0];return F.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return F.copy(this).selfAdd(e)}},F.prototype.init=function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof F){var e=arguments[0];this._hi=e._hi,this._lo=e._lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this._hi=n,this._lo=i}},F.prototype.gt=function(t){return(this._hi>t._hi||this._hi===t._hi)&&this._lo>t._lo},F.prototype.isNegative=function(){return(this._hi<0||0===this._hi)&&this._lo<0},F.prototype.trunc=function(){return this.isNaN()?F.NaN:this.isPositive()?this.floor():this.ceil()},F.prototype.signum=function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0},F.prototype.interfaces_=function(){return[e,E,x]},F.prototype.getClass=function(){return F},F.sqr=function(t){return F.valueOf(t).selfMultiply(t)},F.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return F.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new F(e)}},F.sqrt=function(t){return F.valueOf(t).sqrt()},F.parse=function(t){for(var e=0,n=t.length;A.isWhitespace(t.charAt(e));)e++;var i=!1;if(e<n){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var o=new F,s=0,a=0,u=0;!(e>=n);){var l=t.charAt(e);if(e++,A.isDigit(l)){var c=l-"0";o.selfMultiply(F.TEN),o.selfAdd(c),s++}else{if("."!==l){if("e"===l||"E"===l){var p=t.substring(e);try{u=M.parseInt(p)}catch(e){throw e instanceof Error?new Error("Invalid exponent "+p+" in string "+t):e}break}throw new Error("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=s}}var h=o,f=s-a-u;if(0===f)h=o;else if(f>0){var g=F.TEN.pow(f);h=o.divide(g)}else if(f<0){var d=F.TEN.pow(-f);h=o.multiply(d)}return i?h.negate():h},F.createNaN=function(){return new F(v.NaN,v.NaN)},F.copy=function(t){return new F(t)},F.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i},F.stringOfChar=function(t,e){for(var n=new D,i=0;i<e;i++)n.append(t);return n.toString()},G.PI.get=function(){return new F(3.141592653589793,1.2246467991473532e-16)},G.TWO_PI.get=function(){return new F(6.283185307179586,2.4492935982947064e-16)},G.PI_2.get=function(){return new F(1.5707963267948966,6.123233995736766e-17)},G.E.get=function(){return new F(2.718281828459045,1.4456468917292502e-16)},G.NaN.get=function(){return new F(v.NaN,v.NaN)},G.EPS.get=function(){return 1.23259516440783e-32},G.SPLIT.get=function(){return 134217729},G.MAX_PRINT_DIGITS.get=function(){return 32},G.TEN.get=function(){return F.valueOf(10)},G.ONE.get=function(){return F.valueOf(1)},G.SCI_NOT_EXPONENT_CHAR.get=function(){return"E"},G.SCI_NOT_ZERO.get=function(){return"0.0E0"},Object.defineProperties(F,G);var q=function(){},B={DP_SAFE_EPSILON:{configurable:!0}};q.prototype.interfaces_=function(){return[]},q.prototype.getClass=function(){return q},q.orientationIndex=function(t,e,n){var i=q.orientationIndexFilter(t,e,n);if(i<=1)return i;var r=F.valueOf(e.x).selfAdd(-t.x),o=F.valueOf(e.y).selfAdd(-t.y),s=F.valueOf(n.x).selfAdd(-e.x),a=F.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()},q.signOfDet2x2=function(t,e,n,i){return t.multiply(i).selfSubtract(e.multiply(n)).signum()},q.intersection=function(t,e,n,i){var r=F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(e.x).selfSubtract(t.x)),o=F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(e.y).selfSubtract(t.y)),s=r.subtract(o),a=F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),u=F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u).selfDivide(s).doubleValue(),c=F.valueOf(t.x).selfAdd(F.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),p=F.valueOf(e.x).selfSubtract(t.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),h=F.valueOf(e.y).selfSubtract(t.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),f=p.subtract(h).selfDivide(s).doubleValue(),g=F.valueOf(n.y).selfAdd(F.valueOf(i.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();return new C(c,g)},q.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),o=(t.y-n.y)*(e.x-n.x),s=r-o;if(r>0){if(o<=0)return q.signum(s);i=r+o}else{if(!(r<0))return q.signum(s);if(o>=0)return q.signum(s);i=-r-o}var a=q.DP_SAFE_EPSILON*i;return s>=a||-s>=a?q.signum(s):2},q.signum=function(t){return t>0?1:t<0?-1:0},B.DP_SAFE_EPSILON.get=function(){return 1e-15},Object.defineProperties(q,B);var V=function(){},U={X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0},M:{configurable:!0}};U.X.get=function(){return 0},U.Y.get=function(){return 1},U.Z.get=function(){return 2},U.M.get=function(){return 3},V.prototype.setOrdinate=function(t,e,n){},V.prototype.size=function(){},V.prototype.getOrdinate=function(t,e){},V.prototype.getCoordinate=function(){},V.prototype.getCoordinateCopy=function(t){},V.prototype.getDimension=function(){},V.prototype.getX=function(t){},V.prototype.clone=function(){},V.prototype.expandEnvelope=function(t){},V.prototype.copy=function(){},V.prototype.getY=function(t){},V.prototype.toCoordinateArray=function(){},V.prototype.interfaces_=function(){return[x]},V.prototype.getClass=function(){return V},Object.defineProperties(V,U);var z=function(){},X=function(t){function e(){t.call(this,"Projective point not representable on the Cartesian plane.")}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(z),Y=function(){};Y.arraycopy=function(t,e,n,i,r){for(var o=0,s=e;s<e+r;s++)n[i+o]=t[s],o++},Y.getProperty=function(t){return{"line.separator":"\n"}[t]};var k=function t(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var e=arguments[0];this.x=e.x,this.y=e.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.x=n,this.y=i,this.w=1}else if(arguments[0]instanceof t&&arguments[1]instanceof t){var r=arguments[0],o=arguments[1];this.x=r.y*o.w-o.y*r.w,this.y=o.x*r.w-r.x*o.w,this.w=r.x*o.y-o.x*r.y}else if(arguments[0]instanceof C&&arguments[1]instanceof C){var s=arguments[0],a=arguments[1];this.x=s.y-a.y,this.y=a.x-s.x,this.w=s.x*a.y-a.x*s.y}}else if(3===arguments.length){var u=arguments[0],l=arguments[1],c=arguments[2];this.x=u,this.y=l,this.w=c}else if(4===arguments.length){var p=arguments[0],h=arguments[1],f=arguments[2],g=arguments[3],d=p.y-h.y,y=h.x-p.x,_=p.x*h.y-h.x*p.y,m=f.y-g.y,v=g.x-f.x,I=f.x*g.y-g.x*f.y;this.x=y*I-v*_,this.y=m*_-d*I,this.w=d*v-m*y}};k.prototype.getY=function(){var t=this.y/this.w;if(v.isNaN(t)||v.isInfinite(t))throw new X;return t},k.prototype.getX=function(){var t=this.x/this.w;if(v.isNaN(t)||v.isInfinite(t))throw new X;return t},k.prototype.getCoordinate=function(){var t=new C;return t.x=this.getX(),t.y=this.getY(),t},k.prototype.interfaces_=function(){return[]},k.prototype.getClass=function(){return k},k.intersection=function(t,e,n,i){var r=t.y-e.y,o=e.x-t.x,s=t.x*e.y-e.x*t.y,a=n.y-i.y,u=i.x-n.x,l=n.x*i.y-i.x*n.y,c=r*u-a*o,p=(o*l-u*s)/c,h=(a*s-r*l)/c;if(v.isNaN(p)||v.isInfinite(p)||v.isNaN(h)||v.isInfinite(h))throw new X;return new C(p,h)};var j=function t(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof C){var e=arguments[0];this.init(e.x,e.x,e.y,e.y)}else if(arguments[0]instanceof t){var n=arguments[0];this.init(n)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i.x,r.x,i.y,r.y)}else if(4===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2],u=arguments[3];this.init(o,s,a,u)}},H={serialVersionUID:{configurable:!0}};j.prototype.getArea=function(){return this.getWidth()*this.getHeight()},j.prototype.equals=function(t){if(!(t instanceof j))return!1;var e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()},j.prototype.intersection=function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new j;var e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,r=this._maxy<t._maxy?this._maxy:t._maxy;return new j(e,i,n,r)},j.prototype.isNull=function(){return this._maxx<this._minx},j.prototype.getMaxX=function(){return this._maxx},j.prototype.covers=function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof j){var e=arguments[0];return!this.isNull()&&!e.isNull()&&(e.getMinX()>=this._minx&&e.getMaxX()<=this._maxx&&e.getMinY()>=this._miny&&e.getMaxY()<=this._maxy)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return!this.isNull()&&(n>=this._minx&&n<=this._maxx&&i>=this._miny&&i<=this._maxy)}},j.prototype.intersects=function(){if(1===arguments.length){if(arguments[0]instanceof j){var t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof C){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return!this.isNull()&&!(n>this._maxx||n<this._minx||i>this._maxy||i<this._miny)}},j.prototype.getMinY=function(){return this._miny},j.prototype.getMinX=function(){return this._minx},j.prototype.expandToInclude=function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof j){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this._minx=e.getMinX(),this._maxx=e.getMaxX(),this._miny=e.getMinY(),this._maxy=e.getMaxY()):(e._minx<this._minx&&(this._minx=e._minx),e._maxx>this._maxx&&(this._maxx=e._maxx),e._miny<this._miny&&(this._miny=e._miny),e._maxy>this._maxy&&(this._maxy=e._maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this._minx=n,this._maxx=n,this._miny=i,this._maxy=i):(n<this._minx&&(this._minx=n),n>this._maxx&&(this._maxx=n),i<this._miny&&(this._miny=i),i>this._maxy&&(this._maxy=i))}},j.prototype.minExtent=function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t<e?t:e},j.prototype.getWidth=function(){return this.isNull()?0:this._maxx-this._minx},j.prototype.compareTo=function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0},j.prototype.translate=function(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},j.prototype.toString=function(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"},j.prototype.setToNull=function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1},j.prototype.getHeight=function(){return this.isNull()?0:this._maxy-this._miny},j.prototype.maxExtent=function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},j.prototype.expandBy=function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this._minx-=e,this._maxx+=e,this._miny-=n,this._maxy+=n,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}},j.prototype.contains=function(){if(1===arguments.length){if(arguments[0]instanceof j){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof C){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},j.prototype.centre=function(){return this.isNull()?null:new C((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},j.prototype.init=function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof j){var e=arguments[0];this._minx=e._minx,this._maxx=e._maxx,this._miny=e._miny,this._maxy=e._maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];r<o?(this._minx=r,this._maxx=o):(this._minx=o,this._maxx=r),s<a?(this._miny=s,this._maxy=a):(this._miny=a,this._maxy=s)}},j.prototype.getMaxY=function(){return this._maxy},j.prototype.distance=function(t){if(this.intersects(t))return 0;var e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);var n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},j.prototype.hashCode=function(){var t=17;return t=37*t+C.hashCode(this._minx),t=37*t+C.hashCode(this._maxx),t=37*t+C.hashCode(this._miny),t=37*t+C.hashCode(this._maxy)},j.prototype.interfaces_=function(){return[E,e]},j.prototype.getClass=function(){return j},j.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2],s=arguments[3],a=Math.min(o.x,s.x),u=Math.max(o.x,s.x),l=Math.min(i.x,r.x),c=Math.max(i.x,r.x);return!(l>u)&&(!(c<a)&&(a=Math.min(o.y,s.y),u=Math.max(o.y,s.y),l=Math.min(i.y,r.y),c=Math.max(i.y,r.y),!(l>u)&&!(c<a)))}},H.serialVersionUID.get=function(){return 0x51845cd552189800},Object.defineProperties(j,H);var W={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/},K=function(t){this.geometryFactory=t||new _e};K.prototype.read=function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=W.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((r=W.emptyTypeStr.exec(t))[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],Q[n]&&(e=Q[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},K.prototype.write=function(t){return this.extractGeometry(t)},K.prototype.extractGeometry=function(t){var e=t.getGeometryType().toLowerCase();if(!J[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+J[e].apply(this,[t])+")"};var J={coordinate:function(t){return t.x+" "+t.y},point:function(t){return J.coordinate.call(this,t._coordinates._coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.point.apply(this,[t._geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t._points._coordinates.length;n<i;++n)e.push(J.coordinate.apply(this,[t._points._coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t._points._coordinates.length;n<i;++n)e.push(J.coordinate.apply(this,[t._points._coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.linestring.apply(this,[t._geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+J.linestring.apply(this,[t._shell])+")");for(var n=0,i=t._holes.length;n<i;++n)e.push("("+J.linestring.apply(this,[t._holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.polygon.apply(this,[t._geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Q={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(W.spaces);return this.geometryFactory.createPoint(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].trim().split(W.spaces),i.push(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].trim().split(W.spaces),i.push(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(W.parenComma),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,o=t.trim().split(W.parenComma),s=[],a=0,u=o.length;a<u;++a)e=o[a].replace(W.trimParens,"$1"),n=Q.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n._points),0===a?r=i:s.push(i);return this.geometryFactory.createPolygon(r,s)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(W.doubleParenComma),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();for(var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[],i=0,r=e.length;i<r;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}},Z=function(t){this.parser=new K(t)};Z.prototype.write=function(t){return this.parser.write(t)},Z.toLineString=function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"};var $=function(t){function e(e){t.call(this,e),this.name="RuntimeException",this.message=e,this.stack=(new t).stack}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),tt=function(t){function e(){if(t.call(this),0===arguments.length)t.call(this);else if(1===arguments.length){var e=arguments[0];t.call(this,e)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}($),et=function(){};et.prototype.interfaces_=function(){return[]},et.prototype.getClass=function(){return et},et.shouldNeverReachHere=function(){if(0===arguments.length)et.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new tt("Should never reach here"+(null!==t?": "+t:""))}},et.isTrue=function(){var t,e;if(1===arguments.length)t=arguments[0],et.isTrue(t,null);else if(2===arguments.length&&(t=arguments[0],e=arguments[1],!t))throw null===e?new tt:new tt(e)},et.equals=function(){var t,e,n;if(2===arguments.length)t=arguments[0],e=arguments[1],et.equals(t,e,null);else if(3===arguments.length&&(t=arguments[0],e=arguments[1],n=arguments[2],!e.equals(t)))throw new tt("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))};var nt=function(){this._result=null,this._inputLines=Array(2).fill().map(function(){return Array(2)}),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new C,this._intPt[1]=new C,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},it={DONT_INTERSECT:{configurable:!0},DO_INTERSECT:{configurable:!0},COLLINEAR:{configurable:!0},NO_INTERSECTION:{configurable:!0},POINT_INTERSECTION:{configurable:!0},COLLINEAR_INTERSECTION:{configurable:!0}};nt.prototype.getIndexAlongSegment=function(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]},nt.prototype.getTopologySummary=function(){var t=new D;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},nt.prototype.computeIntersection=function(t,e,n,i){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=i,this._result=this.computeIntersect(t,e,n,i)},nt.prototype.getIntersectionNum=function(){return this._result},nt.prototype.computeIntLineIndex=function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}},nt.prototype.isProper=function(){return this.hasIntersection()&&this._isProper},nt.prototype.setPrecisionModel=function(t){this._precisionModel=t},nt.prototype.isInteriorIntersection=function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}},nt.prototype.getIntersection=function(t){return this._intPt[t]},nt.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper},nt.prototype.hasIntersection=function(){return this._result!==nt.NO_INTERSECTION},nt.prototype.getEdgeDistance=function(t,e){return nt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])},nt.prototype.isCollinear=function(){return this._result===nt.COLLINEAR_INTERSECTION},nt.prototype.toString=function(){return Z.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Z.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()},nt.prototype.getEndpoint=function(t,e){return this._inputLines[t][e]},nt.prototype.isIntersection=function(t){for(var e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1},nt.prototype.getIntersectionAlongSegment=function(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]},nt.prototype.interfaces_=function(){return[]},nt.prototype.getClass=function(){return nt},nt.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),o=-1;if(t.equals(e))o=0;else if(t.equals(n))o=i>r?i:r;else{var s=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);0!==(o=i>r?s:a)||t.equals(e)||(o=Math.max(s,a))}return et.isTrue(!(0===o&&!t.equals(e)),"Bad distance calculation"),o},nt.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,o=Math.sqrt(i*i+r*r);return et.isTrue(!(0===o&&!t.equals(e)),"Invalid distance calculation"),o},it.DONT_INTERSECT.get=function(){return 0},it.DO_INTERSECT.get=function(){return 1},it.COLLINEAR.get=function(){return 2},it.NO_INTERSECTION.get=function(){return 0},it.POINT_INTERSECTION.get=function(){return 1},it.COLLINEAR_INTERSECTION.get=function(){return 2},Object.defineProperties(nt,it);var rt=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isInSegmentEnvelopes=function(t){var e=new j(this._inputLines[0][0],this._inputLines[0][1]),n=new j(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)},e.prototype.computeIntersection=function(){if(3!==arguments.length)return t.prototype.computeIntersection.apply(this,arguments);var e=arguments[0],n=arguments[1],i=arguments[2];if(this._isProper=!1,j.intersects(n,i,e)&&0===at.orientationIndex(n,i,e)&&0===at.orientationIndex(i,n,e))return this._isProper=!0,(e.equals(n)||e.equals(i))&&(this._isProper=!1),this._result=t.POINT_INTERSECTION,null;this._result=t.NO_INTERSECTION},e.prototype.normalizeToMinimum=function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},e.prototype.safeHCoordinateIntersection=function(t,n,i,r){var o=null;try{o=k.intersection(t,n,i,r)}catch(s){if(!(s instanceof X))throw s;o=e.nearestEndpoint(t,n,i,r)}return o},e.prototype.intersection=function(t,n,i,r){var o=this.intersectionWithNormalization(t,n,i,r);return this.isInSegmentEnvelopes(o)||(o=new C(e.nearestEndpoint(t,n,i,r))),null!==this._precisionModel&&this._precisionModel.makePrecise(o),o},e.prototype.smallestInAbsValue=function(t,e,n,i){var r=t,o=Math.abs(r);return Math.abs(e)<o&&(r=e,o=Math.abs(e)),Math.abs(n)<o&&(r=n,o=Math.abs(n)),Math.abs(i)<o&&(r=i),r},e.prototype.checkDD=function(t,e,n,i,r){var o=q.intersection(t,e,n,i),s=this.isInSegmentEnvelopes(o);Y.out.println("DD in env = "+s+"  --------------------- "+o),r.distance(o)>1e-4&&Y.out.println("Distance = "+r.distance(o))},e.prototype.intersectionWithNormalization=function(t,e,n,i){var r=new C(t),o=new C(e),s=new C(n),a=new C(i),u=new C;this.normalizeToEnvCentre(r,o,s,a,u);var l=this.safeHCoordinateIntersection(r,o,s,a);return l.x+=u.x,l.y+=u.y,l},e.prototype.computeCollinearIntersection=function(e,n,i,r){var o=j.intersects(e,n,i),s=j.intersects(e,n,r),a=j.intersects(i,r,e),u=j.intersects(i,r,n);return o&&s?(this._intPt[0]=i,this._intPt[1]=r,t.COLLINEAR_INTERSECTION):a&&u?(this._intPt[0]=e,this._intPt[1]=n,t.COLLINEAR_INTERSECTION):o&&a?(this._intPt[0]=i,this._intPt[1]=e,!i.equals(e)||s||u?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):o&&u?(this._intPt[0]=i,this._intPt[1]=n,!i.equals(n)||s||a?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):s&&a?(this._intPt[0]=r,this._intPt[1]=e,!r.equals(e)||o||u?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):s&&u?(this._intPt[0]=r,this._intPt[1]=n,!r.equals(n)||o||a?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):t.NO_INTERSECTION},e.prototype.normalizeToEnvCentre=function(t,e,n,i,r){var o=t.x<e.x?t.x:e.x,s=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,c=n.y<i.y?n.y:i.y,p=n.x>i.x?n.x:i.x,h=n.y>i.y?n.y:i.y,f=((o>l?o:l)+(a<p?a:p))/2,g=((s>c?s:c)+(u<h?u:h))/2;r.x=f,r.y=g,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},e.prototype.computeIntersect=function(e,n,i,r){if(this._isProper=!1,!j.intersects(e,n,i,r))return t.NO_INTERSECTION;var o=at.orientationIndex(e,n,i),s=at.orientationIndex(e,n,r);if(o>0&&s>0||o<0&&s<0)return t.NO_INTERSECTION;var a=at.orientationIndex(i,r,e),u=at.orientationIndex(i,r,n);if(a>0&&u>0||a<0&&u<0)return t.NO_INTERSECTION;return 0===o&&0===s&&0===a&&0===u?this.computeCollinearIntersection(e,n,i,r):(0===o||0===s||0===a||0===u?(this._isProper=!1,e.equals2D(i)||e.equals2D(r)?this._intPt[0]=e:n.equals2D(i)||n.equals2D(r)?this._intPt[0]=n:0===o?this._intPt[0]=new C(i):0===s?this._intPt[0]=new C(r):0===a?this._intPt[0]=new C(e):0===u&&(this._intPt[0]=new C(n))):(this._isProper=!0,this._intPt[0]=this.intersection(e,n,i,r)),t.POINT_INTERSECTION)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e.nearestEndpoint=function(t,e,n,i){var r=t,o=at.distancePointLine(t,n,i),s=at.distancePointLine(e,n,i);return s<o&&(o=s,r=e),(s=at.distancePointLine(n,t,e))<o&&(o=s,r=n),(s=at.distancePointLine(i,t,e))<o&&(o=s,r=i),r},e}(nt),ot=function(){};ot.prototype.interfaces_=function(){return[]},ot.prototype.getClass=function(){return ot},ot.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,o=n.x-e.x,s=n.y-e.y;return ot.signOfDet2x2(i,r,o,s)},ot.signOfDet2x2=function(t,e,n,i){var r=null,o=null,s=null;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?e<=i||(r=-r,o=t,t=n,n=o,o=e,e=i,i=o):e<=-i?(r=-r,n=-n,i=-i):(o=t,t=-n,n=o,o=e,e=-i,i=o):i>0?-e<=i?(r=-r,t=-t,e=-e):(o=-t,t=n,n=o,o=-e,e=i,i=o):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,o=-t,t=-n,n=o,o=-e,e=-i,i=o),t>0){if(!(n>0))return r;if(!(t<=n))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(s=Math.floor(n/t),n-=s*t,(i-=s*e)<0)return-r;if(i>e)return r;if(t>n+n){if(e<i+i)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(s=Math.floor(t/n),t-=s*n,(e-=s*i)<0)return r;if(e>i)return-r;if(n>t+t){if(i<e+e)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}};var st=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;var t=arguments[0];this._p=t};st.prototype.countSegment=function(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this._p.x>=n&&this._p.x<=i&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){var r=t.x-this._p.x,o=t.y-this._p.y,s=e.x-this._p.x,a=e.y-this._p.y,u=ot.signOfDet2x2(r,o,s,a);if(0===u)return this._isPointOnSegment=!0,null;a<o&&(u=-u),u>0&&this._crossingCount++}},st.prototype.isPointInPolygon=function(){return this.getLocation()!==w.EXTERIOR},st.prototype.getLocation=function(){return this._isPointOnSegment?w.BOUNDARY:this._crossingCount%2==1?w.INTERIOR:w.EXTERIOR},st.prototype.isOnSegment=function(){return this._isPointOnSegment},st.prototype.interfaces_=function(){return[]},st.prototype.getClass=function(){return st},st.locatePointInRing=function(){if(arguments[0]instanceof C&&T(arguments[1],V)){for(var t=arguments[0],e=arguments[1],n=new st(t),i=new C,r=new C,o=1;o<e.size();o++)if(e.getCoordinate(o,i),e.getCoordinate(o-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof C&&arguments[1]instanceof Array){for(var s=arguments[0],a=arguments[1],u=new st(s),l=1;l<a.length;l++){var c=a[l],p=a[l-1];if(u.countSegment(c,p),u.isOnSegment())return u.getLocation()}return u.getLocation()}};var at=function(){},ut={CLOCKWISE:{configurable:!0},RIGHT:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},LEFT:{configurable:!0},COLLINEAR:{configurable:!0},STRAIGHT:{configurable:!0}};at.prototype.interfaces_=function(){return[]},at.prototype.getClass=function(){return at},at.orientationIndex=function(t,e,n){return q.orientationIndex(t,e,n)},at.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,o=t[i+1].y;e+=r*(t[i-1].y-o)}return e/2}if(T(arguments[0],V)){var s=arguments[0],a=s.size();if(a<3)return 0;var u=new C,l=new C,c=new C;s.getCoordinate(0,l),s.getCoordinate(1,c);var p=l.x;c.x-=p;for(var h=0,f=1;f<a-1;f++)u.y=l.y,l.x=c.x,l.y=c.y,s.getCoordinate(f+1,c),c.x-=p,h+=l.x*(u.y-c.y);return h/2}},at.distanceLineLine=function(t,e,n,i){if(t.equals(e))return at.distancePointLine(t,n,i);if(n.equals(i))return at.distancePointLine(i,t,e);var r=!1;if(j.intersects(t,e,n,i)){var o=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===o)r=!0;else{var s=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/o,u=s/o;(u<0||u>1||a<0||a>1)&&(r=!0)}}else r=!0;return r?R.min(at.distancePointLine(t,n,i),at.distancePointLine(e,n,i),at.distancePointLine(n,t,e),at.distancePointLine(i,t,e)):0},at.isPointInRing=function(t,e){return at.locatePointInRing(t,e)!==w.EXTERIOR},at.computeLength=function(t){var e=t.size();if(e<=1)return 0;var n=0,i=new C;t.getCoordinate(0,i);for(var r=i.x,o=i.y,s=1;s<e;s++){t.getCoordinate(s,i);var a=i.x,u=i.y,l=a-r,c=u-o;n+=Math.sqrt(l*l+c*c),r=a,o=u}return n},at.isCCW=function(t){var e=t.length-1;if(e<3)throw new m("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],i=0,r=1;r<=e;r++){var o=t[r];o.y>n.y&&(n=o,i=r)}var s=i;do{(s-=1)<0&&(s=e)}while(t[s].equals2D(n)&&s!==i);var a=i;do{a=(a+1)%e}while(t[a].equals2D(n)&&a!==i);var u=t[s],l=t[a];if(u.equals2D(n)||l.equals2D(n)||u.equals2D(l))return!1;var c=at.computeOrientation(u,n,l),p=!1;return p=0===c?u.x>l.x:c>0,p},at.locatePointInRing=function(t,e){return st.locatePointInRing(t,e)},at.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},at.computeOrientation=function(t,e,n){return at.orientationIndex(t,e,n)},at.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new m("Line array must contain at least one vertex");for(var n=t.distance(e[0]),i=0;i<e.length-1;i++){var r=at.distancePointLine(t,e[i],e[i+1]);r<n&&(n=r)}return n}if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];if(s.x===a.x&&s.y===a.y)return o.distance(s);var u=(a.x-s.x)*(a.x-s.x)+(a.y-s.y)*(a.y-s.y),l=((o.x-s.x)*(a.x-s.x)+(o.y-s.y)*(a.y-s.y))/u;if(l<=0)return o.distance(s);if(l>=1)return o.distance(a);var c=((s.y-o.y)*(a.x-s.x)-(s.x-o.x)*(a.y-s.y))/u;return Math.abs(c)*Math.sqrt(u)}},at.isOnLine=function(t,e){for(var n=new rt,i=1;i<e.length;i++){var r=e[i-1],o=e[i];if(n.computeIntersection(t,r,o),n.hasIntersection())return!0}return!1},ut.CLOCKWISE.get=function(){return-1},ut.RIGHT.get=function(){return at.CLOCKWISE},ut.COUNTERCLOCKWISE.get=function(){return 1},ut.LEFT.get=function(){return at.COUNTERCLOCKWISE},ut.COLLINEAR.get=function(){return 0},ut.STRAIGHT.get=function(){return at.COLLINEAR},Object.defineProperties(at,ut);var lt=function(){};lt.prototype.filter=function(t){},lt.prototype.interfaces_=function(){return[]},lt.prototype.getClass=function(){return lt};var ct=function(){var t=arguments[0];this._envelope=null,this._factory=null,this._SRID=null,this._userData=null,this._factory=t,this._SRID=t.getSRID()},pt={serialVersionUID:{configurable:!0},SORTINDEX_POINT:{configurable:!0},SORTINDEX_MULTIPOINT:{configurable:!0},SORTINDEX_LINESTRING:{configurable:!0},SORTINDEX_LINEARRING:{configurable:!0},SORTINDEX_MULTILINESTRING:{configurable:!0},SORTINDEX_POLYGON:{configurable:!0},SORTINDEX_MULTIPOLYGON:{configurable:!0},SORTINDEX_GEOMETRYCOLLECTION:{configurable:!0},geometryChangedFilter:{configurable:!0}};ct.prototype.isGeometryCollection=function(){return this.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION},ct.prototype.getFactory=function(){return this._factory},ct.prototype.getGeometryN=function(t){return this},ct.prototype.getArea=function(){return 0},ct.prototype.isRectangle=function(){return!1},ct.prototype.equals=function(){if(arguments[0]instanceof ct){var t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof ct))return!1;var n=e;return this.equalsExact(n)}},ct.prototype.equalsExact=function(t){return this===t||this.equalsExact(t,0)},ct.prototype.geometryChanged=function(){this.apply(ct.geometryChangedFilter)},ct.prototype.geometryChangedAction=function(){this._envelope=null},ct.prototype.equalsNorm=function(t){return null!==t&&this.norm().equalsExact(t.norm())},ct.prototype.getLength=function(){return 0},ct.prototype.getNumGeometries=function(){return 1},ct.prototype.compareTo=function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.getSortIndex()!==n.getSortIndex()?this.getSortIndex()-n.getSortIndex():this.isEmpty()&&n.isEmpty()?0:this.isEmpty()?-1:n.isEmpty()?1:this.compareToSameClass(n,i)}},ct.prototype.getUserData=function(){return this._userData},ct.prototype.getSRID=function(){return this._SRID},ct.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},ct.prototype.checkNotGeometryCollection=function(t){if(t.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION)throw new m("This method does not support GeometryCollection arguments")},ct.prototype.equal=function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},ct.prototype.norm=function(){var t=this.copy();return t.normalize(),t},ct.prototype.getPrecisionModel=function(){return this._factory.getPrecisionModel()},ct.prototype.getEnvelopeInternal=function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new j(this._envelope)},ct.prototype.setSRID=function(t){this._SRID=t},ct.prototype.setUserData=function(t){this._userData=t},ct.prototype.compare=function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),o=i.next(),s=r.compareTo(o);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0},ct.prototype.hashCode=function(){return this.getEnvelopeInternal().hashCode()},ct.prototype.isGeometryCollectionOrDerived=function(){return this.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===ct.SORTINDEX_MULTIPOINT||this.getSortIndex()===ct.SORTINDEX_MULTILINESTRING||this.getSortIndex()===ct.SORTINDEX_MULTIPOLYGON},ct.prototype.interfaces_=function(){return[x,E,e]},ct.prototype.getClass=function(){return ct},ct.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},ct.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},pt.serialVersionUID.get=function(){return 0x799ea46522854c00},pt.SORTINDEX_POINT.get=function(){return 0},pt.SORTINDEX_MULTIPOINT.get=function(){return 1},pt.SORTINDEX_LINESTRING.get=function(){return 2},pt.SORTINDEX_LINEARRING.get=function(){return 3},pt.SORTINDEX_MULTILINESTRING.get=function(){return 4},pt.SORTINDEX_POLYGON.get=function(){return 5},pt.SORTINDEX_MULTIPOLYGON.get=function(){return 6},pt.SORTINDEX_GEOMETRYCOLLECTION.get=function(){return 7},pt.geometryChangedFilter.get=function(){return ht},Object.defineProperties(ct,pt);var ht=function(){};ht.interfaces_=function(){return[lt]},ht.filter=function(t){t.geometryChangedAction()};var ft=function(){};ft.prototype.filter=function(t){},ft.prototype.interfaces_=function(){return[]},ft.prototype.getClass=function(){return ft};var gt=function(){},dt={Mod2BoundaryNodeRule:{configurable:!0},EndPointBoundaryNodeRule:{configurable:!0},MultiValentEndPointBoundaryNodeRule:{configurable:!0},MonoValentEndPointBoundaryNodeRule:{configurable:!0},MOD2_BOUNDARY_RULE:{configurable:!0},ENDPOINT_BOUNDARY_RULE:{configurable:!0},MULTIVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},MONOVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},OGC_SFS_BOUNDARY_RULE:{configurable:!0}};gt.prototype.isInBoundary=function(t){},gt.prototype.interfaces_=function(){return[]},gt.prototype.getClass=function(){return gt},dt.Mod2BoundaryNodeRule.get=function(){return yt},dt.EndPointBoundaryNodeRule.get=function(){return _t},dt.MultiValentEndPointBoundaryNodeRule.get=function(){return mt},dt.MonoValentEndPointBoundaryNodeRule.get=function(){return vt},dt.MOD2_BOUNDARY_RULE.get=function(){return new yt},dt.ENDPOINT_BOUNDARY_RULE.get=function(){return new _t},dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new mt},dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new vt},dt.OGC_SFS_BOUNDARY_RULE.get=function(){return gt.MOD2_BOUNDARY_RULE},Object.defineProperties(gt,dt);var yt=function(){};yt.prototype.isInBoundary=function(t){return t%2==1},yt.prototype.interfaces_=function(){return[gt]},yt.prototype.getClass=function(){return yt};var _t=function(){};_t.prototype.isInBoundary=function(t){return t>0},_t.prototype.interfaces_=function(){return[gt]},_t.prototype.getClass=function(){return _t};var mt=function(){};mt.prototype.isInBoundary=function(t){return t>1},mt.prototype.interfaces_=function(){return[gt]},mt.prototype.getClass=function(){return mt};var vt=function(){};vt.prototype.isInBoundary=function(t){return 1===t},vt.prototype.interfaces_=function(){return[gt]},vt.prototype.getClass=function(){return vt};var It=function(){};It.prototype.add=function(){},It.prototype.addAll=function(){},It.prototype.isEmpty=function(){},It.prototype.iterator=function(){},It.prototype.size=function(){},It.prototype.toArray=function(){},It.prototype.remove=function(){},(n.prototype=new Error).name="IndexOutOfBoundsException";var Et=function(){};Et.prototype.hasNext=function(){},Et.prototype.next=function(){},Et.prototype.remove=function(){};var xt=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(){},e.prototype.set=function(){},e.prototype.isEmpty=function(){},e}(It);(i.prototype=new Error).name="NoSuchElementException";var Nt=function(t){function e(){t.call(this),this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0])}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.ensureCapacity=function(){},e.prototype.interfaces_=function(){return[t,It]},e.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],arguments[1]),!0},e.prototype.clear=function(){this.array_=[]},e.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},e.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},e.prototype.iterator=function(){return new Ct(this)},e.prototype.get=function(t){if(t<0||t>=this.size())throw new n;return this.array_[t]},e.prototype.isEmpty=function(){return 0===this.array_.length},e.prototype.size=function(){return this.array_.length},e.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},e.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;n<i;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},e}(xt),Ct=function(t){function e(e){t.call(this),this.arrayList_=e,this.position_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new i;return this.arrayList_.get(this.position_++)},e.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},e.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},e.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))},e}(Et),St=function(t){function e(){if(t.call(this),0===arguments.length);else if(1===arguments.length){var e=arguments[0];this.ensureCapacity(e.length),this.add(e,!0)}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.ensureCapacity(n.length),this.add(n,i)}}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={coordArrayType:{configurable:!0}};return n.coordArrayType.get=function(){return new Array(0).fill(null)},e.prototype.getCoordinate=function(t){return this.get(t)},e.prototype.addAll=function(){if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=!1,r=e.iterator();r.hasNext();)this.add(r.next(),n),i=!0;return i}return t.prototype.addAll.apply(this,arguments)},e.prototype.clone=function(){for(var e=t.prototype.clone.call(this),n=0;n<this.size();n++)e.add(n,this.get(n).copy());return e},e.prototype.toCoordinateArray=function(){return this.toArray(e.coordArrayType)},e.prototype.add=function(){if(1===arguments.length){var e=arguments[0];t.prototype.add.call(this,e)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var n=arguments[0],i=arguments[1];return this.add(n,i,!0),!0}if(arguments[0]instanceof C&&"boolean"==typeof arguments[1]){var r=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(r))return null}t.prototype.add.call(this,r)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],s=arguments[1];return this.add(o,s),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var a=arguments[0],u=arguments[1];if(arguments[2])for(var l=0;l<a.length;l++)this.add(a[l],u);else for(var c=a.length-1;c>=0;c--)this.add(a[c],u);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1];if(!arguments[2]){var f=this.size();if(f>0){if(p>0){if(this.get(p-1).equals2D(h))return null}if(p<f){if(this.get(p).equals2D(h))return null}}}t.prototype.add.call(this,p,h)}}else if(4===arguments.length){var g=arguments[0],d=arguments[1],y=arguments[2],_=arguments[3],m=1;y>_&&(m=-1);for(var v=y;v!==_;v+=m)this.add(g[v],d);return!0}},e.prototype.closeRing=function(){this.size()>0&&this.add(new C(this.get(0)),!1)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},Object.defineProperties(e,n),e}(Nt),Lt=function(){},bt={ForwardComparator:{configurable:!0},BidirectionalComparator:{configurable:!0},coordArrayType:{configurable:!0}};bt.ForwardComparator.get=function(){return wt},bt.BidirectionalComparator.get=function(){return Ot},bt.coordArrayType.get=function(){return new Array(0).fill(null)},Lt.prototype.interfaces_=function(){return[]},Lt.prototype.getClass=function(){return Lt},Lt.isRing=function(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])},Lt.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(Lt.indexOf(i,e)<0)return i}return null},Lt.scroll=function(t,e){var n=Lt.indexOf(e,t);if(n<0)return null;var i=new Array(t.length).fill(null);Y.arraycopy(t,n,i,0,t.length-n),Y.arraycopy(t,0,i,t.length-n,n),Y.arraycopy(i,0,t,0,t.length)},Lt.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var s=0;s<i.length;s++)if(0!==o.compare(i[s],r[s]))return!1;return!0}},Lt.intersection=function(t,e){for(var n=new St,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},Lt.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},Lt.removeRepeatedPoints=function(t){if(!Lt.hasRepeatedPoints(t))return t;return new St(t,!1).toCoordinateArray()},Lt.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;i<=n;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},Lt.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,o=0;o<t.length;o++)null!==t[o]&&(i[r++]=t[o]);return i},Lt.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new C(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],o=arguments[2],s=arguments[3],a=arguments[4],u=0;u<a;u++)o[s+u]=new C(i[r+u])},Lt.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},Lt.envelope=function(t){for(var e=new j,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},Lt.toCoordinateArray=function(t){return t.toArray(Lt.coordArrayType)},Lt.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},Lt.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},Lt.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},Lt.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},Lt.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},Lt.extract=function(t,e,n){e=R.clamp(e,0,t.length);var i=(n=R.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var o=0,s=e;s<=n;s++)r[o++]=t[s];return r},Object.defineProperties(Lt,bt);var wt=function(){};wt.prototype.compare=function(t,e){return Lt.compare(t,e)},wt.prototype.interfaces_=function(){return[N]},wt.prototype.getClass=function(){return wt};var Ot=function(){};Ot.prototype.compare=function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=Lt.compare(n,i);return Lt.isEqualReversed(n,i)?0:r},Ot.prototype.OLDcompare=function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=Lt.increasingDirection(n),o=Lt.increasingDirection(i),s=r>0?0:n.length-1,a=o>0?0:n.length-1,u=0;u<n.length;u++){var l=n[s].compareTo(i[a]);if(0!==l)return l;s+=r,a+=o}return 0},Ot.prototype.interfaces_=function(){return[N]},Ot.prototype.getClass=function(){return Ot};var Tt=function(){};Tt.prototype.get=function(){},Tt.prototype.put=function(){},Tt.prototype.size=function(){},Tt.prototype.values=function(){},Tt.prototype.entrySet=function(){};var Rt=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Tt);(r.prototype=new Error).name="OperationNotSupported",(o.prototype=new It).contains=function(){};var Pt=function(t){function e(){t.call(this),this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0])}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return!0}return!1},e.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},e.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},e.prototype.remove=function(t){throw new Error},e.prototype.size=function(){return this.array_.length},e.prototype.isEmpty=function(){return 0===this.array_.length},e.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},e.prototype.iterator=function(){return new Dt(this)},e}(o),Dt=function(t){function e(e){t.call(this),this.hashSet_=e,this.position_=0}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new i;return this.hashSet_.array_[this.position_++]},e.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},e.prototype.remove=function(){throw new r},e}(Et),Mt=0;(p.prototype=new Rt).get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},p.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:Mt,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do{if(n=r,(i=t.compareTo(r.key))<0)r=r.left;else{if(!(i>0)){var o=r.value;return r.value=e,o}r=r.right}}while(null!==r);var s={key:t,left:null,right:null,value:e,parent:n,color:Mt,getValue:function(){return this.value},getKey:function(){return this.key}};return i<0?n.left=s:n.right=s,this.fixAfterInsertion(s),this.size_++,null},p.prototype.fixAfterInsertion=function(t){for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)if(a(t)===l(a(a(t)))){var e=c(a(a(t)));1===s(e)?(u(a(t),Mt),u(e,Mt),u(a(a(t)),1),t=a(a(t))):(t===c(a(t))&&(t=a(t),this.rotateLeft(t)),u(a(t),Mt),u(a(a(t)),1),this.rotateRight(a(a(t))))}else{var n=l(a(a(t)));1===s(n)?(u(a(t),Mt),u(n,Mt),u(a(a(t)),1),t=a(a(t))):(t===l(a(t))&&(t=a(t),this.rotateRight(t)),u(a(t),Mt),u(a(a(t)),1),this.rotateLeft(a(a(t))))}this.root_.color=Mt},p.prototype.values=function(){var t=new Nt,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=p.successor(e));)t.add(e.value);return t},p.prototype.entrySet=function(){var t=new Pt,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=p.successor(e));)t.add(e);return t},p.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null===t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},p.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null===t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},p.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},p.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var n=t.parent,i=t;null!==n&&i===n.right;)i=n,n=n.parent;return n},p.prototype.size=function(){return this.size_};var At=function(){};At.prototype.interfaces_=function(){return[]},At.prototype.getClass=function(){return At},h.prototype=new o,(f.prototype=new h).contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return!0}return!1},f.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},f.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},f.prototype.remove=function(t){throw new r},f.prototype.size=function(){return this.array_.length},f.prototype.isEmpty=function(){return 0===this.array_.length},f.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},f.prototype.iterator=function(){return new Ft(this)};var Ft=function(t){this.treeSet_=t,this.position_=0};Ft.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new i;return this.treeSet_.array_[this.position_++]},Ft.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},Ft.prototype.remove=function(){throw new r};var Gt=function(){};Gt.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)i=function(t,e){return t.compareTo(e)},r.sort(i);else if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else if(3===arguments.length){(e=r.slice(arguments[1],arguments[2])).sort();var o=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<o.length;t++)r.push(o[t])}else if(4===arguments.length)for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),o=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<o.length;t++)r.push(o[t])},Gt.asList=function(t){for(var e=new Nt,n=0,i=t.length;n<i;n++)e.add(t[n]);return e};var qt=function(){},Bt={P:{configurable:!0},L:{configurable:!0},A:{configurable:!0},FALSE:{configurable:!0},TRUE:{configurable:!0},DONTCARE:{configurable:!0},SYM_FALSE:{configurable:!0},SYM_TRUE:{configurable:!0},SYM_DONTCARE:{configurable:!0},SYM_P:{configurable:!0},SYM_L:{configurable:!0},SYM_A:{configurable:!0}};Bt.P.get=function(){return 0},Bt.L.get=function(){return 1},Bt.A.get=function(){return 2},Bt.FALSE.get=function(){return-1},Bt.TRUE.get=function(){return-2},Bt.DONTCARE.get=function(){return-3},Bt.SYM_FALSE.get=function(){return"F"},Bt.SYM_TRUE.get=function(){return"T"},Bt.SYM_DONTCARE.get=function(){return"*"},Bt.SYM_P.get=function(){return"0"},Bt.SYM_L.get=function(){return"1"},Bt.SYM_A.get=function(){return"2"},qt.prototype.interfaces_=function(){return[]},qt.prototype.getClass=function(){return qt},qt.toDimensionSymbol=function(t){switch(t){case qt.FALSE:return qt.SYM_FALSE;case qt.TRUE:return qt.SYM_TRUE;case qt.DONTCARE:return qt.SYM_DONTCARE;case qt.P:return qt.SYM_P;case qt.L:return qt.SYM_L;case qt.A:return qt.SYM_A}throw new m("Unknown dimension value: "+t)},qt.toDimensionValue=function(t){switch(A.toUpperCase(t)){case qt.SYM_FALSE:return qt.FALSE;case qt.SYM_TRUE:return qt.TRUE;case qt.SYM_DONTCARE:return qt.DONTCARE;case qt.SYM_P:return qt.P;case qt.SYM_L:return qt.L;case qt.SYM_A:return qt.A}throw new m("Unknown dimension symbol: "+t)},Object.defineProperties(qt,Bt);var Vt=function(){};Vt.prototype.filter=function(t){},Vt.prototype.interfaces_=function(){return[]},Vt.prototype.getClass=function(){return Vt};var Ut=function(){};Ut.prototype.filter=function(t,e){},Ut.prototype.isDone=function(){},Ut.prototype.isGeometryChanged=function(){},Ut.prototype.interfaces_=function(){return[]},Ut.prototype.getClass=function(){return Ut};var zt=function(t){function e(e,n){if(t.call(this,n),this._geometries=e||[],t.hasNullElements(this._geometries))throw new m("geometries must not contain null elements")}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){for(var t=new j,e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t},e.prototype.getGeometryN=function(t){return this._geometries[t]},e.prototype.getSortIndex=function(){return t.SORTINDEX_GEOMETRYCOLLECTION},e.prototype.getCoordinates=function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this._geometries.length;n++)for(var i=this._geometries[n].getCoordinates(),r=0;r<i.length;r++)t[++e]=i[r];return t},e.prototype.getArea=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return!1;var i=e;if(this._geometries.length!==i._geometries.length)return!1;for(var r=0;r<this._geometries.length;r++)if(!this._geometries[r].equalsExact(i._geometries[r],n))return!1;return!0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){for(var t=0;t<this._geometries.length;t++)this._geometries[t].normalize();Gt.sort(this._geometries)},e.prototype.getCoordinate=function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()},e.prototype.getBoundaryDimension=function(){for(var t=qt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t},e.prototype.getDimension=function(){for(var t=qt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t},e.prototype.getLength=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t},e.prototype.getNumPoints=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t},e.prototype.getNumGeometries=function(){return this._geometries.length},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[n]=this._geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0],e=new f(Gt.asList(this._geometries)),n=new f(Gt.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],o=i,s=this.getNumGeometries(),a=o.getNumGeometries(),u=0;u<s&&u<a;){var l=this.getGeometryN(u),c=o.getGeometryN(u),p=l.compareToSameClass(c,r);if(0!==p)return p;u++}return u<s?1:u<a?-1:0}},e.prototype.apply=function(){if(T(arguments[0],ft))for(var t=arguments[0],e=0;e<this._geometries.length;e++)this._geometries[e].apply(t);else if(T(arguments[0],Ut)){var n=arguments[0];if(0===this._geometries.length)return null;for(var i=0;i<this._geometries.length&&(this._geometries[i].apply(n),!n.isDone());i++);n.isGeometryChanged()&&this.geometryChanged()}else if(T(arguments[0],Vt)){var r=arguments[0];r.filter(this);for(var o=0;o<this._geometries.length;o++)this._geometries[o].apply(r)}else if(T(arguments[0],lt)){var s=arguments[0];s.filter(this);for(var a=0;a<this._geometries.length;a++)this._geometries[a].apply(s)}},e.prototype.getBoundary=function(){return this.checkNotGeometryCollection(this),et.shouldNeverReachHere(),null},e.prototype.clone=function(){var e=t.prototype.clone.call(this);e._geometries=new Array(this._geometries.length).fill(null);for(var n=0;n<this._geometries.length;n++)e._geometries[n]=this._geometries[n].clone();return e},e.prototype.getGeometryType=function(){return"GeometryCollection"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.isEmpty=function(){for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return-0x4f07bcb1f857d800},Object.defineProperties(e,n),e}(ct),Xt=function(t){function e(){t.apply(this,arguments)}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTILINESTRING},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return this.isClosed()?qt.FALSE:0},e.prototype.isClosed=function(){if(this.isEmpty())return!1;for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0},e.prototype.getDimension=function(){return 1},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)},e.prototype.getBoundary=function(){return new Yt(this).getBoundary()},e.prototype.getGeometryType=function(){return"MultiLineString"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return[At]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x7155d2ab4afa8000},Object.defineProperties(e,n),e}(zt),Yt=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){var t=arguments[0],e=gt.MOD2_BOUNDARY_RULE;this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this._geom=n,this._geomFact=n.getFactory(),this._bnRule=i}};Yt.prototype.boundaryMultiLineString=function(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)},Yt.prototype.getBoundary=function(){return this._geom instanceof Kt?this.boundaryLineString(this._geom):this._geom instanceof Xt?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()},Yt.prototype.boundaryLineString=function(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},Yt.prototype.getEmptyMultiPoint=function(){return this._geomFact.createMultiPoint()},Yt.prototype.computeBoundaryCoordinates=function(t){var e=new Nt;this._endpointMap=new p;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this._endpointMap.entrySet().iterator();r.hasNext();){var o=r.next(),s=o.getValue().count;this._bnRule.isInBoundary(s)&&e.add(o.getKey())}return Lt.toCoordinateArray(e)},Yt.prototype.addEndpoint=function(t){var e=this._endpointMap.get(t);null===e&&(e=new kt,this._endpointMap.put(t,e)),e.count++},Yt.prototype.interfaces_=function(){return[]},Yt.prototype.getClass=function(){return Yt},Yt.getBoundary=function(){if(1===arguments.length){var t=arguments[0];return new Yt(t).getBoundary()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return new Yt(e,n).getBoundary()}};var kt=function(){this.count=null};kt.prototype.interfaces_=function(){return[]},kt.prototype.getClass=function(){return kt};var jt=function(){},Ht={NEWLINE:{configurable:!0},SIMPLE_ORDINATE_FORMAT:{configurable:!0}};jt.prototype.interfaces_=function(){return[]},jt.prototype.getClass=function(){return jt},jt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;i<e;i++)n[i]=t;return String(n)},jt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new function(){},n=new function(){}(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],o="",s=new function(){}(new function(){}(jt.getStackTrace(i))),a=0;a<r;a++)try{o+=s.readLine()+jt.NEWLINE}catch(t){if(!(t instanceof g))throw t;et.shouldNeverReachHere()}return o}},jt.split=function(t,e){for(var n=e.length,i=new Nt,r=""+t,o=r.indexOf(e);o>=0;){var s=r.substring(0,o);i.add(s),o=(r=r.substring(o+n)).indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},jt.toString=function(){if(1===arguments.length){var t=arguments[0];return jt.SIMPLE_ORDINATE_FORMAT.format(t)}},jt.spaces=function(t){return jt.chars(" ",t)},Ht.NEWLINE.get=function(){return Y.getProperty("line.separator")},Ht.SIMPLE_ORDINATE_FORMAT.get=function(){return new function(){}("0.#")},Object.defineProperties(jt,Ht);var Wt=function(){};Wt.prototype.interfaces_=function(){return[]},Wt.prototype.getClass=function(){return Wt},Wt.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),o=0;o<r;o++)n.setOrdinate(i,o,t.getOrdinate(e,o))},Wt.isRing=function(t){var e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,V.X)===t.getOrdinate(e-1,V.X)&&t.getOrdinate(0,V.Y)===t.getOrdinate(e-1,V.Y))},Wt.isEqual=function(t,e){var n=t.size();if(n!==e.size())return!1;for(var i=Math.min(t.getDimension(),e.getDimension()),r=0;r<n;r++)for(var o=0;o<i;o++){var s=t.getOrdinate(r,o),a=e.getOrdinate(r,o);if(t.getOrdinate(r,o)!==e.getOrdinate(r,o)&&(!v.isNaN(s)||!v.isNaN(a)))return!1}return!0},Wt.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Wt.copy(e,0,i,0,r),r>0)for(var o=r;o<n;o++)Wt.copy(e,r-1,i,o,1);return i},Wt.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;i<=n;i++)Wt.swap(t,i,e-i)},Wt.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Wt.copy=function(t,e,n,i,r){for(var o=0;o<r;o++)Wt.copyCoord(t,e+o,n,i+o)},Wt.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new D;i.append("(");for(var r=0;r<e;r++){r>0&&i.append(" ");for(var o=0;o<n;o++)o>0&&i.append(","),i.append(jt.toString(t.getOrdinate(r,o)))}return i.append(")"),i.toString()}},Wt.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(n<=3)return Wt.createClosedRing(t,e,4);return e.getOrdinate(0,V.X)===e.getOrdinate(n-1,V.X)&&e.getOrdinate(0,V.Y)===e.getOrdinate(n-1,V.Y)?e:Wt.createClosedRing(t,e,n+1)},Wt.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Wt.copy(e,0,i,0,r);for(var o=r;o<n;o++)Wt.copy(e,0,i,o,1);return i};var Kt=function(t){function e(e,n){t.call(this,n),this._points=null,this.init(e)}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){return this.isEmpty()?new j:this._points.expandEnvelope(new j)},e.prototype.isRing=function(){return this.isClosed()&&this.isSimple()},e.prototype.getSortIndex=function(){return t.SORTINDEX_LINESTRING},e.prototype.getCoordinates=function(){return this._points.toCoordinateArray()},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return!1;var i=e;if(this._points.size()!==i._points.size())return!1;for(var r=0;r<this._points.size();r++)if(!this.equal(this._points.getCoordinate(r),i._points.getCoordinate(r),n))return!1;return!0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){for(var t=0;t<Math.trunc(this._points.size()/2);t++){var e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e)))return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0&&Wt.reverse(this._points),null}},e.prototype.getCoordinate=function(){return this.isEmpty()?null:this._points.getCoordinate(0)},e.prototype.getBoundaryDimension=function(){return this.isClosed()?qt.FALSE:0},e.prototype.isClosed=function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},e.prototype.getEndPoint=function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},e.prototype.getDimension=function(){return 1},e.prototype.getLength=function(){return at.computeLength(this._points)},e.prototype.getNumPoints=function(){return this._points.size()},e.prototype.reverse=function(){var t=this._points.copy();Wt.reverse(t);return this.getFactory().createLineString(t)},e.prototype.compareToSameClass=function(){if(1===arguments.length){for(var t=arguments[0],e=0,n=0;e<this._points.size()&&n<t._points.size();){var i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){var r=arguments[0];return arguments[1].compare(this._points,r._points)}},e.prototype.apply=function(){if(T(arguments[0],ft))for(var t=arguments[0],e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e));else if(T(arguments[0],Ut)){var n=arguments[0];if(0===this._points.size())return null;for(var i=0;i<this._points.size()&&(n.filter(this._points,i),!n.isDone());i++);n.isGeometryChanged()&&this.geometryChanged()}else if(T(arguments[0],Vt)){arguments[0].filter(this)}else if(T(arguments[0],lt)){arguments[0].filter(this)}},e.prototype.getBoundary=function(){return new Yt(this).getBoundary()},e.prototype.isEquivalentClass=function(t){return t instanceof e},e.prototype.clone=function(){var e=t.prototype.clone.call(this);return e._points=this._points.clone(),e},e.prototype.getCoordinateN=function(t){return this._points.getCoordinate(t)},e.prototype.getGeometryType=function(){return"LineString"},e.prototype.copy=function(){return new e(this._points.copy(),this._factory)},e.prototype.getCoordinateSequence=function(){return this._points},e.prototype.isEmpty=function(){return 0===this._points.size()},e.prototype.init=function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new m("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t},e.prototype.isCoordinate=function(t){for(var e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1},e.prototype.getStartPoint=function(){return this.isEmpty()?null:this.getPointN(0)},e.prototype.getPointN=function(t){return this.getFactory().createPoint(this._points.getCoordinate(t))},e.prototype.interfaces_=function(){return[At]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x2b2b51ba435c8e00},Object.defineProperties(e,n),e}(ct),Jt=function(){};Jt.prototype.interfaces_=function(){return[]},Jt.prototype.getClass=function(){return Jt};var Qt=function(t){function e(e,n){t.call(this,n),this._coordinates=e||null,this.init(this._coordinates)}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){if(this.isEmpty())return new j;var t=new j;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t},e.prototype.getSortIndex=function(){return t.SORTINDEX_POINT},e.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.getCoordinate()]},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!this.isEquivalentClass(e)&&(!(!this.isEmpty()||!e.isEmpty())||this.isEmpty()===e.isEmpty()&&this.equal(e.getCoordinate(),this.getCoordinate(),n))}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){},e.prototype.getCoordinate=function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.getDimension=function(){return 0},e.prototype.getNumPoints=function(){return this.isEmpty()?0:1},e.prototype.reverse=function(){return this.copy()},e.prototype.getX=function(){if(null===this.getCoordinate())throw new Error("getX called on empty Point");return this.getCoordinate().x},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){var e=arguments[0];return arguments[1].compare(this._coordinates,e._coordinates)}},e.prototype.apply=function(){if(T(arguments[0],ft)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(T(arguments[0],Ut)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this._coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(T(arguments[0],Vt)){arguments[0].filter(this)}else if(T(arguments[0],lt)){arguments[0].filter(this)}},e.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},e.prototype.clone=function(){var e=t.prototype.clone.call(this);return e._coordinates=this._coordinates.clone(),e},e.prototype.getGeometryType=function(){return"Point"},e.prototype.copy=function(){return new e(this._coordinates.copy(),this._factory)},e.prototype.getCoordinateSequence=function(){return this._coordinates},e.prototype.getY=function(){if(null===this.getCoordinate())throw new Error("getY called on empty Point");return this.getCoordinate().y},e.prototype.isEmpty=function(){return 0===this._coordinates.size()},e.prototype.init=function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),et.isTrue(t.size()<=1),this._coordinates=t},e.prototype.isSimple=function(){return!0},e.prototype.interfaces_=function(){return[Jt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x44077bad161cbc00},Object.defineProperties(e,n),e}(ct),Zt=function(){};Zt.prototype.interfaces_=function(){return[]},Zt.prototype.getClass=function(){return Zt};var $t=function(t){function e(e,n,i){if(t.call(this,i),this._shell=null,this._holes=null,null===e&&(e=this.getFactory().createLinearRing()),null===n&&(n=[]),t.hasNullElements(n))throw new m("holes must not contain null elements");if(e.isEmpty()&&t.hasNonEmptyElements(n))throw new m("shell is empty but holes are not");this._shell=e,this._holes=n}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){return this._shell.getEnvelopeInternal()},e.prototype.getSortIndex=function(){return t.SORTINDEX_POLYGON},e.prototype.getCoordinates=function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this._shell.getCoordinates(),i=0;i<n.length;i++)t[++e]=n[i];for(var r=0;r<this._holes.length;r++)for(var o=this._holes[r].getCoordinates(),s=0;s<o.length;s++)t[++e]=o[s];return t},e.prototype.getArea=function(){var t=0;t+=Math.abs(at.signedArea(this._shell.getCoordinateSequence()));for(var e=0;e<this._holes.length;e++)t-=Math.abs(at.signedArea(this._holes[e].getCoordinateSequence()));return t},e.prototype.isRectangle=function(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;for(var t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;n<5;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var o=t.getX(0),s=t.getY(0),a=1;a<=4;a++){var u=t.getX(a),l=t.getY(a);if(u!==o===(l!==s))return!1;o=u,s=l}return!0},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return!1;var i=e,r=this._shell,o=i._shell;if(!r.equalsExact(o,n))return!1;if(this._holes.length!==i._holes.length)return!1;for(var s=0;s<this._holes.length;s++)if(!this._holes[s].equalsExact(i._holes[s],n))return!1;return!0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){if(0===arguments.length){this.normalize(this._shell,!0);for(var t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);Gt.sort(this._holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);Y.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=Lt.minCoordinate(e.getCoordinates());Lt.scroll(i,r),Y.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],at.isCCW(e.getCoordinates())===n&&Lt.reverse(e.getCoordinates())}},e.prototype.getCoordinate=function(){return this._shell.getCoordinate()},e.prototype.getNumInteriorRing=function(){return this._holes.length},e.prototype.getBoundaryDimension=function(){return 1},e.prototype.getDimension=function(){return 2},e.prototype.getLength=function(){var t=0;t+=this._shell.getLength();for(var e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t},e.prototype.getNumPoints=function(){for(var t=this._shell.getNumPoints(),e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t},e.prototype.reverse=function(){var t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(var e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t},e.prototype.convexHull=function(){return this.getExteriorRing().convexHull()},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],o=i,s=this._shell,a=o._shell,u=s.compareToSameClass(a,r);if(0!==u)return u;for(var l=this.getNumInteriorRing(),c=o.getNumInteriorRing(),p=0;p<l&&p<c;){var h=this.getInteriorRingN(p),f=o.getInteriorRingN(p),g=h.compareToSameClass(f,r);if(0!==g)return g;p++}return p<l?1:p<c?-1:0}},e.prototype.apply=function(t){if(T(t,ft)){this._shell.apply(t);for(var e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(T(t,Ut)){if(this._shell.apply(t),!t.isDone())for(var n=0;n<this._holes.length&&(this._holes[n].apply(t),!t.isDone());n++);t.isGeometryChanged()&&this.geometryChanged()}else if(T(t,Vt))t.filter(this);else if(T(t,lt)){t.filter(this),this._shell.apply(t);for(var i=0;i<this._holes.length;i++)this._holes[i].apply(t)}},e.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(var e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},e.prototype.clone=function(){var e=t.prototype.clone.call(this);e._shell=this._shell.clone(),e._holes=new Array(this._holes.length).fill(null);for(var n=0;n<this._holes.length;n++)e._holes[n]=this._holes[n].clone();return e},e.prototype.getGeometryType=function(){return"Polygon"},e.prototype.copy=function(){for(var t=this._shell.copy(),n=new Array(this._holes.length).fill(null),i=0;i<n.length;i++)n[i]=this._holes[i].copy();return new e(t,n,this._factory)},e.prototype.getExteriorRing=function(){return this._shell},e.prototype.isEmpty=function(){return this._shell.isEmpty()},e.prototype.getInteriorRingN=function(t){return this._holes[t]},e.prototype.interfaces_=function(){return[Zt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return-0x307ffefd8dc97200},Object.defineProperties(e,n),e}(ct),te=function(t){function e(){t.apply(this,arguments)}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTIPOINT},e.prototype.isValid=function(){return!0},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getCoordinate=function(){if(1===arguments.length){var e=arguments[0];return this._geometries[e].getCoordinate()}return t.prototype.getCoordinate.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.getDimension=function(){return 0},e.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},e.prototype.getGeometryType=function(){return"MultiPoint"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return[Jt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return-0x6fb1ed4162e0fc00},Object.defineProperties(e,n),e}(zt),ee=function(t){function e(e,n){e instanceof C&&n instanceof _e&&(e=n.getCoordinateSequenceFactory().create(e)),t.call(this,e,n),this.validateConstruction()}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={MINIMUM_VALID_SIZE:{configurable:!0},serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_LINEARRING},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.isClosed=function(){return!!this.isEmpty()||t.prototype.isClosed.call(this)},e.prototype.reverse=function(){var t=this._points.copy();Wt.reverse(t);return this.getFactory().createLinearRing(t)},e.prototype.validateConstruction=function(){if(!this.isEmpty()&&!t.prototype.isClosed.call(this))throw new m("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<e.MINIMUM_VALID_SIZE)throw new m("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},e.prototype.getGeometryType=function(){return"LinearRing"},e.prototype.copy=function(){return new e(this._points.copy(),this._factory)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},n.MINIMUM_VALID_SIZE.get=function(){return 4},n.serialVersionUID.get=function(){return-0x3b229e262367a600},Object.defineProperties(e,n),e}(Kt),ne=function(t){function e(){t.apply(this,arguments)}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTIPOLYGON},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return 1},e.prototype.getDimension=function(){return 2},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[n]=this._geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},e.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new Nt,e=0;e<this._geometries.length;e++)for(var n=this._geometries[e].getBoundary(),i=0;i<n.getNumGeometries();i++)t.add(n.getGeometryN(i));var r=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(r))},e.prototype.getGeometryType=function(){return"MultiPolygon"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return[Zt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return-0x7a5aa1369171980},Object.defineProperties(e,n),e}(zt),ie=function(t){this._factory=t||null,this._isUserDataCopied=!1},re={NoOpGeometryOperation:{configurable:!0},CoordinateOperation:{configurable:!0},CoordinateSequenceOperation:{configurable:!0}};ie.prototype.setCopyUserData=function(t){this._isUserDataCopied=t},ie.prototype.edit=function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n},ie.prototype.editInternal=function(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof zt?this.editGeometryCollection(t,e):t instanceof $t?this.editPolygon(t,e):t instanceof Qt?e.edit(t,this._factory):t instanceof Kt?e.edit(t,this._factory):(et.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},ie.prototype.editGeometryCollection=function(t,e){for(var n=e.edit(t,this._factory),i=new Nt,r=0;r<n.getNumGeometries();r++){var o=this.edit(n.getGeometryN(r),e);null===o||o.isEmpty()||i.add(o)}return n.getClass()===te?this._factory.createMultiPoint(i.toArray([])):n.getClass()===Xt?this._factory.createMultiLineString(i.toArray([])):n.getClass()===ne?this._factory.createMultiPolygon(i.toArray([])):this._factory.createGeometryCollection(i.toArray([]))},ie.prototype.editPolygon=function(t,e){var n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this._factory.createPolygon();for(var r=new Nt,o=0;o<n.getNumInteriorRing();o++){var s=this.edit(n.getInteriorRingN(o),e);null===s||s.isEmpty()||r.add(s)}return this._factory.createPolygon(i,r.toArray([]))},ie.prototype.interfaces_=function(){return[]},ie.prototype.getClass=function(){return ie},ie.GeometryEditorOperation=function(){},re.NoOpGeometryOperation.get=function(){return oe},re.CoordinateOperation.get=function(){return se},re.CoordinateSequenceOperation.get=function(){return ae},Object.defineProperties(ie,re);var oe=function(){};oe.prototype.edit=function(t,e){return t},oe.prototype.interfaces_=function(){return[ie.GeometryEditorOperation]},oe.prototype.getClass=function(){return oe};var se=function(){};se.prototype.edit=function(t,e){var n=this.editCoordinates(t.getCoordinates(),t);return null===n?t:t instanceof ee?e.createLinearRing(n):t instanceof Kt?e.createLineString(n):t instanceof Qt?n.length>0?e.createPoint(n[0]):e.createPoint():t},se.prototype.interfaces_=function(){return[ie.GeometryEditorOperation]},se.prototype.getClass=function(){return se};var ae=function(){};ae.prototype.edit=function(t,e){return t instanceof ee?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Kt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Qt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},ae.prototype.interfaces_=function(){return[ie.GeometryEditorOperation]},ae.prototype.getClass=function(){return ae};var ue=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array)this._coordinates=arguments[0],this._dimension=3;else if(Number.isInteger(arguments[0])){var t=arguments[0];this._coordinates=new Array(t).fill(null);for(var e=0;e<t;e++)this._coordinates[e]=new C}else if(T(arguments[0],V)){var n=arguments[0];if(null===n)return this._coordinates=new Array(0).fill(null),null;this._dimension=n.getDimension(),this._coordinates=new Array(n.size()).fill(null);for(var i=0;i<this._coordinates.length;i++)this._coordinates[i]=n.getCoordinateCopy(i)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],o=arguments[1];this._coordinates=r,this._dimension=o,null===r&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var s=arguments[0],a=arguments[1];this._coordinates=new Array(s).fill(null),this._dimension=a;for(var u=0;u<s;u++)this._coordinates[u]=new C}},le={serialVersionUID:{configurable:!0}};ue.prototype.setOrdinate=function(t,e,n){switch(e){case V.X:this._coordinates[t].x=n;break;case V.Y:this._coordinates[t].y=n;break;case V.Z:this._coordinates[t].z=n;break;default:throw new m("invalid ordinateIndex")}},ue.prototype.size=function(){return this._coordinates.length},ue.prototype.getOrdinate=function(t,e){switch(e){case V.X:return this._coordinates[t].x;case V.Y:return this._coordinates[t].y;case V.Z:return this._coordinates[t].z}return v.NaN},ue.prototype.getCoordinate=function(){if(1===arguments.length){var t=arguments[0];return this._coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this._coordinates[e].x,n.y=this._coordinates[e].y,n.z=this._coordinates[e].z}},ue.prototype.getCoordinateCopy=function(t){return new C(this._coordinates[t])},ue.prototype.getDimension=function(){return this._dimension},ue.prototype.getX=function(t){return this._coordinates[t].x},ue.prototype.clone=function(){for(var t=new Array(this.size()).fill(null),e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].clone();return new ue(t,this._dimension)},ue.prototype.expandEnvelope=function(t){for(var e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t},ue.prototype.copy=function(){for(var t=new Array(this.size()).fill(null),e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new ue(t,this._dimension)},ue.prototype.toString=function(){if(this._coordinates.length>0){var t=new D(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(var e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"},ue.prototype.getY=function(t){return this._coordinates[t].y},ue.prototype.toCoordinateArray=function(){return this._coordinates},ue.prototype.interfaces_=function(){return[V,e]},ue.prototype.getClass=function(){return ue},le.serialVersionUID.get=function(){return-0xcb44a778db18e00},Object.defineProperties(ue,le);var ce=function(){},pe={serialVersionUID:{configurable:!0},instanceObject:{configurable:!0}};ce.prototype.readResolve=function(){return ce.instance()},ce.prototype.create=function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new ue(t)}if(T(arguments[0],V)){var e=arguments[0];return new ue(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),i<2?new ue(n):new ue(n,i)}},ce.prototype.interfaces_=function(){return[b,e]},ce.prototype.getClass=function(){return ce},ce.instance=function(){return ce.instanceObject},pe.serialVersionUID.get=function(){return-0x38e49fa6cf6f2e00},pe.instanceObject.get=function(){return new ce},Object.defineProperties(ce,pe);var he=function(t){function e(){t.call(this),this.map_=new Map}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return this.map_.get(t)||null},e.prototype.put=function(t,e){return this.map_.set(t,e),e},e.prototype.values=function(){for(var t=new Nt,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},e.prototype.entrySet=function(){var t=new Pt;return this.map_.entries().forEach(function(e){return t.add(e)}),t},e.prototype.size=function(){return this.map_.size()},e}(Tt),fe=function t(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=t.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof de){var e=arguments[0];this._modelType=e,e===t.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var n=arguments[0];this._modelType=t.FIXED,this.setScale(n)}else if(arguments[0]instanceof t){var i=arguments[0];this._modelType=i._modelType,this._scale=i._scale}},ge={serialVersionUID:{configurable:!0},maximumPreciseValue:{configurable:!0}};fe.prototype.equals=function(t){if(!(t instanceof fe))return!1;var e=t;return this._modelType===e._modelType&&this._scale===e._scale},fe.prototype.compareTo=function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new M(n).compareTo(new M(i))},fe.prototype.getScale=function(){return this._scale},fe.prototype.isFloating=function(){return this._modelType===fe.FLOATING||this._modelType===fe.FLOATING_SINGLE},fe.prototype.getType=function(){return this._modelType},fe.prototype.toString=function(){var t="UNKNOWN";return this._modelType===fe.FLOATING?t="Floating":this._modelType===fe.FLOATING_SINGLE?t="Floating-Single":this._modelType===fe.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},fe.prototype.makePrecise=function(){if("number"==typeof arguments[0]){var t=arguments[0];if(v.isNaN(t))return t;if(this._modelType===fe.FLOATING_SINGLE){return t}return this._modelType===fe.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof C){var e=arguments[0];if(this._modelType===fe.FLOATING)return null;e.x=this.makePrecise(e.x),e.y=this.makePrecise(e.y)}},fe.prototype.getMaximumSignificantDigits=function(){var t=16;return this._modelType===fe.FLOATING?t=16:this._modelType===fe.FLOATING_SINGLE?t=6:this._modelType===fe.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},fe.prototype.setScale=function(t){this._scale=Math.abs(t)},fe.prototype.interfaces_=function(){return[e,E]},fe.prototype.getClass=function(){return fe},fe.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},ge.serialVersionUID.get=function(){return 0x6bee6404e9a25c00},ge.maximumPreciseValue.get=function(){return 9007199254740992},Object.defineProperties(fe,ge);var de=function t(e){this._name=e||null,t.nameToTypeMap.put(e,this)},ye={serialVersionUID:{configurable:!0},nameToTypeMap:{configurable:!0}};de.prototype.readResolve=function(){return de.nameToTypeMap.get(this._name)},de.prototype.toString=function(){return this._name},de.prototype.interfaces_=function(){return[e]},de.prototype.getClass=function(){return de},ye.serialVersionUID.get=function(){return-552860263173159e4},ye.nameToTypeMap.get=function(){return new he},Object.defineProperties(de,ye),fe.Type=de,fe.FIXED=new de("FIXED"),fe.FLOATING=new de("FLOATING"),fe.FLOATING_SINGLE=new de("FLOATING SINGLE");var _e=function t(){this._precisionModel=new fe,this._SRID=0,this._coordinateSequenceFactory=t.getDefaultCoordinateSequenceFactory(),0===arguments.length||(1===arguments.length?T(arguments[0],b)?this._coordinateSequenceFactory=arguments[0]:arguments[0]instanceof fe&&(this._precisionModel=arguments[0]):2===arguments.length?(this._precisionModel=arguments[0],this._SRID=arguments[1]):3===arguments.length&&(this._precisionModel=arguments[0],this._SRID=arguments[1],this._coordinateSequenceFactory=arguments[2]))},me={serialVersionUID:{configurable:!0}};_e.prototype.toGeometry=function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new C(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new C(t.getMinX(),t.getMinY()),new C(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new C(t.getMinX(),t.getMinY()),new C(t.getMinX(),t.getMaxY()),new C(t.getMaxX(),t.getMaxY()),new C(t.getMaxX(),t.getMinY()),new C(t.getMinX(),t.getMinY())]),null)},_e.prototype.createLineString=function(t){return t?t instanceof Array?new Kt(this.getCoordinateSequenceFactory().create(t),this):T(t,V)?new Kt(t,this):void 0:new Kt(this.getCoordinateSequenceFactory().create([]),this)},_e.prototype.createMultiLineString=function(){if(0===arguments.length)return new Xt(null,this);if(1===arguments.length){var t=arguments[0];return new Xt(t,this)}},_e.prototype.buildGeometry=function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var o=r.next(),s=o.getClass();null===e&&(e=s),s!==e&&(n=!0),o.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(_e.toGeometryArray(t));var a=t.iterator().next();if(t.size()>1){if(a instanceof $t)return this.createMultiPolygon(_e.toPolygonArray(t));if(a instanceof Kt)return this.createMultiLineString(_e.toLineStringArray(t));if(a instanceof Qt)return this.createMultiPoint(_e.toPointArray(t));et.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},_e.prototype.createMultiPointFromCoords=function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},_e.prototype.createPoint=function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(T(arguments[0],V)){var e=arguments[0];return new Qt(e,this)}}},_e.prototype.getCoordinateSequenceFactory=function(){return this._coordinateSequenceFactory},_e.prototype.createPolygon=function(){if(0===arguments.length)return new $t(null,null,this);if(1===arguments.length){if(T(arguments[0],V)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof ee){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new $t(i,r,this)}},_e.prototype.getSRID=function(){return this._SRID},_e.prototype.createGeometryCollection=function(){if(0===arguments.length)return new zt(null,this);if(1===arguments.length){var t=arguments[0];return new zt(t,this)}},_e.prototype.createGeometry=function(t){return new ie(this).edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];return this._coordinateSequenceFactory.create(t)}}})},_e.prototype.getPrecisionModel=function(){return this._precisionModel},_e.prototype.createLinearRing=function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(T(arguments[0],V)){var e=arguments[0];return new ee(e,this)}}},_e.prototype.createMultiPolygon=function(){if(0===arguments.length)return new ne(null,this);if(1===arguments.length){var t=arguments[0];return new ne(t,this)}},_e.prototype.createMultiPoint=function(){if(0===arguments.length)return new te(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new te(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(T(arguments[0],V)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var o=this.getCoordinateSequenceFactory().create(1,n.getDimension());Wt.copy(n,r,o,0,1),i[r]=this.createPoint(o)}return this.createMultiPoint(i)}}},_e.prototype.interfaces_=function(){return[e]},_e.prototype.getClass=function(){return _e},_e.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.getDefaultCoordinateSequenceFactory=function(){return ce.instance()},_e.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},me.serialVersionUID.get=function(){return-0x5ea75f2051eeb400},Object.defineProperties(_e,me);var ve=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],Ie=function(t){this.geometryFactory=t||new _e};Ie.prototype.read=function(t){var e,n=(e="string"==typeof t?JSON.parse(t):t).type;if(!Ee[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==ve.indexOf(n)?Ee[n].apply(this,[e.coordinates]):"GeometryCollection"===n?Ee[n].apply(this,[e.geometries]):Ee[n].apply(this,[e])},Ie.prototype.write=function(t){var e=t.getGeometryType();if(!xe[e])throw new Error("Geometry is not supported");return xe[e].apply(this,[t])};var Ee={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!Ee[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Ee.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(new C(i[0],i[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new C(t[0],t[1]),new C(t[2],t[1]),new C(t[2],t[3]),new C(t[0],t[3]),new C(t[0],t[1])])},Point:function(t){var e=new C(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Ee.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=Ee.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Ee.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=Ee.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var o=t[r],s=Ee.coordinates.apply(this,[o]),a=this.geometryFactory.createLinearRing(s);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(Ee.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},xe={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:xe.coordinate.apply(this,[t.getCoordinate()])}},MultiPoint:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(xe.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=xe.LineString.apply(this,[t._shell]);e.push(n.coordinates);for(var i=0;i<t._holes.length;++i){var r=t._holes[i],o=xe.LineString.apply(this,[r]);e.push(o.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=i.getGeometryType();e.push(xe[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}},Ne=function(t){this.geometryFactory=t||new _e,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new Ie(this.geometryFactory)};Ne.prototype.read=function(t){var e=this.parser.read(t);return this.precisionModel.getType()===fe.FIXED&&this.reducePrecision(e),e},Ne.prototype.reducePrecision=function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;e<n;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;e<n;e++)this.reducePrecision(t.geometries[e])};var Ce=function(){this.parser=new Ie(this.geometryFactory)};Ce.prototype.write=function(t){return this.parser.write(t)};var Se=function(){},Le={ON:{configurable:!0},LEFT:{configurable:!0},RIGHT:{configurable:!0}};Se.prototype.interfaces_=function(){return[]},Se.prototype.getClass=function(){return Se},Se.opposite=function(t){return t===Se.LEFT?Se.RIGHT:t===Se.RIGHT?Se.LEFT:t},Le.ON.get=function(){return 0},Le.LEFT.get=function(){return 1},Le.RIGHT.get=function(){return 2},Object.defineProperties(Se,Le),(d.prototype=new Error).name="EmptyStackException",(y.prototype=new xt).add=function(t){return this.array_.push(t),!0},y.prototype.get=function(t){if(t<0||t>=this.size())throw new Error;return this.array_[t]},y.prototype.push=function(t){return this.array_.push(t),t},y.prototype.pop=function(t){if(0===this.array_.length)throw new d;return this.array_.pop()},y.prototype.peek=function(){if(0===this.array_.length)throw new d;return this.array_[this.array_.length-1]},y.prototype.empty=function(){return 0===this.array_.length},y.prototype.isEmpty=function(){return this.empty()},y.prototype.search=function(t){return this.array_.indexOf(t)},y.prototype.size=function(){return this.array_.length},y.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};var be=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null};be.prototype.getCoordinate=function(){return this._minCoord},be.prototype.getRightmostSide=function(t,e){var n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n},be.prototype.findRightmostEdgeAtVertex=function(){var t=this._minDe.getEdge().getCoordinates();et.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this._minIndex-1],n=t[this._minIndex+1],i=at.computeOrientation(this._minCoord,n,e),r=!1;e.y<this._minCoord.y&&n.y<this._minCoord.y&&i===at.COUNTERCLOCKWISE?r=!0:e.y>this._minCoord.y&&n.y>this._minCoord.y&&i===at.CLOCKWISE&&(r=!0),r&&(this._minIndex=this._minIndex-1)},be.prototype.getRightmostSideOfSegment=function(t,e){var n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;var i=Se.LEFT;return n[e].y<n[e+1].y&&(i=Se.RIGHT),i},be.prototype.getEdge=function(){return this._orientedDe},be.prototype.checkForRightmostCoordinate=function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])},be.prototype.findRightmostEdgeAtNode=function(){var t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)},be.prototype.findEdge=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}et.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===Se.LEFT&&(this._orientedDe=this._minDe.getSym())},be.prototype.interfaces_=function(){return[]},be.prototype.getClass=function(){return be};var we=function(t){function e(n,i){t.call(this,e.msgWithCoord(n,i)),this.pt=i?new C(i):null,this.name="TopologyException"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getCoordinate=function(){return this.pt},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e.msgWithCoord=function(t,e){return e?t:t+" [ "+e+" ]"},e}($),Oe=function(){this.array_=[]};Oe.prototype.addLast=function(t){this.array_.push(t)},Oe.prototype.removeFirst=function(){return this.array_.shift()},Oe.prototype.isEmpty=function(){return 0===this.array_.length};var Te=function(){this._finder=null,this._dirEdgeList=new Nt,this._nodes=new Nt,this._rightMostCoord=null,this._env=null,this._finder=new be};Te.prototype.clearVisitedEdges=function(){for(var t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}},Te.prototype.getRightmostCoordinate=function(){return this._rightMostCoord},Te.prototype.computeNodeDepth=function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new we("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var r=t.getEdges().iterator();r.hasNext();){var o=r.next();o.setVisited(!0),this.copySymDepths(o)}},Te.prototype.computeDepth=function(t){this.clearVisitedEdges();var e=this._finder.getEdge();e.setEdgeDepths(Se.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},Te.prototype.create=function(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()},Te.prototype.findResultEdges=function(){for(var t=this._dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(Se.RIGHT)>=1&&e.getDepth(Se.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},Te.prototype.computeDepths=function(t){var e=new Pt,n=new Oe,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var o=r.getEdges().iterator();o.hasNext();){var s=o.next().getSym();if(!s.isVisited()){var a=s.getNode();e.contains(a)||(n.addLast(a),e.add(a))}}}},Te.prototype.compareTo=function(t){var e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0},Te.prototype.getEnvelope=function(){if(null===this._env){for(var t=new j,e=this._dirEdgeList.iterator();e.hasNext();)for(var n=e.next().getEdge().getCoordinates(),i=0;i<n.length-1;i++)t.expandToInclude(n[i]);this._env=t}return this._env},Te.prototype.addReachable=function(t){var e=new y;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},Te.prototype.copySymDepths=function(t){var e=t.getSym();e.setDepth(Se.LEFT,t.getDepth(Se.RIGHT)),e.setDepth(Se.RIGHT,t.getDepth(Se.LEFT))},Te.prototype.add=function(t,e){t.setVisited(!0),this._nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this._dirEdgeList.add(i);var r=i.getSym().getNode();r.isVisited()||e.push(r)}},Te.prototype.getNodes=function(){return this._nodes},Te.prototype.getDirectedEdges=function(){return this._dirEdgeList},Te.prototype.interfaces_=function(){return[E]},Te.prototype.getClass=function(){return Te};var Re=function t(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var e=arguments[0];this.init(e.length)}else if(Number.isInteger(arguments[0])){var n=arguments[0];this.init(1),this.location[Se.ON]=n}else if(arguments[0]instanceof t){var i=arguments[0];if(this.init(i.location.length),null!==i)for(var r=0;r<this.location.length;r++)this.location[r]=i.location[r]}}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.init(3),this.location[Se.ON]=o,this.location[Se.LEFT]=s,this.location[Se.RIGHT]=a}};Re.prototype.setAllLocations=function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},Re.prototype.isNull=function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==w.NONE)return!1;return!0},Re.prototype.setAllLocationsIfNull=function(t){for(var e=0;e<this.location.length;e++)this.location[e]===w.NONE&&(this.location[e]=t)},Re.prototype.isLine=function(){return 1===this.location.length},Re.prototype.merge=function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[Se.ON]=this.location[Se.ON],e[Se.LEFT]=w.NONE,e[Se.RIGHT]=w.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===w.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},Re.prototype.getLocations=function(){return this.location},Re.prototype.flip=function(){if(this.location.length<=1)return null;var t=this.location[Se.LEFT];this.location[Se.LEFT]=this.location[Se.RIGHT],this.location[Se.RIGHT]=t},Re.prototype.toString=function(){var t=new D;return this.location.length>1&&t.append(w.toLocationSymbol(this.location[Se.LEFT])),t.append(w.toLocationSymbol(this.location[Se.ON])),this.location.length>1&&t.append(w.toLocationSymbol(this.location[Se.RIGHT])),t.toString()},Re.prototype.setLocations=function(t,e,n){this.location[Se.ON]=t,this.location[Se.LEFT]=e,this.location[Se.RIGHT]=n},Re.prototype.get=function(t){return t<this.location.length?this.location[t]:w.NONE},Re.prototype.isArea=function(){return this.location.length>1},Re.prototype.isAnyNull=function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===w.NONE)return!0;return!1},Re.prototype.setLocation=function(){if(1===arguments.length){var t=arguments[0];this.setLocation(Se.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},Re.prototype.init=function(t){this.location=new Array(t).fill(null),this.setAllLocations(w.NONE)},Re.prototype.isEqualOnSide=function(t,e){return this.location[e]===t.location[e]},Re.prototype.allPositionsEqual=function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},Re.prototype.interfaces_=function(){return[]},Re.prototype.getClass=function(){return Re};var Pe=function t(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var e=arguments[0];this.elt[0]=new Re(e),this.elt[1]=new Re(e)}else if(arguments[0]instanceof t){var n=arguments[0];this.elt[0]=new Re(n.elt[0]),this.elt[1]=new Re(n.elt[1])}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.elt[0]=new Re(w.NONE),this.elt[1]=new Re(w.NONE),this.elt[i].setLocation(r)}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.elt[0]=new Re(o,s,a),this.elt[1]=new Re(o,s,a)}else if(4===arguments.length){var u=arguments[0],l=arguments[1],c=arguments[2],p=arguments[3];this.elt[0]=new Re(w.NONE,w.NONE,w.NONE),this.elt[1]=new Re(w.NONE,w.NONE,w.NONE),this.elt[u].setLocations(l,c,p)}};Pe.prototype.getGeometryCount=function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},Pe.prototype.setAllLocations=function(t,e){this.elt[t].setAllLocations(e)},Pe.prototype.isNull=function(t){return this.elt[t].isNull()},Pe.prototype.setAllLocationsIfNull=function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},Pe.prototype.isLine=function(t){return this.elt[t].isLine()},Pe.prototype.merge=function(t){for(var e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Re(t.elt[e]):this.elt[e].merge(t.elt[e])},Pe.prototype.flip=function(){this.elt[0].flip(),this.elt[1].flip()},Pe.prototype.getLocation=function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(Se.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},Pe.prototype.toString=function(){var t=new D;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},Pe.prototype.isArea=function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},Pe.prototype.isAnyNull=function(t){return this.elt[t].isAnyNull()},Pe.prototype.setLocation=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(Se.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},Pe.prototype.isEqualOnSide=function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},Pe.prototype.allPositionsEqual=function(t,e){return this.elt[t].allPositionsEqual(e)},Pe.prototype.toLine=function(t){this.elt[t].isArea()&&(this.elt[t]=new Re(this.elt[t].location[0]))},Pe.prototype.interfaces_=function(){return[]},Pe.prototype.getClass=function(){return Pe},Pe.toLineLabel=function(t){for(var e=new Pe(w.NONE),n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e};var De=function(){this._startDe=null,this._maxNodeDegree=-1,this._edges=new Nt,this._pts=new Nt,this._label=new Pe(w.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new Nt,this._geometryFactory=null;var t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()};De.prototype.computeRing=function(){if(null!==this._ring)return null;for(var t=new Array(this._pts.size()).fill(null),e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=at.isCCW(this._ring.getCoordinates())},De.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},De.prototype.computePoints=function(t){this._startDe=t;var e=t,n=!0;do{if(null===e)throw new we("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new we("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);var i=e.getLabel();et.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)},De.prototype.getLinearRing=function(){return this._ring},De.prototype.getCoordinate=function(t){return this._pts.get(t)},De.prototype.computeMaxNodeDegree=function(){this._maxNodeDegree=0;var t=this._startDe;do{var e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2},De.prototype.addPoints=function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var o=r;o<i.length;o++)this._pts.add(i[o])}else{var s=i.length-2;n&&(s=i.length-1);for(var a=s;a>=0;a--)this._pts.add(i[a])}},De.prototype.isHole=function(){return this._isHole},De.prototype.setInResult=function(){var t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)},De.prototype.containsPoint=function(t){var e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!at.isPointInRing(t,e.getCoordinates()))return!1;for(var n=this._holes.iterator();n.hasNext();){if(n.next().containsPoint(t))return!1}return!0},De.prototype.addHole=function(t){this._holes.add(t)},De.prototype.isShell=function(){return null===this._shell},De.prototype.getLabel=function(){return this._label},De.prototype.getEdges=function(){return this._edges},De.prototype.getMaxNodeDegree=function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree},De.prototype.getShell=function(){return this._shell},De.prototype.mergeLabel=function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,Se.RIGHT);if(i===w.NONE)return null;if(this._label.getLocation(n)===w.NONE)return this._label.setLocation(n,i),null}},De.prototype.setShell=function(t){this._shell=t,null!==t&&t.addHole(this)},De.prototype.toPolygon=function(t){for(var e=new Array(this._holes.size()).fill(null),n=0;n<this._holes.size();n++)e[n]=this._holes.get(n).getLinearRing();return t.createPolygon(this.getLinearRing(),e)},De.prototype.interfaces_=function(){return[]},De.prototype.getClass=function(){return De};var Me=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setEdgeRing=function(t,e){t.setMinEdgeRing(e)},e.prototype.getNext=function(t){return t.getNextMin()},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(De),Ae=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.buildMinimalRings=function(){var t=new Nt,e=this._startDe;do{if(null===e.getMinEdgeRing()){var n=new Me(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t},e.prototype.setEdgeRing=function(t,e){t.setEdgeRing(e)},e.prototype.linkDirectedEdgesForMinimalEdgeRings=function(){var t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)},e.prototype.getNext=function(t){return t.getNext()},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(De),Fe=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._label=t}};Fe.prototype.setVisited=function(t){this._isVisited=t},Fe.prototype.setInResult=function(t){this._isInResult=t},Fe.prototype.isCovered=function(){return this._isCovered},Fe.prototype.isCoveredSet=function(){return this._isCoveredSet},Fe.prototype.setLabel=function(t){this._label=t},Fe.prototype.getLabel=function(){return this._label},Fe.prototype.setCovered=function(t){this._isCovered=t,this._isCoveredSet=!0},Fe.prototype.updateIM=function(t){et.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},Fe.prototype.isInResult=function(){return this._isInResult},Fe.prototype.isVisited=function(){return this._isVisited},Fe.prototype.interfaces_=function(){return[]},Fe.prototype.getClass=function(){return Fe};var Ge=function(t){function e(){t.call(this),this._coord=null,this._edges=null;var e=arguments[0],n=arguments[1];this._coord=e,this._edges=n,this._label=new Pe(0,w.NONE)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isIncidentEdgeInResult=function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1},e.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},e.prototype.getCoordinate=function(){return this._coord},e.prototype.print=function(t){t.println("node "+this._coord+" lbl: "+this._label)},e.prototype.computeIM=function(t){},e.prototype.computeMergedLocation=function(t,e){var n=w.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==w.BOUNDARY&&(n=i)}return n},e.prototype.setLabel=function(){if(2!==arguments.length)return t.prototype.setLabel.apply(this,arguments);var e=arguments[0],n=arguments[1];null===this._label?this._label=new Pe(e,n):this._label.setLocation(e,n)},e.prototype.getEdges=function(){return this._edges},e.prototype.mergeLabel=function(){if(arguments[0]instanceof e){var t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Pe)for(var n=arguments[0],i=0;i<2;i++){var r=this.computeMergedLocation(n,i);this._label.getLocation(i)===w.NONE&&this._label.setLocation(i,r)}},e.prototype.add=function(t){this._edges.insert(t),t.setNode(this)},e.prototype.setLabelBoundary=function(t){if(null===this._label)return null;var e=w.NONE;null!==this._label&&(e=this._label.getLocation(t));var n=null;switch(e){case w.BOUNDARY:n=w.INTERIOR;break;case w.INTERIOR:default:n=w.BOUNDARY}this._label.setLocation(t,n)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Fe),qe=function(){this.nodeMap=new p,this.nodeFact=null;var t=arguments[0];this.nodeFact=t};qe.prototype.find=function(t){return this.nodeMap.get(t)},qe.prototype.addNode=function(){if(arguments[0]instanceof C){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof Ge){var n=arguments[0],i=this.nodeMap.get(n.getCoordinate());return null===i?(this.nodeMap.put(n.getCoordinate(),n),n):(i.mergeLabel(n),i)}},qe.prototype.print=function(t){for(var e=this.iterator();e.hasNext();){e.next().print(t)}},qe.prototype.iterator=function(){return this.nodeMap.values().iterator()},qe.prototype.values=function(){return this.nodeMap.values()},qe.prototype.getBoundaryNodes=function(t){for(var e=new Nt,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===w.BOUNDARY&&e.add(i)}return e},qe.prototype.add=function(t){var e=t.getCoordinate();this.addNode(e).add(t)},qe.prototype.interfaces_=function(){return[]},qe.prototype.getClass=function(){return qe};var Be=function(){},Ve={NE:{configurable:!0},NW:{configurable:!0},SW:{configurable:!0},SE:{configurable:!0}};Be.prototype.interfaces_=function(){return[]},Be.prototype.getClass=function(){return Be},Be.isNorthern=function(t){return t===Be.NE||t===Be.NW},Be.isOpposite=function(t,e){if(t===e)return!1;return 2===(t-e+4)%4},Be.commonHalfPlane=function(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;var n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n},Be.isInHalfPlane=function(t,e){return e===Be.SE?t===Be.SE||t===Be.SW:t===e||t===e+1},Be.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new m("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Be.NE:Be.SE:e>=0?Be.NW:Be.SW}if(arguments[0]instanceof C&&arguments[1]instanceof C){var n=arguments[0],i=arguments[1];if(i.x===n.x&&i.y===n.y)throw new m("Cannot compute the quadrant for two identical points "+n);return i.x>=n.x?i.y>=n.y?Be.NE:Be.SE:i.y>=n.y?Be.NW:Be.SW}},Ve.NE.get=function(){return 0},Ve.NW.get=function(){return 1},Ve.SW.get=function(){return 2},Ve.SE.get=function(){return 3},Object.defineProperties(Be,Ve);var Ue=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){var t=arguments[0];this._edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];this._edge=e,this.init(n,i),this._label=null}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];this._edge=r,this.init(o,s),this._label=a}};Ue.prototype.compareDirection=function(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:at.computeOrientation(t._p0,t._p1,this._p1)},Ue.prototype.getDy=function(){return this._dy},Ue.prototype.getCoordinate=function(){return this._p0},Ue.prototype.setNode=function(t){this._node=t},Ue.prototype.print=function(t){var e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)},Ue.prototype.compareTo=function(t){var e=t;return this.compareDirection(e)},Ue.prototype.getDirectedCoordinate=function(){return this._p1},Ue.prototype.getDx=function(){return this._dx},Ue.prototype.getLabel=function(){return this._label},Ue.prototype.getEdge=function(){return this._edge},Ue.prototype.getQuadrant=function(){return this._quadrant},Ue.prototype.getNode=function(){return this._node},Ue.prototype.toString=function(){var t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label},Ue.prototype.computeLabel=function(t){},Ue.prototype.init=function(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Be.quadrant(this._dx,this._dy),et.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")},Ue.prototype.interfaces_=function(){return[E]},Ue.prototype.getClass=function(){return Ue};var ze=function(t){function e(){var e=arguments[0],n=arguments[1];if(t.call(this,e),this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999],this._isForward=n,n)this.init(e.getCoordinate(0),e.getCoordinate(1));else{var i=e.getNumPoints()-1;this.init(e.getCoordinate(i),e.getCoordinate(i-1))}this.computeDirectedLabel()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getNextMin=function(){return this._nextMin},e.prototype.getDepth=function(t){return this._depth[t]},e.prototype.setVisited=function(t){this._isVisited=t},e.prototype.computeDirectedLabel=function(){this._label=new Pe(this._edge.getLabel()),this._isForward||this._label.flip()},e.prototype.getNext=function(){return this._next},e.prototype.setDepth=function(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new we("assigned depths do not match",this.getCoordinate());this._depth[t]=e},e.prototype.isInteriorAreaEdge=function(){for(var t=!0,e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Se.LEFT)===w.INTERIOR&&this._label.getLocation(e,Se.RIGHT)===w.INTERIOR||(t=!1);return t},e.prototype.setNextMin=function(t){this._nextMin=t},e.prototype.print=function(e){t.prototype.print.call(this,e),e.print(" "+this._depth[Se.LEFT]+"/"+this._depth[Se.RIGHT]),e.print(" ("+this.getDepthDelta()+")"),this._isInResult&&e.print(" inResult")},e.prototype.setMinEdgeRing=function(t){this._minEdgeRing=t},e.prototype.isLineEdge=function(){var t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,w.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,w.EXTERIOR);return t&&e&&n},e.prototype.setEdgeRing=function(t){this._edgeRing=t},e.prototype.getMinEdgeRing=function(){return this._minEdgeRing},e.prototype.getDepthDelta=function(){var t=this._edge.getDepthDelta();return this._isForward||(t=-t),t},e.prototype.setInResult=function(t){this._isInResult=t},e.prototype.getSym=function(){return this._sym},e.prototype.isForward=function(){return this._isForward},e.prototype.getEdge=function(){return this._edge},e.prototype.printEdge=function(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)},e.prototype.setSym=function(t){this._sym=t},e.prototype.setVisitedEdge=function(t){this.setVisited(t),this._sym.setVisited(t)},e.prototype.setEdgeDepths=function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===Se.LEFT&&(i=-1);var r=Se.opposite(t),o=e+n*i;this.setDepth(t,e),this.setDepth(r,o)},e.prototype.getEdgeRing=function(){return this._edgeRing},e.prototype.isInResult=function(){return this._isInResult},e.prototype.setNext=function(t){this._next=t},e.prototype.isVisited=function(){return this._isVisited},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e.depthFactor=function(t,e){return t===w.EXTERIOR&&e===w.INTERIOR?1:t===w.INTERIOR&&e===w.EXTERIOR?-1:0},e}(Ue),Xe=function(){};Xe.prototype.createNode=function(t){return new Ge(t,null)},Xe.prototype.interfaces_=function(){return[]},Xe.prototype.getClass=function(){return Xe};var Ye=function(){if(this._edges=new Nt,this._nodes=null,this._edgeEndList=new Nt,0===arguments.length)this._nodes=new qe(new Xe);else if(1===arguments.length){var t=arguments[0];this._nodes=new qe(t)}};Ye.prototype.printEdges=function(t){t.println("Edges:");for(var e=0;e<this._edges.size();e++){t.println("edge "+e+":");var n=this._edges.get(e);n.print(t),n.eiList.print(t)}},Ye.prototype.find=function(t){return this._nodes.find(t)},Ye.prototype.addNode=function(){if(arguments[0]instanceof Ge){var t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof C){var e=arguments[0];return this._nodes.addNode(e)}},Ye.prototype.getNodeIterator=function(){return this._nodes.iterator()},Ye.prototype.linkResultDirectedEdges=function(){for(var t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}},Ye.prototype.debugPrintln=function(t){Y.out.println(t)},Ye.prototype.isBoundaryNode=function(t,e){var n=this._nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===w.BOUNDARY},Ye.prototype.linkAllDirectedEdges=function(){for(var t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}},Ye.prototype.matchInSameDirection=function(t,e,n,i){return!!t.equals(n)&&(at.computeOrientation(t,e,i)===at.COLLINEAR&&Be.quadrant(t,e)===Be.quadrant(n,i))},Ye.prototype.getEdgeEnds=function(){return this._edgeEndList},Ye.prototype.debugPrint=function(t){Y.out.print(t)},Ye.prototype.getEdgeIterator=function(){return this._edges.iterator()},Ye.prototype.findEdgeInSameDirection=function(t,e){for(var n=0;n<this._edges.size();n++){var i=this._edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},Ye.prototype.insertEdge=function(t){this._edges.add(t)},Ye.prototype.findEdgeEnd=function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},Ye.prototype.addEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this._edges.add(n);var i=new ze(n,!0),r=new ze(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},Ye.prototype.add=function(t){this._nodes.add(t),this._edgeEndList.add(t)},Ye.prototype.getNodes=function(){return this._nodes.values()},Ye.prototype.findEdge=function(t,e){for(var n=0;n<this._edges.size();n++){var i=this._edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},Ye.prototype.interfaces_=function(){return[]},Ye.prototype.getClass=function(){return Ye},Ye.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}};var ke=function(){this._geometryFactory=null,this._shellList=new Nt;var t=arguments[0];this._geometryFactory=t};ke.prototype.sortShellsAndHoles=function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},ke.prototype.computePolygons=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next().toPolygon(this._geometryFactory);e.add(i)}return e},ke.prototype.placeFreeHoles=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new we("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},ke.prototype.buildMinimalEdgeRings=function(t,e,n){for(var i=new Nt,r=t.iterator();r.hasNext();){var o=r.next();if(o.getMaxNodeDegree()>2){o.linkDirectedEdgesForMinimalEdgeRings();var s=o.buildMinimalRings(),a=this.findShell(s);null!==a?(this.placePolygonHoles(a,s),e.add(a)):n.addAll(s)}else i.add(o)}return i},ke.prototype.containsPoint=function(t){for(var e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return!0}return!1},ke.prototype.buildMaximalEdgeRings=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new Ae(i,this._geometryFactory);e.add(r),r.setInResult()}}return e},ke.prototype.placePolygonHoles=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},ke.prototype.getPolygons=function(){return this.computePolygons(this._shellList)},ke.prototype.findEdgeRingContaining=function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),o=null,s=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),c=l.getEnvelopeInternal();null!==o&&(s=o.getLinearRing().getEnvelopeInternal());var p=!1;c.contains(i)&&at.isPointInRing(r,l.getCoordinates())&&(p=!0),p&&(null===o||s.contains(c))&&(o=u)}return o},ke.prototype.findShell=function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return et.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n},ke.prototype.add=function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Ye.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new Nt,o=this.buildMinimalEdgeRings(i,this._shellList,r);this.sortShellsAndHoles(o,this._shellList,r),this.placeFreeHoles(this._shellList,r)}},ke.prototype.interfaces_=function(){return[]},ke.prototype.getClass=function(){return ke};var je=function(){};je.prototype.getBounds=function(){},je.prototype.interfaces_=function(){return[]},je.prototype.getClass=function(){return je};var He=function(){this._bounds=null,this._item=null;var t=arguments[0],e=arguments[1];this._bounds=t,this._item=e};He.prototype.getItem=function(){return this._item},He.prototype.getBounds=function(){return this._bounds},He.prototype.interfaces_=function(){return[je,e]},He.prototype.getClass=function(){return He};var We=function(){this._size=null,this._items=null,this._size=0,this._items=new Nt,this._items.add(null)};We.prototype.poll=function(){if(this.isEmpty())return null;var t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t},We.prototype.size=function(){return this._size},We.prototype.reorder=function(t){for(var e=null,n=this._items.get(t);2*t<=this._size&&((e=2*t)!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)},We.prototype.clear=function(){this._size=0,this._items.clear()},We.prototype.isEmpty=function(){return 0===this._size},We.prototype.add=function(t){this._items.add(null),this._size+=1;var e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)},We.prototype.interfaces_=function(){return[]},We.prototype.getClass=function(){return We};var Ke=function(){};Ke.prototype.visitItem=function(t){},Ke.prototype.interfaces_=function(){return[]},Ke.prototype.getClass=function(){return Ke};var Je=function(){};Je.prototype.insert=function(t,e){},Je.prototype.remove=function(t,e){},Je.prototype.query=function(){},Je.prototype.interfaces_=function(){return[]},Je.prototype.getClass=function(){return Je};var Qe=function(){if(this._childBoundables=new Nt,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._level=t}},Ze={serialVersionUID:{configurable:!0}};Qe.prototype.getLevel=function(){return this._level},Qe.prototype.size=function(){return this._childBoundables.size()},Qe.prototype.getChildBoundables=function(){return this._childBoundables},Qe.prototype.addChildBoundable=function(t){et.isTrue(null===this._bounds),this._childBoundables.add(t)},Qe.prototype.isEmpty=function(){return this._childBoundables.isEmpty()},Qe.prototype.getBounds=function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds},Qe.prototype.interfaces_=function(){return[je,e]},Qe.prototype.getClass=function(){return Qe},Ze.serialVersionUID.get=function(){return 0x5a1e55ec41369800},Object.defineProperties(Qe,Ze);var $e=function(){};$e.reverseOrder=function(){return{compare:function(t,e){return e.compareTo(t)}}},$e.min=function(t){return $e.sort(t),t.get(0)},$e.sort=function(t,e){var n=t.toArray();e?Gt.sort(n,e):Gt.sort(n);for(var i=t.iterator(),r=0,o=n.length;r<o;r++)i.next(),i.set(n[r])},$e.singletonList=function(t){var e=new Nt;return e.add(t),e};var tn=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()};tn.prototype.expandToQueue=function(t,e){var n=tn.isComposite(this._boundable1),i=tn.isComposite(this._boundable2);if(n&&i)return tn.area(this._boundable1)>tn.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new m("neither boundable is composite")},tn.prototype.isLeaves=function(){return!(tn.isComposite(this._boundable1)||tn.isComposite(this._boundable2))},tn.prototype.compareTo=function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},tn.prototype.expand=function(t,e,n,i){for(var r=t.getChildBoundables().iterator();r.hasNext();){var o=r.next(),s=new tn(o,e,this._itemDistance);s.getDistance()<i&&n.add(s)}},tn.prototype.getBoundable=function(t){return 0===t?this._boundable1:this._boundable2},tn.prototype.getDistance=function(){return this._distance},tn.prototype.distance=function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())},tn.prototype.interfaces_=function(){return[E]},tn.prototype.getClass=function(){return tn},tn.area=function(t){return t.getBounds().getArea()},tn.isComposite=function(t){return t instanceof Qe};var en=function t(){if(this._root=null,this._built=!1,this._itemBoundables=new Nt,this._nodeCapacity=null,0===arguments.length){var e=t.DEFAULT_NODE_CAPACITY;this._nodeCapacity=e}else if(1===arguments.length){var n=arguments[0];et.isTrue(n>1,"Node capacity must be greater than 1"),this._nodeCapacity=n}},nn={IntersectsOp:{configurable:!0},serialVersionUID:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};en.prototype.getNodeCapacity=function(){return this._nodeCapacity},en.prototype.lastNode=function(t){return t.get(t.size()-1)},en.prototype.size=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();n instanceof Qe?t+=this.size(n):n instanceof He&&(t+=1)}return t}},en.prototype.removeItem=function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof He&&r.getItem()===e&&(n=r)}return null!==n&&(t.getChildBoundables().remove(n),!0)},en.prototype.itemsTree=function(){if(0===arguments.length){this.build();var t=this.itemsTree(this._root);return null===t?new Nt:t}if(1===arguments.length){for(var e=arguments[0],n=new Nt,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Qe){var o=this.itemsTree(r);null!==o&&n.add(o)}else r instanceof He?n.add(r.getItem()):et.shouldNeverReachHere()}return n.size()<=0?null:n}},en.prototype.insert=function(t,e){et.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new He(t,e))},en.prototype.boundablesAtLevel=function(){if(1===arguments.length){var t=arguments[0],e=new Nt;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(et.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var o=i.getChildBoundables().iterator();o.hasNext();){var s=o.next();s instanceof Qe?this.boundablesAtLevel(n,s,r):(et.isTrue(s instanceof He),-1===n&&r.add(s))}return null}},en.prototype.query=function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new Nt;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.query(t,this._root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),n)&&this.query(n,this._root,i)}else if(3===arguments.length)if(T(arguments[2],Ke)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe)for(var r=arguments[0],o=arguments[1],s=arguments[2],a=o.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Qe?this.query(r,l,s):l instanceof He?s.visitItem(l.getItem()):et.shouldNeverReachHere())}else if(T(arguments[2],xt)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe)for(var c=arguments[0],p=arguments[1],h=arguments[2],f=p.getChildBoundables(),g=0;g<f.size();g++){var d=f.get(g);this.getIntersectsOp().intersects(d.getBounds(),c)&&(d instanceof Qe?this.query(c,d,h):d instanceof He?h.add(d.getItem()):et.shouldNeverReachHere())}},en.prototype.build=function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0},en.prototype.getRoot=function(){return this.build(),this._root},en.prototype.remove=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=this.removeItem(i,r);if(o)return!0;for(var s=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&(u instanceof Qe&&(o=this.remove(n,u,r)))){s=u;break}}return null!==s&&s.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(s),o}},en.prototype.createHigherLevels=function(t,e){et.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},en.prototype.depth=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();if(n instanceof Qe){var i=this.depth(n);i>t&&(t=i)}}return t+1}},en.prototype.createParentBoundables=function(t,e){et.isTrue(!t.isEmpty());var n=new Nt;n.add(this.createNode(e));var i=new Nt(t);$e.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var o=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(o)}return n},en.prototype.isEmpty=function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()},en.prototype.interfaces_=function(){return[e]},en.prototype.getClass=function(){return en},en.compareDoubles=function(t,e){return t>e?1:t<e?-1:0},nn.IntersectsOp.get=function(){return rn},nn.serialVersionUID.get=function(){return-0x35ef64c82d4c5400},nn.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(en,nn);var rn=function(){},on=function(){};on.prototype.distance=function(t,e){},on.prototype.interfaces_=function(){return[]},on.prototype.getClass=function(){return on};var sn=function(t){function n(e){e=e||n.DEFAULT_NODE_CAPACITY,t.call(this,e)}t&&(n.__proto__=t),(n.prototype=Object.create(t&&t.prototype)).constructor=n;var i={STRtreeNode:{configurable:!0},serialVersionUID:{configurable:!0},xComparator:{configurable:!0},yComparator:{configurable:!0},intersectsOp:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};return n.prototype.createParentBoundablesFromVerticalSlices=function(t,e){et.isTrue(t.length>0);for(var n=new Nt,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},n.prototype.createNode=function(t){return new an(t)},n.prototype.size=function(){return 0===arguments.length?t.prototype.size.call(this):t.prototype.size.apply(this,arguments)},n.prototype.insert=function(){if(2!==arguments.length)return t.prototype.insert.apply(this,arguments);var e=arguments[0],n=arguments[1];if(e.isNull())return null;t.prototype.insert.call(this,e,n)},n.prototype.getIntersectsOp=function(){return n.intersectsOp},n.prototype.verticalSlices=function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),o=0;o<e;o++){i[o]=new Nt;for(var s=0;r.hasNext()&&s<n;){var a=r.next();i[o].add(a),s++}}return i},n.prototype.query=function(){if(1===arguments.length){var e=arguments[0];return t.prototype.query.call(this,e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];t.prototype.query.call(this,n,i)}else if(3===arguments.length)if(T(arguments[2],Ke)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe){var r=arguments[0],o=arguments[1],s=arguments[2];t.prototype.query.call(this,r,o,s)}else if(T(arguments[2],xt)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe){var a=arguments[0],u=arguments[1],l=arguments[2];t.prototype.query.call(this,a,u,l)}},n.prototype.getComparator=function(){return n.yComparator},n.prototype.createParentBoundablesFromVerticalSlice=function(e,n){return t.prototype.createParentBoundables.call(this,e,n)},n.prototype.remove=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return t.prototype.remove.call(this,e,n)}return t.prototype.remove.apply(this,arguments)},n.prototype.depth=function(){return 0===arguments.length?t.prototype.depth.call(this):t.prototype.depth.apply(this,arguments)},n.prototype.createParentBoundables=function(t,e){et.isTrue(!t.isEmpty());var i=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),r=new Nt(t);$e.sort(r,n.xComparator);var o=this.verticalSlices(r,Math.trunc(Math.ceil(Math.sqrt(i))));return this.createParentBoundablesFromVerticalSlices(o,e)},n.prototype.nearestNeighbour=function(){if(1===arguments.length){if(T(arguments[0],on)){var t=arguments[0],e=new tn(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof tn){var i=arguments[0];return this.nearestNeighbour(i,v.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof n&&T(arguments[1],on)){var r=arguments[0],o=arguments[1],s=new tn(this.getRoot(),r.getRoot(),o);return this.nearestNeighbour(s)}if(arguments[0]instanceof tn&&"number"==typeof arguments[1]){var a=arguments[0],u=arguments[1],l=null,c=new We;for(c.add(a);!c.isEmpty()&&u>0;){var p=c.poll(),h=p.getDistance();if(h>=u)break;p.isLeaves()?(u=h,l=p):p.expandToQueue(c,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var f=arguments[0],g=arguments[1],d=arguments[2],y=new He(f,g),_=new tn(this.getRoot(),y,d);return this.nearestNeighbour(_)[0]}},n.prototype.interfaces_=function(){return[Je,e]},n.prototype.getClass=function(){return n},n.centreX=function(t){return n.avg(t.getMinX(),t.getMaxX())},n.avg=function(t,e){return(t+e)/2},n.centreY=function(t){return n.avg(t.getMinY(),t.getMaxY())},i.STRtreeNode.get=function(){return an},i.serialVersionUID.get=function(){return 0x39920f7d5f261e0},i.xComparator.get=function(){return{interfaces_:function(){return[N]},compare:function(e,i){return t.compareDoubles(n.centreX(e.getBounds()),n.centreX(i.getBounds()))}}},i.yComparator.get=function(){return{interfaces_:function(){return[N]},compare:function(e,i){return t.compareDoubles(n.centreY(e.getBounds()),n.centreY(i.getBounds()))}}},i.intersectsOp.get=function(){return{interfaces_:function(){return[t.IntersectsOp]},intersects:function(t,e){return t.intersects(e)}}},i.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(n,i),n}(en),an=function(t){function e(){var e=arguments[0];t.call(this,e)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.computeBounds=function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new j(n.getBounds()):t.expandToInclude(n.getBounds())}return t},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Qe),un=function(){};un.prototype.interfaces_=function(){return[]},un.prototype.getClass=function(){return un},un.relativeSign=function(t,e){return t<e?-1:t>e?1:0},un.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=un.relativeSign(e.x,n.x),r=un.relativeSign(e.y,n.y);switch(t){case 0:return un.compareValue(i,r);case 1:return un.compareValue(r,i);case 2:return un.compareValue(r,-i);case 3:return un.compareValue(-i,r);case 4:return un.compareValue(-i,-r);case 5:return un.compareValue(-r,-i);case 6:return un.compareValue(-r,i);case 7:return un.compareValue(i,-r)}return et.shouldNeverReachHere("invalid octant value"),0},un.compareValue=function(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0};var ln=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this._segString=t,this.coord=new C(e),this.segmentIndex=n,this._segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))};ln.prototype.getCoordinate=function(){return this.coord},ln.prototype.print=function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},ln.prototype.compareTo=function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:un.compare(this._segmentOctant,this.coord,e.coord)},ln.prototype.isEndPoint=function(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t},ln.prototype.isInterior=function(){return this._isInterior},ln.prototype.interfaces_=function(){return[E]},ln.prototype.getClass=function(){return ln};var cn=function(){this._nodeMap=new p,this._edge=null;var t=arguments[0];this._edge=t};cn.prototype.getSplitCoordinates=function(){var t=new St;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},cn.prototype.addCollapsedNodes=function(){var t=new Nt;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this._edge.getCoordinate(n),n)}},cn.prototype.print=function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){e.next().print(t)}},cn.prototype.findCollapsesFromExistingVertices=function(t){for(var e=0;e<this._edge.size()-2;e++){var n=this._edge.getCoordinate(e),i=this._edge.getCoordinate(e+2);n.equals2D(i)&&t.add(new M(e+1))}},cn.prototype.addEdgeCoordinates=function(t,e,n){var i=this._edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);n.add(new C(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this._edge.getCoordinate(o));r&&n.add(new C(e.coord))},cn.prototype.iterator=function(){return this._nodeMap.values().iterator()},cn.prototype.addSplitEdges=function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},cn.prototype.findCollapseIndex=function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i&&(n[0]=t.segmentIndex+1,!0)},cn.prototype.findCollapsesFromInsertedNodes=function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next();this.findCollapseIndex(i,r,e)&&t.add(new M(e[0])),i=r}},cn.prototype.getEdge=function(){return this._edge},cn.prototype.addEndpoints=function(){var t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)},cn.prototype.createSplitEdge=function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this._edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var o=new Array(n).fill(null),s=0;o[s++]=new C(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this._edge.getCoordinate(a);return r&&(o[s]=new C(e.coord)),new gn(o,this._edge.getData())},cn.prototype.add=function(t,e){var n=new ln(this._edge,t,e,this._edge.getSegmentOctant(e)),i=this._nodeMap.get(n);return null!==i?(et.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this._nodeMap.put(n,n),n)},cn.prototype.checkSplitEdgesCorrectness=function(t){var e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new $("bad split edge start point at "+n);var i=t.get(t.size()-1).getCoordinates(),r=i[i.length-1];if(!r.equals2D(e[e.length-1]))throw new $("bad split edge end point at "+r)},cn.prototype.interfaces_=function(){return[]},cn.prototype.getClass=function(){return cn};var pn=function(){};pn.prototype.interfaces_=function(){return[]},pn.prototype.getClass=function(){return pn},pn.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new m("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof C&&arguments[1]instanceof C){var r=arguments[0],o=arguments[1],s=o.x-r.x,a=o.y-r.y;if(0===s&&0===a)throw new m("Cannot compute the octant for two identical points "+r);return pn.octant(s,a)}};var hn=function(){};hn.prototype.getCoordinates=function(){},hn.prototype.size=function(){},hn.prototype.getCoordinate=function(t){},hn.prototype.isClosed=function(){},hn.prototype.setData=function(t){},hn.prototype.getData=function(){},hn.prototype.interfaces_=function(){return[]},hn.prototype.getClass=function(){return hn};var fn=function(){};fn.prototype.addIntersection=function(t,e){},fn.prototype.interfaces_=function(){return[hn]},fn.prototype.getClass=function(){return fn};var gn=function(){this._nodeList=new cn(this),this._pts=null,this._data=null;var t=arguments[0],e=arguments[1];this._pts=t,this._data=e};gn.prototype.getCoordinates=function(){return this._pts},gn.prototype.size=function(){return this._pts.length},gn.prototype.getCoordinate=function(t){return this._pts[t]},gn.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},gn.prototype.getSegmentOctant=function(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},gn.prototype.setData=function(t){this._data=t},gn.prototype.safeOctant=function(t,e){return t.equals2D(e)?0:pn.octant(t,e)},gn.prototype.getData=function(){return this._data},gn.prototype.addIntersection=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[3],o=new C(n.getIntersection(r));this.addIntersection(o,i)}},gn.prototype.toString=function(){return Z.toLineString(new ue(this._pts))},gn.prototype.getNodeList=function(){return this._nodeList},gn.prototype.addIntersectionNode=function(t,e){var n=e,i=n+1;if(i<this._pts.length){var r=this._pts[i];t.equals2D(r)&&(n=i)}return this._nodeList.add(t,n)},gn.prototype.addIntersections=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},gn.prototype.interfaces_=function(){return[fn]},gn.prototype.getClass=function(){return gn},gn.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new Nt;return gn.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){r.next().getNodeList().addSplitEdges(i)}};var dn=function(){if(this.p0=null,this.p1=null,0===arguments.length)this.p0=new C,this.p1=new C;else if(1===arguments.length){var t=arguments[0];this.p0=new C(t.p0),this.p1=new C(t.p1)}else if(2===arguments.length)this.p0=arguments[0],this.p1=arguments[1];else if(4===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=arguments[3];this.p0=new C(e,n),this.p1=new C(i,r)}},yn={serialVersionUID:{configurable:!0}};dn.prototype.minX=function(){return Math.min(this.p0.x,this.p1.x)},dn.prototype.orientationIndex=function(){if(arguments[0]instanceof dn){var t=arguments[0],e=at.orientationIndex(this.p0,this.p1,t.p0),n=at.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof C){var i=arguments[0];return at.orientationIndex(this.p0,this.p1,i)}},dn.prototype.toGeometry=function(t){return t.createLineString([this.p0,this.p1])},dn.prototype.isVertical=function(){return this.p0.x===this.p1.x},dn.prototype.equals=function(t){if(!(t instanceof dn))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},dn.prototype.intersection=function(t){var e=new rt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},dn.prototype.project=function(){if(arguments[0]instanceof C){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new C(t);var e=this.projectionFactor(t),n=new C;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof dn){var i=arguments[0],r=this.projectionFactor(i.p0),o=this.projectionFactor(i.p1);if(r>=1&&o>=1)return null;if(r<=0&&o<=0)return null;var s=this.project(i.p0);r<0&&(s=this.p0),r>1&&(s=this.p1);var a=this.project(i.p1);return o<0&&(a=this.p0),o>1&&(a=this.p1),new dn(s,a)}},dn.prototype.normalize=function(){this.p1.compareTo(this.p0)<0&&this.reverse()},dn.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},dn.prototype.getCoordinate=function(t){return 0===t?this.p0:this.p1},dn.prototype.distancePerpendicular=function(t){return at.distancePointLinePerpendicular(t,this.p0,this.p1)},dn.prototype.minY=function(){return Math.min(this.p0.y,this.p1.y)},dn.prototype.midPoint=function(){return dn.midPoint(this.p0,this.p1)},dn.prototype.projectionFactor=function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(i<=0)return v.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i},dn.prototype.closestPoints=function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=v.MAX_VALUE,r=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var s=this.closestPoint(t.p1);(r=s.distance(t.p1))<i&&(i=r,n[0]=s,n[1]=t.p1);var a=t.closestPoint(this.p0);(r=a.distance(this.p0))<i&&(i=r,n[0]=this.p0,n[1]=a);var u=t.closestPoint(this.p1);return(r=u.distance(this.p1))<i&&(i=r,n[0]=this.p1,n[1]=u),n},dn.prototype.closestPoint=function(t){var e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1},dn.prototype.maxX=function(){return Math.max(this.p0.x,this.p1.x)},dn.prototype.getLength=function(){return this.p0.distance(this.p1)},dn.prototype.compareTo=function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},dn.prototype.reverse=function(){var t=this.p0;this.p0=this.p1,this.p1=t},dn.prototype.equalsTopo=function(t){return this.p0.equals(t.p0)&&(this.p1.equals(t.p1)||this.p0.equals(t.p1))&&this.p1.equals(t.p0)},dn.prototype.lineIntersection=function(t){try{return k.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof X))throw t}return null},dn.prototype.maxY=function(){return Math.max(this.p0.y,this.p1.y)},dn.prototype.pointAlongOffset=function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,o=this.p1.y-this.p0.y,s=Math.sqrt(r*r+o*o),a=0,u=0;if(0!==e){if(s<=0)throw new Error("Cannot compute offset from zero-length line segment");a=e*r/s,u=e*o/s}return new C(n-u,i+a)},dn.prototype.setCoordinates=function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},dn.prototype.segmentFraction=function(t){var e=this.projectionFactor(t);return e<0?e=0:(e>1||v.isNaN(e))&&(e=1),e},dn.prototype.toString=function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},dn.prototype.isHorizontal=function(){return this.p0.y===this.p1.y},dn.prototype.distance=function(){if(arguments[0]instanceof dn){var t=arguments[0];return at.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof C){var e=arguments[0];return at.distancePointLine(e,this.p0,this.p1)}},dn.prototype.pointAlong=function(t){var e=new C;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},dn.prototype.hashCode=function(){var t=v.doubleToLongBits(this.p0.x);t^=31*v.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=v.doubleToLongBits(this.p1.x);n^=31*v.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))},dn.prototype.interfaces_=function(){return[E,e]},dn.prototype.getClass=function(){return dn},dn.midPoint=function(t,e){return new C((t.x+e.x)/2,(t.y+e.y)/2)},yn.serialVersionUID.get=function(){return 0x2d2172135f411c00},Object.defineProperties(dn,yn);var _n=function(){this.tempEnv1=new j,this.tempEnv2=new j,this._overlapSeg1=new dn,this._overlapSeg2=new dn};_n.prototype.overlap=function(){if(2===arguments.length);else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(i,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}},_n.prototype.interfaces_=function(){return[]},_n.prototype.getClass=function(){return _n};var mn=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=i};mn.prototype.getLineSegment=function(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]},mn.prototype.computeSelect=function(t,e,n,i){var r=this._pts[e],o=this._pts[n];if(i.tempEnv1.init(r,o),n-e==1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var s=Math.trunc((e+n)/2);e<s&&this.computeSelect(t,e,s,i),s<n&&this.computeSelect(t,s,n,i)},mn.prototype.getCoordinates=function(){for(var t=new Array(this._end-this._start+1).fill(null),e=0,n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t},mn.prototype.computeOverlaps=function(t,e){this.computeOverlapsInternal(this._start,this._end,t,t._start,t._end,e)},mn.prototype.setId=function(t){this._id=t},mn.prototype.select=function(t,e){this.computeSelect(t,this._start,this._end,e)},mn.prototype.getEnvelope=function(){if(null===this._env){var t=this._pts[this._start],e=this._pts[this._end];this._env=new j(t,e)}return this._env},mn.prototype.getEndIndex=function(){return this._end},mn.prototype.getStartIndex=function(){return this._start},mn.prototype.getContext=function(){return this._context},mn.prototype.getId=function(){return this._id},mn.prototype.computeOverlapsInternal=function(t,e,n,i,r,o){var s=this._pts[t],a=this._pts[e],u=n._pts[i],l=n._pts[r];if(e-t==1&&r-i==1)return o.overlap(this,t,n,i),null;if(o.tempEnv1.init(s,a),o.tempEnv2.init(u,l),!o.tempEnv1.intersects(o.tempEnv2))return null;var c=Math.trunc((t+e)/2),p=Math.trunc((i+r)/2);t<c&&(i<p&&this.computeOverlapsInternal(t,c,n,i,p,o),p<r&&this.computeOverlapsInternal(t,c,n,p,r,o)),c<e&&(i<p&&this.computeOverlapsInternal(c,e,n,i,p,o),p<r&&this.computeOverlapsInternal(c,e,n,p,r,o))},mn.prototype.interfaces_=function(){return[]},mn.prototype.getClass=function(){return mn};var vn=function(){};vn.prototype.interfaces_=function(){return[]},vn.prototype.getClass=function(){return vn},vn.getChainStartIndices=function(t){var e=0,n=new Nt;n.add(new M(e));do{var i=vn.findChainEnd(t,e);n.add(new M(i)),e=i}while(e<t.length-1);return vn.toIntArray(n)},vn.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Be.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){if(Be.quadrant(t[r-1],t[r])!==i)break}r++}return r-1},vn.getChains=function(){if(1===arguments.length){var t=arguments[0];return vn.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new Nt,r=vn.getChainStartIndices(e),o=0;o<r.length-1;o++){var s=new mn(e,r[o],r[o+1],n);i.add(s)}return i}},vn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e};var In=function(){};In.prototype.computeNodes=function(t){},In.prototype.getNodedSubstrings=function(){},In.prototype.interfaces_=function(){return[]},In.prototype.getClass=function(){return In};var En=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}};En.prototype.setSegmentIntersector=function(t){this._segInt=t},En.prototype.interfaces_=function(){return[In]},En.prototype.getClass=function(){return En};var xn=function(t){function e(e){e?t.call(this,e):t.call(this),this._monoChains=new Nt,this._index=new sn,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={SegmentOverlapAction:{configurable:!0}};return e.prototype.getMonotoneChains=function(){return this._monoChains},e.prototype.getNodedSubstrings=function(){return gn.getNodedSubstrings(this._nodedSegStrings)},e.prototype.getIndex=function(){return this._index},e.prototype.add=function(t){for(var e=vn.getChains(t.getCoordinates(),t).iterator();e.hasNext();){var n=e.next();n.setId(this._idCounter++),this._index.insert(n.getEnvelope(),n),this._monoChains.add(n)}},e.prototype.computeNodes=function(t){this._nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},e.prototype.intersectChains=function(){for(var t=new Nn(this._segInt),e=this._monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this._index.query(n.getEnvelope()).iterator();i.hasNext();){var r=i.next();if(r.getId()>n.getId()&&(n.computeOverlaps(r,t),this._nOverlaps++),this._segInt.isDone())return null}},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},n.SegmentOverlapAction.get=function(){return Nn},Object.defineProperties(e,n),e}(En),Nn=function(t){function e(){t.call(this),this._si=null;var e=arguments[0];this._si=e}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.overlap=function(){if(4!==arguments.length)return t.prototype.overlap.apply(this,arguments);var e=arguments[0],n=arguments[1],i=arguments[2],r=arguments[3],o=e.getContext(),s=i.getContext();this._si.processIntersections(o,n,s,r)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(_n),Cn=function t(){if(this._quadrantSegments=t.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=t.CAP_ROUND,this._joinStyle=t.JOIN_ROUND,this._mitreLimit=t.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=t.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var e=arguments[0];this.setQuadrantSegments(e)}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.setQuadrantSegments(n),this.setEndCapStyle(i)}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];this.setQuadrantSegments(r),this.setEndCapStyle(o),this.setJoinStyle(s),this.setMitreLimit(a)}},Sn={CAP_ROUND:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},JOIN_ROUND:{configurable:!0},JOIN_MITRE:{configurable:!0},JOIN_BEVEL:{configurable:!0},DEFAULT_QUADRANT_SEGMENTS:{configurable:!0},DEFAULT_MITRE_LIMIT:{configurable:!0},DEFAULT_SIMPLIFY_FACTOR:{configurable:!0}};Cn.prototype.getEndCapStyle=function(){return this._endCapStyle},Cn.prototype.isSingleSided=function(){return this._isSingleSided},Cn.prototype.setQuadrantSegments=function(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=Cn.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Cn.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==Cn.JOIN_ROUND&&(this._quadrantSegments=Cn.DEFAULT_QUADRANT_SEGMENTS)},Cn.prototype.getJoinStyle=function(){return this._joinStyle},Cn.prototype.setJoinStyle=function(t){this._joinStyle=t},Cn.prototype.setSimplifyFactor=function(t){this._simplifyFactor=t<0?0:t},Cn.prototype.getSimplifyFactor=function(){return this._simplifyFactor},Cn.prototype.getQuadrantSegments=function(){return this._quadrantSegments},Cn.prototype.setEndCapStyle=function(t){this._endCapStyle=t},Cn.prototype.getMitreLimit=function(){return this._mitreLimit},Cn.prototype.setMitreLimit=function(t){this._mitreLimit=t},Cn.prototype.setSingleSided=function(t){this._isSingleSided=t},Cn.prototype.interfaces_=function(){return[]},Cn.prototype.getClass=function(){return Cn},Cn.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Sn.CAP_ROUND.get=function(){return 1},Sn.CAP_FLAT.get=function(){return 2},Sn.CAP_SQUARE.get=function(){return 3},Sn.JOIN_ROUND.get=function(){return 1},Sn.JOIN_MITRE.get=function(){return 2},Sn.JOIN_BEVEL.get=function(){return 3},Sn.DEFAULT_QUADRANT_SEGMENTS.get=function(){return 8},Sn.DEFAULT_MITRE_LIMIT.get=function(){return 5},Sn.DEFAULT_SIMPLIFY_FACTOR.get=function(){return.01},Object.defineProperties(Cn,Sn);var Ln=function(t){this._distanceTol=null,this._isDeleted=null,this._angleOrientation=at.COUNTERCLOCKWISE,this._inputLine=t||null},bn={INIT:{configurable:!0},DELETE:{configurable:!0},KEEP:{configurable:!0},NUM_PTS_TO_CHECK:{configurable:!0}};Ln.prototype.isDeletable=function(t,e,n,i){var r=this._inputLine[t],o=this._inputLine[e],s=this._inputLine[n];return!!this.isConcave(r,o,s)&&(!!this.isShallow(r,o,s,i)&&this.isShallowSampled(r,o,t,n,i))},Ln.prototype.deleteShallowConcavities=function(){for(var t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),i=!1;n<this._inputLine.length;){var r=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=Ln.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},Ln.prototype.isShallowConcavity=function(t,e,n,i){if(!(at.computeOrientation(t,e,n)===this._angleOrientation))return!1;return at.distancePointLine(e,t,n)<i},Ln.prototype.isShallowSampled=function(t,e,n,i,r){var o=Math.trunc((i-n)/Ln.NUM_PTS_TO_CHECK);o<=0&&(o=1);for(var s=n;s<i;s+=o)if(!this.isShallow(t,e,this._inputLine[s],r))return!1;return!0},Ln.prototype.isConcave=function(t,e,n){var i=at.computeOrientation(t,e,n)===this._angleOrientation;return i},Ln.prototype.simplify=function(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=at.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()},Ln.prototype.findNextNonDeletedIndex=function(t){for(var e=t+1;e<this._inputLine.length&&this._isDeleted[e]===Ln.DELETE;)e++;return e},Ln.prototype.isShallow=function(t,e,n,i){return at.distancePointLine(e,t,n)<i},Ln.prototype.collapseLine=function(){for(var t=new St,e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==Ln.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()},Ln.prototype.interfaces_=function(){return[]},Ln.prototype.getClass=function(){return Ln},Ln.simplify=function(t,e){return new Ln(t).simplify(e)},bn.INIT.get=function(){return 0},bn.DELETE.get=function(){return 1},bn.KEEP.get=function(){return 1},bn.NUM_PTS_TO_CHECK.get=function(){return 10},Object.defineProperties(Ln,bn);var wn=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new Nt},On={COORDINATE_ARRAY_TYPE:{configurable:!0}};wn.prototype.getCoordinates=function(){return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE)},wn.prototype.setPrecisionModel=function(t){this._precisionModel=t},wn.prototype.addPt=function(t){var e=new C(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)},wn.prototype.revere=function(){},wn.prototype.addPts=function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var i=t.length-1;i>=0;i--)this.addPt(t[i])},wn.prototype.isRedundant=function(t){if(this._ptList.size()<1)return!1;var e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance},wn.prototype.toString=function(){return(new _e).createLineString(this.getCoordinates()).toString()},wn.prototype.closeRing=function(){if(this._ptList.size()<1)return null;var t=new C(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)},wn.prototype.setMinimumVertexDistance=function(t){this._minimimVertexDistance=t},wn.prototype.interfaces_=function(){return[]},wn.prototype.getClass=function(){return wn},On.COORDINATE_ARRAY_TYPE.get=function(){return new Array(0).fill(null)},Object.defineProperties(wn,On);var Tn=function(){},Rn={PI_TIMES_2:{configurable:!0},PI_OVER_2:{configurable:!0},PI_OVER_4:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},CLOCKWISE:{configurable:!0},NONE:{configurable:!0}};Tn.prototype.interfaces_=function(){return[]},Tn.prototype.getClass=function(){return Tn},Tn.toDegrees=function(t){return 180*t/Math.PI},Tn.normalize=function(t){for(;t>Math.PI;)t-=Tn.PI_TIMES_2;for(;t<=-Math.PI;)t+=Tn.PI_TIMES_2;return t},Tn.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},Tn.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y;return i*(n.x-e.x)+r*(n.y-e.y)>0},Tn.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y;return i*(n.x-e.x)+r*(n.y-e.y)<0},Tn.interiorAngle=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n);return Math.abs(r-i)},Tn.normalizePositive=function(t){if(t<0){for(;t<0;)t+=Tn.PI_TIMES_2;t>=Tn.PI_TIMES_2&&(t=0)}else{for(;t>=Tn.PI_TIMES_2;)t-=Tn.PI_TIMES_2;t<0&&(t=0)}return t},Tn.angleBetween=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n);return Tn.diff(i,r)},Tn.diff=function(t,e){var n=null;return(n=t<e?e-t:t-e)>Math.PI&&(n=2*Math.PI-n),n},Tn.toRadians=function(t){return t*Math.PI/180},Tn.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?Tn.COUNTERCLOCKWISE:n<0?Tn.CLOCKWISE:Tn.NONE},Tn.angleBetweenOriented=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n)-i;return r<=-Math.PI?r+Tn.PI_TIMES_2:r>Math.PI?r-Tn.PI_TIMES_2:r},Rn.PI_TIMES_2.get=function(){return 2*Math.PI},Rn.PI_OVER_2.get=function(){return Math.PI/2},Rn.PI_OVER_4.get=function(){return Math.PI/4},Rn.COUNTERCLOCKWISE.get=function(){return at.COUNTERCLOCKWISE},Rn.CLOCKWISE.get=function(){return at.CLOCKWISE},Rn.NONE.get=function(){return at.COLLINEAR},Object.defineProperties(Tn,Rn);var Pn=function t(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new dn,this._seg1=new dn,this._offset0=new dn,this._offset1=new dn,this._side=0,this._hasNarrowConcaveAngle=!1;var e=arguments[0],n=arguments[1],i=arguments[2];this._precisionModel=e,this._bufParams=n,this._li=new rt,this._filletAngleQuantum=Math.PI/2/n.getQuadrantSegments(),n.getQuadrantSegments()>=8&&n.getJoinStyle()===Cn.JOIN_ROUND&&(this._closingSegLengthFactor=t.MAX_CLOSING_SEG_LEN_FACTOR),this.init(i)},Dn={OFFSET_SEGMENT_SEPARATION_FACTOR:{configurable:!0},INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},CURVE_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},MAX_CLOSING_SEG_LEN_FACTOR:{configurable:!0}};Pn.prototype.addNextSegment=function(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var n=at.computeOrientation(this._s0,this._s1,this._s2),i=n===at.CLOCKWISE&&this._side===Se.LEFT||n===at.COUNTERCLOCKWISE&&this._side===Se.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},Pn.prototype.addLineEndCap=function(t,e){var n=new dn(t,e),i=new dn;this.computeOffsetSegment(n,Se.LEFT,this._distance,i);var r=new dn;this.computeOffsetSegment(n,Se.RIGHT,this._distance,r);var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o);switch(this._bufParams.getEndCapStyle()){case Cn.CAP_ROUND:this._segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,at.CLOCKWISE,this._distance),this._segList.addPt(r.p1);break;case Cn.CAP_FLAT:this._segList.addPt(i.p1),this._segList.addPt(r.p1);break;case Cn.CAP_SQUARE:var u=new C;u.x=Math.abs(this._distance)*Math.cos(a),u.y=Math.abs(this._distance)*Math.sin(a);var l=new C(i.p1.x+u.x,i.p1.y+u.y),c=new C(r.p1.x+u.x,r.p1.y+u.y);this._segList.addPt(l),this._segList.addPt(c)}},Pn.prototype.getCoordinates=function(){return this._segList.getCoordinates()},Pn.prototype.addMitreJoin=function(t,e,n,i){var r=!0,o=null;try{o=k.intersection(e.p0,e.p1,n.p0,n.p1);(i<=0?1:o.distance(t)/Math.abs(i))>this._bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof X))throw t;o=new C(0,0),r=!1}r?this._segList.addPt(o):this.addLimitedMitreJoin(e,n,i,this._bufParams.getMitreLimit())},Pn.prototype.addFilletCorner=function(t,e,n,i,r){var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o),u=n.x-t.x,l=n.y-t.y,c=Math.atan2(l,u);i===at.CLOCKWISE?a<=c&&(a+=2*Math.PI):a>=c&&(a-=2*Math.PI),this._segList.addPt(e),this.addFilletArc(t,a,c,i,r),this._segList.addPt(n)},Pn.prototype.addOutsideTurn=function(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Cn.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Cn.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))},Pn.prototype.createSquare=function(t){this._segList.addPt(new C(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new C(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new C(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new C(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()},Pn.prototype.addSegments=function(t,e){this._segList.addPts(t,e)},Pn.prototype.addFirstSegment=function(){this._segList.addPt(this._offset1.p0)},Pn.prototype.addLastSegment=function(){this._segList.addPt(this._offset1.p1)},Pn.prototype.initSideSegments=function(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)},Pn.prototype.addLimitedMitreJoin=function(t,e,n,i){var r=this._seg0.p1,o=Tn.angle(r,this._seg0.p0),s=Tn.angleBetweenOriented(this._seg0.p0,r,this._seg1.p1)/2,a=Tn.normalize(o+s),u=Tn.normalize(a+Math.PI),l=i*n,c=n-l*Math.abs(Math.sin(s)),p=r.x+l*Math.cos(u),h=r.y+l*Math.sin(u),f=new C(p,h),g=new dn(r,f),d=g.pointAlongOffset(1,c),y=g.pointAlongOffset(1,-c);this._side===Se.LEFT?(this._segList.addPt(d),this._segList.addPt(y)):(this._segList.addPt(y),this._segList.addPt(d))},Pn.prototype.computeOffsetSegment=function(t,e,n,i){var r=e===Se.LEFT?1:-1,o=t.p1.x-t.p0.x,s=t.p1.y-t.p0.y,a=Math.sqrt(o*o+s*s),u=r*n*o/a,l=r*n*s/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},Pn.prototype.addFilletArc=function(t,e,n,i,r){var o=i===at.CLOCKWISE?-1:1,s=Math.abs(e-n),a=Math.trunc(s/this._filletAngleQuantum+.5);if(a<1)return null;for(var u=s/a,l=0,c=new C;l<s;){var p=e+o*l;c.x=t.x+r*Math.cos(p),c.y=t.y+r*Math.sin(p),this._segList.addPt(c),l+=u}},Pn.prototype.addInsideTurn=function(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var n=new C((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(n);var i=new C((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(i)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}},Pn.prototype.createCircle=function(t){var e=new C(t.x+this._distance,t.y);this._segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()},Pn.prototype.addBevelJoin=function(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)},Pn.prototype.init=function(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new wn,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},Pn.prototype.addCollinear=function(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Cn.JOIN_BEVEL||this._bufParams.getJoinStyle()===Cn.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,at.CLOCKWISE,this._distance))},Pn.prototype.closeRing=function(){this._segList.closeRing()},Pn.prototype.hasNarrowConcaveAngle=function(){return this._hasNarrowConcaveAngle},Pn.prototype.interfaces_=function(){return[]},Pn.prototype.getClass=function(){return Pn},Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get=function(){return.001},Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return.001},Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return 1e-6},Dn.MAX_CLOSING_SEG_LEN_FACTOR.get=function(){return 80},Object.defineProperties(Pn,Dn);var Mn=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e};Mn.prototype.getOffsetCurve=function(t,e){if(this._distance=e,0===e)return null;var n=e<0,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var o=r.getCoordinates();return n&&Lt.reverse(o),o},Mn.prototype.computeSingleSidedBufferCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);var r=Ln.simplify(t,-i),o=r.length-1;n.initSideSegments(r[o],r[o-1],Se.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(r[s],!0)}else{n.addSegments(t,!1);var a=Ln.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],Se.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0)}n.addLastSegment(),n.closeRing()},Mn.prototype.computeRingBufferCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);e===Se.RIGHT&&(i=-i);var r=Ln.simplify(t,i),o=r.length-1;n.initSideSegments(r[o-1],r[0],e);for(var s=1;s<=o;s++){var a=1!==s;n.addNextSegment(r[s],a)}n.closeRing()},Mn.prototype.computeLineBufferCurve=function(t,e){var n=this.simplifyTolerance(this._distance),i=Ln.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],Se.LEFT);for(var o=2;o<=r;o++)e.addNextSegment(i[o],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var s=Ln.simplify(t,-n),a=s.length-1;e.initSideSegments(s[a],s[a-1],Se.LEFT);for(var u=a-2;u>=0;u--)e.addNextSegment(s[u],!0);e.addLastSegment(),e.addLineEndCap(s[1],s[0]),e.closeRing()},Mn.prototype.computePointCurve=function(t,e){switch(this._bufParams.getEndCapStyle()){case Cn.CAP_ROUND:e.createCircle(t);break;case Cn.CAP_SQUARE:e.createSquare(t)}},Mn.prototype.getLineCurve=function(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this._bufParams.isSingleSided()){var r=e<0;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);return i.getCoordinates()},Mn.prototype.getBufferParameters=function(){return this._bufParams},Mn.prototype.simplifyTolerance=function(t){return t*this._bufParams.getSimplifyFactor()},Mn.prototype.getRingCurve=function(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Mn.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},Mn.prototype.computeOffsetCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);if(e){var r=Ln.simplify(t,-i),o=r.length-1;n.initSideSegments(r[o],r[o-1],Se.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(r[s],!0)}else{var a=Ln.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],Se.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0)}n.addLastSegment()},Mn.prototype.getSegGen=function(t){return new Pn(this._precisionModel,this._bufParams,t)},Mn.prototype.interfaces_=function(){return[]},Mn.prototype.getClass=function(){return Mn},Mn.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new C(t[n]);return e};var An=function(){this._subgraphs=null,this._seg=new dn,this._cga=new at;var t=arguments[0];this._subgraphs=t},Fn={DepthSegment:{configurable:!0}};An.prototype.findStabbedSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=new Nt,n=this._subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(T(arguments[2],xt)&&arguments[0]instanceof C&&arguments[1]instanceof ze)for(var o=arguments[0],s=arguments[1],a=arguments[2],u=s.getEdge().getCoordinates(),l=0;l<u.length-1;l++){this._seg.p0=u[l],this._seg.p1=u[l+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(!(Math.max(this._seg.p0.x,this._seg.p1.x)<o.x)&&!(this._seg.isHorizontal()||o.y<this._seg.p0.y||o.y>this._seg.p1.y||at.computeOrientation(this._seg.p0,this._seg.p1,o)===at.RIGHT)){var c=s.getDepth(Se.LEFT);this._seg.p0.equals(u[l])||(c=s.getDepth(Se.RIGHT));var p=new Gn(this._seg,c);a.add(p)}}else if(T(arguments[2],xt)&&arguments[0]instanceof C&&T(arguments[1],xt))for(var h=arguments[0],f=arguments[1],g=arguments[2],d=f.iterator();d.hasNext();){var y=d.next();y.isForward()&&this.findStabbedSegments(h,y,g)}},An.prototype.getDepth=function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;return $e.min(e)._leftDepth},An.prototype.interfaces_=function(){return[]},An.prototype.getClass=function(){return An},Fn.DepthSegment.get=function(){return Gn},Object.defineProperties(An,Fn);var Gn=function(){this._upwardSeg=null,this._leftDepth=null;var t=arguments[0],e=arguments[1];this._upwardSeg=new dn(t),this._leftDepth=e};Gn.prototype.compareTo=function(t){var e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;var n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:0!=(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg))?n:this._upwardSeg.compareTo(e._upwardSeg)},Gn.prototype.compareX=function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},Gn.prototype.toString=function(){return this._upwardSeg.toString()},Gn.prototype.interfaces_=function(){return[E]},Gn.prototype.getClass=function(){return Gn};var qn=function(t,e,n){this.p0=t||null,this.p1=e||null,this.p2=n||null};qn.prototype.area=function(){return qn.area(this.p0,this.p1,this.p2)},qn.prototype.signedArea=function(){return qn.signedArea(this.p0,this.p1,this.p2)},qn.prototype.interpolateZ=function(t){if(null===t)throw new m("Supplied point is null.");return qn.interpolateZ(t,this.p0,this.p1,this.p2)},qn.prototype.longestSideLength=function(){return qn.longestSideLength(this.p0,this.p1,this.p2)},qn.prototype.isAcute=function(){return qn.isAcute(this.p0,this.p1,this.p2)},qn.prototype.circumcentre=function(){return qn.circumcentre(this.p0,this.p1,this.p2)},qn.prototype.area3D=function(){return qn.area3D(this.p0,this.p1,this.p2)},qn.prototype.centroid=function(){return qn.centroid(this.p0,this.p1,this.p2)},qn.prototype.inCentre=function(){return qn.inCentre(this.p0,this.p1,this.p2)},qn.prototype.interfaces_=function(){return[]},qn.prototype.getClass=function(){return qn},qn.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},qn.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},qn.det=function(t,e,n,i){return t*i-e*n},qn.interpolateZ=function(t,e,n,i){var r=e.x,o=e.y,s=n.x-r,a=i.x-r,u=n.y-o,l=i.y-o,c=s*l-a*u,p=t.x-r,h=t.y-o,f=(l*p-a*h)/c,g=(-u*p+s*h)/c;return e.z+f*(n.z-e.z)+g*(i.z-e.z)},qn.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),o=n.distance(t),s=i;return r>s&&(s=r),o>s&&(s=o),s},qn.isAcute=function(t,e,n){return!!Tn.isAcute(t,e,n)&&(!!Tn.isAcute(e,n,t)&&!!Tn.isAcute(n,t,e))},qn.circumcentre=function(t,e,n){var i=n.x,r=n.y,o=t.x-i,s=t.y-r,a=e.x-i,u=e.y-r,l=2*qn.det(o,s,a,u),c=qn.det(s,o*o+s*s,u,a*a+u*u),p=qn.det(o,o*o+s*s,a,a*a+u*u);return new C(i-c/l,r+p/l)},qn.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new k(t.x+n/2,t.y+i/2,1),o=new k(t.x-i+n/2,t.y+n+i/2,1);return new k(r,o)},qn.angleBisector=function(t,e,n){var i=e.distance(t),r=i/(i+e.distance(n)),o=n.x-t.x,s=n.y-t.y;return new C(t.x+r*o,t.y+r*s)},qn.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,o=e.z-t.z,s=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-o*a,c=o*s-i*u,p=i*a-r*s,h=l*l+c*c+p*p,f=Math.sqrt(h)/2;return f},qn.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new C(i,r)},qn.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),o=t.distance(e),s=i+r+o,a=(i*t.x+r*e.x+o*n.x)/s,u=(i*t.y+r*e.y+o*n.y)/s;return new C(a,u)};var Bn=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new Nt;var t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n};Bn.prototype.addPoint=function(t){if(this._distance<=0)return null;var e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,w.EXTERIOR,w.INTERIOR)},Bn.prototype.addPolygon=function(t){var e=this._distance,n=Se.LEFT;this._distance<0&&(e=-this._distance,n=Se.RIGHT);var i=t.getExteriorRing(),r=Lt.removeRepeatedPoints(i.getCoordinates());if(this._distance<0&&this.isErodedCompletely(i,this._distance))return null;if(this._distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,w.EXTERIOR,w.INTERIOR);for(var o=0;o<t.getNumInteriorRing();o++){var s=t.getInteriorRingN(o),a=Lt.removeRepeatedPoints(s.getCoordinates());this._distance>0&&this.isErodedCompletely(s,-this._distance)||this.addPolygonRing(a,e,Se.opposite(n),w.INTERIOR,w.EXTERIOR)}},Bn.prototype.isTriangleErodedCompletely=function(t,e){var n=new qn(t[0],t[1],t[2]),i=n.inCentre();return at.distancePointLine(i,n.p0,n.p1)<Math.abs(e)},Bn.prototype.addLineString=function(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;var e=Lt.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,w.EXTERIOR,w.INTERIOR)},Bn.prototype.addCurve=function(t,e,n){if(null===t||t.length<2)return null;var i=new gn(t,new Pe(0,w.BOUNDARY,e,n));this._curveList.add(i)},Bn.prototype.getCurves=function(){return this.add(this._inputGeom),this._curveList},Bn.prototype.addPolygonRing=function(t,e,n,i,r){if(0===e&&t.length<ee.MINIMUM_VALID_SIZE)return null;var o=i,s=r;t.length>=ee.MINIMUM_VALID_SIZE&&at.isCCW(t)&&(o=r,s=i,n=Se.opposite(n));var a=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(a,o,s)},Bn.prototype.add=function(t){if(t.isEmpty())return null;t instanceof $t?this.addPolygon(t):t instanceof Kt?this.addLineString(t):t instanceof Qt?this.addPoint(t):t instanceof te?this.addCollection(t):t instanceof Xt?this.addCollection(t):t instanceof ne?this.addCollection(t):t instanceof zt&&this.addCollection(t)},Bn.prototype.isErodedCompletely=function(t,e){var n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return e<0&&2*Math.abs(e)>r},Bn.prototype.addCollection=function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},Bn.prototype.interfaces_=function(){return[]},Bn.prototype.getClass=function(){return Bn};var Vn=function(){};Vn.prototype.locate=function(t){},Vn.prototype.interfaces_=function(){return[]},Vn.prototype.getClass=function(){return Vn};var Un=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};Un.prototype.next=function(){if(this._atStart)return this._atStart=!1,Un.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new i;var t=this._parent.getGeometryN(this._index++);return t instanceof zt?(this._subcollectionIterator=new Un(t),this._subcollectionIterator.next()):t},Un.prototype.remove=function(){throw new Error(this.getClass().getName())},Un.prototype.hasNext=function(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)},Un.prototype.interfaces_=function(){return[Et]},Un.prototype.getClass=function(){return Un},Un.isAtomic=function(t){return!(t instanceof zt)};var zn=function(){this._geom=null;var t=arguments[0];this._geom=t};zn.prototype.locate=function(t){return zn.locate(t,this._geom)},zn.prototype.interfaces_=function(){return[Vn]},zn.prototype.getClass=function(){return zn},zn.isPointInRing=function(t,e){return!!e.getEnvelopeInternal().intersects(t)&&at.isPointInRing(t,e.getCoordinates())},zn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!zn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(zn.isPointInRing(t,r))return!1}return!0},zn.containsPoint=function(t,e){if(e instanceof $t)return zn.containsPointInPolygon(t,e);if(e instanceof zt)for(var n=new Un(e);n.hasNext();){var i=n.next();if(i!==e&&zn.containsPoint(t,i))return!0}return!1},zn.locate=function(t,e){return e.isEmpty()?w.EXTERIOR:zn.containsPoint(t,e)?w.INTERIOR:w.EXTERIOR};var Xn=function(){this._edgeMap=new p,this._edgeList=null,this._ptInAreaLocation=[w.NONE,w.NONE]};Xn.prototype.getNextCW=function(t){this.getEdges();var e=this._edgeList.indexOf(t),n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)},Xn.prototype.propagateSideLabels=function(t){for(var e=w.NONE,n=this.iterator();n.hasNext();){var i=n.next().getLabel();i.isArea(t)&&i.getLocation(t,Se.LEFT)!==w.NONE&&(e=i.getLocation(t,Se.LEFT))}if(e===w.NONE)return null;for(var r=e,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getLabel();if(a.getLocation(t,Se.ON)===w.NONE&&a.setLocation(t,Se.ON,r),a.isArea(t)){var u=a.getLocation(t,Se.LEFT),l=a.getLocation(t,Se.RIGHT);if(l!==w.NONE){if(l!==r)throw new we("side location conflict",s.getCoordinate());u===w.NONE&&et.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),r=u}else et.isTrue(a.getLocation(t,Se.LEFT)===w.NONE,"found single null side"),a.setLocation(t,Se.RIGHT,r),a.setLocation(t,Se.LEFT,r)}}},Xn.prototype.getCoordinate=function(){var t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()},Xn.prototype.print=function(t){Y.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){e.next().print(t)}},Xn.prototype.isAreaLabelsConsistent=function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},Xn.prototype.checkAreaLabelsConsistent=function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel().getLocation(t,Se.LEFT);et.isTrue(i!==w.NONE,"Found unlabelled area edge");for(var r=i,o=this.iterator();o.hasNext();){var s=o.next().getLabel();et.isTrue(s.isArea(t),"Found non-area edge");var a=s.getLocation(t,Se.LEFT),u=s.getLocation(t,Se.RIGHT);if(a===u)return!1;if(u!==r)return!1;r=a}return!0},Xn.prototype.findIndex=function(t){this.iterator();for(var e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1},Xn.prototype.iterator=function(){return this.getEdges().iterator()},Xn.prototype.getEdges=function(){return null===this._edgeList&&(this._edgeList=new Nt(this._edgeMap.values())),this._edgeList},Xn.prototype.getLocation=function(t,e,n){return this._ptInAreaLocation[t]===w.NONE&&(this._ptInAreaLocation[t]=zn.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]},Xn.prototype.toString=function(){var t=new D;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},Xn.prototype.computeEdgeEndLabels=function(t){for(var e=this.iterator();e.hasNext();){e.next().computeLabel(t)}},Xn.prototype.computeLabelling=function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next().getLabel(),r=0;r<2;r++)i.isLine(r)&&i.getLocation(r)===w.BOUNDARY&&(e[r]=!0);for(var o=this.iterator();o.hasNext();)for(var s=o.next(),a=s.getLabel(),u=0;u<2;u++)if(a.isAnyNull(u)){var l=w.NONE;if(e[u])l=w.EXTERIOR;else{var c=s.getCoordinate();l=this.getLocation(u,c,t)}a.setAllLocationsIfNull(u,l)}},Xn.prototype.getDegree=function(){return this._edgeMap.size()},Xn.prototype.insertEdgeEnd=function(t,e){this._edgeMap.put(t,e),this._edgeList=null},Xn.prototype.interfaces_=function(){return[]},Xn.prototype.getClass=function(){return Xn};var Yn=function(t){function e(){t.call(this),this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();for(var t=null,e=null,n=this._SCANNING_FOR_INCOMING,i=0;i<this._resultAreaEdgeList.size();i++){var r=this._resultAreaEdgeList.get(i),o=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this._SCANNING_FOR_INCOMING:if(!o.isInResult())continue;e=o,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new we("no outgoing dirEdge found",this.getCoordinate());et.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},e.prototype.insert=function(t){var e=t;this.insertEdgeEnd(e,e)},e.prototype.getRightmostEdge=function(){var t=this.getEdges(),e=t.size();if(e<1)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),o=i.getQuadrant();return Be.isNorthern(r)&&Be.isNorthern(o)?n:Be.isNorthern(r)||Be.isNorthern(o)?0!==n.getDy()?n:0!==i.getDy()?i:(et.shouldNeverReachHere("found two horizontal edges incident on node"),null):i},e.prototype.print=function(t){Y.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},e.prototype.getResultAreaEdges=function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new Nt;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList},e.prototype.updateLabelling=function(t){for(var e=this.iterator();e.hasNext();){var n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}},e.prototype.linkAllDirectedEdges=function(){this.getEdges();for(var t=null,e=null,n=this._edgeList.size()-1;n>=0;n--){var i=this._edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},e.prototype.computeDepths=function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=t.getDepth(Se.LEFT),i=t.getDepth(Se.RIGHT),r=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,r)!==i)throw new we("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],s=arguments[1],a=arguments[2],u=o;u<s;u++){var l=this._edgeList.get(u);l.setEdgeDepths(Se.RIGHT,a),a=l.getDepth(Se.LEFT)}return a}},e.prototype.mergeSymLabels=function(){for(var t=this.iterator();t.hasNext();){var e=t.next();e.getLabel().merge(e.getSym().getLabel())}},e.prototype.linkMinimalDirectedEdges=function(t){for(var e=null,n=null,i=this._SCANNING_FOR_INCOMING,r=this._resultAreaEdgeList.size()-1;r>=0;r--){var o=this._resultAreaEdgeList.get(r),s=o.getSym();switch(null===e&&o.getEdgeRing()===t&&(e=o),i){case this._SCANNING_FOR_INCOMING:if(s.getEdgeRing()!==t)continue;n=s,i=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(o.getEdgeRing()!==t)continue;n.setNextMin(o),i=this._SCANNING_FOR_INCOMING}}i===this._LINKING_TO_OUTGOING&&(et.isTrue(null!==e,"found null for first outgoing dirEdge"),et.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},e.prototype.getOutgoingDegree=function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){for(var n=arguments[0],i=0,r=this.iterator();r.hasNext();){r.next().getEdgeRing()===n&&i++}return i}},e.prototype.getLabel=function(){return this._label},e.prototype.findCoveredLineEdges=function(){for(var t=w.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=w.INTERIOR;break}if(i.isInResult()){t=w.EXTERIOR;break}}}if(t===w.NONE)return null;for(var r=t,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getSym();s.isLineEdge()?s.getEdge().setCovered(r===w.INTERIOR):(s.isInResult()&&(r=w.EXTERIOR),a.isInResult()&&(r=w.INTERIOR))}},e.prototype.computeLabelling=function(e){t.prototype.computeLabelling.call(this,e),this._label=new Pe(w.NONE);for(var n=this.iterator();n.hasNext();)for(var i=n.next().getEdge().getLabel(),r=0;r<2;r++){var o=i.getLocation(r);o!==w.INTERIOR&&o!==w.BOUNDARY||this._label.setLocation(r,w.INTERIOR)}},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Xn),kn=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createNode=function(t){return new Ge(t,new Yn)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Xe),jn=function t(){this._pts=null,this._orientation=null;var e=arguments[0];this._pts=e,this._orientation=t.orientation(e)};jn.prototype.compareTo=function(t){var e=t;return jn.compareOriented(this._pts,this._orientation,e._pts,e._orientation)},jn.prototype.interfaces_=function(){return[E]},jn.prototype.getClass=function(){return jn},jn.orientation=function(t){return 1===Lt.increasingDirection(t)},jn.compareOriented=function(t,e,n,i){for(var r=e?1:-1,o=i?1:-1,s=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var c=t[u].compareTo(n[l]);if(0!==c)return c;var p=(u+=r)===s,h=(l+=o)===a;if(p&&!h)return-1;if(!p&&h)return 1;if(p&&h)return 0}};var Hn=function(){this._edges=new Nt,this._ocaMap=new p};Hn.prototype.print=function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this._edges.size();e++){var n=this._edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},Hn.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},Hn.prototype.findEdgeIndex=function(t){for(var e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1},Hn.prototype.iterator=function(){return this._edges.iterator()},Hn.prototype.getEdges=function(){return this._edges},Hn.prototype.get=function(t){return this._edges.get(t)},Hn.prototype.findEqualEdge=function(t){var e=new jn(t.getCoordinates());return this._ocaMap.get(e)},Hn.prototype.add=function(t){this._edges.add(t);var e=new jn(t.getCoordinates());this._ocaMap.put(e,t)},Hn.prototype.interfaces_=function(){return[]},Hn.prototype.getClass=function(){return Hn};var Wn=function(){};Wn.prototype.processIntersections=function(t,e,n,i){},Wn.prototype.isDone=function(){},Wn.prototype.interfaces_=function(){return[]},Wn.prototype.getClass=function(){return Wn};var Kn=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this._li=t};Kn.prototype.isTrivialIntersection=function(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(Kn.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},Kn.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Kn.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Kn.prototype.getLineIntersector=function(){return this._li},Kn.prototype.hasProperIntersection=function(){return this._hasProper},Kn.prototype.processIntersections=function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))},Kn.prototype.hasIntersection=function(){return this._hasIntersection},Kn.prototype.isDone=function(){return!1},Kn.prototype.hasInteriorIntersection=function(){return this._hasInterior},Kn.prototype.interfaces_=function(){return[Wn]},Kn.prototype.getClass=function(){return Kn},Kn.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)};var Jn=function(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new C(t),this.segmentIndex=e,this.dist=n};Jn.prototype.getSegmentIndex=function(){return this.segmentIndex},Jn.prototype.getCoordinate=function(){return this.coord},Jn.prototype.print=function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},Jn.prototype.compareTo=function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},Jn.prototype.isEndPoint=function(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t},Jn.prototype.toString=function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},Jn.prototype.getDistance=function(){return this.dist},Jn.prototype.compare=function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},Jn.prototype.interfaces_=function(){return[E]},Jn.prototype.getClass=function(){return Jn};var Qn=function(){this._nodeMap=new p,this.edge=null;var t=arguments[0];this.edge=t};Qn.prototype.print=function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){e.next().print(t)}},Qn.prototype.iterator=function(){return this._nodeMap.values().iterator()},Qn.prototype.addSplitEdges=function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},Qn.prototype.addEndpoints=function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},Qn.prototype.createSplitEdge=function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var o=new Array(n).fill(null),s=0;o[s++]=new C(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this.edge.pts[a];return r&&(o[s]=e.coord),new ni(o,new Pe(this.edge._label))},Qn.prototype.add=function(t,e,n){var i=new Jn(t,e,n),r=this._nodeMap.get(i);return null!==r?r:(this._nodeMap.put(i,i),i)},Qn.prototype.isIntersection=function(t){for(var e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1},Qn.prototype.interfaces_=function(){return[]},Qn.prototype.getClass=function(){return Qn};var Zn=function(){};Zn.prototype.getChainStartIndices=function(t){var e=0,n=new Nt;n.add(new M(e));do{var i=this.findChainEnd(t,e);n.add(new M(i)),e=i}while(e<t.length-1);return Zn.toIntArray(n)},Zn.prototype.findChainEnd=function(t,e){for(var n=Be.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){if(Be.quadrant(t[i-1],t[i])!==n)break;i++}return i-1},Zn.prototype.interfaces_=function(){return[]},Zn.prototype.getClass=function(){return Zn},Zn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e};var $n=function(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new j,this.env2=new j;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Zn;this.startIndex=e.getChainStartIndices(this.pts)};$n.prototype.getCoordinates=function(){return this.pts},$n.prototype.getMaxX=function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},$n.prototype.getMinX=function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n},$n.prototype.computeIntersectsForChain=function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],c=this.pts[r],p=this.pts[o],h=s.pts[a],f=s.pts[u];if(o-r==1&&u-a==1)return l.addIntersections(this.e,r,s.e,a),null;if(this.env1.init(c,p),this.env2.init(h,f),!this.env1.intersects(this.env2))return null;var g=Math.trunc((r+o)/2),d=Math.trunc((a+u)/2);r<g&&(a<d&&this.computeIntersectsForChain(r,g,s,a,d,l),d<u&&this.computeIntersectsForChain(r,g,s,d,u,l)),g<o&&(a<d&&this.computeIntersectsForChain(g,o,s,a,d,l),d<u&&this.computeIntersectsForChain(g,o,s,d,u,l))}},$n.prototype.getStartIndexes=function(){return this.startIndex},$n.prototype.computeIntersects=function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},$n.prototype.interfaces_=function(){return[]},$n.prototype.getClass=function(){return $n};var ti=function t(){this._depth=Array(2).fill().map(function(){return Array(3)});for(var e=0;e<2;e++)for(var n=0;n<3;n++)this._depth[e][n]=t.NULL_VALUE},ei={NULL_VALUE:{configurable:!0}};ti.prototype.getDepth=function(t,e){return this._depth[t][e]},ti.prototype.setDepth=function(t,e,n){this._depth[t][e]=n},ti.prototype.isNull=function(){if(0===arguments.length){for(var t=0;t<2;t++)for(var e=0;e<3;e++)if(this._depth[t][e]!==ti.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this._depth[n][1]===ti.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this._depth[i][r]===ti.NULL_VALUE}},ti.prototype.normalize=function(){for(var t=0;t<2;t++)if(!this.isNull(t)){var e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(var n=1;n<3;n++){var i=0;this._depth[t][n]>e&&(i=1),this._depth[t][n]=i}}},ti.prototype.getDelta=function(t){return this._depth[t][Se.RIGHT]-this._depth[t][Se.LEFT]},ti.prototype.getLocation=function(t,e){return this._depth[t][e]<=0?w.EXTERIOR:w.INTERIOR},ti.prototype.toString=function(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]},ti.prototype.add=function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<2;e++)for(var n=1;n<3;n++){var i=t.getLocation(e,n);i!==w.EXTERIOR&&i!==w.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=ti.depthAtLocation(i):this._depth[e][n]+=ti.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],o=arguments[1];arguments[2]===w.INTERIOR&&this._depth[r][o]++}},ti.prototype.interfaces_=function(){return[]},ti.prototype.getClass=function(){return ti},ti.depthAtLocation=function(t){return t===w.EXTERIOR?0:t===w.INTERIOR?1:ti.NULL_VALUE},ei.NULL_VALUE.get=function(){return-1},Object.defineProperties(ti,ei);var ni=function(t){function e(){if(t.call(this),this.pts=null,this._env=null,this.eiList=new Qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new ti,this._depthDelta=0,1===arguments.length){var n=arguments[0];e.call(this,n,null)}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.pts=i,this._label=r}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDepth=function(){return this._depth},e.prototype.getCollapsedEdge=function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new e(t,Pe.toLineLabel(this._label))},e.prototype.isIsolated=function(){return this._isIsolated},e.prototype.getCoordinates=function(){return this.pts},e.prototype.setIsolated=function(t){this._isIsolated=t},e.prototype.setName=function(t){this._name=t},e.prototype.equals=function(t){if(!(t instanceof e))return!1;var n=t;if(this.pts.length!==n.pts.length)return!1;for(var i=!0,r=!0,o=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(n.pts[s])||(i=!1),this.pts[s].equals2D(n.pts[--o])||(r=!1),!i&&!r)return!1;return!0},e.prototype.getCoordinate=function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},e.prototype.print=function(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)},e.prototype.computeIM=function(t){e.updateIM(this._label,t)},e.prototype.isCollapsed=function(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))},e.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1])},e.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1},e.prototype.getDepthDelta=function(){return this._depthDelta},e.prototype.getNumPoints=function(){return this.pts.length},e.prototype.printReverse=function(t){t.print("edge "+this._name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},e.prototype.getMonotoneChainEdge=function(){return null===this._mce&&(this._mce=new $n(this)),this._mce},e.prototype.getEnvelope=function(){if(null===this._env){this._env=new j;for(var t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env},e.prototype.addIntersection=function(t,e,n,i){var r=new C(t.getIntersection(i)),o=e,s=t.getEdgeDistance(n,i),a=o+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(o=a,s=0)}this.eiList.add(r,o,s)},e.prototype.toString=function(){var t=new D;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()},e.prototype.isPointwiseEqual=function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},e.prototype.setDepthDelta=function(t){this._depthDelta=t},e.prototype.getEdgeIntersectionList=function(){return this.eiList},e.prototype.addIntersections=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e.updateIM=function(){if(2!==arguments.length)return t.prototype.updateIM.apply(this,arguments);var e=arguments[0],n=arguments[1];n.setAtLeastIfValid(e.getLocation(0,Se.ON),e.getLocation(1,Se.ON),1),e.isArea()&&(n.setAtLeastIfValid(e.getLocation(0,Se.LEFT),e.getLocation(1,Se.LEFT),2),n.setAtLeastIfValid(e.getLocation(0,Se.RIGHT),e.getLocation(1,Se.RIGHT),2))},e}(Fe),ii=function(t){this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Hn,this._bufParams=t||null};ii.prototype.setWorkingPrecisionModel=function(t){this._workingPrecisionModel=t},ii.prototype.insertUniqueEdge=function(t){var e=this._edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new Pe(t.getLabel())).flip(),n.merge(i);var r=ii.depthDelta(i),o=e.getDepthDelta()+r;e.setDepthDelta(o)}else this._edgeList.add(t),t.setDepthDelta(ii.depthDelta(t.getLabel()))},ii.prototype.buildSubgraphs=function(t,e){for(var n=new Nt,i=t.iterator();i.hasNext();){var r=i.next(),o=r.getRightmostCoordinate(),s=new An(n).getDepth(o);r.computeDepth(s),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},ii.prototype.createSubgraphs=function(t){for(var e=new Nt,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new Te;r.create(i),e.add(r)}}return $e.sort(e,$e.reverseOrder()),e},ii.prototype.createEmptyResultGeometry=function(){return this._geomFact.createPolygon()},ii.prototype.getNoder=function(t){if(null!==this._workingNoder)return this._workingNoder;var e=new xn,n=new rt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Kn(n)),e},ii.prototype.buffer=function(t,e){var n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();var i=new Mn(n,this._bufParams),r=new Bn(t,e,i).getCurves();if(r.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(r,n),this._graph=new Ye(new kn),this._graph.addEdges(this._edgeList.getEdges());var o=this.createSubgraphs(this._graph),s=new ke(this._geomFact);this.buildSubgraphs(o,s);var a=s.getPolygons();if(a.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(a)},ii.prototype.computeNodedEdges=function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings().iterator();i.hasNext();){var r=i.next(),o=r.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var s=r.getData(),a=new ni(r.getCoordinates(),new Pe(s));this.insertUniqueEdge(a)}}},ii.prototype.setNoder=function(t){this._workingNoder=t},ii.prototype.interfaces_=function(){return[]},ii.prototype.getClass=function(){return ii},ii.depthDelta=function(t){var e=t.getLocation(0,Se.LEFT),n=t.getLocation(0,Se.RIGHT);return e===w.INTERIOR&&n===w.EXTERIOR?1:e===w.EXTERIOR&&n===w.INTERIOR?-1:0},ii.convertSegStrings=function(t){for(var e=new _e,n=new Nt;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)};var ri=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._offsetX=0,this._offsetY=0,this._isScaled=!this.isIntegerPrecision()}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=arguments[3];this._noder=n,this._scaleFactor=i,this._offsetX=r,this._offsetY=o,this._isScaled=!this.isIntegerPrecision()}};ri.prototype.rescale=function(){if(T(arguments[0],It))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.rescale(e.getCoordinates())}else if(arguments[0]instanceof Array){for(var n=arguments[0],i=0;i<n.length;i++)n[i].x=n[i].x/this._scaleFactor+this._offsetX,n[i].y=n[i].y/this._scaleFactor+this._offsetY;2===n.length&&n[0].equals2D(n[1])&&Y.out.println(n)}},ri.prototype.scale=function(){if(T(arguments[0],It)){for(var t=arguments[0],e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();e.add(new gn(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],o=new Array(r.length).fill(null),s=0;s<r.length;s++)o[s]=new C(Math.round((r[s].x-this._offsetX)*this._scaleFactor),Math.round((r[s].y-this._offsetY)*this._scaleFactor),r[s].z);return Lt.removeRepeatedPoints(o)}},ri.prototype.isIntegerPrecision=function(){return 1===this._scaleFactor},ri.prototype.getNodedSubstrings=function(){var t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t},ri.prototype.computeNodes=function(t){var e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)},ri.prototype.interfaces_=function(){return[In]},ri.prototype.getClass=function(){return ri};var oi=function(){this._li=new rt,this._segStrings=null;var t=arguments[0];this._segStrings=t},si={fact:{configurable:!0}};oi.prototype.checkEndPtVertexIntersections=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length)for(var n=arguments[0],i=arguments[1].iterator();i.hasNext();)for(var r=i.next().getCoordinates(),o=1;o<r.length-1;o++)if(r[o].equals(n))throw new $("found endpt/interior pt intersection at index "+o+" :pt "+n)},oi.prototype.checkInteriorIntersections=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this._segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],o=arguments[1],s=r.getCoordinates(),a=o.getCoordinates(),u=0;u<s.length-1;u++)for(var l=0;l<a.length-1;l++)this.checkInteriorIntersections(r,u,o,l);else if(4===arguments.length){var c=arguments[0],p=arguments[1],h=arguments[2],f=arguments[3];if(c===h&&p===f)return null;var g=c.getCoordinates()[p],d=c.getCoordinates()[p+1],y=h.getCoordinates()[f],_=h.getCoordinates()[f+1];if(this._li.computeIntersection(g,d,y,_),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,g,d)||this.hasInteriorIntersection(this._li,y,_)))throw new $("found non-noded intersection at "+g+"-"+d+" and "+y+"-"+_)}},oi.prototype.checkValid=function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},oi.prototype.checkCollapses=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0].getCoordinates(),i=0;i<n.length-2;i++)this.checkCollapse(n[i],n[i+1],n[i+2])},oi.prototype.hasInteriorIntersection=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},oi.prototype.checkCollapse=function(t,e,n){if(t.equals(n))throw new $("found non-noded collapse at "+oi.fact.createLineString([t,e,n]))},oi.prototype.interfaces_=function(){return[]},oi.prototype.getClass=function(){return oi},si.fact.get=function(){return new _e},Object.defineProperties(oi,si);var ai=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new m("Scale factor must be non-zero");1!==e&&(this._pt=new C(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new C,this._p1Scaled=new C),this.initCorners(this._pt)},ui={SAFE_ENV_EXPANSION_FACTOR:{configurable:!0}};ai.prototype.intersectsScaled=function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),o=Math.max(t.y,e.y),s=this._maxx<n||this._minx>i||this._maxy<r||this._miny>o;if(s)return!1;var a=this.intersectsToleranceSquare(t,e);return et.isTrue(!(s&&a),"Found bad envelope test"),a},ai.prototype.initCorners=function(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new C(this._maxx,this._maxy),this._corner[1]=new C(this._minx,this._maxy),this._corner[2]=new C(this._minx,this._miny),this._corner[3]=new C(this._maxx,this._miny)},ai.prototype.intersects=function(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))},ai.prototype.scale=function(t){return Math.round(t*this._scaleFactor)},ai.prototype.getCoordinate=function(){return this._originalPt},ai.prototype.copyScaled=function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},ai.prototype.getSafeEnvelope=function(){if(null===this._safeEnv){var t=ai.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new j(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv},ai.prototype.intersectsPixelClosure=function(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))},ai.prototype.intersectsToleranceSquare=function(t,e){var n=!1,i=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(i=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!i)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))},ai.prototype.addSnappedNode=function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return!!this.intersects(n,i)&&(t.addIntersection(this.getCoordinate(),e),!0)},ai.prototype.interfaces_=function(){return[]},ai.prototype.getClass=function(){return ai},ui.SAFE_ENV_EXPANSION_FACTOR.get=function(){return.75},Object.defineProperties(ai,ui);var li=function(){this.tempEnv1=new j,this.selectedSegment=new dn};li.prototype.select=function(){if(1===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},li.prototype.interfaces_=function(){return[]},li.prototype.getClass=function(){return li};var ci=function(){this._index=null;var t=arguments[0];this._index=t},pi={HotPixelSnapAction:{configurable:!0}};ci.prototype.snap=function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),o=new hi(e,n,i);return this._index.query(r,{interfaces_:function(){return[Ke]},visitItem:function(t){t.select(r,o)}}),o.isNodeAdded()}},ci.prototype.interfaces_=function(){return[]},ci.prototype.getClass=function(){return ci},pi.HotPixelSnapAction.get=function(){return hi},Object.defineProperties(ci,pi);var hi=function(t){function e(){t.call(this),this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var e=arguments[0],n=arguments[1],i=arguments[2];this._hotPixel=e,this._parentEdge=n,this._hotPixelVertexIndex=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isNodeAdded=function(){return this._isNodeAdded},e.prototype.select=function(){if(2!==arguments.length)return t.prototype.select.apply(this,arguments);var e=arguments[0],n=arguments[1],i=e.getContext();if(null!==this._parentEdge&&i===this._parentEdge&&n===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(i,n)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(li),fi=function(){this._li=null,this._interiorIntersections=null;var t=arguments[0];this._li=t,this._interiorIntersections=new Nt};fi.prototype.processIntersections=function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var u=0;u<this._li.getIntersectionNum();u++)this._interiorIntersections.add(this._li.getIntersection(u));t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)}},fi.prototype.isDone=function(){return!1},fi.prototype.getInteriorIntersections=function(){return this._interiorIntersections},fi.prototype.interfaces_=function(){return[Wn]},fi.prototype.getClass=function(){return fi};var gi=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var t=arguments[0];this._pm=t,this._li=new rt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};gi.prototype.checkCorrectness=function(t){var e=gn.getNodedSubstrings(t),n=new oi(e);try{n.checkValid()}catch(t){if(!(t instanceof z))throw t;t.printStackTrace()}},gi.prototype.getNodedSubstrings=function(){return gn.getNodedSubstrings(this._nodedSegStrings)},gi.prototype.snapRound=function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},gi.prototype.findInteriorIntersections=function(t,e){var n=new fi(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()},gi.prototype.computeVertexSnaps=function(){if(T(arguments[0],It))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.computeVertexSnaps(e)}else if(arguments[0]instanceof gn)for(var n=arguments[0],i=n.getCoordinates(),r=0;r<i.length;r++){var o=new ai(i[r],this._scaleFactor,this._li);this._pointSnapper.snap(o,n,r)&&n.addIntersection(i[r],r)}},gi.prototype.computeNodes=function(t){this._nodedSegStrings=t,this._noder=new xn,this._pointSnapper=new ci(this._noder.getIndex()),this.snapRound(t,this._li)},gi.prototype.computeIntersectionSnaps=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new ai(n,this._scaleFactor,this._li);this._pointSnapper.snap(i)}},gi.prototype.interfaces_=function(){return[In]},gi.prototype.getClass=function(){return gi};var di=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Cn,this._resultGeometry=null,this._saveException=null,1===arguments.length){var t=arguments[0];this._argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this._argGeom=e,this._bufParams=n}},yi={CAP_ROUND:{configurable:!0},CAP_BUTT:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},MAX_PRECISION_DIGITS:{configurable:!0}};di.prototype.bufferFixedPrecision=function(t){var e=new ri(new gi(new fe(1)),t.getScale()),n=new ii(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)},di.prototype.bufferReducedPrecision=function(){var t=this;if(0===arguments.length){for(var e=di.MAX_PRECISION_DIGITS;e>=0;e--){try{t.bufferReducedPrecision(e)}catch(e){if(!(e instanceof we))throw e;t._saveException=e}if(null!==t._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var n=arguments[0],i=di.precisionScaleFactor(this._argGeom,this._distance,n),r=new fe(i);this.bufferFixedPrecision(r)}},di.prototype.computeGeometry=function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var t=this._argGeom.getFactory().getPrecisionModel();t.getType()===fe.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},di.prototype.setQuadrantSegments=function(t){this._bufParams.setQuadrantSegments(t)},di.prototype.bufferOriginalPrecision=function(){try{var t=new ii(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof $))throw t;this._saveException=t}},di.prototype.getResultGeometry=function(t){return this._distance=t,this.computeGeometry(),this._resultGeometry},di.prototype.setEndCapStyle=function(t){this._bufParams.setEndCapStyle(t)},di.prototype.interfaces_=function(){return[]},di.prototype.getClass=function(){return di},di.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return new di(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof ct&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=arguments[2],o=new di(n);o.setQuadrantSegments(r);return o.getResultGeometry(i)}if(arguments[2]instanceof Cn&&arguments[0]instanceof ct&&"number"==typeof arguments[1]){var s=arguments[0],a=arguments[1],u=arguments[2];return new di(s,u).getResultGeometry(a)}}else if(4===arguments.length){var l=arguments[0],c=arguments[1],p=arguments[2],h=arguments[3],f=new di(l);f.setQuadrantSegments(p),f.setEndCapStyle(h);return f.getResultGeometry(c)}},di.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=R.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY()))+2*(e>0?e:0),o=n-Math.trunc(Math.log(r)/Math.log(10)+1);return Math.pow(10,o)},yi.CAP_ROUND.get=function(){return Cn.CAP_ROUND},yi.CAP_BUTT.get=function(){return Cn.CAP_FLAT},yi.CAP_FLAT.get=function(){return Cn.CAP_FLAT},yi.CAP_SQUARE.get=function(){return Cn.CAP_SQUARE},yi.MAX_PRECISION_DIGITS.get=function(){return 12},Object.defineProperties(di,yi);var _i=function(){this._pt=[new C,new C],this._distance=v.NaN,this._isNull=!0};_i.prototype.getCoordinates=function(){return this._pt},_i.prototype.getCoordinate=function(t){return this._pt[t]},_i.prototype.setMinimum=function(){if(1===arguments.length){var t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i<this._distance&&this.initialize(e,n,i)}},_i.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._pt[0].setCoordinate(n),this._pt[1].setCoordinate(i),this._distance=r,this._isNull=!1}},_i.prototype.getDistance=function(){return this._distance},_i.prototype.setMaximum=function(){if(1===arguments.length){var t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i>this._distance&&this.initialize(e,n,i)}},_i.prototype.interfaces_=function(){return[]},_i.prototype.getClass=function(){return _i};var mi=function(){};mi.prototype.interfaces_=function(){return[]},mi.prototype.getClass=function(){return mi},mi.computeDistance=function(){if(arguments[2]instanceof _i&&arguments[0]instanceof Kt&&arguments[1]instanceof C)for(var t=arguments[0],e=arguments[1],n=arguments[2],i=t.getCoordinates(),r=new dn,o=0;o<i.length-1;o++){r.setCoordinates(i[o],i[o+1]);var s=r.closestPoint(e);n.setMinimum(s,e)}else if(arguments[2]instanceof _i&&arguments[0]instanceof $t&&arguments[1]instanceof C){var a=arguments[0],u=arguments[1],l=arguments[2];mi.computeDistance(a.getExteriorRing(),u,l);for(var c=0;c<a.getNumInteriorRing();c++)mi.computeDistance(a.getInteriorRingN(c),u,l)}else if(arguments[2]instanceof _i&&arguments[0]instanceof ct&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1],f=arguments[2];if(p instanceof Kt)mi.computeDistance(p,h,f);else if(p instanceof $t)mi.computeDistance(p,h,f);else if(p instanceof zt)for(var g=p,d=0;d<g.getNumGeometries();d++){var y=g.getGeometryN(d);mi.computeDistance(y,h,f)}else f.setMinimum(p.getCoordinate(),h)}else if(arguments[2]instanceof _i&&arguments[0]instanceof dn&&arguments[1]instanceof C){var _=arguments[0],m=arguments[1],v=arguments[2],I=_.closestPoint(m);v.setMinimum(I,m)}};var vi=function(t){this._maxPtDist=new _i,this._inputGeom=t||null},Ii={MaxPointDistanceFilter:{configurable:!0},MaxMidpointDistanceFilter:{configurable:!0}};vi.prototype.computeMaxMidpointDistance=function(t){var e=new xi(this._inputGeom);t.apply(e),this._maxPtDist.setMaximum(e.getMaxPointDistance())},vi.prototype.computeMaxVertexDistance=function(t){var e=new Ei(this._inputGeom);t.apply(e),this._maxPtDist.setMaximum(e.getMaxPointDistance())},vi.prototype.findDistance=function(t){return this.computeMaxVertexDistance(t),this.computeMaxMidpointDistance(t),this._maxPtDist.getDistance()},vi.prototype.getDistancePoints=function(){return this._maxPtDist},vi.prototype.interfaces_=function(){return[]},vi.prototype.getClass=function(){return vi},Ii.MaxPointDistanceFilter.get=function(){return Ei},Ii.MaxMidpointDistanceFilter.get=function(){return xi},Object.defineProperties(vi,Ii);var Ei=function(t){this._maxPtDist=new _i,this._minPtDist=new _i,this._geom=t||null};Ei.prototype.filter=function(t){this._minPtDist.initialize(),mi.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Ei.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ei.prototype.interfaces_=function(){return[ft]},Ei.prototype.getClass=function(){return Ei};var xi=function(t){this._maxPtDist=new _i,this._minPtDist=new _i,this._geom=t||null};xi.prototype.filter=function(t,e){if(0===e)return null;var n=t.getCoordinate(e-1),i=t.getCoordinate(e),r=new C((n.x+i.x)/2,(n.y+i.y)/2);this._minPtDist.initialize(),mi.computeDistance(this._geom,r,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},xi.prototype.isDone=function(){return!1},xi.prototype.isGeometryChanged=function(){return!1},xi.prototype.getMaxPointDistance=function(){return this._maxPtDist},xi.prototype.interfaces_=function(){return[Ut]},xi.prototype.getClass=function(){return xi};var Ni=function(t){this._comps=t||null};Ni.prototype.filter=function(t){t instanceof $t&&this._comps.add(t)},Ni.prototype.interfaces_=function(){return[Vt]},Ni.prototype.getClass=function(){return Ni},Ni.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return Ni.getPolygons(t,new Nt)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof $t?n.add(e):e instanceof zt&&e.apply(new Ni(n)),n}};var Ci=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this._lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this._lines=e,this._isForcedToLineString=n}};Ci.prototype.filter=function(t){if(this._isForcedToLineString&&t instanceof ee){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Kt&&this._lines.add(t)},Ci.prototype.setForceToLineString=function(t){this._isForcedToLineString=t},Ci.prototype.interfaces_=function(){return[lt]},Ci.prototype.getClass=function(){return Ci},Ci.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(Ci.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(Ci.getLines(e,n))}},Ci.getLines=function(){if(1===arguments.length){var t=arguments[0];return Ci.getLines(t,!1)}if(2===arguments.length){if(T(arguments[0],It)&&T(arguments[1],It)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();Ci.getLines(r,n)}return n}if(arguments[0]instanceof ct&&"boolean"==typeof arguments[1]){var o=arguments[0],s=arguments[1],a=new Nt;return o.apply(new Ci(a,s)),a}if(arguments[0]instanceof ct&&T(arguments[1],It)){var u=arguments[0],l=arguments[1];return u instanceof Kt?l.add(u):u.apply(new Ci(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&T(arguments[0],It)&&T(arguments[1],It)){for(var c=arguments[0],p=arguments[1],h=arguments[2],f=c.iterator();f.hasNext();){var g=f.next();Ci.getLines(g,p,h)}return p}if("boolean"==typeof arguments[2]&&arguments[0]instanceof ct&&T(arguments[1],It)){var d=arguments[0],y=arguments[1],_=arguments[2];return d.apply(new Ci(y,_)),y}}};var Si=function(){if(this._boundaryRule=gt.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new m("Rule must be non-null");this._boundaryRule=t}};Si.prototype.locateInternal=function(){if(arguments[0]instanceof C&&arguments[1]instanceof $t){var t=arguments[0],e=arguments[1];if(e.isEmpty())return w.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===w.EXTERIOR)return w.EXTERIOR;if(i===w.BOUNDARY)return w.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var o=e.getInteriorRingN(r),s=this.locateInPolygonRing(t,o);if(s===w.INTERIOR)return w.EXTERIOR;if(s===w.BOUNDARY)return w.BOUNDARY}return w.INTERIOR}if(arguments[0]instanceof C&&arguments[1]instanceof Kt){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return w.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?at.isOnLine(a,l)?w.INTERIOR:w.EXTERIOR:w.BOUNDARY}if(arguments[0]instanceof C&&arguments[1]instanceof Qt){var c=arguments[0];return arguments[1].getCoordinate().equals2D(c)?w.INTERIOR:w.EXTERIOR}},Si.prototype.locateInPolygonRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?at.locatePointInRing(t,e.getCoordinates()):w.EXTERIOR},Si.prototype.intersects=function(t,e){return this.locate(t,e)!==w.EXTERIOR},Si.prototype.updateLocationInfo=function(t){t===w.INTERIOR&&(this._isIn=!0),t===w.BOUNDARY&&this._numBoundaries++},Si.prototype.computeLocation=function(t,e){if(e instanceof Qt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof Kt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof $t)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Xt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof ne)for(var o=e,s=0;s<o.getNumGeometries();s++){var a=o.getGeometryN(s);this.updateLocationInfo(this.locateInternal(t,a))}else if(e instanceof zt)for(var u=new Un(e);u.hasNext();){var l=u.next();l!==e&&this.computeLocation(t,l)}},Si.prototype.locate=function(t,e){return e.isEmpty()?w.EXTERIOR:e instanceof Kt?this.locateInternal(t,e):e instanceof $t?this.locateInternal(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?w.BOUNDARY:this._numBoundaries>0||this._isIn?w.INTERIOR:w.EXTERIOR)},Si.prototype.interfaces_=function(){return[]},Si.prototype.getClass=function(){return Si};var Li=function t(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){var e=arguments[0],n=arguments[1];t.call(this,e,t.INSIDE_AREA,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._component=i,this._segIndex=r,this._pt=o}},bi={INSIDE_AREA:{configurable:!0}};Li.prototype.isInsideArea=function(){return this._segIndex===Li.INSIDE_AREA},Li.prototype.getCoordinate=function(){return this._pt},Li.prototype.getGeometryComponent=function(){return this._component},Li.prototype.getSegmentIndex=function(){return this._segIndex},Li.prototype.interfaces_=function(){return[]},Li.prototype.getClass=function(){return Li},bi.INSIDE_AREA.get=function(){return-1},Object.defineProperties(Li,bi);var wi=function(t){this._pts=t||null};wi.prototype.filter=function(t){t instanceof Qt&&this._pts.add(t)},wi.prototype.interfaces_=function(){return[Vt]},wi.prototype.getClass=function(){return wi},wi.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Qt?$e.singletonList(t):wi.getPoints(t,new Nt)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Qt?n.add(e):e instanceof zt&&e.apply(new wi(n)),n}};var Oi=function(){this._locations=null;var t=arguments[0];this._locations=t};Oi.prototype.filter=function(t){(t instanceof Qt||t instanceof Kt||t instanceof $t)&&this._locations.add(new Li(t,0,t.getCoordinate()))},Oi.prototype.interfaces_=function(){return[Vt]},Oi.prototype.getClass=function(){return Oi},Oi.getLocations=function(t){var e=new Nt;return t.apply(new Oi(e)),e};var Ti=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new Si,this._minDistanceLocation=null,this._minDistance=v.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];this._geom=[t,e],this._terminateDistance=0}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=n,this._geom[1]=i,this._terminateDistance=r}};Ti.prototype.computeContainmentDistance=function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=Ni.getPolygons(this._geom[e]);if(r.size()>0){var o=Oi.getLocations(this._geom[i]);if(this.computeContainmentDistance(o,r,n),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[i]=n[0],this._minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&T(arguments[0],xt)&&T(arguments[1],xt)){for(var s=arguments[0],a=arguments[1],u=arguments[2],l=0;l<s.size();l++)for(var c=s.get(l),p=0;p<a.size();p++)if(this.computeContainmentDistance(c,a.get(p),u),this._minDistance<=this._terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof $t){var h=arguments[0],f=arguments[1],g=arguments[2],d=h.getCoordinate();if(w.EXTERIOR!==this._ptLocator.locate(d,f))return this._minDistance=0,g[0]=h,g[1]=new Li(f,d),null}},Ti.prototype.computeMinDistanceLinesPoints=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o);if(this.computeMinDistance(r,s,n),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.computeFacetDistance=function(){var t=new Array(2).fill(null),e=Ci.getLines(this._geom[0]),n=Ci.getLines(this._geom[1]),i=wi.getPoints(this._geom[0]),r=wi.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},Ti.prototype.nearestLocations=function(){return this.computeMinDistance(),this._minDistanceLocation},Ti.prototype.updateMinDistance=function(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])},Ti.prototype.nearestPoints=function(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]},Ti.prototype.computeMinDistance=function(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Kt&&arguments[1]instanceof Qt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),o=0;o<i.length-1;o++){var s=at.distancePointLine(r,i[o],i[o+1]);if(s<this._minDistance){this._minDistance=s;var a=new dn(i[o],i[o+1]).closestPoint(r);n[0]=new Li(t,o,a),n[1]=new Li(e,0,r)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Kt&&arguments[1]instanceof Kt){var u=arguments[0],l=arguments[1],c=arguments[2];if(u.getEnvelopeInternal().distance(l.getEnvelopeInternal())>this._minDistance)return null;for(var p=u.getCoordinates(),h=l.getCoordinates(),f=0;f<p.length-1;f++)for(var g=0;g<h.length-1;g++){var d=at.distanceLineLine(p[f],p[f+1],h[g],h[g+1]);if(d<this._minDistance){this._minDistance=d;var y=new dn(p[f],p[f+1]),_=new dn(h[g],h[g+1]),m=y.closestPoints(_);c[0]=new Li(u,f,m[0]),c[1]=new Li(l,g,m[1])}if(this._minDistance<=this._terminateDistance)return null}}},Ti.prototype.computeMinDistancePoints=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o),a=r.getCoordinate().distance(s.getCoordinate());if(a<this._minDistance&&(this._minDistance=a,n[0]=new Li(r,0,r.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.distance=function(){if(null===this._geom[0]||null===this._geom[1])throw new m("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)},Ti.prototype.computeMinDistanceLines=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o);if(this.computeMinDistance(r,s,n),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.interfaces_=function(){return[]},Ti.prototype.getClass=function(){return Ti},Ti.distance=function(t,e){return new Ti(t,e).distance()},Ti.isWithinDistance=function(t,e,n){return new Ti(t,e,n).distance()<=n},Ti.nearestPoints=function(t,e){return new Ti(t,e).nearestPoints()};var Ri=function(){this._pt=[new C,new C],this._distance=v.NaN,this._isNull=!0};Ri.prototype.getCoordinates=function(){return this._pt},Ri.prototype.getCoordinate=function(t){return this._pt[t]},Ri.prototype.setMinimum=function(){if(1===arguments.length){var t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i<this._distance&&this.initialize(e,n,i)}},Ri.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._pt[0].setCoordinate(n),this._pt[1].setCoordinate(i),this._distance=r,this._isNull=!1}},Ri.prototype.toString=function(){return Z.toLineString(this._pt[0],this._pt[1])},Ri.prototype.getDistance=function(){return this._distance},Ri.prototype.setMaximum=function(){if(1===arguments.length){var t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i>this._distance&&this.initialize(e,n,i)}},Ri.prototype.interfaces_=function(){return[]},Ri.prototype.getClass=function(){return Ri};var Pi=function(){};Pi.prototype.interfaces_=function(){return[]},Pi.prototype.getClass=function(){return Pi},Pi.computeDistance=function(){if(arguments[2]instanceof Ri&&arguments[0]instanceof Kt&&arguments[1]instanceof C)for(var t=arguments[0],e=arguments[1],n=arguments[2],i=new dn,r=t.getCoordinates(),o=0;o<r.length-1;o++){i.setCoordinates(r[o],r[o+1]);var s=i.closestPoint(e);n.setMinimum(s,e)}else if(arguments[2]instanceof Ri&&arguments[0]instanceof $t&&arguments[1]instanceof C){var a=arguments[0],u=arguments[1],l=arguments[2];Pi.computeDistance(a.getExteriorRing(),u,l);for(var c=0;c<a.getNumInteriorRing();c++)Pi.computeDistance(a.getInteriorRingN(c),u,l)}else if(arguments[2]instanceof Ri&&arguments[0]instanceof ct&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1],f=arguments[2];if(p instanceof Kt)Pi.computeDistance(p,h,f);else if(p instanceof $t)Pi.computeDistance(p,h,f);else if(p instanceof zt)for(var g=p,d=0;d<g.getNumGeometries();d++){var y=g.getGeometryN(d);Pi.computeDistance(y,h,f)}else f.setMinimum(p.getCoordinate(),h)}else if(arguments[2]instanceof Ri&&arguments[0]instanceof dn&&arguments[1]instanceof C){var _=arguments[0],m=arguments[1],v=arguments[2],I=_.closestPoint(m);v.setMinimum(I,m)}};var Di=function(){this._g0=null,this._g1=null,this._ptDist=new Ri,this._densifyFrac=0;var t=arguments[0],e=arguments[1];this._g0=t,this._g1=e},Mi={MaxPointDistanceFilter:{configurable:!0},MaxDensifiedByFractionDistanceFilter:{configurable:!0}};Di.prototype.getCoordinates=function(){return this._ptDist.getCoordinates()},Di.prototype.setDensifyFraction=function(t){if(t>1||t<=0)throw new m("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t},Di.prototype.compute=function(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)},Di.prototype.distance=function(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()},Di.prototype.computeOrientedDistance=function(t,e,n){var i=new Ai(e);if(t.apply(i),n.setMaximum(i.getMaxPointDistance()),this._densifyFrac>0){var r=new Fi(e,this._densifyFrac);t.apply(r),n.setMaximum(r.getMaxPointDistance())}},Di.prototype.orientedDistance=function(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()},Di.prototype.interfaces_=function(){return[]},Di.prototype.getClass=function(){return Di},Di.distance=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return new Di(t,e).distance()}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=new Di(n,i);return o.setDensifyFraction(r),o.distance()}},Mi.MaxPointDistanceFilter.get=function(){return Ai},Mi.MaxDensifiedByFractionDistanceFilter.get=function(){return Fi},Object.defineProperties(Di,Mi);var Ai=function(){this._maxPtDist=new Ri,this._minPtDist=new Ri,this._euclideanDist=new Pi,this._geom=null;var t=arguments[0];this._geom=t};Ai.prototype.filter=function(t){this._minPtDist.initialize(),Pi.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Ai.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ai.prototype.interfaces_=function(){return[ft]},Ai.prototype.getClass=function(){return Ai};var Fi=function(){this._maxPtDist=new Ri,this._minPtDist=new Ri,this._geom=null,this._numSubSegs=0;var t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))};Fi.prototype.filter=function(t,e){if(0===e)return null;for(var n=t.getCoordinate(e-1),i=t.getCoordinate(e),r=(i.x-n.x)/this._numSubSegs,o=(i.y-n.y)/this._numSubSegs,s=0;s<this._numSubSegs;s++){var a=n.x+s*r,u=n.y+s*o,l=new C(a,u);this._minPtDist.initialize(),Pi.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}},Fi.prototype.isDone=function(){return!1},Fi.prototype.isGeometryChanged=function(){return!1},Fi.prototype.getMaxPointDistance=function(){return this._maxPtDist},Fi.prototype.interfaces_=function(){return[Ut]},Fi.prototype.getClass=function(){return Fi};var Gi=function(t,e,n){this._minValidDistance=null,this._maxValidDistance=null,this._minDistanceFound=null,this._maxDistanceFound=null,this._isValid=!0,this._errMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=t||null,this._bufDistance=e||null,this._result=n||null},qi={VERBOSE:{configurable:!0},MAX_DISTANCE_DIFF_FRAC:{configurable:!0}};Gi.prototype.checkMaximumDistance=function(t,e,n){var i=new Di(e,t);if(i.setDensifyFraction(.25),this._maxDistanceFound=i.orientedDistance(),this._maxDistanceFound>n){this._isValid=!1;var r=i.getCoordinates();this._errorLocation=r[1],this._errorIndicator=t.getFactory().createLineString(r),this._errMsg="Distance between buffer curve and input is too large ("+this._maxDistanceFound+" at "+Z.toLineString(r[0],r[1])+")"}},Gi.prototype.isValid=function(){var t=Math.abs(this._bufDistance),e=Gi.MAX_DISTANCE_DIFF_FRAC*t;return this._minValidDistance=t-e,this._maxValidDistance=t+e,!(!this._input.isEmpty()&&!this._result.isEmpty())||(this._bufDistance>0?this.checkPositiveValid():this.checkNegativeValid(),Gi.VERBOSE&&Y.out.println("Min Dist= "+this._minDistanceFound+"  err= "+(1-this._minDistanceFound/this._bufDistance)+"  Max Dist= "+this._maxDistanceFound+"  err= "+(this._maxDistanceFound/this._bufDistance-1)),this._isValid)},Gi.prototype.checkNegativeValid=function(){if(!(this._input instanceof $t||this._input instanceof ne||this._input instanceof zt))return null;var t=this.getPolygonLines(this._input);if(this.checkMinimumDistance(t,this._result,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(t,this._result,this._maxValidDistance)},Gi.prototype.getErrorIndicator=function(){return this._errorIndicator},Gi.prototype.checkMinimumDistance=function(t,e,n){var i=new Ti(t,e,n);if(this._minDistanceFound=i.distance(),this._minDistanceFound<n){this._isValid=!1;var r=i.nearestPoints();this._errorLocation=i.nearestPoints()[1],this._errorIndicator=t.getFactory().createLineString(r),this._errMsg="Distance between buffer curve and input is too small ("+this._minDistanceFound+" at "+Z.toLineString(r[0],r[1])+" )"}},Gi.prototype.checkPositiveValid=function(){var t=this._result.getBoundary();if(this.checkMinimumDistance(this._input,t,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(this._input,t,this._maxValidDistance)},Gi.prototype.getErrorLocation=function(){return this._errorLocation},Gi.prototype.getPolygonLines=function(t){for(var e=new Nt,n=new Ci(e),i=Ni.getPolygons(t).iterator();i.hasNext();){i.next().apply(n)}return t.getFactory().buildGeometry(e)},Gi.prototype.getErrorMessage=function(){return this._errMsg},Gi.prototype.interfaces_=function(){return[]},Gi.prototype.getClass=function(){return Gi},qi.VERBOSE.get=function(){return!1},qi.MAX_DISTANCE_DIFF_FRAC.get=function(){return.012},Object.defineProperties(Gi,qi);var Bi=function(t,e,n){this._isValid=!0,this._errorMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=t||null,this._distance=e||null,this._result=n||null},Vi={VERBOSE:{configurable:!0},MAX_ENV_DIFF_FRAC:{configurable:!0}};Bi.prototype.isValid=function(){return this.checkPolygonal(),this._isValid?(this.checkExpectedEmpty(),this._isValid?(this.checkEnvelope(),this._isValid?(this.checkArea(),this._isValid?(this.checkDistance(),this._isValid):this._isValid):this._isValid):this._isValid):this._isValid},Bi.prototype.checkEnvelope=function(){if(this._distance<0)return null;var t=this._distance*Bi.MAX_ENV_DIFF_FRAC;0===t&&(t=.001);var e=new j(this._input.getEnvelopeInternal());e.expandBy(this._distance);var n=new j(this._result.getEnvelopeInternal());n.expandBy(t),n.contains(e)||(this._isValid=!1,this._errorMsg="Buffer envelope is incorrect",this._errorIndicator=this._input.getFactory().toGeometry(n)),this.report("Envelope")},Bi.prototype.checkDistance=function(){var t=new Gi(this._input,this._distance,this._result);t.isValid()||(this._isValid=!1,this._errorMsg=t.getErrorMessage(),this._errorLocation=t.getErrorLocation(),this._errorIndicator=t.getErrorIndicator()),this.report("Distance")},Bi.prototype.checkArea=function(){var t=this._input.getArea(),e=this._result.getArea();this._distance>0&&t>e&&(this._isValid=!1,this._errorMsg="Area of positive buffer is smaller than input",this._errorIndicator=this._result),this._distance<0&&t<e&&(this._isValid=!1,this._errorMsg="Area of negative buffer is larger than input",this._errorIndicator=this._result),this.report("Area")},Bi.prototype.checkPolygonal=function(){this._result instanceof $t||this._result instanceof ne||(this._isValid=!1),this._errorMsg="Result is not polygonal",this._errorIndicator=this._result,this.report("Polygonal")},Bi.prototype.getErrorIndicator=function(){return this._errorIndicator},Bi.prototype.getErrorLocation=function(){return this._errorLocation},Bi.prototype.checkExpectedEmpty=function(){return this._input.getDimension()>=2?null:this._distance>0?null:(this._result.isEmpty()||(this._isValid=!1,this._errorMsg="Result is non-empty",this._errorIndicator=this._result),void this.report("ExpectedEmpty"))},Bi.prototype.report=function(t){if(!Bi.VERBOSE)return null;Y.out.println("Check "+t+": "+(this._isValid?"passed":"FAILED"))},Bi.prototype.getErrorMessage=function(){return this._errorMsg},Bi.prototype.interfaces_=function(){return[]},Bi.prototype.getClass=function(){return Bi},Bi.isValidMsg=function(t,e,n){var i=new Bi(t,e,n);return i.isValid()?null:i.getErrorMessage()},Bi.isValid=function(t,e,n){return!!new Bi(t,e,n).isValid()},Vi.VERBOSE.get=function(){return!1},Vi.MAX_ENV_DIFF_FRAC.get=function(){return.012},Object.defineProperties(Bi,Vi);var Ui=function(){this._pts=null,this._data=null;var t=arguments[0],e=arguments[1];this._pts=t,this._data=e};Ui.prototype.getCoordinates=function(){return this._pts},Ui.prototype.size=function(){return this._pts.length},Ui.prototype.getCoordinate=function(t){return this._pts[t]},Ui.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Ui.prototype.getSegmentOctant=function(t){return t===this._pts.length-1?-1:pn.octant(this.getCoordinate(t),this.getCoordinate(t+1))},Ui.prototype.setData=function(t){this._data=t},Ui.prototype.getData=function(){return this._data},Ui.prototype.toString=function(){return Z.toLineString(new ue(this._pts))},Ui.prototype.interfaces_=function(){return[hn]},Ui.prototype.getClass=function(){return Ui};var zi=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new Nt,this._intersectionCount=0,this._keepIntersections=!0;var t=arguments[0];this._li=t,this._interiorIntersection=null};zi.prototype.getInteriorIntersection=function(){return this._interiorIntersection},zi.prototype.setCheckEndSegmentsOnly=function(t){this._isCheckEndSegmentsOnly=t},zi.prototype.getIntersectionSegments=function(){return this._intSegments},zi.prototype.count=function(){return this._intersectionCount},zi.prototype.getIntersections=function(){return this._intersections},zi.prototype.setFindAllIntersections=function(t){this._findAllIntersections=t},zi.prototype.setKeepIntersections=function(t){this._keepIntersections=t},zi.prototype.processIntersections=function(t,e,n,i){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,i)))return null}var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=s,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)},zi.prototype.isEndSegment=function(t,e){return 0===e||e>=t.size()-2},zi.prototype.hasIntersection=function(){return null!==this._interiorIntersection},zi.prototype.isDone=function(){return!this._findAllIntersections&&null!==this._interiorIntersection},zi.prototype.interfaces_=function(){return[Wn]},zi.prototype.getClass=function(){return zi},zi.createAllIntersectionsFinder=function(t){var e=new zi(t);return e.setFindAllIntersections(!0),e},zi.createAnyIntersectionFinder=function(t){return new zi(t)},zi.createIntersectionCounter=function(t){var e=new zi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e};var Xi=function(){this._li=new rt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;var t=arguments[0];this._segStrings=t};Xi.prototype.execute=function(){if(null!==this._segInt)return null;this.checkInteriorIntersections()},Xi.prototype.getIntersections=function(){return this._segInt.getIntersections()},Xi.prototype.isValid=function(){return this.execute(),this._isValid},Xi.prototype.setFindAllIntersections=function(t){this._findAllIntersections=t},Xi.prototype.checkInteriorIntersections=function(){this._isValid=!0,this._segInt=new zi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);var t=new xn;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null},Xi.prototype.checkValid=function(){if(this.execute(),!this._isValid)throw new we(this.getErrorMessage(),this._segInt.getInteriorIntersection())},Xi.prototype.getErrorMessage=function(){if(this._isValid)return"no intersections found";var t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Z.toLineString(t[0],t[1])+" and "+Z.toLineString(t[2],t[3])},Xi.prototype.interfaces_=function(){return[]},Xi.prototype.getClass=function(){return Xi},Xi.computeIntersections=function(t){var e=new Xi(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()};var Yi=function t(){this._nv=null;var e=arguments[0];this._nv=new Xi(t.toSegmentStrings(e))};Yi.prototype.checkValid=function(){this._nv.checkValid()},Yi.prototype.interfaces_=function(){return[]},Yi.prototype.getClass=function(){return Yi},Yi.toSegmentStrings=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ui(i.getCoordinates(),i))}return e},Yi.checkValid=function(t){new Yi(t).checkValid()};var ki=function(t){this._mapOp=t};ki.prototype.map=function(t){for(var e=new Nt,n=0;n<t.getNumGeometries();n++){var i=this._mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(_e.toGeometryArray(e))},ki.prototype.interfaces_=function(){return[]},ki.prototype.getClass=function(){return ki},ki.map=function(t,e){return new ki(e).map(t)};var ji=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new Nt,this._resultLineList=new Nt;var t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n};ji.prototype.collectLines=function(t){for(var e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}},ji.prototype.labelIsolatedLine=function(t,e){var n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)},ji.prototype.build=function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList},ji.prototype.collectLineEdge=function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!Lr.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},ji.prototype.findCoveredLineEdges=function(){for(var t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(var e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getEdge();if(n.isLineEdge()&&!i.isCoveredSet()){var r=this._op.isCoveredByA(n.getCoordinate());i.setCovered(r)}}},ji.prototype.labelIsolatedLines=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},ji.prototype.buildLines=function(t){for(var e=this._lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=this._geometryFactory.createLineString(n.getCoordinates());this._resultLineList.add(i),n.setInResult(!0)}},ji.prototype.collectBoundaryTouchEdge=function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(et.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(Lr.isResultOfOp(i,e)&&e===Lr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},ji.prototype.interfaces_=function(){return[]},ji.prototype.getClass=function(){return ji};var Hi=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new Nt;var t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e};Hi.prototype.filterCoveredNodeToPoint=function(t){var e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){var n=this._geometryFactory.createPoint(e);this._resultPointList.add(n)}},Hi.prototype.extractNonCoveredResultNodes=function(t){for(var e=this._op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===Lr.INTERSECTION))){var i=n.getLabel();Lr.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},Hi.prototype.build=function(t){return this.extractNonCoveredResultNodes(t),this._resultPointList},Hi.prototype.interfaces_=function(){return[]},Hi.prototype.getClass=function(){return Hi};var Wi=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};Wi.prototype.transformPoint=function(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},Wi.prototype.transformPolygon=function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof ee&&!i.isEmpty()||(n=!1);for(var r=new Nt,o=0;o<t.getNumInteriorRing();o++){var s=this.transformLinearRing(t.getInteriorRingN(o),t);null===s||s.isEmpty()||(s instanceof ee||(n=!1),r.add(s))}if(n)return this._factory.createPolygon(i,r.toArray([]));var a=new Nt;return null!==i&&a.add(i),a.addAll(r),this._factory.buildGeometry(a)},Wi.prototype.createCoordinateSequence=function(t){return this._factory.getCoordinateSequenceFactory().create(t)},Wi.prototype.getInputGeometry=function(){return this._inputGeom},Wi.prototype.transformMultiLineString=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this._factory.buildGeometry(n)},Wi.prototype.transformCoordinates=function(t,e){return this.copy(t)},Wi.prototype.transformLineString=function(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},Wi.prototype.transformMultiPoint=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this._factory.buildGeometry(n)},Wi.prototype.transformMultiPolygon=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this._factory.buildGeometry(n)},Wi.prototype.copy=function(t){return t.copy()},Wi.prototype.transformGeometryCollection=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this._pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(_e.toGeometryArray(n)):this._factory.buildGeometry(n)},Wi.prototype.transform=function(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Qt)return this.transformPoint(t,null);if(t instanceof te)return this.transformMultiPoint(t,null);if(t instanceof ee)return this.transformLinearRing(t,null);if(t instanceof Kt)return this.transformLineString(t,null);if(t instanceof Xt)return this.transformMultiLineString(t,null);if(t instanceof $t)return this.transformPolygon(t,null);if(t instanceof ne)return this.transformMultiPolygon(t,null);if(t instanceof zt)return this.transformGeometryCollection(t,null);throw new m("Unknown Geometry subtype: "+t.getClass().getName())},Wi.prototype.transformLinearRing=function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);var i=n.size();return i>0&&i<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)},Wi.prototype.interfaces_=function(){return[]},Wi.prototype.getClass=function(){return Wi};var Ki=function t(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new dn,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Kt&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];t.call(this,e.getCoordinates(),n)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var i=arguments[0],r=arguments[1];this._srcPts=i,this._isClosed=t.isClosed(i),this._snapTolerance=r}};Ki.prototype.snapVertices=function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;i<n;i++){var r=t.get(i),o=this.findSnapForVertex(r,e);null!==o&&(t.set(i,new C(o)),0===i&&this._isClosed&&t.set(t.size()-1,new C(o)))}},Ki.prototype.findSnapForVertex=function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null},Ki.prototype.snapTo=function(t){var e=new St(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()},Ki.prototype.snapSegments=function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;i<n;i++){var r=e[i],o=this.findSegmentIndexToSnap(r,t);o>=0&&t.add(o+1,new C(r),!1)}},Ki.prototype.findSegmentIndexToSnap=function(t,e){for(var n=v.MAX_VALUE,i=-1,r=0;r<e.size()-1;r++){if(this._seg.p0=e.get(r),this._seg.p1=e.get(r+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}var o=this._seg.distance(t);o<this._snapTolerance&&o<n&&(n=o,i=r)}return i},Ki.prototype.setAllowSnappingToSourceVertices=function(t){this._allowSnappingToSourceVertices=t},Ki.prototype.interfaces_=function(){return[]},Ki.prototype.getClass=function(){return Ki},Ki.isClosed=function(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])};var Ji=function(t){this._srcGeom=t||null},Qi={SNAP_PRECISION_FACTOR:{configurable:!0}};Ji.prototype.snapTo=function(t,e){var n=this.extractTargetCoordinates(t);return new Zi(e,n).transform(this._srcGeom)},Ji.prototype.snapToSelf=function(t,e){var n=this.extractTargetCoordinates(this._srcGeom),i=new Zi(t,n,!0).transform(this._srcGeom),r=i;return e&&T(r,Zt)&&(r=i.buffer(0)),r},Ji.prototype.computeSnapTolerance=function(t){return this.computeMinimumSegmentLength(t)/10},Ji.prototype.extractTargetCoordinates=function(t){for(var e=new f,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},Ji.prototype.computeMinimumSegmentLength=function(t){for(var e=v.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);i<e&&(e=i)}return e},Ji.prototype.interfaces_=function(){return[]},Ji.prototype.getClass=function(){return Ji},Ji.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ji(t);i[0]=r.snapTo(e,n);var o=new Ji(e);return i[1]=o.snapTo(i[0],n),i},Ji.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ji.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===fe.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],o=arguments[1];return Math.min(Ji.computeOverlaySnapTolerance(r),Ji.computeOverlaySnapTolerance(o))}},Ji.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Ji.SNAP_PRECISION_FACTOR},Ji.snapToSelf=function(t,e,n){return new Ji(t).snapToSelf(e,n)},Qi.SNAP_PRECISION_FACTOR.get=function(){return 1e-9},Object.defineProperties(Ji,Qi);var Zi=function(t){function e(e,n,i){t.call(this),this._snapTolerance=e||null,this._snapPts=n||null,this._isSelfSnap=void 0!==i&&i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.snapLine=function(t,e){var n=new Ki(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)},e.prototype.transformCoordinates=function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(i)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Wi),$i=function(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=0,this._commonSignExp=null};$i.prototype.getCommon=function(){return v.longBitsToDouble(this._commonBits)},$i.prototype.add=function(t){var e=v.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=$i.signExpBits(this._commonBits),this._isFirst=!1,null;if($i.signExpBits(e)!==this._commonSignExp)return this._commonBits=0,null;this._commonMantissaBitsCount=$i.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=$i.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))},$i.prototype.toString=function(){if(1===arguments.length){var t=arguments[0],e=v.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+v.toBinaryString(t),i=n.substring(n.length-64);return i.substring(0,1)+"  "+i.substring(1,12)+"(exp) "+i.substring(12)+" [ "+e+" ]"}},$i.prototype.interfaces_=function(){return[]},$i.prototype.getClass=function(){return $i},$i.getBit=function(t,e){return 0!=(t&1<<e)?1:0},$i.signExpBits=function(t){return t>>52},$i.zeroLowerBits=function(t,e){return t&~((1<<e)-1)},$i.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if($i.getBit(t,i)!==$i.getBit(e,i))return n;n++}return 52};var tr=function(){this._commonCoord=null,this._ccFilter=new nr},er={CommonCoordinateFilter:{configurable:!0},Translater:{configurable:!0}};tr.prototype.addCommonBits=function(t){var e=new ir(this._commonCoord);t.apply(e),t.geometryChanged()},tr.prototype.removeCommonBits=function(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;var e=new C(this._commonCoord);e.x=-e.x,e.y=-e.y;var n=new ir(e);return t.apply(n),t.geometryChanged(),t},tr.prototype.getCommonCoordinate=function(){return this._commonCoord},tr.prototype.add=function(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()},tr.prototype.interfaces_=function(){return[]},tr.prototype.getClass=function(){return tr},er.CommonCoordinateFilter.get=function(){return nr},er.Translater.get=function(){return ir},Object.defineProperties(tr,er);var nr=function(){this._commonBitsX=new $i,this._commonBitsY=new $i};nr.prototype.filter=function(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)},nr.prototype.getCommonCoordinate=function(){return new C(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())},nr.prototype.interfaces_=function(){return[ft]},nr.prototype.getClass=function(){return nr};var ir=function(){this.trans=null;var t=arguments[0];this.trans=t};ir.prototype.filter=function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},ir.prototype.isDone=function(){return!1},ir.prototype.isGeometryChanged=function(){return!0},ir.prototype.interfaces_=function(){return[Ut]},ir.prototype.getClass=function(){return ir};var rr=function(t,e){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null,this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()};rr.prototype.selfSnap=function(t){return new Ji(t).snapTo(t,this._snapTolerance)},rr.prototype.removeCommonBits=function(t){this._cbr=new tr,this._cbr.add(t[0]),this._cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e},rr.prototype.prepareResult=function(t){return this._cbr.addCommonBits(t),t},rr.prototype.getResultGeometry=function(t){var e=this.snap(this._geom),n=Lr.overlayOp(e[0],e[1],t);return this.prepareResult(n)},rr.prototype.checkValid=function(t){t.isValid()||Y.out.println("Snapped geometry is invalid")},rr.prototype.computeSnapTolerance=function(){this._snapTolerance=Ji.computeOverlaySnapTolerance(this._geom[0],this._geom[1])},rr.prototype.snap=function(t){var e=this.removeCommonBits(t);return Ji.snap(e[0],e[1],this._snapTolerance)},rr.prototype.interfaces_=function(){return[]},rr.prototype.getClass=function(){return rr},rr.overlayOp=function(t,e,n){return new rr(t,e).getResultGeometry(n)},rr.union=function(t,e){return rr.overlayOp(t,e,Lr.UNION)},rr.intersection=function(t,e){return rr.overlayOp(t,e,Lr.INTERSECTION)},rr.symDifference=function(t,e){return rr.overlayOp(t,e,Lr.SYMDIFFERENCE)},rr.difference=function(t,e){return rr.overlayOp(t,e,Lr.DIFFERENCE)};var or=function(t,e){this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e};or.prototype.getResultGeometry=function(t){var e=null,n=!1,i=null;try{e=Lr.overlayOp(this._geom[0],this._geom[1],t);n=!0}catch(t){if(!(t instanceof $))throw t;i=t}if(!n)try{e=rr.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof $?i:t}return e},or.prototype.interfaces_=function(){return[]},or.prototype.getClass=function(){return or},or.overlayOp=function(t,e,n){return new or(t,e).getResultGeometry(n)},or.union=function(t,e){return or.overlayOp(t,e,Lr.UNION)},or.intersection=function(t,e){return or.overlayOp(t,e,Lr.INTERSECTION)},or.symDifference=function(t,e){return or.overlayOp(t,e,Lr.SYMDIFFERENCE)},or.difference=function(t,e){return or.overlayOp(t,e,Lr.DIFFERENCE)};var sr=function(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e};sr.prototype.computeIntersections=function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},sr.prototype.interfaces_=function(){return[]},sr.prototype.getClass=function(){return sr};var ar=function t(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){var e=arguments[0],n=arguments[1];this._eventType=t.DELETE,this._xValue=e,this._insertEvent=n}else if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._eventType=t.INSERT,this._label=i,this._xValue=r,this._obj=o}},ur={INSERT:{configurable:!0},DELETE:{configurable:!0}};ar.prototype.isDelete=function(){return this._eventType===ar.DELETE},ar.prototype.setDeleteEventIndex=function(t){this._deleteEventIndex=t},ar.prototype.getObject=function(){return this._obj},ar.prototype.compareTo=function(t){var e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0},ar.prototype.getInsertEvent=function(){return this._insertEvent},ar.prototype.isInsert=function(){return this._eventType===ar.INSERT},ar.prototype.isSameLabel=function(t){return null!==this._label&&this._label===t._label},ar.prototype.getDeleteEventIndex=function(){return this._deleteEventIndex},ar.prototype.interfaces_=function(){return[E]},ar.prototype.getClass=function(){return ar},ur.INSERT.get=function(){return 1},ur.DELETE.get=function(){return 2},Object.defineProperties(ar,ur);var lr=function(){};lr.prototype.interfaces_=function(){return[]},lr.prototype.getClass=function(){return lr};var cr=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n};cr.prototype.isTrivialIntersection=function(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(cr.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},cr.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},cr.prototype.setIsDoneIfProperInt=function(t){this._isDoneWhenProperInt=t},cr.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},cr.prototype.isBoundaryPointInternal=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next().getCoordinate();if(t.isIntersection(i))return!0}return!1},cr.prototype.hasProperIntersection=function(){return this._hasProper},cr.prototype.hasIntersection=function(){return this._hasIntersection},cr.prototype.isDone=function(){return this._isDone},cr.prototype.isBoundaryPoint=function(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))},cr.prototype.setBoundaryNodes=function(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e},cr.prototype.addIntersections=function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))},cr.prototype.interfaces_=function(){return[]},cr.prototype.getClass=function(){return cr},cr.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)};var pr=function(t){function e(){t.call(this),this.events=new Nt,this.nOverlaps=null}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.prepareEvents=function(){$e.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},e.prototype.computeIntersections=function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof cr&&T(arguments[0],xt)&&T(arguments[1],xt)){var i=arguments[0],r=arguments[1],o=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(o)}else if("boolean"==typeof arguments[2]&&T(arguments[0],xt)&&arguments[1]instanceof cr){var s=arguments[0],a=arguments[1];arguments[2]?this.addEdges(s,null):this.addEdges(s),this.computeIntersections(a)}},e.prototype.addEdge=function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var o=new sr(n,r),s=new ar(e,n.getMinX(r),o);this.events.add(s),this.events.add(new ar(n.getMaxX(r),s))}},e.prototype.processOverlaps=function(t,e,n,i){for(var r=n.getObject(),o=t;o<e;o++){var s=this.events.get(o);if(s.isInsert()){var a=s.getObject();n.isSameLabel(s)||(r.computeIntersections(a,i),this.nOverlaps++)}}},e.prototype.addEdges=function(){if(1===arguments.length)for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.addEdge(e,e)}else if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var o=r.next();this.addEdge(o,i)}},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(lr),hr=function(){this._min=v.POSITIVE_INFINITY,this._max=v.NEGATIVE_INFINITY},fr={NodeComparator:{configurable:!0}};hr.prototype.getMin=function(){return this._min},hr.prototype.intersects=function(t,e){return!(this._min>e||this._max<t)},hr.prototype.getMax=function(){return this._max},hr.prototype.toString=function(){return Z.toLineString(new C(this._min,0),new C(this._max,0))},hr.prototype.interfaces_=function(){return[]},hr.prototype.getClass=function(){return hr},fr.NodeComparator.get=function(){return gr},Object.defineProperties(hr,fr);var gr=function(){};gr.prototype.compare=function(t,e){var n=t,i=e,r=(n._min+n._max)/2,o=(i._min+i._max)/2;return r<o?-1:r>o?1:0},gr.prototype.interfaces_=function(){return[N]},gr.prototype.getClass=function(){return gr};var dr=function(t){function e(){t.call(this),this._item=null;var e=arguments[0],n=arguments[1],i=arguments[2];this._min=e,this._max=n,this._item=i}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.query=function(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(hr),yr=function(t){function e(){t.call(this),this._node1=null,this._node2=null;var e=arguments[0],n=arguments[1];this._node1=e,this._node2=n,this.buildExtent(this._node1,this._node2)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.buildExtent=function(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)},e.prototype.query=function(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(hr),_r=function(){this._leaves=new Nt,this._root=null,this._level=0};_r.prototype.buildTree=function(){$e.sort(this._leaves,new hr.NodeComparator);for(var t=this._leaves,e=null,n=new Nt;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},_r.prototype.insert=function(t,e,n){if(null!==this._root)throw new Error("Index cannot be added to once it has been queried");this._leaves.add(new dr(t,e,n))},_r.prototype.query=function(t,e,n){this.init(),this._root.query(t,e,n)},_r.prototype.buildRoot=function(){if(null!==this._root)return null;this._root=this.buildTree()},_r.prototype.printNode=function(t){Y.out.println(Z.toLineString(new C(t._min,this._level),new C(t._max,this._level)))},_r.prototype.init=function(){if(null!==this._root)return null;this.buildRoot()},_r.prototype.buildLevel=function(t,e){this._level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(i);else{var r=new yr(t.get(n),t.get(n+1));e.add(r)}}},_r.prototype.interfaces_=function(){return[]},_r.prototype.getClass=function(){return _r};var mr=function(){this._items=new Nt};mr.prototype.visitItem=function(t){this._items.add(t)},mr.prototype.getItems=function(){return this._items},mr.prototype.interfaces_=function(){return[Ke]},mr.prototype.getClass=function(){return mr};var vr=function(){this._index=null;var t=arguments[0];if(!T(t,Zt))throw new m("Argument must be Polygonal");this._index=new xr(t)},Ir={SegmentVisitor:{configurable:!0},IntervalIndexedGeometry:{configurable:!0}};vr.prototype.locate=function(t){var e=new st(t),n=new Er(e);return this._index.query(t.y,t.y,n),e.getLocation()},vr.prototype.interfaces_=function(){return[Vn]},vr.prototype.getClass=function(){return vr},Ir.SegmentVisitor.get=function(){return Er},Ir.IntervalIndexedGeometry.get=function(){return xr},Object.defineProperties(vr,Ir);var Er=function(){this._counter=null;var t=arguments[0];this._counter=t};Er.prototype.visitItem=function(t){var e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},Er.prototype.interfaces_=function(){return[Ke]},Er.prototype.getClass=function(){return Er};var xr=function(){this._index=new _r;var t=arguments[0];this.init(t)};xr.prototype.init=function(t){for(var e=Ci.getLines(t).iterator();e.hasNext();){var n=e.next().getCoordinates();this.addLine(n)}},xr.prototype.addLine=function(t){for(var e=1;e<t.length;e++){var n=new dn(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this._index.insert(i,r,n)}},xr.prototype.query=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new mr;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._index.query(i,r,o)}},xr.prototype.interfaces_=function(){return[]},xr.prototype.getClass=function(){return xr};var Nr=function(t){function e(){if(t.call(this),this._parentGeom=null,this._lineEdgeMap=new he,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new Si,2===arguments.length){var e=arguments[0],n=arguments[1],i=gt.OGC_SFS_BOUNDARY_RULE;this._argIndex=e,this._parentGeom=n,this._boundaryNodeRule=i,null!==n&&this.add(n)}else if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];this._argIndex=r,this._parentGeom=o,this._boundaryNodeRule=s,null!==o&&this.add(o)}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.insertBoundaryPoint=function(t,n){var i=this._nodes.addNode(n).getLabel(),r=1;w.NONE;i.getLocation(t,Se.ON)===w.BOUNDARY&&r++;var o=e.determineBoundary(this._boundaryNodeRule,r);i.setLocation(t,o)},e.prototype.computeSelfNodes=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=new cr(n,!0,!1);o.setIsDoneIfProperInt(r);var s=this.createEdgeSetIntersector(),a=this._parentGeom instanceof ee||this._parentGeom instanceof $t||this._parentGeom instanceof ne,u=i||!a;return s.computeIntersections(this._edges,o,u),this.addSelfIntersectionNodes(this._argIndex),o}},e.prototype.computeSplitEdges=function(t){for(var e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}},e.prototype.computeEdgeIntersections=function(t,e,n){var i=new cr(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,i),i},e.prototype.getGeometry=function(){return this._parentGeom},e.prototype.getBoundaryNodeRule=function(){return this._boundaryNodeRule},e.prototype.hasTooFewPoints=function(){return this._hasTooFewPoints},e.prototype.addPoint=function(){if(arguments[0]instanceof Qt){var t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,w.INTERIOR)}else if(arguments[0]instanceof C){var e=arguments[0];this.insertPoint(this._argIndex,e,w.INTERIOR)}},e.prototype.addPolygon=function(t){this.addPolygonRing(t.getExteriorRing(),w.EXTERIOR,w.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,w.INTERIOR,w.EXTERIOR)}},e.prototype.addEdge=function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],w.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],w.BOUNDARY)},e.prototype.addLineString=function(t){var e=Lt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;var n=new ni(e,new Pe(this._argIndex,w.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),et.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])},e.prototype.getInvalidPoint=function(){return this._invalidPoint},e.prototype.getBoundaryPoints=function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},e.prototype.getBoundaryNodes=function(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes},e.prototype.addSelfIntersectionNode=function(t,e,n){if(this.isBoundaryNode(t,e))return null;n===w.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)},e.prototype.addPolygonRing=function(t,e,n){if(t.isEmpty())return null;var i=Lt.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=i[0],null;var r=e,o=n;at.isCCW(i)&&(r=n,o=e);var s=new ni(i,new Pe(this._argIndex,w.BOUNDARY,r,o));this._lineEdgeMap.put(t,s),this.insertEdge(s),this.insertPoint(this._argIndex,i[0],w.BOUNDARY)},e.prototype.insertPoint=function(t,e,n){var i=this._nodes.addNode(e),r=i.getLabel();null===r?i._label=new Pe(t,n):r.setLocation(t,n)},e.prototype.createEdgeSetIntersector=function(){return new pr},e.prototype.addSelfIntersectionNodes=function(t){for(var e=this._edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var o=r.next();this.addSelfIntersectionNode(t,o.coord,i)}},e.prototype.add=function(){if(1!==arguments.length)return t.prototype.add.apply(this,arguments);var e=arguments[0];if(e.isEmpty())return null;if(e instanceof ne&&(this._useBoundaryDeterminationRule=!1),e instanceof $t)this.addPolygon(e);else if(e instanceof Kt)this.addLineString(e);else if(e instanceof Qt)this.addPoint(e);else if(e instanceof te)this.addCollection(e);else if(e instanceof Xt)this.addCollection(e);else if(e instanceof ne)this.addCollection(e);else{if(!(e instanceof zt))throw new Error(e.getClass().getName());this.addCollection(e)}},e.prototype.addCollection=function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},e.prototype.locate=function(t){return T(this._parentGeom,Zt)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new vr(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)},e.prototype.findEdge=function(){if(1===arguments.length){var e=arguments[0];return this._lineEdgeMap.get(e)}return t.prototype.findEdge.apply(this,arguments)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e.determineBoundary=function(t,e){return t.isInBoundary(e)?w.BOUNDARY:w.INTERIOR},e}(Ye),Cr=function(){if(this._li=new rt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Nr(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=gt.OGC_SFS_BOUNDARY_RULE;e.getPrecisionModel().compareTo(n.getPrecisionModel())>=0?this.setComputationPrecision(e.getPrecisionModel()):this.setComputationPrecision(n.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Nr(0,e,i),this._arg[1]=new Nr(1,n,i)}else if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];r.getPrecisionModel().compareTo(o.getPrecisionModel())>=0?this.setComputationPrecision(r.getPrecisionModel()):this.setComputationPrecision(o.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Nr(0,r,s),this._arg[1]=new Nr(1,o,s)}};Cr.prototype.getArgGeometry=function(t){return this._arg[t].getGeometry()},Cr.prototype.setComputationPrecision=function(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)},Cr.prototype.interfaces_=function(){return[]},Cr.prototype.getClass=function(){return Cr};var Sr=function(){};Sr.prototype.interfaces_=function(){return[]},Sr.prototype.getClass=function(){return Sr},Sr.map=function(){if(arguments[0]instanceof ct&&T(arguments[1],Sr.MapOp)){for(var t=arguments[0],e=arguments[1],n=new Nt,i=0;i<t.getNumGeometries();i++){var r=e.map(t.getGeometryN(i));null!==r&&n.add(r)}return t.getFactory().buildGeometry(n)}if(T(arguments[0],It)&&T(arguments[1],Sr.MapOp)){for(var o=arguments[0],s=arguments[1],a=new Nt,u=o.iterator();u.hasNext();){var l=u.next(),c=s.map(l);null!==c&&a.add(c)}return a}},Sr.MapOp=function(){};var Lr=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n),this._ptLocator=new Si,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Hn,this._resultPolyList=new Nt,this._resultLineList=new Nt,this._resultPointList=new Nt,this._graph=new Ye(new kn),this._geomFact=e.getFactory()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.insertUniqueEdge=function(t){var e=this._edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new Pe(t.getLabel())).flip();var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this._edgeList.add(t)},e.prototype.getGraph=function(){return this._graph},e.prototype.cancelDuplicateResultEdges=function(){for(var t=this._graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},e.prototype.isCoveredByLA=function(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)},e.prototype.computeGeometry=function(t,n,i,r){var o=new Nt;return o.addAll(t),o.addAll(n),o.addAll(i),o.isEmpty()?e.createEmptyResult(r,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(o)},e.prototype.mergeSymLabels=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}},e.prototype.isCovered=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(this._ptLocator.locate(t,i)!==w.EXTERIOR)return!0}return!1},e.prototype.replaceCollapsedEdges=function(){for(var t=new Nt,e=this._edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)},e.prototype.updateNodeLabelling=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},e.prototype.getResultGeometry=function(t){return this.computeOverlay(t),this._resultGeom},e.prototype.insertUniqueEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},e.prototype.computeOverlay=function(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);var e=new Nt;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),Yi.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new ke(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();var i=new ji(this,this._geomFact,this._ptLocator);this._resultLineList=i.build(t);var r=new Hi(this,this._geomFact,this._ptLocator);this._resultPointList=r.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)},e.prototype.labelIncompleteNode=function(t,e){var n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)},e.prototype.copyPoints=function(t){for(var e=this._arg[t].getNodeIterator();e.hasNext();){var n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}},e.prototype.findResultAreaEdges=function(t){for(var n=this._graph.getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea()&&!i.isInteriorAreaEdge()&&e.isResultOfOp(r.getLocation(0,Se.RIGHT),r.getLocation(1,Se.RIGHT),t)&&i.setInResult(!0)}},e.prototype.computeLabelsFromDepths=function(){for(var t=this._edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;r<2;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(et.isTrue(!i.isNull(r,Se.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,Se.LEFT,i.getLocation(r,Se.LEFT)),et.isTrue(!i.isNull(r,Se.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,Se.RIGHT,i.getLocation(r,Se.RIGHT))))}}},e.prototype.computeLabelling=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()},e.prototype.labelIncompleteNodes=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}},e.prototype.isCoveredByA=function(t){return!!this.isCovered(t,this._resultPolyList)},e.prototype.interfaces_=function(){return[]},e.prototype.getClass=function(){return e},e}(Cr);Lr.overlayOp=function(t,e,n){return new Lr(t,e).getResultGeometry(n)},Lr.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return Lr.createEmptyResult(Lr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return ki.map(t,{interfaces_:function(){return[Sr.MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.INTERSECTION)},Lr.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Lr.createEmptyResult(Lr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.SYMDIFFERENCE)},Lr.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),o=-1;switch(t){case Lr.INTERSECTION:o=Math.min(i,r);break;case Lr.UNION:o=Math.max(i,r);break;case Lr.DIFFERENCE:o=i;break;case Lr.SYMDIFFERENCE:o=Math.max(i,r)}return o},Lr.createEmptyResult=function(t,e,n,i){var r=null;switch(Lr.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},Lr.difference=function(t,e){return t.isEmpty()?Lr.createEmptyResult(Lr.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.DIFFERENCE))},Lr.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return Lr.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];switch(r===w.BOUNDARY&&(r=w.INTERIOR),o===w.BOUNDARY&&(o=w.INTERIOR),s){case Lr.INTERSECTION:return r===w.INTERIOR&&o===w.INTERIOR;case Lr.UNION:return r===w.INTERIOR||o===w.INTERIOR;case Lr.DIFFERENCE:return r===w.INTERIOR&&o!==w.INTERIOR;case Lr.SYMDIFFERENCE:return r===w.INTERIOR&&o!==w.INTERIOR||r!==w.INTERIOR&&o===w.INTERIOR}return!1}},Lr.INTERSECTION=1,Lr.UNION=2,Lr.DIFFERENCE=3,Lr.SYMDIFFERENCE=4;var br=function(){this._g=null,this._boundaryDistanceTolerance=null,this._linework=null,this._ptLocator=new Si,this._seg=new dn;var t=arguments[0],e=arguments[1];this._g=t,this._boundaryDistanceTolerance=e,this._linework=this.extractLinework(t)};br.prototype.isWithinToleranceOfBoundary=function(t){for(var e=0;e<this._linework.getNumGeometries();e++)for(var n=this._linework.getGeometryN(e).getCoordinateSequence(),i=0;i<n.size()-1;i++){n.getCoordinate(i,this._seg.p0),n.getCoordinate(i+1,this._seg.p1);if(this._seg.distance(t)<=this._boundaryDistanceTolerance)return!0}return!1},br.prototype.getLocation=function(t){return this.isWithinToleranceOfBoundary(t)?w.BOUNDARY:this._ptLocator.locate(t,this._g)},br.prototype.extractLinework=function(t){var e=new wr;t.apply(e);var n=e.getLinework(),i=_e.toLineStringArray(n);return t.getFactory().createMultiLineString(i)},br.prototype.interfaces_=function(){return[]},br.prototype.getClass=function(){return br};var wr=function(){this._linework=null,this._linework=new Nt};wr.prototype.getLinework=function(){return this._linework},wr.prototype.filter=function(t){if(t instanceof $t){var e=t;this._linework.add(e.getExteriorRing());for(var n=0;n<e.getNumInteriorRing();n++)this._linework.add(e.getInteriorRingN(n))}},wr.prototype.interfaces_=function(){return[Vt]},wr.prototype.getClass=function(){return wr};var Or=function(){this._g=null,this._doLeft=!0,this._doRight=!0;var t=arguments[0];this._g=t};Or.prototype.extractPoints=function(t,e,n){for(var i=t.getCoordinates(),r=0;r<i.length-1;r++)this.computeOffsetPoints(i[r],i[r+1],e,n)},Or.prototype.setSidesToGenerate=function(t,e){this._doLeft=t,this._doRight=e},Or.prototype.getPoints=function(t){for(var e=new Nt,n=Ci.getLines(this._g).iterator();n.hasNext();){var i=n.next();this.extractPoints(i,t,e)}return e},Or.prototype.computeOffsetPoints=function(t,e,n,i){var r=e.x-t.x,o=e.y-t.y,s=Math.sqrt(r*r+o*o),a=n*r/s,u=n*o/s,l=(e.x+t.x)/2,c=(e.y+t.y)/2;if(this._doLeft){var p=new C(l-u,c+a);i.add(p)}if(this._doRight){var h=new C(l+u,c-a);i.add(h)}},Or.prototype.interfaces_=function(){return[]},Or.prototype.getClass=function(){return Or};var Tr=function t(){this._geom=null,this._locFinder=null,this._location=new Array(3).fill(null),this._invalidLocation=null,this._boundaryDistanceTolerance=t.TOLERANCE,this._testCoords=new Nt;var e=arguments[0],n=arguments[1],i=arguments[2];this._boundaryDistanceTolerance=t.computeBoundaryDistanceTolerance(e,n),this._geom=[e,n,i],this._locFinder=[new br(this._geom[0],this._boundaryDistanceTolerance),new br(this._geom[1],this._boundaryDistanceTolerance),new br(this._geom[2],this._boundaryDistanceTolerance)]},Rr={TOLERANCE:{configurable:!0}};Tr.prototype.reportResult=function(t,e,n){Y.out.println("Overlay result invalid - A:"+w.toLocationSymbol(e[0])+" B:"+w.toLocationSymbol(e[1])+" expected:"+(n?"i":"e")+" actual:"+w.toLocationSymbol(e[2]))},Tr.prototype.isValid=function(t){this.addTestPts(this._geom[0]),this.addTestPts(this._geom[1]);var e=this.checkValid(t);return e},Tr.prototype.checkValid=function(){if(1===arguments.length){for(var t=arguments[0],e=0;e<this._testCoords.size();e++){var n=this._testCoords.get(e);if(!this.checkValid(t,n))return this._invalidLocation=n,!1}return!0}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this._location[0]=this._locFinder[0].getLocation(r),this._location[1]=this._locFinder[1].getLocation(r),this._location[2]=this._locFinder[2].getLocation(r),!!Tr.hasLocation(this._location,w.BOUNDARY)||this.isValidResult(i,this._location)}},Tr.prototype.addTestPts=function(t){var e=new Or(t);this._testCoords.addAll(e.getPoints(5*this._boundaryDistanceTolerance))},Tr.prototype.isValidResult=function(t,e){var n=Lr.isResultOfOp(e[0],e[1],t),i=!(n^e[2]===w.INTERIOR);return i||this.reportResult(t,e,n),i},Tr.prototype.getInvalidLocation=function(){return this._invalidLocation},Tr.prototype.interfaces_=function(){return[]},Tr.prototype.getClass=function(){return Tr},Tr.hasLocation=function(t,e){for(var n=0;n<3;n++)if(t[n]===e)return!0;return!1},Tr.computeBoundaryDistanceTolerance=function(t,e){return Math.min(Ji.computeSizeBasedSnapTolerance(t),Ji.computeSizeBasedSnapTolerance(e))},Tr.isValid=function(t,e,n,i){return new Tr(t,e,i).isValid(n)},Rr.TOLERANCE.get=function(){return 1e-6},Object.defineProperties(Tr,Rr);var Pr=function t(e){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null,this._geomFactory=t.extractFactory(e),this._inputGeoms=e};Pr.prototype.extractElements=function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this._skipEmpty&&i.isEmpty()||e.add(i)}},Pr.prototype.combine=function(){for(var t=new Nt,e=this._inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection(null):null:this._geomFactory.buildGeometry(t)},Pr.prototype.interfaces_=function(){return[]},Pr.prototype.getClass=function(){return Pr},Pr.combine=function(){if(1===arguments.length){var t=arguments[0];return new Pr(t).combine()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return new Pr(Pr.createList(e,n)).combine()}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];return new Pr(Pr.createList(i,r,o)).combine()}},Pr.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Pr.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Nt;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2],s=new Nt;return s.add(i),s.add(r),s.add(o),s}};var Dr=function(){this._inputPolys=null,this._geomFactory=null;var t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new Nt)},Mr={STRTREE_NODE_CAPACITY:{configurable:!0}};Dr.prototype.reduceToGeometries=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next(),r=null;T(i,xt)?r=this.unionTree(i):i instanceof ct&&(r=i),e.add(r)}return e},Dr.prototype.extractByEnvelope=function(t,e,n){for(var i=new Nt,r=0;r<e.getNumGeometries();r++){var o=e.getGeometryN(r);o.getEnvelopeInternal().intersects(t)?i.add(o):n.add(o)}return this._geomFactory.buildGeometry(i)},Dr.prototype.unionOptimized=function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){return Pr.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var r=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,r)},Dr.prototype.union=function(){if(null===this._inputPolys)throw new Error("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();for(var t=new sn(Dr.STRTREE_NODE_CAPACITY),e=this._inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;var i=t.itemsTree();return this.unionTree(i)},Dr.prototype.binaryUnion=function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(i-n<=1){var r=Dr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n==2)return this.unionSafe(Dr.getGeometry(e,n),Dr.getGeometry(e,n+1));var o=Math.trunc((i+n)/2),s=this.binaryUnion(e,n,o),a=this.binaryUnion(e,o,i);return this.unionSafe(s,a)}},Dr.prototype.repeatedUnion=function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},Dr.prototype.unionSafe=function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},Dr.prototype.unionActual=function(t,e){return Dr.restrictToPolygons(t.union(e))},Dr.prototype.unionTree=function(t){var e=this.reduceToGeometries(t);return this.binaryUnion(e)},Dr.prototype.unionUsingEnvelopeIntersection=function(t,e,n){var i=new Nt,r=this.extractByEnvelope(n,t,i),o=this.extractByEnvelope(n,e,i),s=this.unionActual(r,o);i.add(s);return Pr.combine(i)},Dr.prototype.bufferUnion=function(){if(1===arguments.length){var t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().createGeometryCollection([e,n]).buffer(0)}},Dr.prototype.interfaces_=function(){return[]},Dr.prototype.getClass=function(){return Dr},Dr.restrictToPolygons=function(t){if(T(t,Zt))return t;var e=Ni.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(_e.toPolygonArray(e))},Dr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Dr.union=function(t){return new Dr(t).union()},Mr.STRTREE_NODE_CAPACITY.get=function(){return 4},Object.defineProperties(Dr,Mr);var Ar=function(){};Ar.prototype.interfaces_=function(){return[]},Ar.prototype.getClass=function(){return Ar},Ar.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Lr.createEmptyResult(Lr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.UNION)},t.GeoJSONReader=Ne,t.GeoJSONWriter=Ce,t.OverlayOp=Lr,t.UnionOp=Ar,t.BufferOp=di,Object.defineProperty(t,"__esModule",{value:!0})});


/***/ }),

/***/ 41:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasPropertyDescriptors = __webpack_require__(592)();

var GetIntrinsic = __webpack_require__(453);

var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

var gopd = __webpack_require__(5795);

/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ 76:
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 301:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var spline_1 = __importDefault(__webpack_require__(9164));
/**
 * Takes a {@link LineString|line} and returns a curved version
 * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
 * algorithm.
 *
 * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
 *
 * @name bezierSpline
 * @param {Feature<LineString>} line input LineString
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] Translate properties to output
 * @param {number} [options.resolution=10000] time in milliseconds between points
 * @param {number} [options.sharpness=0.85] a measure of how curvy the path should be between splines
 * @returns {Feature<LineString>} curved line
 * @example
 * var line = turf.lineString([
 *   [-76.091308, 18.427501],
 *   [-76.695556, 18.729501],
 *   [-76.552734, 19.40443],
 *   [-74.61914, 19.134789],
 *   [-73.652343, 20.07657],
 *   [-73.157958, 20.210656]
 * ]);
 *
 * var curved = turf.bezierSpline(line);
 *
 * //addToMap
 * var addToMap = [line, curved]
 * curved.properties = { stroke: '#0F0' };
 */
function bezier(line, options) {
    if (options === void 0) { options = {}; }
    // Optional params
    var resolution = options.resolution || 10000;
    var sharpness = options.sharpness || 0.85;
    var coords = [];
    var points = invariant_1.getGeom(line).coordinates.map(function (pt) {
        return { x: pt[0], y: pt[1] };
    });
    var spline = new spline_1.default({
        duration: resolution,
        points: points,
        sharpness: sharpness,
    });
    var pushCoord = function (time) {
        var pos = spline.pos(time);
        if (Math.floor(time / 100) % 2 === 0) {
            coords.push([pos.x, pos.y]);
        }
    };
    for (var i = 0; i < spline.duration; i += 10) {
        pushCoord(i);
    }
    pushCoord(spline.duration);
    return helpers_1.lineString(coords, options.properties);
}
exports["default"] = bezier;


/***/ }),

/***/ 347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var distance_1 = __importDefault(__webpack_require__(9391));
var helpers_1 = __webpack_require__(8967);
var meta_1 = __webpack_require__(8421);
var tin_1 = __importDefault(__webpack_require__(2141));
var turf_dissolve_1 = __importDefault(__webpack_require__(8118));
/**
 * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.
 * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
 *
 * @name concave
 * @param {FeatureCollection<Point>} points input points
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the
 * hull to become concave.
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)
 * @example
 * var points = turf.featureCollection([
 *   turf.point([-63.601226, 44.642643]),
 *   turf.point([-63.591442, 44.651436]),
 *   turf.point([-63.580799, 44.648749]),
 *   turf.point([-63.573589, 44.641788]),
 *   turf.point([-63.587665, 44.64533]),
 *   turf.point([-63.595218, 44.64765])
 * ]);
 * var options = {units: 'miles', maxEdge: 1};
 *
 * var hull = turf.concave(points, options);
 *
 * //addToMap
 * var addToMap = [points, hull]
 */
function concave(points, options) {
    if (options === void 0) { options = {}; }
    var maxEdge = options.maxEdge || Infinity;
    var cleaned = removeDuplicates(points);
    var tinPolys = tin_1.default(cleaned);
    // calculate length of all edges and area of all triangles
    // and remove triangles that fail the max length test
    tinPolys.features = tinPolys.features.filter(function (triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance_1.default(pt1, pt2, options);
        var dist2 = distance_1.default(pt2, pt3, options);
        var dist3 = distance_1.default(pt1, pt3, options);
        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
    });
    if (tinPolys.features.length < 1) {
        return null;
    }
    // merge the adjacent triangles
    var dissolved = turf_dissolve_1.default(tinPolys);
    // geojson-dissolve always returns a MultiPolygon
    if (dissolved.coordinates.length === 1) {
        dissolved.coordinates = dissolved.coordinates[0];
        dissolved.type = "Polygon";
    }
    return helpers_1.feature(dissolved);
}
/**
 * Removes duplicated points in a collection returning a new collection
 *
 * @private
 * @param {FeatureCollection<Point>} points to be cleaned
 * @returns {FeatureCollection<Point>} cleaned set of points
 */
function removeDuplicates(points) {
    var cleaned = [];
    var existing = {};
    meta_1.featureEach(points, function (pt) {
        if (!pt.geometry) {
            return;
        }
        var key = pt.geometry.coordinates.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
            cleaned.push(pt);
            existing[key] = true;
        }
    });
    return helpers_1.featureCollection(cleaned);
}
exports["default"] = concave;


/***/ }),

/***/ 375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var circle_1 = __importDefault(__webpack_require__(5764));
var destination_1 = __importDefault(__webpack_require__(4202));
var helpers_1 = __webpack_require__(8967);
/**
 * Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2;
 * 0 bearing is North of center point, positive clockwise.
 *
 * @name lineArc
 * @param {Coord} center center point
 * @param {number} radius radius of the circle
 * @param {number} bearing1 angle, in decimal degrees, of the first radius of the arc
 * @param {number} bearing2 angle, in decimal degrees, of the second radius of the arc
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @returns {Feature<LineString>} line arc
 * @example
 * var center = turf.point([-75, 40]);
 * var radius = 5;
 * var bearing1 = 25;
 * var bearing2 = 47;
 *
 * var arc = turf.lineArc(center, radius, bearing1, bearing2);
 *
 * //addToMap
 * var addToMap = [center, arc]
 */
function lineArc(center, radius, bearing1, bearing2, options) {
    if (options === void 0) { options = {}; }
    // default params
    var steps = options.steps || 64;
    var angle1 = convertAngleTo360(bearing1);
    var angle2 = convertAngleTo360(bearing2);
    var properties = !Array.isArray(center) && center.type === "Feature"
        ? center.properties
        : {};
    // handle angle parameters
    if (angle1 === angle2) {
        return helpers_1.lineString(circle_1.default(center, radius, options).geometry.coordinates[0], properties);
    }
    var arcStartDegree = angle1;
    var arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
    var alfa = arcStartDegree;
    var coordinates = [];
    var i = 0;
    while (alfa < arcEndDegree) {
        coordinates.push(destination_1.default(center, radius, alfa, options).geometry.coordinates);
        i++;
        alfa = arcStartDegree + (i * 360) / steps;
    }
    if (alfa > arcEndDegree) {
        coordinates.push(destination_1.default(center, radius, arcEndDegree, options).geometry.coordinates);
    }
    return helpers_1.lineString(coordinates, properties);
}
exports["default"] = lineArc;
/**
 * Takes any angle in  degrees
 * and returns a valid angle between 0-360 degrees
 *
 * @private
 * @param {number} alfa angle between -180-180 degrees
 * @returns {number} angle between 0-360 degrees
 */
function convertAngleTo360(alfa) {
    var beta = alfa % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}


/***/ }),

/***/ 414:
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 453:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(9612);

var $Error = __webpack_require__(9383);
var $EvalError = __webpack_require__(1237);
var $RangeError = __webpack_require__(9290);
var $ReferenceError = __webpack_require__(9538);
var $SyntaxError = __webpack_require__(8068);
var $TypeError = __webpack_require__(9675);
var $URIError = __webpack_require__(5345);

var abs = __webpack_require__(1514);
var floor = __webpack_require__(8968);
var max = __webpack_require__(6188);
var min = __webpack_require__(8002);
var pow = __webpack_require__(5880);
var round = __webpack_require__(414);
var sign = __webpack_require__(3093);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(5795);
var $defineProperty = __webpack_require__(655);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(4039)();

var getProto = __webpack_require__(3628);
var $ObjectGPO = __webpack_require__(1064);
var $ReflectGPO = __webpack_require__(8648);

var $apply = __webpack_require__(1002);
var $call = __webpack_require__(76);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(6743);
var hasOwn = __webpack_require__(9957);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6743);
var GetIntrinsic = __webpack_require__(453);
var setFunctionLength = __webpack_require__(6897);

var $TypeError = GetIntrinsic('%TypeError%');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Configuration = exports.DEFAULT_IMAGE_FILTERS_CONFIG = exports.DEFAULT_FILTER_DISTANCE_CONFIG = exports.TARGET_MAX_N_CANVASES_PER_SUBTASK = exports.DEFAULT_N_ANNOS_PER_CANVAS = exports.AllowedToolboxItem = void 0;
var toolbox_1 = __webpack_require__(3045);
var submit_buttons_1 = __webpack_require__(8035);
var image_filters_1 = __webpack_require__(6840);
var annotation_list_1 = __webpack_require__(931);
var utilities_1 = __webpack_require__(8286);
/* eslint-disable @stylistic/no-multi-spaces */
var AllowedToolboxItem;
(function (AllowedToolboxItem) {
    AllowedToolboxItem[AllowedToolboxItem["ModeSelect"] = 0] = "ModeSelect";
    AllowedToolboxItem[AllowedToolboxItem["ZoomPan"] = 1] = "ZoomPan";
    AllowedToolboxItem[AllowedToolboxItem["AnnotationResize"] = 2] = "AnnotationResize";
    AllowedToolboxItem[AllowedToolboxItem["AnnotationID"] = 3] = "AnnotationID";
    AllowedToolboxItem[AllowedToolboxItem["RecolorActive"] = 4] = "RecolorActive";
    AllowedToolboxItem[AllowedToolboxItem["ClassCounter"] = 5] = "ClassCounter";
    AllowedToolboxItem[AllowedToolboxItem["KeypointSlider"] = 6] = "KeypointSlider";
    AllowedToolboxItem[AllowedToolboxItem["SubmitButtons"] = 7] = "SubmitButtons";
    AllowedToolboxItem[AllowedToolboxItem["FilterDistance"] = 8] = "FilterDistance";
    AllowedToolboxItem[AllowedToolboxItem["Brush"] = 9] = "Brush";
    AllowedToolboxItem[AllowedToolboxItem["ImageFilters"] = 10] = "ImageFilters";
    AllowedToolboxItem[AllowedToolboxItem["AnnotationList"] = 11] = "AnnotationList";
})(AllowedToolboxItem || (exports.AllowedToolboxItem = AllowedToolboxItem = {}));
/* eslint-enable @stylistic/no-multi-spaces */
exports.DEFAULT_N_ANNOS_PER_CANVAS = 100;
exports.TARGET_MAX_N_CANVASES_PER_SUBTASK = 8;
exports.DEFAULT_FILTER_DISTANCE_CONFIG = {
    name: "Filter Distance From Row",
    component_name: "filter-distance-from-row",
    filter_min: 0,
    filter_max: 400,
    default_values: { closest_row: { distance: 40 } },
    step_value: 2,
    multi_class_mode: false,
    disable_multi_class_mode: false,
    filter_on_load: true,
    show_options: true,
    show_overlay: false,
    toggle_overlay_keybind: "p",
    filter_during_polyline_move: true,
};
exports.DEFAULT_IMAGE_FILTERS_CONFIG = {
    default_values: {
        brightness: 100,
        contrast: 100,
        hueRotate: 0,
        invert: 0,
        saturate: 100,
    },
};
var Configuration = /** @class */ (function () {
    function Configuration() {
        var kwargs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            kwargs[_i] = arguments[_i];
        }
        // Values useful for generating HTML for tool
        this.container_id = "container";
        this.px_per_px = 1;
        this.anno_scaling_mode = "fixed";
        this.initial_crop = null;
        this.annbox_id = "annbox";
        this.imwrap_id = "imwrap";
        this.canvas_fid_pfx = "front-canvas";
        this.canvas_bid_pfx = "back-canvas";
        this.canvas_did = "demo-canvas";
        this.canvas_class = "easel";
        this.image_id_pfx = "ann_image";
        this.imgsz_class = "imgsz";
        this.toolbox_id = "toolbox";
        // Dimensions of various components of the tool
        this.image_width = null;
        this.image_height = null;
        this.demo_width = 120;
        this.demo_height = 40;
        this.polygon_ender_size = 15;
        this.edit_handle_size = 30;
        this.brush_size = 60;
        // Configuration for the annotation task itself
        this.image_data = null;
        this.allow_soft_id = false;
        this.default_annotation_color = "#fa9d2a";
        this.username = "ULabelUser";
        this.initial_line_size = 4;
        // ID Dialog config
        this.cl_opacity = 0.4;
        this.outer_diameter = 200;
        this.inner_prop = 0.3;
        // Behavior on special interactions
        this.instructions_url = null;
        this.submit_buttons = [];
        // Passthrough
        this.task_meta = {};
        this.annotation_meta = {};
        this.subtasks = null;
        /**
         * Map from AllowedToolboxItem enum to the class that implements it.
         * The typing here uses a
         * [abstract construct signature](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-construct-signatures)
         * to handle the different constructors for each toolbox item.
         */
        this.toolbox_map = new Map([
            [AllowedToolboxItem.ModeSelect, toolbox_1.ModeSelectionToolboxItem],
            [AllowedToolboxItem.ZoomPan, toolbox_1.ZoomPanToolboxItem],
            [AllowedToolboxItem.AnnotationResize, toolbox_1.AnnotationResizeItem],
            [AllowedToolboxItem.AnnotationID, toolbox_1.AnnotationIDToolboxItem],
            [AllowedToolboxItem.RecolorActive, toolbox_1.RecolorActiveItem],
            [AllowedToolboxItem.ClassCounter, toolbox_1.ClassCounterToolboxItem],
            [AllowedToolboxItem.KeypointSlider, toolbox_1.KeypointSliderItem],
            [AllowedToolboxItem.SubmitButtons, submit_buttons_1.SubmitButtons],
            [AllowedToolboxItem.FilterDistance, toolbox_1.FilterPointDistanceFromRow],
            [AllowedToolboxItem.Brush, toolbox_1.BrushToolboxItem],
            [AllowedToolboxItem.ImageFilters, image_filters_1.ImageFiltersToolboxItem],
            [AllowedToolboxItem.AnnotationList, annotation_list_1.AnnotationListToolboxItem],
        ]);
        // Default toolbox order used when the user doesn't specify one
        this.toolbox_order = [
            AllowedToolboxItem.ModeSelect,
            AllowedToolboxItem.AnnotationList,
            AllowedToolboxItem.Brush,
            AllowedToolboxItem.ImageFilters,
            AllowedToolboxItem.ZoomPan,
            AllowedToolboxItem.AnnotationResize,
            AllowedToolboxItem.AnnotationID,
            AllowedToolboxItem.RecolorActive,
            AllowedToolboxItem.ClassCounter,
            AllowedToolboxItem.KeypointSlider,
            AllowedToolboxItem.SubmitButtons,
        ];
        this.default_keybinds = {
            annotation_size_small: "s",
            annotation_size_large: "l",
            annotation_size_plus: "=",
            annotation_size_minus: "-",
            annotation_vanish: "v",
        };
        // Config for RecolorActiveItem
        this.recolor_active_toolbox_item = {
            gradient_turned_on: false,
        };
        // Config for FilterDistanceToolboxItem
        this.distance_filter_toolbox_item = exports.DEFAULT_FILTER_DISTANCE_CONFIG;
        // Config for ImageFiltersToolboxItem
        this.image_filters_toolbox_item = exports.DEFAULT_IMAGE_FILTERS_CONFIG;
        this.change_zoom_keybind = "r";
        this.create_point_annotation_keybind = "c";
        this.default_annotation_size = 6;
        this.delete_annotation_keybind = "d";
        this.filter_annotations_on_load = true;
        this.switch_subtask_keybind = "z";
        this.toggle_annotation_mode_keybind = "u";
        this.create_bbox_on_initial_crop = "f";
        this.toggle_brush_mode_keybind = "g";
        this.toggle_erase_mode_keybind = "e";
        this.increase_brush_size_keybind = "]";
        this.decrease_brush_size_keybind = "[";
        this.fly_to_next_annotation_keybind = "Tab";
        // null -> Shift+fly_to_next_annotation_keybind
        this.fly_to_previous_annotation_keybind = null;
        this.fly_to_max_zoom = 10;
        this.n_annos_per_canvas = exports.DEFAULT_N_ANNOS_PER_CANVAS;
        this.click_and_drag_poly_annotations = true;
        this.allow_annotations_outside_image = true;
        this.modify_config.apply(this, kwargs);
    }
    // TODO (joshua-dean): Can this any be narrowed?
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Configuration.prototype.modify_config = function () {
        var kwargs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            kwargs[_i] = arguments[_i];
        }
        // Loop through every elements in kwargs
        for (var idx = 0; idx < kwargs.length; idx++) {
            // For every key: value pair, overwrite them/add them to the config
            for (var key in kwargs[idx]) {
                // If the value itself is an object, then loop through it and modify only the defined values
                if ((0, utilities_1.is_object_and_not_array)(kwargs[idx][key]) &&
                    (0, utilities_1.is_object_and_not_array)(this[key])) {
                    var inner_object = kwargs[idx][key];
                    for (var inner_key in inner_object) {
                        this[key][inner_key] = inner_object[inner_key];
                    }
                }
                else {
                    this[key] = kwargs[idx][key];
                }
            }
        }
    };
    return Configuration;
}());
exports.Configuration = Configuration;


/***/ }),

/***/ 592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(453);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ 655:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 931:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnnotationListToolboxItem = void 0;
var toolbox_1 = __webpack_require__(3045);
var blobs_1 = __webpack_require__(2748);
/**
 * Toolbox item for displaying and navigating annotations in a list
 */
var AnnotationListToolboxItem = /** @class */ (function (_super) {
    __extends(AnnotationListToolboxItem, _super);
    function AnnotationListToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.show_deprecated = false;
        _this.group_by_class = false;
        _this.is_collapsed = false;
        _this.sync_scheduled = false;
        _this.ulabel = ulabel;
        _this.add_styles();
        _this.add_event_listeners();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    AnnotationListToolboxItem.prototype.add_styles = function () {
        var css = "\n        #toolbox .annotation-list-toolbox-item {\n            padding: 0.5rem 0;\n        }\n\n        #toolbox .annotation-list-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 0 1.5rem;\n            cursor: pointer;\n        }\n\n        #toolbox .annotation-list-title {\n            margin: 0.5rem 0;\n            font-size: 1rem;\n            font-weight: 600;\n        }\n\n        #toolbox .annotation-list-toggle-btn {\n            background: none;\n            border: none;\n            color: inherit;\n            font-size: 1rem;\n            cursor: pointer;\n            padding: 0.25rem;\n            width: 24px;\n            height: 24px;\n        }\n\n        #toolbox .annotation-list-toggle-btn:hover {\n            background-color: rgba(0, 128, 255, 0.1);\n        }\n\n        #toolbox .annotation-list-content {\n            display: block;\n            padding: 0 1rem;\n        }\n\n        #toolbox .annotation-list-options {\n            display: flex;\n            flex-direction: column;\n            gap: 0.5rem;\n            padding: 0.5rem;\n            font-size: 0.85rem;\n        }\n\n        #toolbox .annotation-list-option {\n            display: flex;\n            align-items: center;\n            gap: 0.5rem;\n        }\n\n        #toolbox .annotation-list-option input[type=\"checkbox\"] {\n            cursor: pointer;\n        }\n\n        #toolbox .annotation-list-option label {\n            cursor: pointer;\n            user-select: none;\n        }\n\n        #toolbox .annotation-list-container {\n            max-height: 300px;\n            overflow-y: auto;\n            border: 1px solid rgba(128, 128, 128, 0.3);\n            border-radius: 4px;\n            margin: 0.5rem 0;\n        }\n\n        #toolbox .annotation-list-empty {\n            padding: 1rem;\n            text-align: center;\n            color: gray;\n            font-style: italic;\n        }\n\n        #toolbox .annotation-list-item {\n            padding: 0.5rem;\n            border-bottom: 1px solid rgba(128, 128, 128, 0.2);\n            cursor: pointer;\n            transition: background-color 150ms;\n        }\n\n        #toolbox .annotation-list-item:last-child {\n            border-bottom: none;\n        }\n\n        #toolbox .annotation-list-item:hover {\n            background-color: rgba(0, 128, 255, 0.1);\n        }\n\n        #toolbox .annotation-list-item.highlighted {\n            background-color: rgba(0, 128, 255, 0.2);\n        }\n\n        #toolbox .annotation-list-item-header {\n            display: flex;\n            align-items: center;\n            gap: 0.5rem;\n        }\n\n        #toolbox .annotation-list-item-icon {\n            width: 20px;\n            height: 20px;\n            flex-shrink: 0;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n\n        #toolbox .annotation-list-item-icon svg {\n            width: 100%;\n            height: 100%;\n        }\n\n        #toolbox .annotation-list-item-text {\n            flex: 1;\n            font-size: 0.85rem;\n        }\n\n        #toolbox .annotation-list-item-class {\n            font-weight: 600;\n        }\n\n        #toolbox .annotation-list-item-id {\n            color: gray;\n            font-size: 0.75rem;\n        }\n\n        #toolbox .annotation-list-class-group {\n            margin-bottom: 0.5rem;\n        }\n\n        #toolbox .annotation-list-class-group-header {\n            display: flex;\n            align-items: center;\n            gap: 0.5rem;\n            padding: 0.5rem;\n            background-color: rgba(128, 128, 128, 0.1);\n            font-weight: 600;\n            font-size: 0.9rem;\n        }\n\n        #toolbox .annotation-list-class-group-color {\n            width: 14px;\n            height: 14px;\n            border-radius: 2px;\n            flex-shrink: 0;\n        }\n\n        #toolbox .annotation-list-class-group-count {\n            margin-left: auto;\n            color: gray;\n            font-size: 0.8rem;\n            font-weight: normal;\n        }\n\n        .ulabel-night #toolbox .annotation-list-container {\n            border-color: rgba(255, 255, 255, 0.3);\n        }\n\n        .ulabel-night #toolbox .annotation-list-item {\n            border-bottom-color: rgba(255, 255, 255, 0.2);\n        }\n\n        .ulabel-night #toolbox .annotation-list-item:hover {\n            background-color: rgba(100, 149, 237, 0.2);\n        }\n\n        .ulabel-night #toolbox .annotation-list-item.highlighted {\n            background-color: rgba(100, 149, 237, 0.3);\n        }\n\n        .ulabel-night #toolbox .annotation-list-class-group-header {\n            background-color: rgba(255, 255, 255, 0.1);\n        }\n\n        .annotation-navigation-toast {\n            position: fixed;\n            top: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            background-color: rgba(0, 0, 0, 0.85);\n            color: white;\n            padding: 12px 24px;\n            border-radius: 8px;\n            font-size: 16px;\n            font-weight: 600;\n            pointer-events: none;\n            z-index: 10000;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n            opacity: 0;\n            transition: opacity 0.3s ease-in-out;\n        }\n\n        .annotation-navigation-toast.show {\n            opacity: 1;\n        }\n\n        .ulabel-night .annotation-navigation-toast {\n            background-color: rgba(255, 255, 255, 0.9);\n            color: black;\n            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);\n        }\n        ";
        var style_id = "annotation-list-toolbox-styles";
        if (document.getElementById(style_id))
            return;
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        head.appendChild(style);
    };
    /**
     * Initialize event listeners for this toolbox item
     */
    AnnotationListToolboxItem.prototype.add_event_listeners = function () {
        var _this = this;
        // Toggle button to show/hide annotation list
        $(document).on("click.ulabel", "#annotation-list-toggle", function () {
            _this.is_collapsed = !_this.is_collapsed;
            _this.update_list();
        });
        // Show/hide deprecated annotations checkbox
        $(document).on("change.ulabel", "#annotation-list-show-deprecated", function (e) {
            _this.show_deprecated = e.target.checked;
            _this.update_list();
        });
        // Group by class checkbox
        $(document).on("change.ulabel", "#annotation-list-group-by-class", function (e) {
            _this.group_by_class = e.target.checked;
            _this.update_list();
        });
        // Click on annotation list item to fly to it
        $(document).on("click.ulabel", ".annotation-list-item", function (e) {
            var annotation_id = $(e.currentTarget).data("annotation-id");
            if (annotation_id) {
                _this.ulabel.fly_to_annotation_id(annotation_id, null, _this.ulabel.config.fly_to_max_zoom);
            }
        });
        // Hover on annotation list item to highlight annotation on canvas
        $(document).on("mouseenter.ulabel", ".annotation-list-item", function (e) {
            var annotation_id = $(e.currentTarget).data("annotation-id");
            if (annotation_id) {
                // Highlight this list item
                $(".annotation-list-item").removeClass("highlighted");
                $(e.currentTarget).addClass("highlighted");
                // Show the global edit suggestion (ID dialog)
                _this.ulabel.show_global_edit_suggestion(annotation_id, null, null);
            }
        });
        // Remove highlight when mouse leaves the list item
        $(document).on("mouseleave.ulabel", ".annotation-list-item", function () {
            $(".annotation-list-item").removeClass("highlighted");
            // Clear the edit suggestion
            _this.ulabel.hide_global_edit_suggestion();
            _this.ulabel.hide_edit_suggestion();
        });
        // Listen for mousemove on the annbox to sync list highlighting from canvas
        $(document).on("mousemove.ulabel", "#".concat(this.ulabel.config.annbox_id), function () {
            // Use requestAnimationFrame to avoid excessive calls
            if (!_this.sync_scheduled) {
                _this.sync_scheduled = true;
                requestAnimationFrame(function () {
                    _this.sync_highlight_from_canvas();
                    _this.sync_scheduled = false;
                });
            }
        });
        // Also listen for mouseleave on annbox to clear highlights when leaving the canvas area
        $(document).on("mouseleave.ulabel", "#".concat(this.ulabel.config.annbox_id), function () {
            // Don't clear if we're hovering over a list item
            if (!$(".annotation-list-item:hover").length) {
                $(".annotation-list-item").removeClass("highlighted");
            }
        });
    };
    /**
     * Build and update the annotation list display
     */
    AnnotationListToolboxItem.prototype.update_list = function () {
        var content = document.querySelector("#annotation-list-content");
        var toggle_btn = document.querySelector("#annotation-list-toggle");
        if (!content || !toggle_btn)
            return;
        // Update toggle button
        toggle_btn.innerText = this.is_collapsed ? "" : "";
        content.style.display = this.is_collapsed ? "none" : "block";
        if (this.is_collapsed)
            return;
        // Get current subtask
        var current_subtask = this.ulabel.get_current_subtask();
        if (!current_subtask)
            return;
        // Build the list HTML
        var list_container = document.querySelector("#annotation-list-container");
        if (!list_container)
            return;
        var annotations = this.get_filtered_annotations(current_subtask);
        if (annotations.length === 0) {
            list_container.innerHTML = "<div class=\"annotation-list-empty\">No annotations</div>";
            return;
        }
        if (this.group_by_class) {
            list_container.innerHTML = this.build_grouped_list_html(annotations, current_subtask);
        }
        else {
            list_container.innerHTML = this.build_flat_list_html(annotations, current_subtask);
        }
    };
    /**
     * Get filtered annotations based on current options
     */
    AnnotationListToolboxItem.prototype.get_filtered_annotations = function (subtask) {
        var annotations = [];
        for (var _i = 0, _a = subtask.annotations.ordering; _i < _a.length; _i++) {
            var annotation_id = _a[_i];
            var annotation = subtask.annotations.access[annotation_id];
            // Skip deprecated if option is disabled
            if (!this.show_deprecated && annotation.deprecated) {
                continue;
            }
            annotations.push(annotation);
        }
        return annotations;
    };
    /**
     * Build HTML for flat (non-grouped) list
     */
    AnnotationListToolboxItem.prototype.build_flat_list_html = function (annotations, subtask) {
        var html = "";
        var _loop_1 = function (i) {
            var annotation = annotations[i];
            var class_id = this_1.get_annotation_class_id(annotation);
            var class_def = subtask.class_defs.find(function (def) { return def.id === class_id; });
            var class_name = class_def ? class_def.name : "Unknown";
            var color = this_1.ulabel.color_info[class_id] || "#cccccc";
            var svg = this_1.get_spatial_type_svg(annotation.spatial_type, color);
            html += "\n                <div class=\"annotation-list-item\" data-annotation-id=\"".concat(annotation.id, "\" data-annotation-idx=\"").concat(i, "\">\n                    <div class=\"annotation-list-item-header\">\n                        <div class=\"annotation-list-item-icon\">").concat(svg, "</div>\n                        <div class=\"annotation-list-item-text\">\n                            <span class=\"annotation-list-item-class\">").concat(class_name, "</span>\n                            <span class=\"annotation-list-item-id\">#").concat(i, "</span>\n                        </div>\n                    </div>\n                </div>\n            ");
        };
        var this_1 = this;
        for (var i = 0; i < annotations.length; i++) {
            _loop_1(i);
        }
        return html;
    };
    /**
     * Build HTML for grouped (by class) list
     */
    AnnotationListToolboxItem.prototype.build_grouped_list_html = function (annotations, subtask) {
        // Group annotations by class
        var groups = {};
        for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {
            var annotation = annotations_1[_i];
            var class_id = this.get_annotation_class_id(annotation);
            if (!groups[class_id]) {
                groups[class_id] = [];
            }
            groups[class_id].push(annotation);
        }
        // Build HTML for each group
        var html = "";
        var _loop_2 = function (class_id_str) {
            var class_id = parseInt(class_id_str);
            var group_annotations = groups[class_id];
            var class_def = subtask.class_defs.find(function (def) { return def.id === class_id; });
            var class_name = class_def ? class_def.name : "Unknown";
            var color = this_2.ulabel.color_info[class_id] || "#cccccc";
            html += "\n                <div class=\"annotation-list-class-group\">\n                    <div class=\"annotation-list-class-group-header\">\n                        <div class=\"annotation-list-class-group-color\" style=\"background-color: ".concat(color, ";\"></div>\n                        <span>").concat(class_name, "</span>\n                        <span class=\"annotation-list-class-group-count\">(").concat(group_annotations.length, ")</span>\n                    </div>\n            ");
            for (var i = 0; i < group_annotations.length; i++) {
                var annotation = group_annotations[i];
                var overall_idx = annotations.indexOf(annotation);
                var svg = this_2.get_spatial_type_svg(annotation.spatial_type, color);
                html += "\n                    <div class=\"annotation-list-item\" data-annotation-id=\"".concat(annotation.id, "\" data-annotation-idx=\"").concat(overall_idx, "\">\n                        <div class=\"annotation-list-item-header\">\n                            <div class=\"annotation-list-item-icon\" style=\"margin-left: 0.5rem;\">").concat(svg, "</div>\n                            <div class=\"annotation-list-item-text\">\n                                <span class=\"annotation-list-item-id\">#").concat(i, "</span>\n                            </div>\n                        </div>\n                    </div>\n                ");
            }
            html += "</div>";
        };
        var this_2 = this;
        for (var class_id_str in groups) {
            _loop_2(class_id_str);
        }
        return html;
    };
    /**
     * Get the SVG icon for a given spatial type
     */
    AnnotationListToolboxItem.prototype.get_spatial_type_svg = function (spatial_type, color) {
        var svg = "";
        switch (spatial_type) {
            case "bbox":
                svg = blobs_1.BBOX_SVG;
                break;
            case "delete_bbox":
                svg = blobs_1.DELETE_BBOX_SVG;
                break;
            case "bbox3":
                svg = blobs_1.BBOX3_SVG;
                break;
            case "point":
                svg = blobs_1.POINT_SVG;
                break;
            case "polygon":
                svg = blobs_1.POLYGON_SVG;
                break;
            case "delete_polygon":
                svg = blobs_1.DELETE_POLYGON_SVG;
                break;
            case "contour":
                svg = blobs_1.CONTOUR_SVG;
                break;
            case "tbar":
                svg = blobs_1.TBAR_SVG;
                break;
            case "polyline":
                svg = blobs_1.POLYLINE_SVG;
                break;
            case "whole-image":
            case "global":
                svg = blobs_1.WHOLE_IMAGE_SVG;
                break;
            default:
                svg = blobs_1.BBOX_SVG; // fallback
                break;
        }
        // Color the SVG by replacing stroke/fill colors
        // The SVGs use various colors, so we'll replace common ones
        svg = svg.replace(/stroke:#[0-9a-fA-F]{6}/g, "stroke:".concat(color));
        svg = svg.replace(/fill:#[0-9a-fA-F]{6}/g, "fill:".concat(color));
        return svg;
    };
    /**
     * Get the primary class ID for an annotation
     */
    AnnotationListToolboxItem.prototype.get_annotation_class_id = function (annotation) {
        if (!annotation.classification_payloads || annotation.classification_payloads.length === 0) {
            return 0;
        }
        // Find the classification payload with the highest confidence
        var max_confidence = -1;
        var class_id = annotation.classification_payloads[0].class_id;
        for (var _i = 0, _a = annotation.classification_payloads; _i < _a.length; _i++) {
            var payload = _a[_i];
            if (payload.confidence > max_confidence) {
                max_confidence = payload.confidence;
                class_id = payload.class_id;
            }
        }
        return class_id;
    };
    /**
     * Get the HTML for this toolbox item
     */
    AnnotationListToolboxItem.prototype.get_html = function () {
        return "\n        <div id=\"annotation-list-container-outer\" class=\"annotation-list-toolbox-item\">\n            <div class=\"toolbox-divider\"></div>\n            <div class=\"annotation-list-header\">\n                <h3 class=\"annotation-list-title\">Annotation List</h3>\n                <button id=\"annotation-list-toggle\" class=\"annotation-list-toggle-btn\">\u25B2</button>\n            </div>\n            <div id=\"annotation-list-content\" class=\"annotation-list-content\">\n                <div class=\"annotation-list-options\">\n                    <div class=\"annotation-list-option\">\n                        <input type=\"checkbox\" id=\"annotation-list-show-deprecated\" />\n                        <label for=\"annotation-list-show-deprecated\">Show Deprecated</label>\n                    </div>\n                    <div class=\"annotation-list-option\">\n                        <input type=\"checkbox\" id=\"annotation-list-group-by-class\" />\n                        <label for=\"annotation-list-group-by-class\">Group by Class</label>\n                    </div>\n                </div>\n                <div id=\"annotation-list-container\" class=\"annotation-list-container\">\n                    <div class=\"annotation-list-empty\">No annotations</div>\n                </div>\n            </div>\n        </div>\n        ";
    };
    /**
     * Returns a unique string for this toolbox item
     */
    AnnotationListToolboxItem.prototype.get_toolbox_item_type = function () {
        return "AnnotationList";
    };
    /**
     * Code called after all of ULabel's constructor and initialization code is called
     */
    AnnotationListToolboxItem.prototype.after_init = function () {
        // Initial list update
        this.update_list();
    };
    /**
     * Update the list when annotations change
     */
    AnnotationListToolboxItem.prototype.redraw_update = function () {
        this.update_list();
        this.sync_highlight_from_canvas();
    };
    /**
     * Update the list when frame changes
     */
    AnnotationListToolboxItem.prototype.frame_update = function () {
        this.update_list();
        this.sync_highlight_from_canvas();
    };
    /**
     * Sync highlighting from canvas hover to list
     * Called when the edit_candidate changes on the canvas
     */
    AnnotationListToolboxItem.prototype.sync_highlight_from_canvas = function () {
        var current_subtask = this.ulabel.get_current_subtask();
        if (!current_subtask)
            return;
        var edit_candidate = current_subtask.state.edit_candidate;
        // Remove all highlights first
        $(".annotation-list-item").removeClass("highlighted");
        // If there's an edit candidate, highlight its list item
        if (edit_candidate && edit_candidate.annid) {
            var list_item = $(".annotation-list-item[data-annotation-id=\"".concat(edit_candidate.annid, "\"]"));
            if (list_item.length > 0) {
                list_item.addClass("highlighted");
                // Optionally scroll the item into view
                list_item[0].scrollIntoView({ block: "nearest", behavior: "smooth" });
            }
        }
    };
    /**
     * Highlight a specific annotation in the list
     * Public method that can be called when flying to an annotation
     */
    AnnotationListToolboxItem.prototype.highlight_annotation = function (annotation_id) {
        // Remove all highlights first
        $(".annotation-list-item").removeClass("highlighted");
        // Highlight the specified annotation
        var list_item = $(".annotation-list-item[data-annotation-id=\"".concat(annotation_id, "\"]"));
        if (list_item.length > 0) {
            list_item.addClass("highlighted");
            // Scroll the item into view
            list_item[0].scrollIntoView({ block: "nearest", behavior: "smooth" });
        }
    };
    return AnnotationListToolboxItem;
}(toolbox_1.ToolboxItem));
exports.AnnotationListToolboxItem = AnnotationListToolboxItem;


/***/ }),

/***/ 1002:
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 1064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(9612);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 1093:
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ 1101:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
var clone_1 = __importDefault(__webpack_require__(3711));
/**
 * Converts a WGS84 GeoJSON object into Mercator (EPSG:900913) projection
 *
 * @name toMercator
 * @param {GeoJSON|Position} geojson WGS84 GeoJSON object
 * @param {Object} [options] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} Projected GeoJSON
 * @example
 * var pt = turf.point([-71,41]);
 * var converted = turf.toMercator(pt);
 *
 * //addToMap
 * var addToMap = [pt, converted];
 */
function toMercator(geojson, options) {
    if (options === void 0) { options = {}; }
    return convert(geojson, "mercator", options);
}
exports.toMercator = toMercator;
/**
 * Converts a Mercator (EPSG:900913) GeoJSON object into WGS84 projection
 *
 * @name toWgs84
 * @param {GeoJSON|Position} geojson Mercator GeoJSON object
 * @param {Object} [options] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} Projected GeoJSON
 * @example
 * var pt = turf.point([-7903683.846322424, 5012341.663847514]);
 * var converted = turf.toWgs84(pt);
 *
 * //addToMap
 * var addToMap = [pt, converted];
 */
function toWgs84(geojson, options) {
    if (options === void 0) { options = {}; }
    return convert(geojson, "wgs84", options);
}
exports.toWgs84 = toWgs84;
/**
 * Converts a GeoJSON coordinates to the defined `projection`
 *
 * @private
 * @param {GeoJSON} geojson GeoJSON Feature or Geometry
 * @param {string} projection defines the projection system to convert the coordinates to
 * @param {Object} [options] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} Converted GeoJSON
 */
function convert(geojson, projection, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    var mutate = options.mutate;
    // Validation
    if (!geojson)
        throw new Error("geojson is required");
    // Handle Position
    if (Array.isArray(geojson) && helpers_1.isNumber(geojson[0]))
        geojson =
            projection === "mercator"
                ? convertToMercator(geojson)
                : convertToWgs84(geojson);
    // Handle GeoJSON
    else {
        // Handle possible data mutation
        if (mutate !== true)
            geojson = clone_1.default(geojson);
        meta_1.coordEach(geojson, function (coord) {
            var newCoord = projection === "mercator"
                ? convertToMercator(coord)
                : convertToWgs84(coord);
            coord[0] = newCoord[0];
            coord[1] = newCoord[1];
        });
    }
    return geojson;
}
/**
 * Convert lon/lat values to 900913 x/y.
 * (from https://github.com/mapbox/sphericalmercator)
 *
 * @private
 * @param {Array<number>} lonLat WGS84 point
 * @returns {Array<number>} Mercator [x, y] point
 */
function convertToMercator(lonLat) {
    var D2R = Math.PI / 180, 
    // 900913 properties
    A = 6378137.0, MAXEXTENT = 20037508.342789244;
    // compensate longitudes passing the 180th meridian
    // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js
    var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
    var xy = [
        A * adjusted * D2R,
        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R)),
    ];
    // if xy value is beyond maxextent (e.g. poles), return maxextent
    if (xy[0] > MAXEXTENT)
        xy[0] = MAXEXTENT;
    if (xy[0] < -MAXEXTENT)
        xy[0] = -MAXEXTENT;
    if (xy[1] > MAXEXTENT)
        xy[1] = MAXEXTENT;
    if (xy[1] < -MAXEXTENT)
        xy[1] = -MAXEXTENT;
    return xy;
}
/**
 * Convert 900913 x/y values to lon/lat.
 * (from https://github.com/mapbox/sphericalmercator)
 *
 * @private
 * @param {Array<number>} xy Mercator [x, y] point
 * @returns {Array<number>} WGS84 [lon, lat] point
 */
function convertToWgs84(xy) {
    // 900913 properties.
    var R2D = 180 / Math.PI;
    var A = 6378137.0;
    return [
        (xy[0] * R2D) / A,
        (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D,
    ];
}
/**
 * Returns the sign of the input, or zero
 *
 * @private
 * @param {number} x input
 * @returns {number} -1|0|1 output
 */
function sign(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
}


/***/ }),

/***/ 1111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var cleanCoords = __webpack_require__(2086);
var clone = __webpack_require__(3711);
var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var cleanCoords__default = /*#__PURE__*/_interopDefaultLegacy(cleanCoords);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);

/*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {
  var dx = p1.x - p2.x,
    dy = p1.y - p2.y;

  return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
  var x = p1.x,
    y = p1.y,
    dx = p2.x - x,
    dy = p2.y - y;

  if (dx !== 0 || dy !== 0) {
    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x = p2.x;
      y = p2.y;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }

  dx = p.x - x;
  dy = p.y - y;

  return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {
  var prevPoint = points[0],
    newPoints = [prevPoint],
    point;

  for (var i = 1, len = points.length; i < len; i++) {
    point = points[i];

    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  }

  if (prevPoint !== point) newPoints.push(point);

  return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance,
    index;

  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if (index - first > 1)
      simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1)
      simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
  var last = points.length - 1;

  var simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {
  if (points.length <= 2) return points;

  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  points = simplifyDouglasPeucker(points, sqTolerance);

  return points;
}

/**
 * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses
 * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.
 *
 * @name simplify
 * @param {GeoJSON} geojson object to be simplified
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.tolerance=1] simplification tolerance
 * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} a simplified GeoJSON
 * @example
 * var geojson = turf.polygon([[
 *   [-70.603637, -33.399918],
 *   [-70.614624, -33.395332],
 *   [-70.639343, -33.392466],
 *   [-70.659942, -33.394759],
 *   [-70.683975, -33.404504],
 *   [-70.697021, -33.419406],
 *   [-70.701141, -33.434306],
 *   [-70.700454, -33.446339],
 *   [-70.694274, -33.458369],
 *   [-70.682601, -33.465816],
 *   [-70.668869, -33.472117],
 *   [-70.646209, -33.473835],
 *   [-70.624923, -33.472117],
 *   [-70.609817, -33.468107],
 *   [-70.595397, -33.458369],
 *   [-70.587158, -33.442901],
 *   [-70.587158, -33.426283],
 *   [-70.590591, -33.414248],
 *   [-70.594711, -33.406224],
 *   [-70.603637, -33.399918]
 * ]]);
 * var options = {tolerance: 0.01, highQuality: false};
 * var simplified = turf.simplify(geojson, options);
 *
 * //addToMap
 * var addToMap = [geojson, simplified]
 */
function simplify$1(geojson, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;
  var highQuality = options.highQuality || false;
  var mutate = options.mutate || false;

  if (!geojson) throw new Error("geojson is required");
  if (tolerance && tolerance < 0) throw new Error("invalid tolerance");

  // Clone geojson to avoid side effects
  if (mutate !== true) geojson = clone__default['default'](geojson);

  meta.geomEach(geojson, function (geom) {
    simplifyGeom(geom, tolerance, highQuality);
  });
  return geojson;
}

/**
 * Simplifies a feature's coordinates
 *
 * @private
 * @param {Geometry} geometry to be simplified
 * @param {number} [tolerance=1] simplification tolerance
 * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
 * @returns {Geometry} output
 */
function simplifyGeom(geometry, tolerance, highQuality) {
  var type = geometry.type;

  // "unsimplyfiable" geometry types
  if (type === "Point" || type === "MultiPoint") return geometry;

  // Remove any extra coordinates
  cleanCoords__default['default'](geometry, true);

  var coordinates = geometry.coordinates;
  switch (type) {
    case "LineString":
      geometry["coordinates"] = simplifyLine(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiLineString":
      geometry["coordinates"] = coordinates.map(function (lines) {
        return simplifyLine(lines, tolerance, highQuality);
      });
      break;
    case "Polygon":
      geometry["coordinates"] = simplifyPolygon(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiPolygon":
      geometry["coordinates"] = coordinates.map(function (rings) {
        return simplifyPolygon(rings, tolerance, highQuality);
      });
  }
  return geometry;
}

/**
 * Simplifies the coordinates of a LineString with simplify-js
 *
 * @private
 * @param {Array<number>} coordinates to be processed
 * @param {number} tolerance simplification tolerance
 * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
 * @returns {Array<Array<number>>} simplified coords
 */
function simplifyLine(coordinates, tolerance, highQuality) {
  return simplify(
    coordinates.map(function (coord) {
      return { x: coord[0], y: coord[1], z: coord[2] };
    }),
    tolerance,
    highQuality
  ).map(function (coords) {
    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
  });
}

/**
 * Simplifies the coordinates of a Polygon with simplify-js
 *
 * @private
 * @param {Array<number>} coordinates to be processed
 * @param {number} tolerance simplification tolerance
 * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
 * @returns {Array<Array<Array<number>>>} simplified coords
 */
function simplifyPolygon(coordinates, tolerance, highQuality) {
  return coordinates.map(function (ring) {
    var pts = ring.map(function (coord) {
      return { x: coord[0], y: coord[1] };
    });
    if (pts.length < 4) {
      throw new Error("invalid polygon");
    }
    var simpleRing = simplify(pts, tolerance, highQuality).map(function (
      coords
    ) {
      return [coords.x, coords.y];
    });
    //remove 1 percent of tolerance until enough points to make a triangle
    while (!checkValidity(simpleRing)) {
      tolerance -= tolerance * 0.01;
      simpleRing = simplify(pts, tolerance, highQuality).map(function (
        coords
      ) {
        return [coords.x, coords.y];
      });
    }
    if (
      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||
      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]
    ) {
      simpleRing.push(simpleRing[0]);
    }
    return simpleRing;
  });
}

/**
 * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last
 *
 * @private
 * @param {Array<number>} ring coordinates to be checked
 * @returns {boolean} true if valid
 */
function checkValidity(ring) {
  if (ring.length < 3) return false;
  //if the last point is the same as the first, it's not a triangle
  return !(
    ring.length === 3 &&
    ring[2][0] === ring[0][0] &&
    ring[2][1] === ring[0][1]
  );
}

module.exports = simplify$1;
module.exports["default"] = simplify$1;


/***/ }),

/***/ 1137:
/***/ ((module) => {

// ray-casting algorithm based on
// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html

module.exports = function pointInPolygonNested (point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = end - start;
    for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i+start][0], yi = vs[i+start][1];
        var xj = vs[j+start][0], yj = vs[j+start][1];
        var intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
};


/***/ }),

/***/ 1189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(1093);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(8875);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ 1207:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var meta_1 = __webpack_require__(8421);
var concaveman_1 = __importDefault(__webpack_require__(1582));
/**
 * Takes a {@link Feature} or a {@link FeatureCollection} and returns a convex hull {@link Polygon}.
 *
 * Internally this uses
 * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that implements a
 * [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
 *
 * @name convex
 * @param {GeoJSON} geojson input Feature or FeatureCollection
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.concavity=Infinity] 1 - thin shape. Infinity - convex hull.
 * @param {Object} [options.properties={}] Translate Properties to Feature
 * @returns {Feature<Polygon>} a convex hull
 * @example
 * var points = turf.featureCollection([
 *   turf.point([10.195312, 43.755225]),
 *   turf.point([10.404052, 43.8424511]),
 *   turf.point([10.579833, 43.659924]),
 *   turf.point([10.360107, 43.516688]),
 *   turf.point([10.14038, 43.588348]),
 *   turf.point([10.195312, 43.755225])
 * ]);
 *
 * var hull = turf.convex(points);
 *
 * //addToMap
 * var addToMap = [points, hull]
 */
function convex(geojson, options) {
    if (options === void 0) { options = {}; }
    // Default parameters
    options.concavity = options.concavity || Infinity;
    // Container
    var points = [];
    // Convert all points to flat 2D coordinate Array
    meta_1.coordEach(geojson, function (coord) {
        points.push([coord[0], coord[1]]);
    });
    if (!points.length) {
        return null;
    }
    var convexHull = concaveman_1.default(points, options.concavity);
    // Convex hull should have at least 3 different vertices in order to create a valid polygon
    if (convexHull.length > 3) {
        return helpers_1.polygon([convexHull]);
    }
    return null;
}
exports["default"] = convex;


/***/ }),

/***/ 1237:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 1279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bbox = __webpack_require__(4383);
var area = __webpack_require__(7849);
var booleanPointInPolygon = __webpack_require__(2446);
var explode = __webpack_require__(3707);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);
var objectAssign = __webpack_require__(5228);
var meta = __webpack_require__(8421);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var area__default = /*#__PURE__*/_interopDefaultLegacy(area);
var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);
var explode__default = /*#__PURE__*/_interopDefaultLegacy(explode);
var objectAssign__default = /*#__PURE__*/_interopDefaultLegacy(objectAssign);

/**
 * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}
 * of the 'property' values
 *
 * @name gridToMatrix
 * @param {FeatureCollection<Point>} grid of points
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
 * @param {boolean} [options.flip=false] returns the matrix upside-down
 * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,
 * the grid points with coordinates on the matrix
 * @returns {Array<Array<number>>} matrix of property values
 * @example
 *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 *   var cellSize = 3;
 *   var grid = turf.pointGrid(extent, cellSize);
 *   // add a random property to each point between 0 and 60
 *   for (var i = 0; i < grid.features.length; i++) {
 *     grid.features[i].properties.elevation = (Math.random() * 60);
 *   }
 *   gridToMatrix(grid);
 *   //= [
 *     [ 1, 13, 10,  9, 10, 13, 18],
 *     [34,  8,  5,  4,  5,  8, 13],
 *     [10,  5,  2,  1,  2,  5,  4],
 *     [ 0,  4, 56, 19,  1,  4,  9],
 *     [10,  5,  2,  1,  2,  5, 10],
 *     [57,  8,  5,  4,  5,  0, 57],
 *     [ 3, 13, 10,  9,  5, 13, 18],
 *     [18, 13, 10,  9, 78, 13, 18]
 *   ]
 */
function gridToMatrix(grid, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip = options.flip;
  var flags = options.flags;

  // validation
  invariant.collectionOf(grid, "Point", "input must contain Points");

  var pointsMatrix = sortPointsByLatLng(grid, flip);

  var matrix = [];
  // create property matrix from sorted points
  // looping order matters here
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point = pointRow[c];
      // Check if zProperty exist
      if (point.properties[zProperty]) row.push(point.properties[zProperty]);
      else row.push(0);
      // add flags
      if (flags === true) point.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }

  return matrix;
}

/**
 * Sorts points by latitude and longitude, creating a 2-dimensional array of points
 *
 * @private
 * @param {FeatureCollection<Point>} points GeoJSON Point features
 * @param {boolean} [flip=false] returns the matrix upside-down
 * @returns {Array<Array<Point>>} points ordered by latitude and longitude
 */
function sortPointsByLatLng(points, flip) {
  var pointsByLatitude = {};

  // divide points by rows with the same latitude
  meta.featureEach(points, function (point) {
    var lat = invariant.getCoords(point)[1];
    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
    pointsByLatitude[lat].push(point);
  });

  // sort points (with the same latitude) by longitude
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {
    var row = pointsByLatitude[lat];
    var rowOrderedByLongitude = row.sort(function (a, b) {
      return invariant.getCoords(a)[0] - invariant.getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });

  // sort rows (of points with the same latitude) by latitude
  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {
    if (flip) return invariant.getCoords(a[0])[1] - invariant.getCoords(b[0])[1];
    else return invariant.getCoords(b[0])[1] - invariant.getCoords(a[0])[1];
  });

  return pointMatrix;
}

/*!
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
var defaultSettings = {
  successCallback: null,
  verbose: false,
  polygons: false,
};

var settings = {};

/*
  Compute isobands(s) of a scalar 2D field given a certain
  threshold and a bandwidth by applying the Marching Squares
  Algorithm. The function returns a list of path coordinates
  either for individual polygons within each grid cell, or the
  outline of connected polygons.
*/
function isoBands(data, minV, bandwidth, options) {
  /* process options */
  options = options ? options : {};

  var optionKeys = Object.keys(defaultSettings);

  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val =
      typeof val !== "undefined" && val !== null ? val : defaultSettings[key];

    settings[key] = val;
  }

  if (settings.verbose)
    console.log(
      "MarchingSquaresJS-isoBands: computing isobands for [" +
        minV +
        ":" +
        (minV + bandwidth) +
        "]"
    );

  var grid = computeBandGrid(data, minV, bandwidth);

  var ret;
  if (settings.polygons) {
    if (settings.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
      );
    ret = BandGrid2Areas(grid);
  } else {
    if (settings.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
      );
    ret = BandGrid2AreaPaths(grid);
  }

  if (typeof settings.successCallback === "function")
    settings.successCallback(ret);

  return ret;
}

/*
  Thats all for the public interface, below follows the actual
  implementation
*/

/* Some private variables */
var Node0 = 64,
  Node1 = 16,
  Node2 = 4,
  Node3 = 1;

/*
  The look-up tables for tracing back the contour path
  of isoBands
*/

var isoBandNextXTL = [];
var isoBandNextYTL = [];
var isoBandNextOTL = [];

var isoBandNextXTR = [];
var isoBandNextYTR = [];
var isoBandNextOTR = [];

var isoBandNextXRT = [];
var isoBandNextYRT = [];
var isoBandNextORT = [];

var isoBandNextXRB = [];
var isoBandNextYRB = [];
var isoBandNextORB = [];

var isoBandNextXBL = [];
var isoBandNextYBL = [];
var isoBandNextOBL = [];

var isoBandNextXBR = [];
var isoBandNextYBR = [];
var isoBandNextOBR = [];

var isoBandNextXLT = [];
var isoBandNextYLT = [];
var isoBandNextOLT = [];

var isoBandNextXLB = [];
var isoBandNextYLB = [];
var isoBandNextOLB = [];

isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
isoBandNextORT[85] = isoBandNextORB[85] = 1;
isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
isoBandNextOLT[85] = isoBandNextOLB[85] = 1;

isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
isoBandNextOTR[85] = isoBandNextOBR[85] = 1;

/* triangle cases */
isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
isoBandNextOBL[1] = isoBandNextOBL[169] = 0;

isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
isoBandNextORB[4] = isoBandNextORB[166] = 1;
isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
isoBandNextOBR[4] = isoBandNextOBR[166] = 0;

isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
isoBandNextORT[16] = isoBandNextORT[154] = 1;
isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
isoBandNextOTR[16] = isoBandNextOTR[154] = 1;

isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
isoBandNextOTL[64] = isoBandNextOTL[106] = 1;

/* single trapezoid cases */
isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
isoBandNextOBR[2] = isoBandNextOBR[168] = 1;

isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
isoBandNextORT[8] = isoBandNextORT[162] = 0;
isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
isoBandNextORB[8] = isoBandNextORB[162] = 1;
isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
isoBandNextOBR[8] = isoBandNextOBR[162] = 0;

isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
isoBandNextORT[32] = isoBandNextORT[138] = 1;
isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
isoBandNextORB[32] = isoBandNextORB[138] = 0;
isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
isoBandNextOTR[32] = isoBandNextOTR[138] = 1;

isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
isoBandNextOTR[128] = isoBandNextOTR[42] = 0;

/* single rectangle cases */
isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
isoBandNextORB[5] = isoBandNextORB[165] = 0;
isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
isoBandNextOLB[5] = isoBandNextOLB[165] = 0;

isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
isoBandNextOTR[20] = isoBandNextOTR[150] = 1;

isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
isoBandNextORT[80] = isoBandNextORT[90] = 1;
isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
isoBandNextOLT[80] = isoBandNextOLT[90] = 1;

isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
isoBandNextOTL[65] = isoBandNextOTL[105] = 0;

isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
isoBandNextORT[160] = isoBandNextORT[10] = 1;
isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
isoBandNextORB[160] = isoBandNextORB[10] = 0;
isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
isoBandNextOLT[160] = isoBandNextOLT[10] = 1;

isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
isoBandNextOTR[130] = isoBandNextOTR[40] = 1;

/* single hexagon cases */
isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
isoBandNextORB[37] = isoBandNextORB[133] = 1;
isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
isoBandNextOTR[37] = isoBandNextOTR[133] = 0;

isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
isoBandNextOTR[148] = isoBandNextOTR[22] = 1;

isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
isoBandNextORT[82] = isoBandNextORT[88] = 1;
isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
isoBandNextOLT[82] = isoBandNextOLT[88] = 0;

isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
isoBandNextORT[73] = isoBandNextORT[97] = 0;
isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
isoBandNextORB[73] = isoBandNextORB[97] = 0;
isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
isoBandNextOTL[73] = isoBandNextOTL[97] = 1;

isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
isoBandNextORT[145] = isoBandNextORT[25] = 0;
isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
isoBandNextOTR[145] = isoBandNextOTR[25] = 0;

isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
isoBandNextORB[70] = isoBandNextORB[100] = 0;
isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
isoBandNextOTL[70] = isoBandNextOTL[100] = 0;

/* single pentagon cases */
isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
isoBandNextORB[101] = isoBandNextORB[69] = 0;
isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
isoBandNextOTL[101] = isoBandNextOTL[69] = 0;

isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
isoBandNextOTR[149] = isoBandNextOTR[21] = 0;

isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
isoBandNextOLT[86] = isoBandNextOLT[84] = 1;

isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
isoBandNextORT[89] = isoBandNextORT[81] = 0;
isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
isoBandNextOBL[89] = isoBandNextOBL[81] = 1;

isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
isoBandNextORT[96] = isoBandNextORT[74] = 0;
isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
isoBandNextORB[96] = isoBandNextORB[74] = 1;
isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
isoBandNextOTL[96] = isoBandNextOTL[74] = 1;

isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
isoBandNextORT[24] = isoBandNextORT[146] = 1;
isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
isoBandNextOTR[24] = isoBandNextOTR[146] = 0;

isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
isoBandNextORB[6] = isoBandNextORB[164] = 1;
isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
isoBandNextOLT[6] = isoBandNextOLT[164] = 0;

isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
isoBandNextOTR[129] = isoBandNextOTR[41] = 0;

isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
isoBandNextOTL[66] = isoBandNextOTL[104] = 1;

isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
isoBandNextORT[144] = isoBandNextORT[26] = 0;
isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
isoBandNextOTR[144] = isoBandNextOTR[26] = 1;

isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
isoBandNextORB[36] = isoBandNextORB[134] = 1;
isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
isoBandNextOTR[36] = isoBandNextOTR[134] = 0;

isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
isoBandNextORT[9] = isoBandNextORT[161] = 0;
isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
isoBandNextORB[9] = isoBandNextORB[161] = 0;
isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
isoBandNextOLB[9] = isoBandNextOLB[161] = 1;

/* 8-sided cases */
isoBandNextXRT[136] = 0;
isoBandNextYRT[136] = 1;
isoBandNextORT[136] = 1;
isoBandNextXRB[136] = 0;
isoBandNextYRB[136] = 1;
isoBandNextORB[136] = 0;
isoBandNextXBR[136] = -1;
isoBandNextYBR[136] = 0;
isoBandNextOBR[136] = 1;
isoBandNextXBL[136] = -1;
isoBandNextYBL[136] = 0;
isoBandNextOBL[136] = 0;
isoBandNextXLB[136] = 0;
isoBandNextYLB[136] = -1;
isoBandNextOLB[136] = 0;
isoBandNextXLT[136] = 0;
isoBandNextYLT[136] = -1;
isoBandNextOLT[136] = 1;
isoBandNextXTL[136] = 1;
isoBandNextYTL[136] = 0;
isoBandNextOTL[136] = 0;
isoBandNextXTR[136] = 1;
isoBandNextYTR[136] = 0;
isoBandNextOTR[136] = 1;

isoBandNextXRT[34] = 0;
isoBandNextYRT[34] = -1;
isoBandNextORT[34] = 0;
isoBandNextXRB[34] = 0;
isoBandNextYRB[34] = -1;
isoBandNextORB[34] = 1;
isoBandNextXBR[34] = 1;
isoBandNextYBR[34] = 0;
isoBandNextOBR[34] = 0;
isoBandNextXBL[34] = 1;
isoBandNextYBL[34] = 0;
isoBandNextOBL[34] = 1;
isoBandNextXLB[34] = 0;
isoBandNextYLB[34] = 1;
isoBandNextOLB[34] = 1;
isoBandNextXLT[34] = 0;
isoBandNextYLT[34] = 1;
isoBandNextOLT[34] = 0;
isoBandNextXTL[34] = -1;
isoBandNextYTL[34] = 0;
isoBandNextOTL[34] = 1;
isoBandNextXTR[34] = -1;
isoBandNextYTR[34] = 0;
isoBandNextOTR[34] = 0;

isoBandNextXRT[35] = 0;
isoBandNextYRT[35] = 1;
isoBandNextORT[35] = 1;
isoBandNextXRB[35] = 0;
isoBandNextYRB[35] = -1;
isoBandNextORB[35] = 1;
isoBandNextXBR[35] = 1;
isoBandNextYBR[35] = 0;
isoBandNextOBR[35] = 0;
isoBandNextXBL[35] = -1;
isoBandNextYBL[35] = 0;
isoBandNextOBL[35] = 0;
isoBandNextXLB[35] = 0;
isoBandNextYLB[35] = -1;
isoBandNextOLB[35] = 0;
isoBandNextXLT[35] = 0;
isoBandNextYLT[35] = 1;
isoBandNextOLT[35] = 0;
isoBandNextXTL[35] = -1;
isoBandNextYTL[35] = 0;
isoBandNextOTL[35] = 1;
isoBandNextXTR[35] = 1;
isoBandNextYTR[35] = 0;
isoBandNextOTR[35] = 1;

/* 6-sided cases */
isoBandNextXRT[153] = 0;
isoBandNextYRT[153] = 1;
isoBandNextORT[153] = 1;
isoBandNextXBL[153] = -1;
isoBandNextYBL[153] = 0;
isoBandNextOBL[153] = 0;
isoBandNextXLB[153] = 0;
isoBandNextYLB[153] = -1;
isoBandNextOLB[153] = 0;
isoBandNextXTR[153] = 1;
isoBandNextYTR[153] = 0;
isoBandNextOTR[153] = 1;

isoBandNextXRB[102] = 0;
isoBandNextYRB[102] = -1;
isoBandNextORB[102] = 1;
isoBandNextXBR[102] = 1;
isoBandNextYBR[102] = 0;
isoBandNextOBR[102] = 0;
isoBandNextXLT[102] = 0;
isoBandNextYLT[102] = 1;
isoBandNextOLT[102] = 0;
isoBandNextXTL[102] = -1;
isoBandNextYTL[102] = 0;
isoBandNextOTL[102] = 1;

isoBandNextXRT[155] = 0;
isoBandNextYRT[155] = -1;
isoBandNextORT[155] = 0;
isoBandNextXBL[155] = 1;
isoBandNextYBL[155] = 0;
isoBandNextOBL[155] = 1;
isoBandNextXLB[155] = 0;
isoBandNextYLB[155] = 1;
isoBandNextOLB[155] = 1;
isoBandNextXTR[155] = -1;
isoBandNextYTR[155] = 0;
isoBandNextOTR[155] = 0;

isoBandNextXRB[103] = 0;
isoBandNextYRB[103] = 1;
isoBandNextORB[103] = 0;
isoBandNextXBR[103] = -1;
isoBandNextYBR[103] = 0;
isoBandNextOBR[103] = 1;
isoBandNextXLT[103] = 0;
isoBandNextYLT[103] = -1;
isoBandNextOLT[103] = 1;
isoBandNextXTL[103] = 1;
isoBandNextYTL[103] = 0;
isoBandNextOTL[103] = 0;

/* 7-sided cases */
isoBandNextXRT[152] = 0;
isoBandNextYRT[152] = 1;
isoBandNextORT[152] = 1;
isoBandNextXBR[152] = -1;
isoBandNextYBR[152] = 0;
isoBandNextOBR[152] = 1;
isoBandNextXBL[152] = -1;
isoBandNextYBL[152] = 0;
isoBandNextOBL[152] = 0;
isoBandNextXLB[152] = 0;
isoBandNextYLB[152] = -1;
isoBandNextOLB[152] = 0;
isoBandNextXLT[152] = 0;
isoBandNextYLT[152] = -1;
isoBandNextOLT[152] = 1;
isoBandNextXTR[152] = 1;
isoBandNextYTR[152] = 0;
isoBandNextOTR[152] = 1;

isoBandNextXRT[156] = 0;
isoBandNextYRT[156] = -1;
isoBandNextORT[156] = 1;
isoBandNextXBR[156] = 1;
isoBandNextYBR[156] = 0;
isoBandNextOBR[156] = 1;
isoBandNextXBL[156] = -1;
isoBandNextYBL[156] = 0;
isoBandNextOBL[156] = 0;
isoBandNextXLB[156] = 0;
isoBandNextYLB[156] = -1;
isoBandNextOLB[156] = 0;
isoBandNextXLT[156] = 0;
isoBandNextYLT[156] = 1;
isoBandNextOLT[156] = 1;
isoBandNextXTR[156] = -1;
isoBandNextYTR[156] = 0;
isoBandNextOTR[156] = 1;

isoBandNextXRT[137] = 0;
isoBandNextYRT[137] = 1;
isoBandNextORT[137] = 1;
isoBandNextXRB[137] = 0;
isoBandNextYRB[137] = 1;
isoBandNextORB[137] = 0;
isoBandNextXBL[137] = -1;
isoBandNextYBL[137] = 0;
isoBandNextOBL[137] = 0;
isoBandNextXLB[137] = 0;
isoBandNextYLB[137] = -1;
isoBandNextOLB[137] = 0;
isoBandNextXTL[137] = 1;
isoBandNextYTL[137] = 0;
isoBandNextOTL[137] = 0;
isoBandNextXTR[137] = 1;
isoBandNextYTR[137] = 0;
isoBandNextOTR[137] = 1;

isoBandNextXRT[139] = 0;
isoBandNextYRT[139] = 1;
isoBandNextORT[139] = 1;
isoBandNextXRB[139] = 0;
isoBandNextYRB[139] = -1;
isoBandNextORB[139] = 0;
isoBandNextXBL[139] = 1;
isoBandNextYBL[139] = 0;
isoBandNextOBL[139] = 0;
isoBandNextXLB[139] = 0;
isoBandNextYLB[139] = 1;
isoBandNextOLB[139] = 0;
isoBandNextXTL[139] = -1;
isoBandNextYTL[139] = 0;
isoBandNextOTL[139] = 0;
isoBandNextXTR[139] = 1;
isoBandNextYTR[139] = 0;
isoBandNextOTR[139] = 1;

isoBandNextXRT[98] = 0;
isoBandNextYRT[98] = -1;
isoBandNextORT[98] = 0;
isoBandNextXRB[98] = 0;
isoBandNextYRB[98] = -1;
isoBandNextORB[98] = 1;
isoBandNextXBR[98] = 1;
isoBandNextYBR[98] = 0;
isoBandNextOBR[98] = 0;
isoBandNextXBL[98] = 1;
isoBandNextYBL[98] = 0;
isoBandNextOBL[98] = 1;
isoBandNextXLT[98] = 0;
isoBandNextYLT[98] = 1;
isoBandNextOLT[98] = 0;
isoBandNextXTL[98] = -1;
isoBandNextYTL[98] = 0;
isoBandNextOTL[98] = 1;

isoBandNextXRT[99] = 0;
isoBandNextYRT[99] = 1;
isoBandNextORT[99] = 0;
isoBandNextXRB[99] = 0;
isoBandNextYRB[99] = -1;
isoBandNextORB[99] = 1;
isoBandNextXBR[99] = 1;
isoBandNextYBR[99] = 0;
isoBandNextOBR[99] = 0;
isoBandNextXBL[99] = -1;
isoBandNextYBL[99] = 0;
isoBandNextOBL[99] = 1;
isoBandNextXLT[99] = 0;
isoBandNextYLT[99] = -1;
isoBandNextOLT[99] = 0;
isoBandNextXTL[99] = 1;
isoBandNextYTL[99] = 0;
isoBandNextOTL[99] = 1;

isoBandNextXRB[38] = 0;
isoBandNextYRB[38] = -1;
isoBandNextORB[38] = 1;
isoBandNextXBR[38] = 1;
isoBandNextYBR[38] = 0;
isoBandNextOBR[38] = 0;
isoBandNextXLB[38] = 0;
isoBandNextYLB[38] = 1;
isoBandNextOLB[38] = 1;
isoBandNextXLT[38] = 0;
isoBandNextYLT[38] = 1;
isoBandNextOLT[38] = 0;
isoBandNextXTL[38] = -1;
isoBandNextYTL[38] = 0;
isoBandNextOTL[38] = 1;
isoBandNextXTR[38] = -1;
isoBandNextYTR[38] = 0;
isoBandNextOTR[38] = 0;

isoBandNextXRB[39] = 0;
isoBandNextYRB[39] = 1;
isoBandNextORB[39] = 1;
isoBandNextXBR[39] = -1;
isoBandNextYBR[39] = 0;
isoBandNextOBR[39] = 0;
isoBandNextXLB[39] = 0;
isoBandNextYLB[39] = -1;
isoBandNextOLB[39] = 1;
isoBandNextXLT[39] = 0;
isoBandNextYLT[39] = 1;
isoBandNextOLT[39] = 0;
isoBandNextXTL[39] = -1;
isoBandNextYTL[39] = 0;
isoBandNextOTL[39] = 1;
isoBandNextXTR[39] = 1;
isoBandNextYTR[39] = 0;
isoBandNextOTR[39] = 0;

/*
  Define helper functions for the polygon_table
  */

/* triangle cases */
var p00 = function (cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
  ];
};
var p01 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
  ];
};
var p02 = function (cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, cell.righttop],
  ];
};
var p03 = function (cell) {
  return [
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* trapezoid cases */
var p04 = function (cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
  ];
};
var p05 = function (cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [1, cell.righttop],
    [1, cell.rightbottom],
  ];
};
var p06 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
var p07 = function (cell) {
  return [
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* rectangle cases */
var p08 = function (cell) {
  return [
    [0, 0],
    [0, cell.leftbottom],
    [1, cell.rightbottom],
    [1, 0],
  ];
};
var p09 = function (cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [cell.topright, 1],
    [1, 1],
  ];
};
var p10 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.lefttop],
    [0, 1],
  ];
};
var p11 = function (cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1],
  ];
};
var p12 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.leftbottom],
    [0, cell.lefttop],
  ];
};
var p13 = function (cell) {
  return [
    [cell.topleft, 1],
    [cell.topright, 1],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
  ];
};
/* square case */
var p14 = function () {
  return [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
  ];
};
/* pentagon cases */
var p15 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1211 || 1011 */
var p16 = function (cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom],
  ];
};
/* 2111 || 0111 */
var p17 = function (cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [1, 1],
  ];
};
/* 1112 || 1110 */
var p18 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
  ];
};
/* 1121 || 1101 */
var p19 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1200 || 1022 */
var p20 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [cell.topright, 1],
  ];
};
/* 0120 || 2102 */
var p21 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
  ];
};
/* 0012 || 2210 */
var p22 = function (cell) {
  return [
    [cell.topright, 1],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
  ];
};
/* 2001 || 0221 */
var p23 = function (cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1002 || 1220 */
var p24 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1],
  ];
};
/* 2100 || 0122 */
var p25 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* 0210 || 2012 */
var p26 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
  ];
};
/* 0021 || 2201 */
/*hexagon cases */
var p27 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* 0211 || 2011 */
var p28 = function (cell) {
  return [
    [1, 1],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1],
  ];
};
/* 2110 || 0112 */
var p29 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
  ];
};
/* 1102 || 1120 */
var p30 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1021 || 1201 */
var p31 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1],
  ];
};
/* 2101 || 0121 */
var p32 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1012 || 1210 */
/* 8-sided cases */
var p33 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* flipped == 1 state for 0202 and 2020 */
/* 6-sided cases */
var p34 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1],
  ];
};
/* 0101 with flipped == 1 || 2121 with flipped == 1 */
var p35 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1010 with flipped == 1 || 1212 with flipped == 1 */
/* 7-sided cases */
var p36 = function (cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1],
  ];
};
/* 2120 with flipped == 1 || 0102 with flipped == 1 */
var p37 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* 2021 with flipped == 1 || 0201 with flipped == 1 */
var p38 = function (cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1],
  ];
};
/* 1202 with flipped == 1 || 1020 with flipped == 1 */
var p39 = function (cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1],
  ];
};
/* 0212 with flipped == 1 || 2010 with flipped == 1 */

/*
  The lookup tables for edge number given the polygon
  is entered at a specific location
*/

var isoBandEdgeRT = [];
var isoBandEdgeRB = [];
var isoBandEdgeBR = [];
var isoBandEdgeBL = [];
var isoBandEdgeLB = [];
var isoBandEdgeLT = [];
var isoBandEdgeTL = [];
var isoBandEdgeTR = [];

/* triangle cases */
isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;

/* trapezoid cases */
isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;

/* rectangle cases */
isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;

/* pentagon cases */
isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;

/* hexagon cases */
isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;

/* 8-sided cases */
isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;

/* 6-sided cases */
isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;

/* 7-sided cases */
isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;

/*
  The lookup tables for all different polygons that
  may appear within a grid cell
*/

var polygon_table = [];

/* triangle cases */
polygon_table[1] = polygon_table[169] = p00; /* 2221 || 0001 */
polygon_table[4] = polygon_table[166] = p01; /* 2212 || 0010 */
polygon_table[16] = polygon_table[154] = p02; /* 2122 || 0100 */
polygon_table[64] = polygon_table[106] = p03; /* 1222 || 1000 */

/* trapezoid cases */
polygon_table[168] = polygon_table[2] = p04; /* 2220 || 0002 */
polygon_table[162] = polygon_table[8] = p05; /* 2202 || 0020 */
polygon_table[138] = polygon_table[32] = p06; /* 2022 || 0200 */
polygon_table[42] = polygon_table[128] = p07; /* 0222 || 2000 */

/* rectangle cases */
polygon_table[5] = polygon_table[165] = p08; /* 0011 || 2211 */
polygon_table[20] = polygon_table[150] = p09; /* 0110 || 2112 */
polygon_table[80] = polygon_table[90] = p10; /* 1100 || 1122 */
polygon_table[65] = polygon_table[105] = p11; /* 1001 || 1221 */
polygon_table[160] = polygon_table[10] = p12; /* 2200 || 0022 */
polygon_table[130] = polygon_table[40] = p13; /* 2002 || 0220 */

/* square case */
polygon_table[85] = p14; /* 1111 */

/* pentagon cases */
polygon_table[101] = polygon_table[69] = p15; /* 1211 || 1011 */
polygon_table[149] = polygon_table[21] = p16; /* 2111 || 0111 */
polygon_table[86] = polygon_table[84] = p17; /* 1112 || 1110 */
polygon_table[89] = polygon_table[81] = p18; /* 1121 || 1101 */
polygon_table[96] = polygon_table[74] = p19; /* 1200 || 1022 */
polygon_table[24] = polygon_table[146] = p20; /* 0120 || 2102 */
polygon_table[6] = polygon_table[164] = p21; /* 0012 || 2210 */
polygon_table[129] = polygon_table[41] = p22; /* 2001 || 0221 */
polygon_table[66] = polygon_table[104] = p23; /* 1002 || 1220 */
polygon_table[144] = polygon_table[26] = p24; /* 2100 || 0122 */
polygon_table[36] = polygon_table[134] = p25; /* 0210 || 2012 */
polygon_table[9] = polygon_table[161] = p26; /* 0021 || 2201 */

/* hexagon cases */
polygon_table[37] = polygon_table[133] = p27; /* 0211 || 2011 */
polygon_table[148] = polygon_table[22] = p28; /* 2110 || 0112 */
polygon_table[82] = polygon_table[88] = p29; /* 1102 || 1120 */
polygon_table[73] = polygon_table[97] = p30; /* 1021 || 1201 */
polygon_table[145] = polygon_table[25] = p31; /* 2101 || 0121 */
polygon_table[70] = polygon_table[100] = p32; /* 1012 || 1210 */

/* 8-sided cases */
polygon_table[34] = function (c) {
  return [p07(c), p05(c)];
}; /* 0202 || 2020 with flipped == 0 */
polygon_table[35] = p33; /* flipped == 1 state for 0202 and 2020 */
polygon_table[136] = function (c) {
  return [p06(c), p04(c)];
}; /* 2020 || 0202 with flipped == 0 */

/* 6-sided cases */
polygon_table[153] = function (c) {
  return [p02(c), p00(c)];
}; /* 0101 with flipped == 0 || 2121 with flipped == 2 */
polygon_table[102] = function (c) {
  return [p01(c), p03(c)];
}; /* 1010 with flipped == 0 || 1212 with flipped == 2 */
polygon_table[155] = p34; /* 0101 with flipped == 1 || 2121 with flipped == 1 */
polygon_table[103] = p35; /* 1010 with flipped == 1 || 1212 with flipped == 1 */

/* 7-sided cases */
polygon_table[152] = function (c) {
  return [p02(c), p04(c)];
}; /* 2120 with flipped == 2 || 0102 with flipped == 0 */
polygon_table[156] = p36; /* 2120 with flipped == 1 || 0102 with flipped == 1 */
polygon_table[137] = function (c) {
  return [p06(c), p00(c)];
}; /* 2021 with flipped == 2 || 0201 with flipped == 0 */
polygon_table[139] = p37; /* 2021 with flipped == 1 || 0201 with flipped == 1 */
polygon_table[98] = function (c) {
  return [p05(c), p03(c)];
}; /* 1202 with flipped == 2 || 1020 with flipped == 0 */
polygon_table[99] = p38; /* 1202 with flipped == 1 || 1020 with flipped == 1 */
polygon_table[38] = function (c) {
  return [p01(c), p07(c)];
}; /* 0212 with flipped == 2 || 2010 with flipped == 0 */
polygon_table[39] = p39; /* 0212 with flipped == 1 || 2010 with flipped == 1 */

/*
####################################
Some small helper functions
####################################
*/

/* assume that x1 == 1 &&  x0 == 0 */
function interpolateX(y, y0, y1) {
  return (y - y0) / (y1 - y0);
}

function isArray(myArray) {
  return myArray.constructor.toString().indexOf("Array") > -1;
}

/*
####################################
Below is the actual Marching Squares implementation
####################################
*/

function computeBandGrid(data, minV, bandwidth) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var BandGrid = { rows: rows, cols: cols, cells: [] };

  var maxV = minV + Math.abs(bandwidth);

  for (var j = 0; j < rows; ++j) {
    BandGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      /*  compose the 4-trit corner representation */
      var cval = 0;

      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];

      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }

      cval |= tl < minV ? 0 : tl > maxV ? 128 : 64;
      cval |= tr < minV ? 0 : tr > maxV ? 32 : 16;
      cval |= br < minV ? 0 : br > maxV ? 8 : 4;
      cval |= bl < minV ? 0 : bl > maxV ? 2 : 1;

      var cval_real = +cval;

      /* resolve ambiguity via averaging */
      var flipped = 0;
      if (
        cval === 17 /* 0101 */ ||
        cval === 18 /* 0102 */ ||
        cval === 33 /* 0201 */ ||
        cval === 34 /* 0202 */ ||
        cval === 38 /* 0212 */ ||
        cval === 68 /* 1010 */ ||
        cval === 72 /* 1020 */ ||
        cval === 98 /* 1202 */ ||
        cval === 102 /* 1212 */ ||
        cval === 132 /* 2010 */ ||
        cval === 136 /* 2020 */ ||
        cval === 137 /* 2021 */ ||
        cval === 152 /* 2120 */ ||
        cval === 153 /* 2121 */
      ) {
        var average = (tl + tr + br + bl) / 4;
        /* set flipped state */
        flipped = average > maxV ? 2 : average < minV ? 0 : 1;

        /* adjust cval for flipped cases */

        /* 8-sided cases */
        if (cval === 34) {
          if (flipped === 1) {
            cval = 35;
          } else if (flipped === 0) {
            cval = 136;
          }
        } else if (cval === 136) {
          if (flipped === 1) {
            cval = 35;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 34;
          }
        } else if (cval === 17) {
          /* 6-sided polygon cases */
          if (flipped === 1) {
            cval = 155;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 153;
          }
        } else if (cval === 68) {
          if (flipped === 1) {
            cval = 103;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 102;
          }
        } else if (cval === 153) {
          if (flipped === 1) cval = 155;
        } else if (cval === 102) {
          if (flipped === 1) cval = 103;
        } else if (cval === 152) {
          /* 7-sided polygon cases */
          if (flipped < 2) {
            cval = 156;
            flipped = 1;
          }
        } else if (cval === 137) {
          if (flipped < 2) {
            cval = 139;
            flipped = 1;
          }
        } else if (cval === 98) {
          if (flipped < 2) {
            cval = 99;
            flipped = 1;
          }
        } else if (cval === 38) {
          if (flipped < 2) {
            cval = 39;
            flipped = 1;
          }
        } else if (cval === 18) {
          if (flipped > 0) {
            cval = 156;
            flipped = 4;
          } else {
            cval = 152;
          }
        } else if (cval === 33) {
          if (flipped > 0) {
            cval = 139;
            flipped = 4;
          } else {
            cval = 137;
          }
        } else if (cval === 72) {
          if (flipped > 0) {
            cval = 99;
            flipped = 4;
          } else {
            cval = 98;
          }
        } else if (cval === 132) {
          if (flipped > 0) {
            cval = 39;
            flipped = 4;
          } else {
            cval = 38;
          }
        }
      }

      /* add cell to BandGrid if it contains at least one polygon-side */
      if (cval != 0 && cval != 170) {
        var topleft,
          topright,
          bottomleft,
          bottomright,
          righttop,
          rightbottom,
          lefttop,
          leftbottom;

        topleft = topright = bottomleft = bottomright = righttop = rightbottom = lefttop = leftbottom = 0.5;

        var edges = [];

        /* do interpolation here */
        /* 1st Triangles */
        if (cval === 1) {
          /* 0001 */
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 169) {
          /* 2221 */
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 4) {
          /* 0010 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = interpolateX(minV, bl, br);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 166) {
          /* 2212 */
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = 1 - interpolateX(maxV, br, bl);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 16) {
          /* 0100 */
          righttop = interpolateX(minV, br, tr);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
        } else if (cval === 154) {
          /* 2122 */
          righttop = 1 - interpolateX(maxV, tr, br);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
        } else if (cval === 64) {
          /* 1000 */
          lefttop = interpolateX(minV, bl, tl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 106) {
          /* 1222 */
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 168) {
          /* 2nd Trapezoids */
          /* 2220 */
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 2) {
          /* 0002 */
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 162) {
          /* 2202 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 8) {
          /* 0020 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 138) {
          /* 2022 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 32) {
          /* 0200 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 42) {
          /* 0222 */
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeLB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 128) {
          /* 2000 */
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeLB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        }

        /* 3rd rectangle cases */
        if (cval === 5) {
          /* 0011 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 165) {
          /* 2211 */
          rightbottom = interpolateX(maxV, br, tr);
          leftbottom = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 20) {
          /* 0110 */
          bottomright = interpolateX(minV, bl, br);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 150) {
          /* 2112 */
          bottomright = 1 - interpolateX(maxV, br, bl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 80) {
          /* 1100 */
          righttop = interpolateX(minV, br, tr);
          lefttop = interpolateX(minV, bl, tl);
          edges.push(isoBandEdgeRT[cval]);
        } else if (cval === 90) {
          /* 1122 */
          righttop = 1 - interpolateX(maxV, tr, br);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges.push(isoBandEdgeRT[cval]);
        } else if (cval === 65) {
          /* 1001 */
          bottomleft = 1 - interpolateX(minV, br, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 105) {
          /* 1221 */
          bottomleft = interpolateX(maxV, bl, br);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 160) {
          /* 2200 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 10) {
          /* 0022 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 130) {
          /* 2002 */
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 40) {
          /* 0220 */
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 101) {
          /* 4th single pentagon cases */
          /* 1211 */
          rightbottom = interpolateX(maxV, br, tr);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 69) {
          /* 1011 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 149) {
          /* 2111 */
          leftbottom = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 21) {
          /* 0111 */
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 86) {
          /* 1112 */
          bottomright = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 84) {
          /* 1110 */
          bottomright = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 89) {
          /* 1121 */
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 81) {
          /* 1101 */
          righttop = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 96) {
          /* 1200 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 74) {
          /* 1022 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 24) {
          /* 0120 */
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 146) {
          /* 2102 */
          righttop = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 6) {
          /* 0012 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 164) {
          /* 2210 */
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 129) {
          /* 2001 */
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeBL[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 41) {
          /* 0221 */
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeBL[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 66) {
          /* 1002 */
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 104) {
          /* 1220 */
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeBL[cval]);
          edges.push(isoBandEdgeTL[cval]);
        } else if (cval === 144) {
          /* 2100 */
          righttop = interpolateX(minV, br, tr);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 26) {
          /* 0122 */
          righttop = 1 - interpolateX(maxV, tr, br);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 36) {
          /* 0210 */
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 134) {
          /* 2012 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 9) {
          /* 0021 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 161) {
          /* 2201 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 37) {
          /* 5th single hexagon cases */
          /* 0211 */
          rightbottom = interpolateX(maxV, br, tr);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 133) {
          /* 2011 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          leftbottom = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 148) {
          /* 2110 */
          bottomright = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 22) {
          /* 0112 */
          bottomright = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 82) {
          /* 1102 */
          righttop = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 88) {
          /* 1120 */
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 73) {
          /* 1021 */
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 97) {
          /* 1201 */
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
        } else if (cval === 145) {
          /* 2101 */
          righttop = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 25) {
          /* 0121 */
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 70) {
          /* 1012 */
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 100) {
          /* 1210 */
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 34) {
          /* 8-sided cases */
          /* 0202 || 2020 with flipped == 0 */
          if (flipped === 0) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 35) {
          /* flipped == 1 state for 0202, and 2020 with flipped == 4*/
          if (flipped === 4) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBL[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 136) {
          /* 2020 || 0202 with flipped == 0 */
          if (flipped === 0) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 153) {
          /* 6-sided polygon cases */
          /* 0101 with flipped == 0 || 2121 with flipped == 2 */
          if (flipped === 0) {
            righttop = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 102) {
          /* 1010 with flipped == 0 || 1212 with flipped == 2 */
          if (flipped === 0) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 155) {
          /* 0101 with flipped == 4 || 2121 with flipped == 1 */
          if (flipped === 4) {
            righttop = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 103) {
          /* 1010 with flipped == 4 || 1212 with flipped == 1 */
          if (flipped === 4) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
        } else if (cval === 152) {
          /* 7-sided polygon cases */
          /* 2120 with flipped == 2 || 0102 with flipped == 0 */
          if (flipped === 0) {
            righttop = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 156) {
          /* 2120 with flipped == 1 || 0102 with flipped == 4 */
          if (flipped === 4) {
            righttop = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeBL[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 137) {
          /* 2021 with flipped == 2 || 0201 with flipped == 0 */
          if (flipped === 0) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 139) {
          /* 2021 with flipped == 1 || 0201 with flipped == 4 */
          if (flipped === 4) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
        } else if (cval === 98) {
          /* 1202 with flipped == 2 || 1020 with flipped == 0 */
          if (flipped === 0) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 99) {
          /* 1202 with flipped == 1 || 1020 with flipped == 4 */
          if (flipped === 4) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRT[cval]);
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBL[cval]);
        } else if (cval === 38) {
          /* 0212 with flipped == 2 || 2010 with flipped == 0 */
          if (flipped === 0) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeLB[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 39) {
          /* 0212 with flipped == 1 || 2010 with flipped == 4 */
          if (flipped === 4) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges.push(isoBandEdgeRB[cval]);
          edges.push(isoBandEdgeBR[cval]);
          edges.push(isoBandEdgeLT[cval]);
        } else if (cval === 85) {
          righttop = 1;
          rightbottom = 0;
          bottomright = 1;
          bottomleft = 0;
          leftbottom = 0;
          lefttop = 1;
          topleft = 0;
          topright = 1;
        }

        if (
          topleft < 0 ||
          topleft > 1 ||
          topright < 0 ||
          topright > 1 ||
          righttop < 0 ||
          righttop > 1 ||
          bottomright < 0 ||
          bottomright > 1 ||
          leftbottom < 0 ||
          leftbottom > 1 ||
          lefttop < 0 ||
          lefttop > 1
        ) {
          console.log(
            "MarchingSquaresJS-isoBands: " +
              cval +
              " " +
              cval_real +
              " " +
              tl +
              "," +
              tr +
              "," +
              br +
              "," +
              bl +
              " " +
              flipped +
              " " +
              topleft +
              " " +
              topright +
              " " +
              righttop +
              " " +
              rightbottom +
              " " +
              bottomright +
              " " +
              bottomleft +
              " " +
              leftbottom +
              " " +
              lefttop
          );
        }

        BandGrid.cells[j][i] = {
          cval: cval,
          cval_real: cval_real,
          flipped: flipped,
          topleft: topleft,
          topright: topright,
          righttop: righttop,
          rightbottom: rightbottom,
          bottomright: bottomright,
          bottomleft: bottomleft,
          leftbottom: leftbottom,
          lefttop: lefttop,
          edges: edges,
        };
      }
    }
  }

  return BandGrid;
}

function BandGrid2AreaPaths(grid) {
  var areas = [];
  var rows = grid.rows;
  var cols = grid.cols;
  var currentPolygon = [];

  for (var j = 0; j < rows; j++) {
    for (var i = 0; i < cols; i++) {
      if (
        typeof grid.cells[j][i] !== "undefined" &&
        grid.cells[j][i].edges.length > 0
      ) {
        /* trace back polygon path starting from this cell */

        var cell = grid.cells[j][i];

        /* get start coordinates */

        var prev = getStartXY(cell),
          next = null,
          p = i,
          q = j;

        if (prev !== null) {
          currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
          //console.log(cell);
          //console.log("coords: " + (prev.p[0] + p) + " " + (prev.p[1] + q));
        }

        do {
          //console.log(p + "," + q);
          //console.log(grid.cells[q][p]);
          //console.log(grid.cells[q][p].edges);
          //console.log("from : " + prev.x + " " + prev.y + " " + prev.o);

          next = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
          if (next !== null) {
            //console.log("coords: " + (next.p[0] + p) + " " + (next.p[1] + q));
            currentPolygon.push([next.p[0] + p, next.p[1] + q]);
            p += next.x;
            q += next.y;
            prev = next;
          } else {
            //console.log("getExitXY() returned null!");
            break;
          }
          //console.log("to : " + next.x + " " + next.y + " " + next.o);
          /* special case, where we've reached the grid boundaries */
          if (
            q < 0 ||
            q >= rows ||
            p < 0 ||
            p >= cols ||
            typeof grid.cells[q][p] === "undefined"
          ) {
            /* to create a closed path, we need to trace our way
                arround the missing data, until we find an entry
                point again
            */

            /* set back coordinates of current cell */
            p -= next.x;
            q -= next.y;

            //console.log("reached boundary at " + p + " " + q);

            var missing = traceOutOfGridPath(
              grid,
              p,
              q,
              next.x,
              next.y,
              next.o
            );
            if (missing !== null) {
              missing.path.forEach(function (pp) {
                //console.log("coords: " + (pp[0]) + " " + (pp[1]));
                currentPolygon.push(pp);
              });
              p = missing.i;
              q = missing.j;
              prev = missing;
            } else {
              break;
            }
            //console.log(grid.cells[q][p]);
          }
        } while (
          typeof grid.cells[q][p] !== "undefined" &&
          grid.cells[q][p].edges.length > 0
        );

        areas.push(currentPolygon);
        //console.log("next polygon");
        //console.log(currentPolygon);
        currentPolygon = [];
        if (grid.cells[j][i].edges.length > 0) i--;
      }
    }
  }
  return areas;
}

function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
  var cell = grid.cells[j][i];
  var cval = cell.cval_real;
  var p = i + d_x,
    q = j + d_y;
  var path = [];
  var closed = false;

  while (!closed) {
    //console.log("processing cell " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
    if (
      typeof grid.cells[q] === "undefined" ||
      typeof grid.cells[q][p] === "undefined"
    ) {
      //console.log("which is undefined");
      /* we can't move on, so we have to change direction to proceed further */

      /* go back to previous cell */
      q -= d_y;
      p -= d_x;
      cell = grid.cells[q][p];
      cval = cell.cval_real;

      /* check where we've left defined cells of the grid... */
      if (d_y === -1) {
        /* we came from top */
        if (d_o === 0) {
          /* exit left */
          if (cval & Node3) {
            /* lower left node is within range, so we move left */
            path.push([p, q]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node2) {
            /* lower right node is within range, so we move right */
            path.push([p + 1, q]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
          } else {
            /* close the path */
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            break;
          }
        } else if (cval & Node3) {
          path.push([p, q]);
          d_x = -1;
          d_y = 0;
          d_o = 0;
        } else if (cval & Node2) {
          path.push([p + cell.bottomright, q]);
          d_x = 0;
          d_y = 1;
          d_o = 1;
          closed = true;
          break;
        } else {
          path.push([p + cell.bottomleft, q]);
          d_x = 0;
          d_y = 1;
          d_o = 0;
          closed = true;
          break;
        }
      } else if (d_y === 1) {
        /* we came from bottom */
        //console.log("we came from bottom and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
        if (d_o === 0) {
          /* exit left */
          if (cval & Node1) {
            /* top right node is within range, so we move right */
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (!(cval & Node0)) {
            /* found entry within same cell */
            path.push([p + cell.topright, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
            closed = true;
            //console.log("found entry from bottom at " + p + "," + q);
            break;
          } else {
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            break;
          }
        } else if (cval & Node1) {
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
        } else {
          /* move right */
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
          //console.log("wtf");
          //break;
        }
      } else if (d_x === -1) {
        /* we came from right */
        //console.log("we came from right and hit a non-existing cell at " + (p + d_x) + "," + (q + d_y) + "!");
        if (d_o === 0) {
          //console.log("continue at bottom");
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
            //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
          } else if (!(cval & Node3)) {
            /* there has to be an entry into the regular grid again! */
            //console.log("exiting top");
            path.push([p, q + cell.lefttop]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
            closed = true;
            break;
          } else {
            //console.log("exiting bottom");
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          //console.log("continue at top");
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
            //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
          } else {
            /* */
            console.log("MarchingSquaresJS-isoBands: wtf");
            break;
          }
        }
      } else if (d_x === 1) {
        /* we came from left */
        //console.log("we came from left and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
        if (d_o === 0) {
          /* exit bottom */
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          /* exit top */
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (!(cval & Node1)) {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          } else {
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            break;
          }
        }
      } else {
        /* we came from the same cell */
        console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
        break;
      }
    } else {
      /* try to find an entry into the regular grid again! */
      cell = grid.cells[q][p];
      cval = cell.cval_real;
      //console.log("which is defined");

      if (d_x === -1) {
        if (d_o === 0) {
          /* try to go downwards */
          if (
            typeof grid.cells[q - 1] !== "undefined" &&
            typeof grid.cells[q - 1][p] !== "undefined"
          ) {
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (cval & Node3) {
            /* proceed searching in x-direction */
            //console.log("proceeding in x-direction!");
            path.push([p, q]);
          } else {
            /* we must have found an entry into the regular grid */
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            //console.log("found entry from bottom at " + p + "," + q);
            break;
          }
        } else if (cval & Node0) {
          /* proceed searchin in x-direction */
          console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
        } else {
          /* we must have found an entry into the regular grid */
          console.log(
            "MarchingSquaresJS-isoBands: found entry from top at " + p + "," + q
          );
          break;
        }
      } else if (d_x === 1) {
        if (d_o === 0) {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        } else {
          /* try to go upwards */
          if (
            typeof grid.cells[q + 1] !== "undefined" &&
            typeof grid.cells[q + 1][p] !== "undefined"
          ) {
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else if (cval & Node1) {
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else {
            /* found an entry point into regular grid! */
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            //console.log("found entry from bottom at " + p + "," + q);
            break;
          }
        }
      } else if (d_y === -1) {
        if (d_o === 1) {
          /* try to go right */
          if (typeof grid.cells[q][p + 1] !== "undefined") {
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            /* found entry into regular grid! */
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            closed = true;
            //console.log("found entry from top at " + p + "," + q);
            break;
          }
        } else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else if (d_y === 1) {
        if (d_o === 0) {
          //console.log("we came from bottom left and proceed to the left");
          /* try to go left */
          if (typeof grid.cells[q][p - 1] !== "undefined") {
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else {
            /* found an entry point into regular grid! */
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            //console.log("found entry from bottom at " + p + "," + q);
            break;
          }
        } else {
          //console.log("we came from bottom right and proceed to the right");
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else {
        console.log("MarchingSquaresJS-isoBands: where did we came from???");
        break;
      }
    }

    p += d_x;
    q += d_y;
    //console.log("going on to  " + p + "," + q + " via " + d_x + " " + d_y + " " + d_o);

    if (p === i && q === j) {
      /* bail out, once we've closed a circle path */
      break;
    }
  }

  //console.log("exit with " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
  return { path: path, i: p, j: q, x: d_x, y: d_y, o: d_o };
}

function deleteEdge(cell, edgeIdx) {
  delete cell.edges[edgeIdx];
  for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
    cell.edges[k - 1] = cell.edges[k];
  }
  cell.edges.pop();
}

function getStartXY(cell) {
  if (cell.edges.length > 0) {
    var e = cell.edges[cell.edges.length - 1];
    //console.log("starting with edge " + e);
    var cval = cell.cval_real;
    switch (e) {
      case 0:
        if (cval & Node1) {
          /* node 1 within range */
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          /* node 1 below or above threshold */
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 1:
        if (cval & Node2) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 2:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 3:
        if (cval & Node3) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 4:
        if (cval & Node1) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 5:
        if (cval & Node2) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 6:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 7:
        if (cval & Node3) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 8:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 9:
        if (cval & Node3) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 10:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 11:
        if (cval & Node0) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 12:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 13:
        if (cval & Node3) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 14:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 15:
        if (cval & Node0) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 16:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 17:
        if (cval & Node0) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 18:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 19:
        if (cval & Node0) {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 20:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 21:
        if (cval & Node1) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 22:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 23:
        if (cval & Node1) {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      default:
        console.log("MarchingSquaresJS-isoBands: edge index out of range!");
        console.log(cell);
        break;
    }
  }

  return null;
}

function getExitXY(cell, x, y, o) {
  var e,
    id_x,
    d_x,
    d_y,
    cval = cell.cval;
  var d_o;

  switch (x) {
    case -1:
      switch (o) {
        case 0:
          e = isoBandEdgeRB[cval];
          d_x = isoBandNextXRB[cval];
          d_y = isoBandNextYRB[cval];
          d_o = isoBandNextORB[cval];
          break;
        default:
          e = isoBandEdgeRT[cval];
          d_x = isoBandNextXRT[cval];
          d_y = isoBandNextYRT[cval];
          d_o = isoBandNextORT[cval];
          break;
      }
      break;
    case 1:
      switch (o) {
        case 0:
          e = isoBandEdgeLB[cval];
          d_x = isoBandNextXLB[cval];
          d_y = isoBandNextYLB[cval];
          d_o = isoBandNextOLB[cval];
          break;
        default:
          e = isoBandEdgeLT[cval];
          d_x = isoBandNextXLT[cval];
          d_y = isoBandNextYLT[cval];
          d_o = isoBandNextOLT[cval];
          break;
      }
      break;
    default:
      switch (y) {
        case -1:
          switch (o) {
            case 0:
              e = isoBandEdgeTL[cval];
              d_x = isoBandNextXTL[cval];
              d_y = isoBandNextYTL[cval];
              d_o = isoBandNextOTL[cval];
              break;
            default:
              e = isoBandEdgeTR[cval];
              d_x = isoBandNextXTR[cval];
              d_y = isoBandNextYTR[cval];
              d_o = isoBandNextOTR[cval];
              break;
          }
          break;
        case 1:
          switch (o) {
            case 0:
              e = isoBandEdgeBL[cval];
              d_x = isoBandNextXBL[cval];
              d_y = isoBandNextYBL[cval];
              d_o = isoBandNextOBL[cval];
              break;
            default:
              e = isoBandEdgeBR[cval];
              d_x = isoBandNextXBR[cval];
              d_y = isoBandNextYBR[cval];
              d_o = isoBandNextOBR[cval];
              break;
          }
          break;
      }
      break;
  }

  id_x = cell.edges.indexOf(e);
  if (typeof cell.edges[id_x] !== "undefined") {
    deleteEdge(cell, id_x);
  } else {
    //console.log("wrong edges...");
    //console.log(x + " " + y + " " + o);
    //console.log(cell);
    return null;
  }

  cval = cell.cval_real;

  switch (e) {
    case 0:
      if (cval & Node1) {
        /* node 1 within range */
        x = cell.topleft;
        y = 1;
      } else {
        /* node 1 below or above threshold */
        x = 1;
        y = cell.righttop;
      }
      break;
    case 1:
      if (cval & Node2) {
        x = 1;
        y = cell.rightbottom;
      } else {
        x = cell.topleft;
        y = 1;
      }
      break;
    case 2:
      if (cval & Node2) {
        x = cell.topleft;
        y = 1;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 3:
      if (cval & Node3) {
        x = cell.bottomleft;
        y = 0;
      } else {
        x = cell.topleft;
        y = 1;
      }
      break;
    case 4:
      if (cval & Node1) {
        x = cell.topright;
        y = 1;
      } else {
        x = 1;
        y = cell.righttop;
      }
      break;
    case 5:
      if (cval & Node2) {
        x = 1;
        y = cell.rightbottom;
      } else {
        x = cell.topright;
        y = 1;
      }
      break;
    case 6:
      if (cval & Node2) {
        x = cell.topright;
        y = 1;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 7:
      if (cval & Node3) {
        x = cell.bottomleft;
        y = 0;
      } else {
        x = cell.topright;
        y = 1;
      }
      break;
    case 8:
      if (cval & Node2) {
        x = 1;
        y = cell.righttop;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 9:
      if (cval & Node3) {
        x = cell.bottomleft;
        y = 0;
      } else {
        x = 1;
        y = cell.righttop;
      }
      break;
    case 10:
      if (cval & Node3) {
        x = 1;
        y = cell.righttop;
      } else {
        x = 0;
        y = cell.leftbottom;
      }
      break;
    case 11:
      if (cval & Node0) {
        x = 0;
        y = cell.lefttop;
      } else {
        x = 1;
        y = cell.righttop;
      }
      break;
    case 12:
      if (cval & Node2) {
        x = 1;
        y = cell.rightbottom;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 13:
      if (cval & Node3) {
        x = cell.bottomleft;
        y = 0;
      } else {
        x = 1;
        y = cell.rightbottom;
      }
      break;
    case 14:
      if (cval & Node3) {
        x = 1;
        y = cell.rightbottom;
      } else {
        x = 0;
        y = cell.leftbottom;
      }
      break;
    case 15:
      if (cval & Node0) {
        x = 0;
        y = cell.lefttop;
      } else {
        x = 1;
        y = cell.rightbottom;
      }
      break;
    case 16:
      if (cval & Node2) {
        x = 0;
        y = cell.leftbottom;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 17:
      if (cval & Node0) {
        x = 0;
        y = cell.lefttop;
      } else {
        x = cell.bottomright;
        y = 0;
      }
      break;
    case 18:
      if (cval & Node3) {
        x = cell.bottomleft;
        y = 0;
      } else {
        x = 0;
        y = cell.leftbottom;
      }
      break;
    case 19:
      if (cval & Node0) {
        x = 0;
        y = cell.lefttop;
      } else {
        x = cell.bottomleft;
        y = 0;
      }
      break;
    case 20:
      if (cval & Node0) {
        x = 0;
        y = cell.leftbottom;
      } else {
        x = cell.topleft;
        y = 1;
      }
      break;
    case 21:
      if (cval & Node1) {
        x = cell.topright;
        y = 1;
      } else {
        x = 0;
        y = cell.leftbottom;
      }
      break;
    case 22:
      if (cval & Node0) {
        x = 0;
        y = cell.lefttop;
      } else {
        x = cell.topleft;
        y = 1;
      }
      break;
    case 23:
      if (cval & Node1) {
        x = cell.topright;
        y = 1;
      } else {
        x = 0;
        y = cell.lefttop;
      }
      break;
    default:
      console.log("MarchingSquaresJS-isoBands: edge index out of range!");
      console.log(cell);
      return null;
  }

  if (
    typeof x === "undefined" ||
    typeof y === "undefined" ||
    typeof d_x === "undefined" ||
    typeof d_y === "undefined" ||
    typeof d_o === "undefined"
  ) {
    console.log("MarchingSquaresJS-isoBands: undefined value!");
    console.log(cell);
    console.log(x + " " + y + " " + d_x + " " + d_y + " " + d_o);
  }
  return { p: [x, y], x: d_x, y: d_y, o: d_o };
}

function BandGrid2Areas(grid) {
  var areas = [];
  var area_idx = 0;

  grid.cells.forEach(function (g, j) {
    g.forEach(function (gg, i) {
      if (typeof gg !== "undefined") {
        var a = polygon_table[gg.cval](gg);
        if (typeof a === "object" && isArray(a)) {
          if (typeof a[0] === "object" && isArray(a[0])) {
            if (typeof a[0][0] === "object" && isArray(a[0][0])) {
              a.forEach(function (aa) {
                aa.forEach(function (aaa) {
                  aaa[0] += i;
                  aaa[1] += j;
                });
                areas[area_idx++] = aa;
              });
            } else {
              a.forEach(function (aa) {
                aa[0] += i;
                aa[1] += j;
              });
              areas[area_idx++] = a;
            }
          } else {
            console.log(
              "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
            );
          }
        } else {
          console.log(
            "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
          );
        }
      }
    });
  });

  return areas;
}

/**
 * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of
 * value breaks and generates filled contour isobands.
 *
 * @name isobands
 * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular
 * @param {Array<number>} breaks where to draw contours
 * @param {Object} [options={}] options on output
 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
 * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands
 * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)
 * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands
 */
function isobands(pointGrid, breaks, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];

  // Validation
  invariant.collectionOf(pointGrid, "Point", "Input must contain Points");
  if (!breaks) throw new Error("breaks is required");
  if (!Array.isArray(breaks)) throw new Error("breaks is not an Array");
  if (!helpers.isObject(commonProperties))
    throw new Error("commonProperties is not an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties is not an Array");

  // Isoband methods
  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });
  var contours = createContourLines(matrix, breaks, zProperty);
  contours = rescaleContours(contours, matrix, pointGrid);

  var multipolygons = contours.map(function (contour, index) {
    if (breaksProperties[index] && !helpers.isObject(breaksProperties[index])) {
      throw new Error("Each mappedProperty is required to be an Object");
    }
    // collect all properties
    var contourProperties = objectAssign__default['default'](
      {},
      commonProperties,
      breaksProperties[index]
    );
    contourProperties[zProperty] = contour[zProperty];
    var multiP = helpers.multiPolygon(contour.groupedRings, contourProperties);
    return multiP;
  });

  return helpers.featureCollection(multipolygons);
}

/**
 * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid
 *
 * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it
 * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be
 * rescaled, with turfjs, to the original area and proportions on the map
 *
 * @private
 * @param {Array<Array<number>>} matrix Grid Data
 * @param {Array<number>} breaks Breaks
 * @param {string} [property='elevation'] Property
 * @returns {Array<any>} contours
 */
function createContourLines(matrix, breaks, property) {
  var contours = [];
  for (var i = 1; i < breaks.length; i++) {
    var lowerBand = +breaks[i - 1]; // make sure the breaks value is a number
    var upperBand = +breaks[i];

    var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
    // as per GeoJson rules for creating a Polygon, make sure the first element
    // in the array of LinearRings represents the exterior ring (i.e. biggest area),
    // and any subsequent elements represent interior rings (i.e. smaller area);
    // this avoids rendering issues of the MultiPolygons on the map
    var nestedRings = orderByArea(isobandsCoords);
    var groupedRings = groupNestedRings(nestedRings);
    var obj = {};
    obj["groupedRings"] = groupedRings;
    obj[property] = lowerBand + "-" + upperBand;
    contours.push(obj);
  }
  return contours;
}

/**
 * Transform isobands of 2D grid to polygons for the map
 *
 * @private
 * @param {Array<any>} contours Contours
 * @param {Array<Array<number>>} matrix Grid Data
 * @param {Object} points Points by Latitude
 * @returns {Array<any>} contours
 */
function rescaleContours(contours, matrix, points) {
  // get dimensions (on the map) of the original grid
  var gridBbox = bbox__default['default'](points); // [ minX, minY, maxX, maxY ]
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];

  // get origin, which is the first point of the last row on the rectangular data on the map
  var x0 = gridBbox[0];
  var y0 = gridBbox[1];
  // get number of cells per side
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;
  // calculate the scaling factor between matrix and rectangular grid on the map
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;

  var resize = function (point) {
    point[0] = point[0] * scaleX + x0;
    point[1] = point[1] * scaleY + y0;
  };

  // resize and shift each point/line of the isobands
  contours.forEach(function (contour) {
    contour.groupedRings.forEach(function (lineRingSet) {
      lineRingSet.forEach(function (lineRing) {
        lineRing.forEach(resize);
      });
    });
  });
  return contours;
}

/*  utility functions */

/**
 * Returns an array of coordinates (of LinearRings) in descending order by area
 *
 * @private
 * @param {Array<LineString>} ringsCoords array of closed LineString
 * @returns {Array} array of the input LineString ordered by area
 */
function orderByArea(ringsCoords) {
  var ringsWithArea = [];
  var areas = [];
  ringsCoords.forEach(function (coords) {
    // var poly = polygon([points]);
    var ringArea = area__default['default'](helpers.polygon([coords]));
    // create an array of areas value
    areas.push(ringArea);
    // associate each lineRing with its area
    ringsWithArea.push({ ring: coords, area: ringArea });
  });
  areas.sort(function (a, b) {
    // bigger --> smaller
    return b - a;
  });
  // create a new array of linearRings coordinates ordered by their area
  var orderedByArea = [];
  areas.forEach(function (area) {
    for (var lr = 0; lr < ringsWithArea.length; lr++) {
      if (ringsWithArea[lr].area === area) {
        orderedByArea.push(ringsWithArea[lr].ring);
        ringsWithArea.splice(lr, 1);
        break;
      }
    }
  });
  return orderedByArea;
}

/**
 * Returns an array of arrays of coordinates, each representing
 * a set of (coordinates of) nested LinearRings,
 * i.e. the first ring contains all the others
 *
 * @private
 * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area
 * @returns {Array<Array>} Array of coordinates of nested LinearRings
 */
function groupNestedRings(orderedLinearRings) {
  // create a list of the (coordinates of) LinearRings
  var lrList = orderedLinearRings.map(function (lr) {
    return { lrCoordinates: lr, grouped: false };
  });
  var groupedLinearRingsCoords = [];
  while (!allGrouped(lrList)) {
    for (var i = 0; i < lrList.length; i++) {
      if (!lrList[i].grouped) {
        // create new group starting with the larger not already grouped ring
        var group = [];
        group.push(lrList[i].lrCoordinates);
        lrList[i].grouped = true;
        var outerMostPoly = helpers.polygon([lrList[i].lrCoordinates]);
        // group all the rings contained by the outermost ring
        for (var j = i + 1; j < lrList.length; j++) {
          if (!lrList[j].grouped) {
            var lrPoly = helpers.polygon([lrList[j].lrCoordinates]);
            if (isInside(lrPoly, outerMostPoly)) {
              group.push(lrList[j].lrCoordinates);
              lrList[j].grouped = true;
            }
          }
        }
        // insert the new group
        groupedLinearRingsCoords.push(group);
      }
    }
  }
  return groupedLinearRingsCoords;
}

/**
 * @private
 * @param {Polygon} testPolygon polygon of interest
 * @param {Polygon} targetPolygon polygon you want to compare with
 * @returns {boolean} true if test-Polygon is inside target-Polygon
 */
function isInside(testPolygon, targetPolygon) {
  var points = explode__default['default'](testPolygon);
  for (var i = 0; i < points.features.length; i++) {
    if (!booleanPointInPolygon__default['default'](points.features[i], targetPolygon)) {
      return false;
    }
  }
  return true;
}

/**
 * @private
 * @param {Array<Object>} list list of objects which might contain the 'group' attribute
 * @returns {boolean} true if all the objects in the list are marked as grouped
 */
function allGrouped(list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].grouped === false) {
      return false;
    }
  }
  return true;
}

module.exports = isobands;
module.exports["default"] = isobands;


/***/ }),

/***/ 1283:
/***/ ((module) => {

/**
 * PriorityQueue
 * Elements in this queue are sorted according to their value
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * PriorityQueue class construcotr
 * @constructor
 *
 * @example
 * queue: [1,2,3,4]
 * priorities: [4,1,2,3]
 * > result = [1,4,2,3]
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @param {string} sorting - asc / desc
 * @returns {PriorityQueue}
 */
function PriorityQueue(elements, priorities, sorting) {
  /** @type {Array} */
  this._queue = [];
  /** @type {Array} */
  this._priorities = [];
  /** @type {string} */
  this._sorting = 'desc';

  this._init(elements, priorities, sorting);
};

/**
 * Insert element
 *
 * @param {Object} ele
 * @param {Object} priority
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.insert = function(ele, priority) {
  var indexToInsert = this._queue.length;
  var index = indexToInsert;

  while (index--) {
    var priority2 = this._priorities[index];
    if (this._sorting === 'desc') {
      if (priority > priority2) {
        indexToInsert = index;
      }
    } else {
      if (priority < priority2) {
        indexToInsert = index;
      }
    }
  }

  this._insertAt(ele, priority, indexToInsert);
};

/**
 * Remove element
 *
 * @param {Object} ele
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.remove = function(ele) {
  var index = this._queue.length;

  while (index--) {
    var ele2 = this._queue[index];
    if (ele === ele2) {
      this._queue.splice(index, 1);
      this._priorities.splice(index, 1);
      break;
    }
  }
};

/**
 * For each loop wrapper
 *
 * @param {function} func
 * @returs {undefined}
 * @access public
 */
PriorityQueue.prototype.forEach = function(func) {
  this._queue.forEach(func);
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElements = function() {
  return this._queue;
};

/**
 * @param {number} index
 * @returns {Object}
 * @access public
 */
PriorityQueue.prototype.getElementPriority = function(index) {
  return this._priorities[index];
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getPriorities = function() {
  return this._priorities;
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElementsWithPriorities = function() {
  var result = [];

  for (var i = 0, l = this._queue.length; i < l; i++) {
    result.push([this._queue[i], this._priorities[i]]);
  }

  return result;
};

/**
 * Set object properties
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._init = function(elements, priorities, sorting) {

  if (elements && priorities) {
    this._queue = [];
    this._priorities = [];

    if (elements.length !== priorities.length) {
      throw new Error('Arrays must have the same length');
    }

    for (var i = 0; i < elements.length; i++) {
      this.insert(elements[i], priorities[i]);
    }
  }

  if (sorting) {
    this._sorting = sorting;
  }
};

/**
 * Insert element at given position
 *
 * @param {Object} ele
 * @param {number} index
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._insertAt = function(ele, priority, index) {
  if (this._queue.length === index) {
    this._queue.push(ele);
    this._priorities.push(priority);
  } else {
    this._queue.splice(index, 0, ele);
    this._priorities.splice(index, 0, priority);
  }
};

if ( true && module.exports) {
  module.exports = PriorityQueue;
}


/***/ }),

/***/ 1288:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Takes two {@link Point|points} and finds the geographic bearing between them,
 * i.e. the angle measured in degrees from the north line (0 degrees)
 *
 * @name bearing
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984]);
 * var point2 = turf.point([-75.534, 39.123]);
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2]
 * point1.properties['marker-color'] = '#f00'
 * point2.properties['marker-color'] = '#0f0'
 * point1.properties.bearing = bearing
 */
function bearing(start, end, options) {
    if (options === void 0) { options = {}; }
    // Reverse calculation
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    var coordinates1 = invariant_1.getCoord(start);
    var coordinates2 = invariant_1.getCoord(end);
    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);
    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return helpers_1.radiansToDegrees(Math.atan2(a, b));
}
exports["default"] = bearing;
/**
 * Calculates Final Bearing
 *
 * @private
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @returns {number} bearing
 */
function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}


/***/ }),

/***/ 1323:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var line_intersect_1 = __importDefault(__webpack_require__(3154));
var meta_1 = __webpack_require__(8421);
var polygon_to_line_1 = __importDefault(__webpack_require__(4527));
/**
 * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.
 *
 * @name booleanDisjoint
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var point = turf.point([2, 2]);
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 *
 * turf.booleanDisjoint(line, point);
 * //=true
 */
function booleanDisjoint(feature1, feature2) {
    var bool = true;
    meta_1.flattenEach(feature1, function (flatten1) {
        meta_1.flattenEach(feature2, function (flatten2) {
            if (bool === false) {
                return false;
            }
            bool = disjoint(flatten1.geometry, flatten2.geometry);
        });
    });
    return bool;
}
/**
 * Disjoint operation for simple Geometries (Point/LineString/Polygon)
 *
 * @private
 * @param {Geometry<any>} geom1 GeoJSON Geometry
 * @param {Geometry<any>} geom2 GeoJSON Geometry
 * @returns {boolean} true/false
 */
function disjoint(geom1, geom2) {
    switch (geom1.type) {
        case "Point":
            switch (geom2.type) {
                case "Point":
                    return !compareCoords(geom1.coordinates, geom2.coordinates);
                case "LineString":
                    return !isPointOnLine(geom2, geom1);
                case "Polygon":
                    return !boolean_point_in_polygon_1.default(geom1, geom2);
            }
            /* istanbul ignore next */
            break;
        case "LineString":
            switch (geom2.type) {
                case "Point":
                    return !isPointOnLine(geom1, geom2);
                case "LineString":
                    return !isLineOnLine(geom1, geom2);
                case "Polygon":
                    return !isLineInPoly(geom2, geom1);
            }
            /* istanbul ignore next */
            break;
        case "Polygon":
            switch (geom2.type) {
                case "Point":
                    return !boolean_point_in_polygon_1.default(geom2, geom1);
                case "LineString":
                    return !isLineInPoly(geom1, geom2);
                case "Polygon":
                    return !isPolyInPoly(geom2, geom1);
            }
    }
    return false;
}
// http://stackoverflow.com/a/11908158/1979085
function isPointOnLine(lineString, pt) {
    for (var i = 0; i < lineString.coordinates.length - 1; i++) {
        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
            return true;
        }
    }
    return false;
}
function isLineOnLine(lineString1, lineString2) {
    var doLinesIntersect = line_intersect_1.default(lineString1, lineString2);
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isLineInPoly(polygon, lineString) {
    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_in_polygon_1.default(coord, polygon)) {
            return true;
        }
    }
    var doLinesIntersect = line_intersect_1.default(lineString, polygon_to_line_1.default(polygon));
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
/**
 * Is Polygon (geom1) in Polygon (geom2)
 * Only takes into account outer rings
 * See http://stackoverflow.com/a/4833823/1979085
 *
 * @private
 * @param {Geometry|Feature<Polygon>} feature1 Polygon1
 * @param {Geometry|Feature<Polygon>} feature2 Polygon2
 * @returns {boolean} true/false
 */
function isPolyInPoly(feature1, feature2) {
    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
        var coord1 = _a[_i];
        if (boolean_point_in_polygon_1.default(coord1, feature2)) {
            return true;
        }
    }
    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
        var coord2 = _c[_b];
        if (boolean_point_in_polygon_1.default(coord2, feature1)) {
            return true;
        }
    }
    var doLinesIntersect = line_intersect_1.default(polygon_to_line_1.default(feature1), polygon_to_line_1.default(feature2));
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
    var dxc = pt[0] - lineSegmentStart[0];
    var dyc = pt[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
        if (dxl > 0) {
            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
        }
        else {
            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
    }
    else if (dyl > 0) {
        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    }
    else {
        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
}
/**
 * compareCoords
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {boolean} true/false if coord pairs match
 */
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
exports["default"] = booleanDisjoint;


/***/ }),

/***/ 1333:
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 1353:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.h3 = record_action;
exports.k8 = record_finish;
exports.DS = record_finish_edit;
exports.WH = record_finish_move;
exports.tN = undo;
exports.ZS = redo;
__webpack_unused_export__ = redo_action;
// Import ULabel from ../src/index - TypeScript will find ../src/index.d.ts for types
// and resolve to ../src/index.js at runtime after compilation
var index_1 = __webpack_require__(7105);
var configuration_1 = __webpack_require__(496);
var annotation_operators_1 = __webpack_require__(2571);
var annotation_1 = __webpack_require__(5573);
var error_logging_1 = __webpack_require__(5638);
// ================= Record Actions =================
/**
 * Record an action in the action stream to allow undo/redo functionality.
 * Also trigger any listeners associated with the action.
 *
 * @param ulabel ULabel instance
 * @param raw_action action to record
 * @param is_redo whether ulabel action is a redo or not
 * @param add_to_action_stream whether to add the action to the action stream
 */
function record_action(ulabel, raw_action, is_redo, add_to_action_stream) {
    if (is_redo === void 0) { is_redo = false; }
    if (add_to_action_stream === void 0) { add_to_action_stream = true; }
    ulabel.set_saved(false);
    var current_subtask = ulabel.get_current_subtask();
    var annotation = current_subtask.annotations.access[raw_action.annotation_id];
    // After a new action, you can no longer redo old actions
    if (add_to_action_stream && !is_redo) {
        current_subtask.actions.undone_stack = [];
    }
    // Stringify the undo/redo payloads
    var act_type = raw_action.act_type;
    var action = {
        act_type: act_type,
        annotation_id: raw_action.annotation_id,
        frame: raw_action.frame,
        undo_payload: JSON.stringify(raw_action.undo_payload),
        redo_payload: JSON.stringify(raw_action.redo_payload),
        prev_timestamp: (annotation === null || annotation === void 0 ? void 0 : annotation.last_edited_at) || null,
        prev_user: (annotation === null || annotation === void 0 ? void 0 : annotation.last_edited_by) || "unknown",
    };
    // Add to stream
    if (add_to_action_stream) {
        current_subtask.actions.stream.push(action);
        // For some redo actions the annotation may no longer exist
        if (annotation !== undefined) {
            // Update annotation edit info
            annotation.last_edited_at = index_1.ULabel.get_time();
            annotation.last_edited_by = ulabel.config.username;
        }
    }
    // Trigger any listeners for the action
    trigger_action_listeners(ulabel, action, false, is_redo);
}
;
/**
 * Finish an action in the action stream.
 *
 * @param ulabel ULabel instance
 * @param active_id ID of the active annotation
 */
function record_finish(ulabel, active_id) {
    // Set up constants for convenience
    var current_subtask = ulabel.get_current_subtask();
    var action = current_subtask.actions.stream.pop();
    // Parse and complete the redo payload
    var redo_payload = JSON.parse(action.redo_payload);
    redo_payload.init_spatial = current_subtask.annotations.access[active_id].spatial_payload;
    redo_payload.finished = true;
    action.redo_payload = JSON.stringify(redo_payload);
    // Add the completed action back to the stream
    current_subtask.actions.stream.push(action);
}
/**
 * Finish an edit action in the action stream.
 *
 * @param ulabel ULabel instance
 * @param active_id ID of the active annotation
 */
function record_finish_edit(ulabel, active_id) {
    // Set up constants for convenience
    var current_subtask = ulabel.get_current_subtask();
    var stream = current_subtask.actions.stream;
    // Iterate backwards through the action stream to find the source "begin_edit" action
    var action = null;
    for (var i = stream.length - 1; i >= 0; i--) {
        if (stream[i].act_type === "begin_edit" && stream[i].annotation_id === active_id) {
            action = stream[i];
            break;
        }
    }
    // If no action was found, log an error and return
    if (action === null) {
        (0, error_logging_1.log_message)("No \"begin_edit\" action found for annotation ID: ".concat(active_id), error_logging_1.LogLevel.ERROR, true);
        return;
    }
    // Parse and complete the redo payload
    var redo_payload = JSON.parse(action.redo_payload);
    redo_payload.annotation = current_subtask.annotations.access[active_id];
    redo_payload.finished = true;
    action.redo_payload = JSON.stringify(redo_payload);
    // Record action without adding to the action stream
    // The "begin_edit" action in the action stream is what is used to
    // undo/redo the edit
    record_action(ulabel, {
        act_type: "finish_edit",
        annotation_id: active_id,
        frame: ulabel.state.current_frame,
        undo_payload: {},
        redo_payload: {},
    }, false, false);
}
/**
 * Finish a move action in the action stream.
 *
 * @param ulabel ULabel instance
 * @param diffX x-axis translation
 * @param diffY y-axis translation
 * @param diffZ z-axis translation
 * @param move_not_allowed whether the move is not allowed (used when allow_annotations_outside_image = false)
 */
function record_finish_move(ulabel, diffX, diffY, diffZ, move_not_allowed) {
    if (diffZ === void 0) { diffZ = 0; }
    if (move_not_allowed === void 0) { move_not_allowed = false; }
    // Set up constants for convenience
    var current_subtask = ulabel.get_current_subtask();
    var action = current_subtask.actions.stream.pop();
    // Parse and complete the redo/undo payloads
    var redo_payload = JSON.parse(action.redo_payload);
    var undo_payload = JSON.parse(action.undo_payload);
    redo_payload.diffX = diffX;
    redo_payload.diffY = diffY;
    redo_payload.diffZ = diffZ;
    undo_payload.diffX = -diffX;
    undo_payload.diffY = -diffY;
    undo_payload.diffZ = -diffZ;
    redo_payload.finished = true;
    redo_payload.move_not_allowed = move_not_allowed;
    action.redo_payload = JSON.stringify(redo_payload);
    action.undo_payload = JSON.stringify(undo_payload);
    // Add the completed action back to the stream
    current_subtask.actions.stream.push(action);
    // Record action without adding to the action stream
    // The "begin_move" action in the action stream is what is used to
    // undo/redo the move
    record_action(ulabel, {
        act_type: "finish_move",
        annotation_id: action.annotation_id,
        frame: ulabel.state.current_frame,
        undo_payload: {},
        redo_payload: {},
    }, false, false);
}
;
/**
 * Finish an action in the action stream.
 *
 * @param ulabel ULabel instance
 * @param action Action to finish
 */
function finish_action(ulabel, action) {
    switch (action.act_type) {
        case "begin_annotation":
        case "begin_edit":
        case "begin_move":
            ulabel.end_drag(ulabel.state.last_move);
            break;
        default:
            break;
    }
}
// ================= Action Listeners =================
function trigger_action_listeners(ulabel, action, is_undo, is_redo) {
    if (is_undo === void 0) { is_undo = false; }
    if (is_redo === void 0) { is_redo = false; }
    var action_map = {
        begin_annotation: {
            action: on_start_annotation_spatial_modification,
            undo: on_annotation_deletion,
        },
        create_nonspatial_annotation: {
            action: on_start_annotation_spatial_modification,
            undo: on_annotation_deletion,
        },
        continue_edit: {
            action: on_in_progress_annotation_spatial_modification,
        },
        continue_move: {
            action: on_in_progress_annotation_spatial_modification,
        },
        continue_brush: {
            action: on_in_progress_annotation_spatial_modification,
        },
        continue_annotation: {
            action: on_in_progress_annotation_spatial_modification,
        },
        create_annotation: {
            action: on_finish_annotation_spatial_modification,
            undo: on_annotation_deletion,
        },
        finish_modify_annotation: {
            action: on_finish_annotation_spatial_modification,
            undo: on_finish_annotation_spatial_modification,
        },
        finish_edit: {
            action: on_finish_annotation_spatial_modification,
        },
        finish_move: {
            action: on_finish_annotation_spatial_modification,
        },
        finish_annotation: {
            action: on_finish_annotation_spatial_modification,
            undo: on_finish_annotation_spatial_modification,
        },
        cancel_annotation: {
            action: on_finish_annotation_spatial_modification,
            undo: on_annotation_revert,
        },
        delete_annotation: {
            action: on_annotation_deletion,
            undo: on_finish_annotation_spatial_modification,
        },
        assign_annotation_id: {
            action: on_annotation_id_change,
            undo: on_annotation_id_change,
        },
        begin_edit: {
            undo: on_finish_annotation_spatial_modification,
            redo: on_finish_annotation_spatial_modification,
        },
        begin_move: {
            undo: on_finish_annotation_spatial_modification,
            redo: on_finish_annotation_spatial_modification,
        },
        start_complex_polygon: {
            undo: on_finish_annotation_spatial_modification,
        },
        merge_polygon_complex_layer: {
            undo: on_annotation_revert,
        },
        simplify_polygon_complex_layer: {
            undo: on_annotation_revert,
        },
        begin_brush: {
            undo: on_annotation_revert,
        },
        delete_annotations_in_polygon: {
        // No listener for this action.
        // It handles the re-rendering of the affected annotations itself.
        },
    };
    // Call the appropriate listener
    if (action.act_type in action_map) {
        if ((!is_undo && !is_redo && "action" in action_map[action.act_type]) ||
            // For actions without a specific "redo" listener, call the "action" listener instead
            (is_redo && !("redo" in action_map[action.act_type]) && "action" in action_map[action.act_type])) {
            action_map[action.act_type].action(ulabel, action);
        }
        else if (is_undo && "undo" in action_map[action.act_type]) {
            action_map[action.act_type].undo(ulabel, action, is_undo);
        }
        else if (is_redo && "redo" in action_map[action.act_type]) {
            action_map[action.act_type].redo(ulabel, action);
        }
    }
}
/**
 * Triggered when an annotation is started.
 *
 * @param ulabel ULabel instance
 * @param action ULabelAction instance
 * @param is_undo whether the action is an undo action
 */
function on_start_annotation_spatial_modification(ulabel, action, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
is_undo) {
    if (is_undo === void 0) { is_undo = false; }
    // Draw new annotation
    ulabel.draw_annotation_from_id(action.annotation_id);
}
/**
 * For modes like edit, move, brush, etc, in-progress changes need to be rendered.
 *
 * @param ulabel ULabel instance
 * @param action ULabelAction instance
 * @param is_undo whether the action is an undo action
 */
function on_in_progress_annotation_spatial_modification(ulabel, action, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
is_undo) {
    var _a;
    if (is_undo === void 0) { is_undo = false; }
    var subtask_key = ulabel.get_current_subtask_key();
    var current_subtask = ulabel.subtasks[subtask_key];
    var offset = ((_a = current_subtask.state.move_candidate) === null || _a === void 0 ? void 0 : _a.offset) || {
        id: action.annotation_id,
        diffX: 0,
        diffY: 0,
        diffZ: 0,
    };
    // Update the toolbox filter distance
    ulabel.update_filter_distance_during_polyline_move(action.annotation_id, true, false, offset);
    // Update the annotation rendering
    ulabel.rebuild_containing_box(action.annotation_id, false, subtask_key);
    ulabel.redraw_annotation(action.annotation_id, subtask_key, offset);
    // Update dialogs
    ulabel.suggest_edits();
}
/**
 * Triggered when an annotation is modified.
 *
 * @param ulabel ULabel instance
 * @param action Action that was completed
 * @param is_undo whether the action is an undo
 * @param is_redo whether the action is a redo
 */
function on_finish_annotation_spatial_modification(ulabel, action, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
is_undo) {
    if (is_undo === void 0) { is_undo = false; }
    // Update annotation rendering
    ulabel.rebuild_containing_box(action.annotation_id);
    ulabel.redraw_annotation(action.annotation_id);
    // Update dialogs
    ulabel.suggest_edits(null, null, true);
    // Update the toolbox
    ulabel.update_filter_distance(action.annotation_id);
    ulabel.toolbox.redraw_update_items(ulabel);
    // Ensure there are no lingering enders
    ulabel.destroy_polygon_ender(action.annotation_id);
}
/**
 * Triggered when an annotation is deleted.
 *
 * @param ulabel ULabel instance
 * @param action ULabelAction instance
 * @param is_undo Whether the action is an undo
 */
function on_annotation_deletion(ulabel, action, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
is_undo) {
    var _a;
    if (is_undo === void 0) { is_undo = false; }
    // Sometimes the annotation is just deprecated, and sometimes it is fully deleted
    // Check if it still exists, because if so we need to redraw
    var current_subtask = ulabel.get_current_subtask();
    var annotations = current_subtask.annotations.access;
    if (action.annotation_id in annotations) {
        var spatial_type = (_a = annotations[action.annotation_id]) === null || _a === void 0 ? void 0 : _a.spatial_type;
        if (annotation_1.NONSPATIAL_MODES.includes(spatial_type)) {
            // Render the change
            ulabel.clear_nonspatial_annotation(action.annotation_id);
        }
        else {
            ulabel.redraw_annotation(action.annotation_id);
            // Force filter points if necessary
            if (annotations[action.annotation_id].spatial_type === "polyline") {
                ulabel.update_filter_distance(action.annotation_id, false, true);
            }
        }
    }
    // Ensure there are no lingering enders
    ulabel.destroy_polygon_ender(action.annotation_id);
    // Update dialogs
    ulabel.suggest_edits(null, null, true);
    // Update the toolbox
    ulabel.toolbox.redraw_update_items(ulabel);
}
/**
 * Triggered when an annotation ID is changed.
 *
 * @param ulabel ULabel instance
 * @param action ULabelAction instance
 * @param is_undo Whether the action is an undo action
 */
function on_annotation_id_change(ulabel, action, is_undo) {
    if (is_undo === void 0) { is_undo = false; }
    // Update the annotation rendering
    ulabel.redraw_annotation(action.annotation_id);
    ulabel.recolor_active_polygon_ender();
    ulabel.recolor_brush_circle();
    // Update dialogs
    if (!is_undo) {
        // Hide the large ID dialog after the user has made a selection
        ulabel.hide_id_dialog();
    }
    ulabel.suggest_edits(null, null, true);
    // Determine if we need to update the filter distance
    // If the filter_distance_toolbox_item exists,
    // Check if the FilterDistance ToolboxItem is in this ULabel instance
    if (ulabel.config.toolbox_order.includes(configuration_1.AllowedToolboxItem.FilterDistance)) {
        var spatial_type = ulabel.get_current_subtask().annotations.access[action.annotation_id].spatial_type;
        if (spatial_type === "polyline") {
            // Get the toolbox item
            var filter_distance_toolbox_item = ulabel.toolbox.items.find(function (item) { return item.get_toolbox_item_type() === "FilterDistance"; });
            // filter annotations if in multi_class_mode
            if (filter_distance_toolbox_item === null || filter_distance_toolbox_item === void 0 ? void 0 : filter_distance_toolbox_item.multi_class_mode) {
                (0, annotation_operators_1.filter_points_distance_from_line)(ulabel, true);
            }
        }
    }
    // Update toolbox
    ulabel.toolbox.redraw_update_items(ulabel);
}
/**
 * Triggered when an annotation is fully reverted as part of an undo action.
 *
 * @param ulabel ULabel instance
 * @param action ULabelAction instance
 * @param is_undo whether the action is an undo action
 */
function on_annotation_revert(ulabel, action, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
is_undo) {
    if (is_undo === void 0) { is_undo = false; }
    // Redraw the annotation
    ulabel.redraw_annotation(action.annotation_id);
}
// ================= Undo / Redo =================
/**
 * Undo the last action in the action stream.
 *
 * @param ulabel ULabel instance
 * @param is_internal_undo whether ulabel undo is triggered by an internal action
 */
function undo(ulabel, is_internal_undo) {
    if (is_internal_undo === void 0) { is_internal_undo = false; }
    // Create constants for convenience
    var current_subtask = ulabel.get_current_subtask();
    var action_stream = current_subtask.actions.stream;
    var undone_stack = current_subtask.actions.undone_stack;
    // If the action_steam is empty, then there are no actions to undo
    if (action_stream.length === 0)
        return;
    if (!current_subtask.state.idd_thumbnail) {
        ulabel.hide_id_dialog();
    }
    var undo_candidate = action_stream.pop();
    // Finish action if it is marked as unfinished
    if (JSON.parse(undo_candidate.redo_payload).finished === false) {
        // Push action back to the stream, finish, then pop it again
        // TODO: better way of doing this?
        action_stream.push(undo_candidate);
        finish_action(ulabel, undo_candidate);
        undo_candidate = action_stream.pop();
    }
    // Set internal undo status
    undo_candidate.is_internal_undo = is_internal_undo;
    undone_stack.push(undo_candidate);
    undo_action(ulabel, undo_candidate);
    // Trigger any listeners for the action
    trigger_action_listeners(ulabel, undo_candidate, true);
}
/**
 * Redo the last undone action.
 *
 * @param ulabel ULabel instance
 */
function redo(ulabel) {
    // Create constants for convenience
    var current_subtask = ulabel.get_current_subtask();
    var undone_stack = current_subtask.actions.undone_stack;
    // If the action_steam is empty, then there are no actions to redo
    if (undone_stack.length === 0)
        return;
    // Redo the action
    var redo_candidate = undone_stack.pop();
    redo_action(ulabel, redo_candidate);
}
/**
 * Call the appropriate undo function for the given action type.
 *
 * @param ulabel ULabel instance
 * @param action Action to undo
 */
function undo_action(ulabel, action) {
    ulabel.update_frame(null, action.frame);
    var undo_payload = JSON.parse(action.undo_payload);
    var annotations = ulabel.get_current_subtask().annotations.access;
    // For some actions like delete_annotations_in_polygon, the annotation may no longer exist
    if (action.annotation_id in annotations) {
        var annotation = annotations[action.annotation_id];
        // Revert the annotation's last edited info
        annotation.last_edited_at = action.prev_timestamp;
        annotation.last_edited_by = action.prev_user;
    }
    switch (action.act_type) {
        case "begin_annotation":
            ulabel.begin_annotation__undo(action.annotation_id);
            break;
        case "continue_annotation":
            ulabel.continue_annotation__undo(action.annotation_id);
            break;
        case "finish_annotation":
            ulabel.finish_annotation__undo(action.annotation_id);
            break;
        case "begin_edit":
            ulabel.begin_edit__undo(action.annotation_id, undo_payload);
            break;
        case "begin_move":
            ulabel.begin_move__undo(action.annotation_id, undo_payload);
            break;
        case "delete_annotation":
            ulabel.delete_annotation__undo(action.annotation_id);
            break;
        case "cancel_annotation":
            ulabel.cancel_annotation__undo(action.annotation_id, undo_payload);
            break;
        case "assign_annotation_id":
            ulabel.assign_annotation_id__undo(action.annotation_id, undo_payload);
            break;
        case "create_annotation":
            ulabel.create_annotation__undo(action.annotation_id);
            break;
        case "create_nonspatial_annotation":
            ulabel.create_nonspatial_annotation__undo(action.annotation_id);
            break;
        case "start_complex_polygon":
            ulabel.start_complex_polygon__undo(action.annotation_id);
            break;
        case "merge_polygon_complex_layer":
            ulabel.merge_polygon_complex_layer__undo(action.annotation_id, undo_payload);
            // If the undo was triggered by the user, they
            // expect ctrl+z to undo the previous action as well
            if (!action.is_internal_undo) {
                undo(ulabel);
            }
            break;
        case "simplify_polygon_complex_layer":
            ulabel.simplify_polygon_complex_layer__undo(action.annotation_id, undo_payload);
            // If the undo was triggered by the user, they
            // expect ctrl+z to undo the previous action as well
            if (!action.is_internal_undo) {
                undo(ulabel);
            }
            break;
        case "delete_annotations_in_polygon":
            ulabel.delete_annotations_in_polygon__undo(undo_payload);
            break;
        case "begin_brush":
            ulabel.begin_brush__undo(action.annotation_id, undo_payload);
            break;
        case "finish_modify_annotation":
            ulabel.finish_modify_annotation__undo(action.annotation_id, undo_payload);
            break;
        default:
            (0, error_logging_1.log_message)("Action type not recognized for undo: ".concat(action.act_type), error_logging_1.LogLevel.WARNING);
            break;
    }
}
/**
 * Call the appropriate redo function for the given action type.
 *
 * @param ulabel ULabel instance
 * @param action Action to redo
 */
function redo_action(ulabel, action) {
    ulabel.update_frame(null, action.frame);
    var redo_payload = JSON.parse(action.redo_payload);
    switch (action.act_type) {
        case "begin_annotation":
            ulabel.begin_annotation(null, action.annotation_id, redo_payload);
            break;
        case "continue_annotation":
            ulabel.continue_annotation(null, null, action.annotation_id, redo_payload);
            break;
        case "finish_annotation":
            ulabel.finish_annotation__redo(action.annotation_id);
            break;
        case "begin_edit":
            ulabel.begin_edit__redo(action.annotation_id, redo_payload);
            break;
        case "begin_move":
            ulabel.begin_move__redo(action.annotation_id, redo_payload);
            break;
        case "delete_annotation":
            ulabel.delete_annotation__redo(action.annotation_id);
            break;
        case "cancel_annotation":
            ulabel.cancel_annotation(action.annotation_id);
            break;
        case "assign_annotation_id":
            ulabel.assign_annotation_id(action.annotation_id, redo_payload);
            break;
        case "create_annotation":
            ulabel.create_annotation__redo(action.annotation_id, redo_payload);
            break;
        case "create_nonspatial_annotation":
            ulabel.create_nonspatial_annotation(action.annotation_id, redo_payload);
            break;
        case "start_complex_polygon":
            ulabel.start_complex_polygon(action.annotation_id);
            break;
        case "merge_polygon_complex_layer":
            ulabel.merge_polygon_complex_layer(action.annotation_id, redo_payload.layer_idx, false, true);
            break;
        case "simplify_polygon_complex_layer":
            ulabel.simplify_polygon_complex_layer(action.annotation_id, redo_payload.active_idx, true);
            // Since this is an internal operation, user expects redo of the next action
            ulabel.redo();
            break;
        case "delete_annotations_in_polygon":
            ulabel.delete_annotations_in_polygon(action.annotation_id, redo_payload);
            break;
        case "finish_modify_annotation":
            ulabel.finish_modify_annotation__redo(action.annotation_id, redo_payload);
            break;
        default:
            (0, error_logging_1.log_message)("Action type not recognized for redo: ".concat(action.act_type), error_logging_1.LogLevel.WARNING);
            break;
    }
}


/***/ }),

/***/ 1356:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);
var d3voronoi = __webpack_require__(3227);

/**
 * @private
 * @param {Array<Array<number>>} coords representing a polygon
 * @returns {Feature<Polygon>} polygon
 */
function coordsToPolygon(coords) {
  coords = coords.slice();
  coords.push(coords[0]);
  return helpers.polygon([coords]);
}

/**
 * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection
 * of Voronoi polygons.
 *
 * The Voronoi algorithim used comes from the d3-voronoi package.
 *
 * @name voronoi
 * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.
 * @param {Object} [options={}] Optional parameters
 * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.
 * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.
 * @example
 * var options = {
 *   bbox: [-70, 40, -60, 60]
 * };
 * var points = turf.randomPoint(100, options);
 * var voronoiPolygons = turf.voronoi(points, options);
 *
 * //addToMap
 * var addToMap = [voronoiPolygons, points];
 */
function voronoi(points, options) {
  // Optional params
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var bbox = options.bbox || [-180, -85, 180, 85];

  // Input Validation
  if (!points) throw new Error("points is required");
  if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
  invariant.collectionOf(points, "Point", "points");

  // Main
  return helpers.featureCollection(
    d3voronoi.voronoi()
      .x(function (feature) {
        return feature.geometry.coordinates[0];
      })
      .y(function (feature) {
        return feature.geometry.coordinates[1];
      })
      .extent([
        [bbox[0], bbox[1]],
        [bbox[2], bbox[3]],
      ])
      .polygons(points.features)
      .map(coordsToPolygon)
  );
}

module.exports = voronoi;
module.exports["default"] = voronoi;


/***/ }),

/***/ 1424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ULABEL_VERSION: () => (/* binding */ ULABEL_VERSION)
/* harmony export */ });
const ULABEL_VERSION = "0.21.0";


/***/ }),

/***/ 1476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pointInPolygonFlat = __webpack_require__(3841)
var pointInPolygonNested = __webpack_require__(1137)

module.exports = function pointInPolygon (point, vs, start, end) {
    if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
    } else {
        return pointInPolygonFlat(point, vs, start, end);
    }
}
module.exports.nested = pointInPolygonNested
module.exports.flat = pointInPolygonFlat


/***/ }),

/***/ 1484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bbox_1 = __importDefault(__webpack_require__(4383));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var rbush_1 = __importDefault(__webpack_require__(2903));
/**
 * Merges a specified property from a FeatureCollection of points into a
 * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`
 * for polygons, this finds every point that lies within each polygon, collects the
 * `inProperty` values from those points, and adds them as an array to `outProperty`
 * on the polygon.
 *
 * @name collect
 * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate
 * @param {FeatureCollection<Point>} points points to be aggregated
 * @param {string} inProperty property to be nested from
 * @param {string} outProperty property to be nested into
 * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`
 * @example
 * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);
 * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);
 * var polyFC = turf.featureCollection([poly1, poly2]);
 * var pt1 = turf.point([5,5], {population: 200});
 * var pt2 = turf.point([1,3], {population: 600});
 * var pt3 = turf.point([14,2], {population: 100});
 * var pt4 = turf.point([13,1], {population: 200});
 * var pt5 = turf.point([19,7], {population: 300});
 * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);
 * var collected = turf.collect(polyFC, pointFC, 'population', 'values');
 * var values = collected.features[0].properties.values
 * //=values => [200, 600]
 *
 * //addToMap
 * var addToMap = [pointFC, collected]
 */
function collect(polygons, points, inProperty, outProperty) {
    var rtree = rbush_1.default(6);
    var treeItems = points.features.map(function (item) {
        var _a;
        return {
            minX: item.geometry.coordinates[0],
            minY: item.geometry.coordinates[1],
            maxX: item.geometry.coordinates[0],
            maxY: item.geometry.coordinates[1],
            property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty],
        };
    });
    rtree.load(treeItems);
    polygons.features.forEach(function (poly) {
        if (!poly.properties) {
            poly.properties = {};
        }
        var bbox = bbox_1.default(poly);
        var potentialPoints = rtree.search({
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3],
        });
        var values = [];
        potentialPoints.forEach(function (pt) {
            if (boolean_point_in_polygon_1.default([pt.minX, pt.minY], poly)) {
                values.push(pt.property);
            }
        });
        poly.properties[outProperty] = values;
    });
    return polygons;
}
exports["default"] = collect;


/***/ }),

/***/ 1514:
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 1582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var RBush = __webpack_require__(5341);
var Queue = __webpack_require__(4262);
var pointInPolygon = __webpack_require__(1476);
var orient = (__webpack_require__(3467).orient2d);

// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18
if (Queue.default) {
    Queue = Queue.default;
}

module.exports = concaveman;
module.exports["default"] = concaveman;

function concaveman(points, concavity, lengthThreshold) {
    // a relative measure of concavity; higher value means simpler hull
    concavity = Math.max(0, concavity === undefined ? 2 : concavity);

    // when a segment goes below this length threshold, it won't be drilled down further
    lengthThreshold = lengthThreshold || 0;

    // start with a convex hull of the points
    var hull = fastConvexHull(points);

    // index the points with an R-tree
    var tree = new RBush(16);
    tree.toBBox = function (a) {
        return {
            minX: a[0],
            minY: a[1],
            maxX: a[0],
            maxY: a[1]
        };
    };
    tree.compareMinX = function (a, b) { return a[0] - b[0]; };
    tree.compareMinY = function (a, b) { return a[1] - b[1]; };

    tree.load(points);

    // turn the convex hull into a linked list and populate the initial edge queue with the nodes
    var queue = [];
    for (var i = 0, last; i < hull.length; i++) {
        var p = hull[i];
        tree.remove(p);
        last = insertNode(p, last);
        queue.push(last);
    }

    // index the segments with an R-tree (for intersection checks)
    var segTree = new RBush(16);
    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));

    var sqConcavity = concavity * concavity;
    var sqLenThreshold = lengthThreshold * lengthThreshold;

    // process edges one by one
    while (queue.length) {
        var node = queue.shift();
        var a = node.p;
        var b = node.next.p;

        // skip the edge if it's already short enough
        var sqLen = getSqDist(a, b);
        if (sqLen < sqLenThreshold) continue;

        var maxSqLen = sqLen / sqConcavity;

        // find the best connection point for the current edge to flex inward to
        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);

        // if we found a connection and it satisfies our concavity measure
        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            // connect the edge endpoints through this point and add 2 new edges to the queue
            queue.push(node);
            queue.push(insertNode(p, node));

            // update point and segment indexes
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
        }
    }

    // convert the resulting hull linked list to an array of points
    node = last;
    var concave = [];
    do {
        concave.push(node.p);
        node = node.next;
    } while (node !== last);

    concave.push(node.p);

    return concave;
}

function findCandidate(tree, a, b, c, d, maxDist, segTree) {
    var queue = new Queue([], compareDist);
    var node = tree.data;

    // search through the point R-tree with a depth-first search using a priority queue
    // in the order of distance to the edge (b, c)
    while (node) {
        for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist) continue; // skip the node if it's farther than we ever need

            queue.push({
                node: child,
                dist: dist
            });
        }

        while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;

            // skip all points that are as close to adjacent edges (a,b) and (c,d),
            // and points that would introduce self-intersections when connected
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 &&
                noIntersections(b, p, segTree) &&
                noIntersections(c, p, segTree)) return p;
        }

        node = queue.pop();
        if (node) node = node.node;
    }

    return null;
}

function compareDist(a, b) {
    return a.dist - b.dist;
}

// square distance from a segment bounding box to the given one
function sqSegBoxDist(a, b, bbox) {
    if (inside(a, bbox) || inside(b, bbox)) return 0;
    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
    if (d1 === 0) return 0;
    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
    if (d2 === 0) return 0;
    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
    if (d3 === 0) return 0;
    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
    if (d4 === 0) return 0;
    return Math.min(d1, d2, d3, d4);
}

function inside(a, bbox) {
    return a[0] >= bbox.minX &&
           a[0] <= bbox.maxX &&
           a[1] >= bbox.minY &&
           a[1] <= bbox.maxY;
}

// check if the edge (a,b) doesn't intersect any other edges
function noIntersections(a, b, segTree) {
    var minX = Math.min(a[0], b[0]);
    var minY = Math.min(a[1], b[1]);
    var maxX = Math.max(a[0], b[0]);
    var maxY = Math.max(a[1], b[1]);

    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});
    for (var i = 0; i < edges.length; i++) {
        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;
    }
    return true;
}

function cross(p1, p2, p3) {
    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

// check if the edges (p1,q1) and (p2,q2) intersect
function intersects(p1, q1, p2, q2) {
    return p1 !== q2 && q1 !== p2 &&
        cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&
        cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
}

// update the bounding box of a node's edge
function updateBBox(node) {
    var p1 = node.p;
    var p2 = node.next.p;
    node.minX = Math.min(p1[0], p2[0]);
    node.minY = Math.min(p1[1], p2[1]);
    node.maxX = Math.max(p1[0], p2[0]);
    node.maxY = Math.max(p1[1], p2[1]);
    return node;
}

// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points
function fastConvexHull(points) {
    var left = points[0];
    var top = points[0];
    var right = points[0];
    var bottom = points[0];

    // find the leftmost, rightmost, topmost and bottommost points
    for (var i = 0; i < points.length; i++) {
        var p = points[i];
        if (p[0] < left[0]) left = p;
        if (p[0] > right[0]) right = p;
        if (p[1] < top[1]) top = p;
        if (p[1] > bottom[1]) bottom = p;
    }

    // filter out points that are inside the resulting quadrilateral
    var cull = [left, top, right, bottom];
    var filtered = cull.slice();
    for (i = 0; i < points.length; i++) {
        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);
    }

    // get convex hull around the filtered points
    return convexHull(filtered);
}

// create a new node in a doubly linked list
function insertNode(p, prev) {
    var node = {
        p: p,
        prev: null,
        next: null,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
    };

    if (!prev) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = prev.next;
        node.prev = prev;
        prev.next.prev = node;
        prev.next = node;
    }
    return node;
}

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function sqSegDist(p, p1, p2) {

    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday
function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
    var ux = x1 - x0;
    var uy = y1 - y0;
    var vx = x3 - x2;
    var vy = y3 - y2;
    var wx = x0 - x2;
    var wy = y0 - y2;
    var a = ux * ux + uy * uy;
    var b = ux * vx + uy * vy;
    var c = vx * vx + vy * vy;
    var d = ux * wx + uy * wy;
    var e = vx * wx + vy * wy;
    var D = a * c - b * b;

    var sc, sN, tc, tN;
    var sD = D;
    var tD = D;

    if (D === 0) {
        sN = 0;
        sD = 1;
        tN = e;
        tD = c;
    } else {
        sN = b * e - c * d;
        tN = a * e - b * d;
        if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
        } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
        }
    }

    if (tN < 0.0) {
        tN = 0.0;
        if (-d < 0.0) sN = 0.0;
        else if (-d > a) sN = sD;
        else {
            sN = -d;
            sD = a;
        }
    } else if (tN > tD) {
        tN = tD;
        if ((-d + b) < 0.0) sN = 0;
        else if (-d + b > a) sN = sD;
        else {
            sN = -d + b;
            sD = a;
        }
    }

    sc = sN === 0 ? 0 : sN / sD;
    tc = tN === 0 ? 0 : tN / tD;

    var cx = (1 - sc) * x0 + sc * x1;
    var cy = (1 - sc) * y0 + sc * y1;
    var cx2 = (1 - tc) * x2 + tc * x3;
    var cy2 = (1 - tc) * y2 + tc * y3;
    var dx = cx2 - cx;
    var dy = cy2 - cy;

    return dx * dx + dy * dy;
}

function compareByX(a, b) {
    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
}

function convexHull(points) {
    points.sort(compareByX);

    var lower = [];
    for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
        }
        lower.push(points[i]);
    }

    var upper = [];
    for (var ii = points.length - 1; ii >= 0; ii--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
        }
        upper.push(points[ii]);
    }

    upper.pop();
    lower.pop();
    return lower.concat(upper);
}


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(8452);
var callBind = __webpack_require__(487);

var implementation = __webpack_require__(7675);
var getPolyfill = __webpack_require__(5330);
var shim = __webpack_require__(3984);

var flagsBound = callBind(getPolyfill());

define(flagsBound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = flagsBound;


/***/ }),

/***/ 1715:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  geoAlbers: () => (/* reexport */ albers),
  geoAlbersUsa: () => (/* reexport */ albersUsa),
  geoArea: () => (/* reexport */ src_area),
  geoAzimuthalEqualArea: () => (/* reexport */ azimuthalEqualArea),
  geoAzimuthalEqualAreaRaw: () => (/* reexport */ azimuthalEqualAreaRaw),
  geoAzimuthalEquidistant: () => (/* reexport */ azimuthalEquidistant),
  geoAzimuthalEquidistantRaw: () => (/* reexport */ azimuthalEquidistantRaw),
  geoBounds: () => (/* reexport */ bounds),
  geoCentroid: () => (/* reexport */ centroid),
  geoCircle: () => (/* reexport */ circle),
  geoClipExtent: () => (/* reexport */ clip_extent),
  geoConicConformal: () => (/* reexport */ conicConformal),
  geoConicConformalRaw: () => (/* reexport */ conicConformalRaw),
  geoConicEqualArea: () => (/* reexport */ conicEqualArea),
  geoConicEqualAreaRaw: () => (/* reexport */ conicEqualAreaRaw),
  geoConicEquidistant: () => (/* reexport */ conicEquidistant),
  geoConicEquidistantRaw: () => (/* reexport */ conicEquidistantRaw),
  geoContains: () => (/* reexport */ contains),
  geoDistance: () => (/* reexport */ distance),
  geoEquirectangular: () => (/* reexport */ equirectangular),
  geoEquirectangularRaw: () => (/* reexport */ equirectangularRaw),
  geoGnomonic: () => (/* reexport */ gnomonic),
  geoGnomonicRaw: () => (/* reexport */ gnomonicRaw),
  geoGraticule: () => (/* reexport */ graticule),
  geoGraticule10: () => (/* reexport */ graticule10),
  geoIdentity: () => (/* reexport */ projection_identity),
  geoInterpolate: () => (/* reexport */ interpolate),
  geoLength: () => (/* reexport */ src_length),
  geoMercator: () => (/* reexport */ mercator),
  geoMercatorRaw: () => (/* reexport */ mercatorRaw),
  geoNaturalEarth1: () => (/* reexport */ naturalEarth1),
  geoNaturalEarth1Raw: () => (/* reexport */ naturalEarth1Raw),
  geoOrthographic: () => (/* reexport */ orthographic),
  geoOrthographicRaw: () => (/* reexport */ orthographicRaw),
  geoPath: () => (/* reexport */ path),
  geoProjection: () => (/* reexport */ projection),
  geoProjectionMutator: () => (/* reexport */ projectionMutator),
  geoRotation: () => (/* reexport */ rotation),
  geoStereographic: () => (/* reexport */ stereographic),
  geoStereographicRaw: () => (/* reexport */ stereographicRaw),
  geoStream: () => (/* reexport */ stream),
  geoTransform: () => (/* reexport */ transform),
  geoTransverseMercator: () => (/* reexport */ transverseMercator),
  geoTransverseMercatorRaw: () => (/* reexport */ transverseMercatorRaw)
});

;// ./node_modules/d3-geo/src/adder.js
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

/* harmony default export */ function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

;// ./node_modules/d3-geo/src/math.js
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

;// ./node_modules/d3-geo/src/noop.js
function noop() {}

;// ./node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function stream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

;// ./node_modules/d3-geo/src/area.js





var areaRingSum = adder();

var areaSum = adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos(phi),
      sinPhi = sin(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos(adLambda),
      v = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ function src_area(object) {
  areaSum.reset();
  stream(object, areaStream);
  return areaSum * 2;
}

;// ./node_modules/d3-geo/src/cartesian.js


function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

;// ./node_modules/d3-geo/src/bounds.js






var bounds_lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    bounds_lambda00, bounds_phi00, // first point
    p0, // previous 3D point
    deltaSum = adder(),
    ranges,
    bounds_range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) bounds_lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    bounds_range[0] = bounds_lambda0, bounds_range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(bounds_range = [bounds_lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(bounds_lambda0, lambda) > angle(bounds_lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(bounds_lambda0, lambda1)) bounds_lambda0 = lambda;
      }
    } else {
      if (lambda1 >= bounds_lambda0) {
        if (lambda < bounds_lambda0) bounds_lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(bounds_lambda0, lambda) > angle(bounds_lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(bounds_lambda0, lambda1)) bounds_lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(bounds_range = [bounds_lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  bounds_range[0] = bounds_lambda0, bounds_range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    bounds_lambda00 = lambda, bounds_phi00 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(bounds_lambda00, bounds_phi00);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) bounds_lambda0 = -(lambda1 = 180);
  bounds_range[0] = bounds_lambda0, bounds_range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(bounds_lambda0 = phi0 = Infinity);
  ranges = [];
  stream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, bounds_lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = bounds_range = null;

  return bounds_lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[bounds_lambda0, phi0], [lambda1, phi1]];
}

;// ./node_modules/d3-geo/src/centroid.js




var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    centroid_lambda00, centroid_phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(centroid_lambda00, centroid_phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  centroid_lambda00 = lambda, centroid_phi00 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  stream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
}

;// ./node_modules/d3-geo/src/constant.js
/* harmony default export */ function src_constant(x) {
  return function() {
    return x;
  };
}

;// ./node_modules/d3-geo/src/compose.js
/* harmony default export */ function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

;// ./node_modules/d3-geo/src/rotation.js



function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi),
      sinDeltaPhi = sin(deltaPhi),
      cosDeltaGamma = cos(deltaGamma),
      sinDeltaGamma = sin(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
}

;// ./node_modules/d3-geo/src/circle.js





// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius),
      sinRadius = sin(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

/* harmony default export */ function circle() {
  var center = src_constant([0, 0]),
      radius = src_constant(90),
      precision = src_constant(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : src_constant([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : src_constant(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : src_constant(+_), circle) : precision;
  };

  return circle;
}

;// ./node_modules/d3-geo/src/clip/buffer.js


/* harmony default export */ function buffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

;// ./node_modules/d3-geo/src/clip/line.js
/* harmony default export */ function line(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

;// ./node_modules/d3-geo/src/pointEqual.js


/* harmony default export */ function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

;// ./node_modules/d3-geo/src/clip/polygon.js


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function clip_polygon(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  polygon_link(subject);
  polygon_link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function polygon_link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

;// ./node_modules/d3-array/src/ascending.js
/* harmony default export */ function src_ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// ./node_modules/d3-array/src/bisector.js


/* harmony default export */ function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return src_ascending(f(d), x);
  };
}

;// ./node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(src_ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ const src_bisect = ((/* unused pure expression or super */ null && (bisectRight)));

;// ./node_modules/d3-array/src/array.js
var array = Array.prototype;

var array_slice = array.slice;
var array_map = array.map;

;// ./node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function ticks_tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

;// ./node_modules/d3-array/src/histogram.js









/* harmony default export */ function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

;// ./node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

;// ./node_modules/d3-array/src/merge.js
/* harmony default export */ function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

;// ./node_modules/d3-array/src/range.js
/* harmony default export */ function src_range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

;// ./node_modules/d3-array/src/index.js




























;// ./node_modules/d3-geo/src/clip/extent.js






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipExtent(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = buffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clip_polygon(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (line(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

/* harmony default export */ function clip_extent() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

;// ./node_modules/d3-geo/src/polygonContains.js




var sum = adder();

/* harmony default export */ function polygonContains(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [sin(lambda), -cos(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin(phi0),
        cosPhi0 = cos(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin(phi1),
          cosPhi1 = cos(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > pi,
          k = sinPhi0 * sinPhi1;

      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign * tau : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
}

;// ./node_modules/d3-geo/src/length.js





var lengthSum = adder(),
    length_lambda0,
    length_sinPhi0,
    length_cosPhi0;

var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  length_lambda0 = lambda, length_sinPhi0 = sin(phi), length_cosPhi0 = cos(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin(phi),
      cosPhi = cos(phi),
      delta = abs(lambda - length_lambda0),
      cosDelta = cos(delta),
      sinDelta = sin(delta),
      x = cosPhi * sinDelta,
      y = length_cosPhi0 * sinPhi - length_sinPhi0 * cosPhi * cosDelta,
      z = length_sinPhi0 * sinPhi + length_cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  length_lambda0 = lambda, length_sinPhi0 = sinPhi, length_cosPhi0 = cosPhi;
}

/* harmony default export */ function src_length(object) {
  lengthSum.reset();
  stream(object, lengthStream);
  return +lengthSum;
}

;// ./node_modules/d3-geo/src/distance.js


var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

/* harmony default export */ function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return src_length(object);
}

;// ./node_modules/d3-geo/src/contains.js




var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

/* harmony default export */ function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

;// ./node_modules/d3-geo/src/graticule.js



function graticuleX(y0, y1, dy) {
  var y = src_range(y0, y1 - epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = src_range(x0, x1 - epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return src_range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(src_range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(src_range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
        .concat(src_range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}

function graticule10() {
  return graticule()();
}

;// ./node_modules/d3-geo/src/interpolate.js


/* harmony default export */ function interpolate(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos(y0),
      sy0 = sin(y0),
      cy1 = cos(y1),
      sy1 = sin(y1),
      kx0 = cy0 * cos(x0),
      ky0 = cy0 * sin(x0),
      kx1 = cy1 * cos(x1),
      ky1 = cy1 * sin(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin(d);

  var interpolate = d ? function(t) {
    var B = sin(t *= d) / k,
        A = sin(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
}

;// ./node_modules/d3-geo/src/identity.js
/* harmony default export */ function src_identity(x) {
  return x;
}

;// ./node_modules/d3-geo/src/path/area.js




var area_areaSum = adder(),
    area_areaRingSum = adder(),
    x00,
    y00,
    area_x0,
    area_y0;

var area_areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    area_areaStream.lineStart = area_areaRingStart;
    area_areaStream.lineEnd = area_areaRingEnd;
  },
  polygonEnd: function() {
    area_areaStream.lineStart = area_areaStream.lineEnd = area_areaStream.point = noop;
    area_areaSum.add(abs(area_areaRingSum));
    area_areaRingSum.reset();
  },
  result: function() {
    var area = area_areaSum / 2;
    area_areaSum.reset();
    return area;
  }
};

function area_areaRingStart() {
  area_areaStream.point = area_areaPointFirst;
}

function area_areaPointFirst(x, y) {
  area_areaStream.point = area_areaPoint;
  x00 = area_x0 = x, y00 = area_y0 = y;
}

function area_areaPoint(x, y) {
  area_areaRingSum.add(area_y0 * x - area_x0 * y);
  area_x0 = x, area_y0 = y;
}

function area_areaRingEnd() {
  area_areaPoint(x00, y00);
}

/* harmony default export */ const path_area = (area_areaStream);

;// ./node_modules/d3-geo/src/path/bounds.js


var bounds_x0 = Infinity,
    bounds_y0 = bounds_x0,
    x1 = -bounds_x0,
    y1 = x1;

var bounds_boundsStream = {
  point: bounds_boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[bounds_x0, bounds_y0], [x1, y1]];
    x1 = y1 = -(bounds_y0 = bounds_x0 = Infinity);
    return bounds;
  }
};

function bounds_boundsPoint(x, y) {
  if (x < bounds_x0) bounds_x0 = x;
  if (x > x1) x1 = x;
  if (y < bounds_y0) bounds_y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const path_bounds = (bounds_boundsStream);

;// ./node_modules/d3-geo/src/path/centroid.js


// TODO Enforce positive area for exterior, negative area for interior?

var centroid_X0 = 0,
    centroid_Y0 = 0,
    centroid_Z0 = 0,
    centroid_X1 = 0,
    centroid_Y1 = 0,
    centroid_Z1 = 0,
    centroid_X2 = 0,
    centroid_Y2 = 0,
    centroid_Z2 = 0,
    centroid_x00,
    centroid_y00,
    centroid_x0,
    centroid_y0;

var centroid_centroidStream = {
  point: centroid_centroidPoint,
  lineStart: centroid_centroidLineStart,
  lineEnd: centroid_centroidLineEnd,
  polygonStart: function() {
    centroid_centroidStream.lineStart = centroid_centroidRingStart;
    centroid_centroidStream.lineEnd = centroid_centroidRingEnd;
  },
  polygonEnd: function() {
    centroid_centroidStream.point = centroid_centroidPoint;
    centroid_centroidStream.lineStart = centroid_centroidLineStart;
    centroid_centroidStream.lineEnd = centroid_centroidLineEnd;
  },
  result: function() {
    var centroid = centroid_Z2 ? [centroid_X2 / centroid_Z2, centroid_Y2 / centroid_Z2]
        : centroid_Z1 ? [centroid_X1 / centroid_Z1, centroid_Y1 / centroid_Z1]
        : centroid_Z0 ? [centroid_X0 / centroid_Z0, centroid_Y0 / centroid_Z0]
        : [NaN, NaN];
    centroid_X0 = centroid_Y0 = centroid_Z0 =
    centroid_X1 = centroid_Y1 = centroid_Z1 =
    centroid_X2 = centroid_Y2 = centroid_Z2 = 0;
    return centroid;
  }
};

function centroid_centroidPoint(x, y) {
  centroid_X0 += x;
  centroid_Y0 += y;
  ++centroid_Z0;
}

function centroid_centroidLineStart() {
  centroid_centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroid_centroidStream.point = centroidPointLine;
  centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - centroid_x0, dy = y - centroid_y0, z = sqrt(dx * dx + dy * dy);
  centroid_X1 += z * (centroid_x0 + x) / 2;
  centroid_Y1 += z * (centroid_y0 + y) / 2;
  centroid_Z1 += z;
  centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
}

function centroid_centroidLineEnd() {
  centroid_centroidStream.point = centroid_centroidPoint;
}

function centroid_centroidRingStart() {
  centroid_centroidStream.point = centroidPointFirstRing;
}

function centroid_centroidRingEnd() {
  centroidPointRing(centroid_x00, centroid_y00);
}

function centroidPointFirstRing(x, y) {
  centroid_centroidStream.point = centroidPointRing;
  centroid_centroidPoint(centroid_x00 = centroid_x0 = x, centroid_y00 = centroid_y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - centroid_x0,
      dy = y - centroid_y0,
      z = sqrt(dx * dx + dy * dy);

  centroid_X1 += z * (centroid_x0 + x) / 2;
  centroid_Y1 += z * (centroid_y0 + y) / 2;
  centroid_Z1 += z;

  z = centroid_y0 * x - centroid_x0 * y;
  centroid_X2 += z * (centroid_x0 + x);
  centroid_Y2 += z * (centroid_y0 + y);
  centroid_Z2 += z * 3;
  centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
}

/* harmony default export */ const path_centroid = (centroid_centroidStream);

;// ./node_modules/d3-geo/src/path/context.js



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

;// ./node_modules/d3-geo/src/path/measure.js




var measure_lengthSum = adder(),
    lengthRing,
    measure_x00,
    measure_y00,
    measure_x0,
    measure_y0;

var measure_lengthStream = {
  point: noop,
  lineStart: function() {
    measure_lengthStream.point = measure_lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) measure_lengthPoint(measure_x00, measure_y00);
    measure_lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +measure_lengthSum;
    measure_lengthSum.reset();
    return length;
  }
};

function measure_lengthPointFirst(x, y) {
  measure_lengthStream.point = measure_lengthPoint;
  measure_x00 = measure_x0 = x, measure_y00 = measure_y0 = y;
}

function measure_lengthPoint(x, y) {
  measure_x0 -= x, measure_y0 -= y;
  measure_lengthSum.add(sqrt(measure_x0 * measure_x0 + measure_y0 * measure_y0));
  measure_x0 = x, measure_y0 = y;
}

/* harmony default export */ const measure = (measure_lengthStream);

;// ./node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: string_circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = string_circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function string_circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

;// ./node_modules/d3-geo/src/path/index.js









/* harmony default export */ function path(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    stream(object, projectionStream(path_area));
    return path_area.result();
  };

  path.measure = function(object) {
    stream(object, projectionStream(measure));
    return measure.result();
  };

  path.bounds = function(object) {
    stream(object, projectionStream(path_bounds));
    return path_bounds.result();
  };

  path.centroid = function(object) {
    stream(object, projectionStream(path_centroid));
    return path_centroid.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, src_identity) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

;// ./node_modules/d3-geo/src/clip/index.js






/* harmony default export */ function clip(pointVisible, clipLine, interpolate, start) {
  return function(rotate, sink) {
    var line = clipLine(sink),
        rotatedStart = rotate.invert(start[0], start[1]),
        ringBuffer = buffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains(polygon, rotatedStart);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clip_polygon(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      var point = rotate(lambda, phi);
      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      var point = rotate(lambda, phi);
      line.point(point[0], point[1]);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point = rotate(lambda, phi);
      ringSink.point(point[0], point[1]);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

;// ./node_modules/d3-geo/src/clip/antimeridian.js



/* harmony default export */ const antimeridian = (clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon
      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

;// ./node_modules/d3-geo/src/clip/circle.js






/* harmony default export */ function clip_circle(radius, delta) {
  var cr = cos(radius),
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi) < epsilon,
        meridian = polar || delta < epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

;// ./node_modules/d3-geo/src/transform.js
/* harmony default export */ function transform(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

;// ./node_modules/d3-geo/src/projection/fit.js



function fitExtent(projection, extent, object) {
  var w = extent[1][0] - extent[0][0],
      h = extent[1][1] - extent[0][1],
      clip = projection.clipExtent && projection.clipExtent();

  projection
      .scale(150)
      .translate([0, 0]);

  if (clip != null) projection.clipExtent(null);

  stream(object, projection.stream(path_bounds));

  var b = path_bounds.result(),
      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

  if (clip != null) projection.clipExtent(clip);

  return projection
      .scale(k * 150)
      .translate([x, y]);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

;// ./node_modules/d3-geo/src/projection/resample.js




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

/* harmony default export */ function resample(project, delta2) {
  return +delta2 ? resample_resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample_resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

;// ./node_modules/d3-geo/src/projection/index.js











var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = antimeridian, // clip angle
      x0 = null, y0, x1, y1, postclip = src_identity, // clip extent
      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * radians, point[1] * radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clip_circle(theta = _ * radians, 6 * radians) : (theta = null, antimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, src_identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

;// ./node_modules/d3-geo/src/projection/conic.js



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

;// ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

;// ./node_modules/d3-geo/src/projection/conicEqualArea.js




function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin(y)) / n;
    return [r * sin(x *= n), r0 - r * cos(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

;// ./node_modules/d3-geo/src/projection/albers.js


/* harmony default export */ function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

;// ./node_modules/d3-geo/src/projection/albersUsa.js





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

;// ./node_modules/d3-geo/src/projection/azimuthal.js


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x),
        cy = cos(y),
        k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin(c),
        cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

;// ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js




var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

/* harmony default export */ function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

;// ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js




var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

/* harmony default export */ function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

;// ./node_modules/d3-geo/src/projection/mercator.js




function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

/* harmony default export */ function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

;// ./node_modules/d3-geo/src/projection/conicConformal.js




function tany(y) {
  return tan((halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
    var r = f / pow(tany(y), n);
    return [r * sin(n * x), f - r * cos(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
  };

  return project;
}

/* harmony default export */ function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

;// ./node_modules/d3-geo/src/projection/equirectangular.js


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

;// ./node_modules/d3-geo/src/projection/conicEquidistant.js




function conicEquidistantRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin(nx), g - gy * cos(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

;// ./node_modules/d3-geo/src/projection/gnomonic.js




function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

/* harmony default export */ function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

;// ./node_modules/d3-geo/src/projection/identity.js





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? src_identity : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ function projection_identity() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = src_identity, // scale, translate and reflect
      x0 = null, y0, x1, y1, clip = src_identity, // clip extent
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
    },
    clipExtent: function(_) {
      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, src_identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    }
  };
}

;// ./node_modules/d3-geo/src/projection/naturalEarth1.js



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

;// ./node_modules/d3-geo/src/projection/orthographic.js




function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

/* harmony default export */ function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon);
}

;// ./node_modules/d3-geo/src/projection/stereographic.js




function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

/* harmony default export */ function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

;// ./node_modules/d3-geo/src/projection/transverseMercator.js



function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

/* harmony default export */ function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

;// ./node_modules/d3-geo/index.js




 // DEPRECATED! Use d3.geoIdentity().clipExtent().



























/***/ }),

/***/ 1734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var boolean_disjoint_1 = __importDefault(__webpack_require__(1323));
var meta_1 = __webpack_require__(8421);
/**
 * Boolean-intersects returns (TRUE) two geometries intersect.
 *
 * @name booleanIntersects
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var point = turf.point([2, 2]);
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 *
 * turf.booleanIntersects(line, point);
 * //=true
 */
function booleanIntersects(feature1, feature2) {
    var bool = false;
    meta_1.flattenEach(feature1, function (flatten1) {
        meta_1.flattenEach(feature2, function (flatten2) {
            if (bool === true) {
                return true;
            }
            bool = !boolean_disjoint_1.default(flatten1.geometry, flatten2.geometry);
        });
    });
    return bool;
}
exports["default"] = booleanIntersects;


/***/ }),

/***/ 1756:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*jshint esversion: 6 */

var Distance = __webpack_require__(6766),
    ClusterInit = __webpack_require__(5810),
    eudist = Distance.eudist,
    mandist = Distance.mandist,
    dist = Distance.dist,
    kmrand = ClusterInit.kmrand,
    kmpp = ClusterInit.kmpp;

var MAX = 10000;

/**
 * Inits an array with values
 */
function init(len, val, v) {
	v = v || [];
	for (var i = 0; i < len; i++) {
		v[i] = val;
	}return v;
}

function skmeans(data, k, initial, maxit) {
	var ks = [],
	    old = [],
	    idxs = [],
	    dist = [];
	var conv = false,
	    it = maxit || MAX;
	var len = data.length,
	    vlen = data[0].length,
	    multi = vlen > 0;
	var count = [];

	if (!initial) {
		var _idxs = {};
		while (ks.length < k) {
			var idx = Math.floor(Math.random() * len);
			if (!_idxs[idx]) {
				_idxs[idx] = true;
				ks.push(data[idx]);
			}
		}
	} else if (initial == "kmrand") {
		ks = kmrand(data, k);
	} else if (initial == "kmpp") {
		ks = kmpp(data, k);
	} else {
		ks = initial;
	}

	do {
		// Reset k count
		init(k, 0, count);

		// For each value in data, find the nearest centroid
		for (var i = 0; i < len; i++) {
			var min = Infinity,
			    _idx = 0;
			for (var j = 0; j < k; j++) {
				// Multidimensional or unidimensional
				var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
				if (dist <= min) {
					min = dist;
					_idx = j;
				}
			}
			idxs[i] = _idx; // Index of the selected centroid for that value
			count[_idx]++; // Number of values for this centroid
		}

		// Recalculate centroids
		var sum = [],
		    old = [],
		    dif = 0;
		for (var _j = 0; _j < k; _j++) {
			// Multidimensional or unidimensional
			sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;
			old[_j] = ks[_j];
		}

		// If multidimensional
		if (multi) {
			for (var _j2 = 0; _j2 < k; _j2++) {
				ks[_j2] = [];
			} // Sum values and count for each centroid
			for (var _i = 0; _i < len; _i++) {
				var _idx2 = idxs[_i],
				    // Centroid for that item
				vsum = sum[_idx2],
				    // Sum values for this centroid
				vect = data[_i]; // Current vector

				// Accumulate value on the centroid for current vector
				for (var h = 0; h < vlen; h++) {
					vsum[h] += vect[h];
				}
			}
			// Calculate the average for each centroid
			conv = true;
			for (var _j3 = 0; _j3 < k; _j3++) {
				var ksj = ks[_j3],
				    // Current centroid
				sumj = sum[_j3],
				    // Accumulated centroid values
				oldj = old[_j3],
				    // Old centroid value
				cj = count[_j3]; // Number of elements for this centroid

				// New average
				for (var _h = 0; _h < vlen; _h++) {
					ksj[_h] = sumj[_h] / cj || 0; // New centroid
				}

				// Find if centroids have moved
				if (conv) {
					for (var _h2 = 0; _h2 < vlen; _h2++) {
						if (oldj[_h2] != ksj[_h2]) {
							conv = false;
							break;
						}
					}
				}
			}
		}
		// If unidimensional
		else {
				// Sum values and count for each centroid
				for (var _i2 = 0; _i2 < len; _i2++) {
					var _idx3 = idxs[_i2];
					sum[_idx3] += data[_i2];
				}
				// Calculate the average for each centroid
				for (var _j4 = 0; _j4 < k; _j4++) {
					ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid
				}
				// Find if centroids have moved
				conv = true;
				for (var _j5 = 0; _j5 < k; _j5++) {
					if (old[_j5] != ks[_j5]) {
						conv = false;
						break;
					}
				}
			}

		conv = conv || --it <= 0;
	} while (!conv);

	return {
		it: MAX - it,
		k: k,
		idxs: idxs,
		centroids: ks
	};
}

module.exports = skmeans;
//# sourceMappingURL=main.js.map


/***/ }),

/***/ 1786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var circle = __webpack_require__(5764);
var lineArc = __webpack_require__(375);
var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var circle__default = /*#__PURE__*/_interopDefaultLegacy(circle);
var lineArc__default = /*#__PURE__*/_interopDefaultLegacy(lineArc);

/**
 * Creates a circular sector of a circle of given radius and center {@link Point},
 * between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.
 *
 * @name sector
 * @param {Coord} center center point
 * @param {number} radius radius of the circle
 * @param {number} bearing1 angle, in decimal degrees, of the first radius of the sector
 * @param {number} bearing2 angle, in decimal degrees, of the second radius of the sector
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {number} [options.steps=64] number of steps
 * @param {Properties} [options.properties={}] Translate properties to Feature Polygon
 * @returns {Feature<Polygon>} sector polygon
 * @example
 * var center = turf.point([-75, 40]);
 * var radius = 5;
 * var bearing1 = 25;
 * var bearing2 = 45;
 *
 * var sector = turf.sector(center, radius, bearing1, bearing2);
 *
 * //addToMap
 * var addToMap = [center, sector];
 */
function sector(center, radius, bearing1, bearing2, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var properties = options.properties;

  // validation
  if (!center) throw new Error("center is required");
  if (bearing1 === undefined || bearing1 === null)
    throw new Error("bearing1 is required");
  if (bearing2 === undefined || bearing2 === null)
    throw new Error("bearing2 is required");
  if (!radius) throw new Error("radius is required");
  if (typeof options !== "object") throw new Error("options must be an object");

  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
    return circle__default['default'](center, radius, options);
  }
  var coords = invariant.getCoords(center);
  var arc = lineArc__default['default'](center, radius, bearing1, bearing2, options);
  var sliceCoords = [[coords]];
  meta.coordEach(arc, function (currentCoords) {
    sliceCoords[0].push(currentCoords);
  });
  sliceCoords[0].push(coords);

  return helpers.polygon(sliceCoords, properties);
}

/**
 * Takes any angle in degrees
 * and returns a valid angle between 0-360 degrees
 *
 * @private
 * @param {number} alfa angle between -180-180 degrees
 * @returns {number} angle between 0-360 degrees
 */
function convertAngleTo360(alfa) {
  var beta = alfa % 360;
  if (beta < 0) beta += 360;
  return beta;
}

module.exports = sector;
module.exports["default"] = sector;


/***/ }),

/***/ 1925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var clone = __webpack_require__(3711);
var center = __webpack_require__(6649);
var centroid = __webpack_require__(4408);
var turfBBox = __webpack_require__(4383);
var rhumbBearing = __webpack_require__(2307);
var rhumbDistance = __webpack_require__(9778);
var rhumbDestination = __webpack_require__(7153);
var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var center__default = /*#__PURE__*/_interopDefaultLegacy(center);
var centroid__default = /*#__PURE__*/_interopDefaultLegacy(centroid);
var turfBBox__default = /*#__PURE__*/_interopDefaultLegacy(turfBBox);
var rhumbBearing__default = /*#__PURE__*/_interopDefaultLegacy(rhumbBearing);
var rhumbDistance__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDistance);
var rhumbDestination__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDestination);

/**
 * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).
 * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.
 *
 * @name transformScale
 * @param {GeoJSON} geojson GeoJSON to be scaled
 * @param {number} factor of scaling, positive or negative values greater than 0
 * @param {Object} [options={}] Optional parameters
 * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} scaled GeoJSON
 * @example
 * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
 * var scaledPoly = turf.transformScale(poly, 3);
 *
 * //addToMap
 * var addToMap = [poly, scaledPoly];
 * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};
 */
function transformScale(geojson, factor, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var origin = options.origin;
  var mutate = options.mutate;

  // Input validation
  if (!geojson) throw new Error("geojson required");
  if (typeof factor !== "number" || factor === 0)
    throw new Error("invalid factor");
  var originIsPoint = Array.isArray(origin) || typeof origin === "object";

  // Clone geojson to avoid side effects
  if (mutate !== true) geojson = clone__default['default'](geojson);

  // Scale each Feature separately
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    meta.featureEach(geojson, function (feature, index) {
      geojson.features[index] = scale(feature, factor, origin);
    });
    return geojson;
  }
  // Scale Feature/Geometry
  return scale(geojson, factor, origin);
}

/**
 * Scale Feature/Geometry
 *
 * @private
 * @param {Feature|Geometry} feature GeoJSON Feature/Geometry
 * @param {number} factor of scaling, positive or negative values greater than 0
 * @param {string|Coord} [origin="centroid"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)
 * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry
 */
function scale(feature, factor, origin) {
  // Default params
  var isPoint = invariant.getType(feature) === "Point";
  origin = defineOrigin(feature, origin);

  // Shortcut no-scaling
  if (factor === 1 || isPoint) return feature;

  // Scale each coordinate
  meta.coordEach(feature, function (coord) {
    var originalDistance = rhumbDistance__default['default'](origin, coord);
    var bearing = rhumbBearing__default['default'](origin, coord);
    var newDistance = originalDistance * factor;
    var newCoord = invariant.getCoords(rhumbDestination__default['default'](origin, newDistance, bearing));
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3) coord[2] *= factor;
  });

  return feature;
}

/**
 * Define Origin
 *
 * @private
 * @param {GeoJSON} geojson GeoJSON
 * @param {string|Coord} origin sw/se/nw/ne/center/centroid
 * @returns {Feature<Point>} Point origin
 */
function defineOrigin(geojson, origin) {
  // Default params
  if (origin === undefined || origin === null) origin = "centroid";

  // Input Coord
  if (Array.isArray(origin) || typeof origin === "object")
    return invariant.getCoord(origin);

  // Define BBox
  var bbox = geojson.bbox ? geojson.bbox : turfBBox__default['default'](geojson);
  var west = bbox[0];
  var south = bbox[1];
  var east = bbox[2];
  var north = bbox[3];

  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return helpers.point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return helpers.point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return helpers.point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return helpers.point([east, north]);
    case "center":
      return center__default['default'](geojson);
    case undefined:
    case null:
    case "centroid":
      return centroid__default['default'](geojson);
    default:
      throw new Error("invalid origin");
  }
}

module.exports = transformScale;
module.exports["default"] = transformScale;


/***/ }),

/***/ 1972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);

/**
 * https://github.com/rook2pawn/node-intersection
 *
 * Author @rook2pawn
 */

/**
 * AB
 *
 * @private
 * @param {Array<Array<number>>} segment - 2 vertex line segment
 * @returns {Array<number>} coordinates [x, y]
 */
function ab(segment) {
  var start = segment[0];
  var end = segment[1];
  return [end[0] - start[0], end[1] - start[1]];
}

/**
 * Cross Product
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Cross Product
 */
function crossProduct(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}

/**
 * Add
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Add
 */
function add(v1, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}

/**
 * Sub
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Sub
 */
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}

/**
 * scalarMult
 *
 * @private
 * @param {number} s scalar
 * @param {Array<number>} v coordinates [x, y]
 * @returns {Array<number>} scalarMult
 */
function scalarMult(s, v) {
  return [s * v[0], s * v[1]];
}

/**
 * Intersect Segments
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {Array<number>} intersection
 */
function intersectSegments(a, b) {
  var p = a[0];
  var r = ab(a);
  var q = b[0];
  var s = ab(b);

  var cross = crossProduct(r, s);
  var qmp = sub(q, p);
  var numerator = crossProduct(qmp, s);
  var t = numerator / cross;
  var intersection = add(p, scalarMult(t, r));
  return intersection;
}

/**
 * Is Parallel
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {boolean} true if a and b are parallel (or co-linear)
 */
function isParallel(a, b) {
  var r = ab(a);
  var s = ab(b);
  return crossProduct(r, s) === 0;
}

/**
 * Intersection
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)
 */
function intersection(a, b) {
  if (isParallel(a, b)) return false;
  return intersectSegments(a, b);
}

/**
 * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.
 *
 * @name lineOffset
 * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON
 * @param {number} distance distance to offset the line (can be of negative value)
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters
 * @returns {Feature<LineString|MultiLineString>} Line offset from the input line
 * @example
 * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { "stroke": "#F00" });
 *
 * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [offsetLine, line]
 * offsetLine.properties.stroke = "#00F"
 */
function lineOffset(geojson, distance, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var units = options.units;

  // Valdiation
  if (!geojson) throw new Error("geojson is required");
  if (distance === undefined || distance === null || isNaN(distance))
    throw new Error("distance is required");

  var type = invariant.getType(geojson);
  var properties = geojson.properties;

  switch (type) {
    case "LineString":
      return lineOffsetFeature(geojson, distance, units);
    case "MultiLineString":
      var coords = [];
      meta.flattenEach(geojson, function (feature) {
        coords.push(
          lineOffsetFeature(feature, distance, units).geometry.coordinates
        );
      });
      return helpers.multiLineString(coords, properties);
    default:
      throw new Error("geometry " + type + " is not supported");
  }
}

/**
 * Line Offset
 *
 * @private
 * @param {Geometry|Feature<LineString>} line input line
 * @param {number} distance distance to offset the line (can be of negative value)
 * @param {string} [units=kilometers] units
 * @returns {Feature<LineString>} Line offset from the input line
 */
function lineOffsetFeature(line, distance, units) {
  var segments = [];
  var offsetDegrees = helpers.lengthToDegrees(distance, units);
  var coords = invariant.getCoords(line);
  var finalCoords = [];
  coords.forEach(function (currentCoords, index) {
    if (index !== coords.length - 1) {
      var segment = processSegment(
        currentCoords,
        coords[index + 1],
        offsetDegrees
      );
      segments.push(segment);
      if (index > 0) {
        var seg2Coords = segments[index - 1];
        var intersects = intersection(segment, seg2Coords);

        // Handling for line segments that aren't straight
        if (intersects !== false) {
          seg2Coords[1] = intersects;
          segment[0] = intersects;
        }

        finalCoords.push(seg2Coords[0]);
        if (index === coords.length - 2) {
          finalCoords.push(segment[0]);
          finalCoords.push(segment[1]);
        }
      }
      // Handling for lines that only have 1 segment
      if (coords.length === 2) {
        finalCoords.push(segment[0]);
        finalCoords.push(segment[1]);
      }
    }
  });
  return helpers.lineString(finalCoords, line.properties);
}

/**
 * Process Segment
 * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line
 *
 * @private
 * @param {Array<number>} point1 Point coordinates
 * @param {Array<number>} point2 Point coordinates
 * @param {number} offset Offset
 * @returns {Array<Array<number>>} offset points
 */
function processSegment(point1, point2, offset) {
  var L = Math.sqrt(
    (point1[0] - point2[0]) * (point1[0] - point2[0]) +
      (point1[1] - point2[1]) * (point1[1] - point2[1])
  );

  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;
  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;
  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;
  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;
  return [
    [out1x, out1y],
    [out2x, out2y],
  ];
}

module.exports = lineOffset;
module.exports["default"] = lineOffset;


/***/ }),

/***/ 2057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var polygon_clipping_1 = __importDefault(__webpack_require__(9004));
var invariant_1 = __webpack_require__(8506);
var helpers_1 = __webpack_require__(8967);
/**
 * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
 * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
 * @param {Object} [options={}] Optional Parameters
 * @param {Object} [options.properties={}] Translate Properties to output Feature
 * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature, or null if the inputs are empty
 * @example
 * var poly1 = turf.polygon([[
 *     [-82.574787, 35.594087],
 *     [-82.574787, 35.615581],
 *     [-82.545261, 35.615581],
 *     [-82.545261, 35.594087],
 *     [-82.574787, 35.594087]
 * ]], {"fill": "#0f0"});
 * var poly2 = turf.polygon([[
 *     [-82.560024, 35.585153],
 *     [-82.560024, 35.602602],
 *     [-82.52964, 35.602602],
 *     [-82.52964, 35.585153],
 *     [-82.560024, 35.585153]
 * ]], {"fill": "#00f"});
 *
 * var union = turf.union(poly1, poly2);
 *
 * //addToMap
 * var addToMap = [poly1, poly2, union];
 */
function union(poly1, poly2, options) {
    if (options === void 0) { options = {}; }
    var geom1 = invariant_1.getGeom(poly1);
    var geom2 = invariant_1.getGeom(poly2);
    var unioned = polygon_clipping_1.default.union(geom1.coordinates, geom2.coordinates);
    if (unioned.length === 0)
        return null;
    if (unioned.length === 1)
        return helpers_1.polygon(unioned[0], options.properties);
    else
        return helpers_1.multiPolygon(unioned, options.properties);
}
exports["default"] = union;


/***/ }),

/***/ 2086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
// To-Do => Improve Typescript GeoJSON handling
/**
 * Removes redundant coordinates from any GeoJSON Geometry.
 *
 * @name cleanCoords
 * @param {Geometry|Feature} geojson Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated
 * @returns {Geometry|Feature} the cleaned input Feature/Geometry
 * @example
 * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);
 * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);
 *
 * turf.cleanCoords(line).geometry.coordinates;
 * //= [[0, 0], [0, 10]]
 *
 * turf.cleanCoords(multiPoint).geometry.coordinates;
 * //= [[0, 0], [2, 2]]
 */
function cleanCoords(geojson, options) {
    if (options === void 0) { options = {}; }
    // Backwards compatible with v4.0
    var mutate = typeof options === "object" ? options.mutate : options;
    if (!geojson)
        throw new Error("geojson is required");
    var type = invariant_1.getType(geojson);
    // Store new "clean" points in this Array
    var newCoords = [];
    switch (type) {
        case "LineString":
            newCoords = cleanLine(geojson);
            break;
        case "MultiLineString":
        case "Polygon":
            invariant_1.getCoords(geojson).forEach(function (line) {
                newCoords.push(cleanLine(line));
            });
            break;
        case "MultiPolygon":
            invariant_1.getCoords(geojson).forEach(function (polygons) {
                var polyPoints = [];
                polygons.forEach(function (ring) {
                    polyPoints.push(cleanLine(ring));
                });
                newCoords.push(polyPoints);
            });
            break;
        case "Point":
            return geojson;
        case "MultiPoint":
            var existing = {};
            invariant_1.getCoords(geojson).forEach(function (coord) {
                var key = coord.join("-");
                if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                    newCoords.push(coord);
                    existing[key] = true;
                }
            });
            break;
        default:
            throw new Error(type + " geometry not supported");
    }
    // Support input mutation
    if (geojson.coordinates) {
        if (mutate === true) {
            geojson.coordinates = newCoords;
            return geojson;
        }
        return { type: type, coordinates: newCoords };
    }
    else {
        if (mutate === true) {
            geojson.geometry.coordinates = newCoords;
            return geojson;
        }
        return helpers_1.feature({ type: type, coordinates: newCoords }, geojson.properties, {
            bbox: geojson.bbox,
            id: geojson.id,
        });
    }
}
/**
 * Clean Coords
 *
 * @private
 * @param {Array<number>|LineString} line Line
 * @returns {Array<number>} Cleaned coordinates
 */
function cleanLine(line) {
    var points = invariant_1.getCoords(line);
    // handle "clean" segment
    if (points.length === 2 && !equals(points[0], points[1]))
        return points;
    var newPoints = [];
    var secondToLast = points.length - 1;
    var newPointsLength = newPoints.length;
    newPoints.push(points[0]);
    for (var i = 1; i < secondToLast; i++) {
        var prevAddedPoint = newPoints[newPoints.length - 1];
        if (points[i][0] === prevAddedPoint[0] &&
            points[i][1] === prevAddedPoint[1])
            continue;
        else {
            newPoints.push(points[i]);
            newPointsLength = newPoints.length;
            if (newPointsLength > 2) {
                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
                    newPoints.splice(newPoints.length - 2, 1);
            }
        }
    }
    newPoints.push(points[points.length - 1]);
    newPointsLength = newPoints.length;
    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)
        throw new Error("invalid polygon");
    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
        newPoints.splice(newPoints.length - 2, 1);
    return newPoints;
}
/**
 * Compares two points and returns if they are equals
 *
 * @private
 * @param {Position} pt1 point
 * @param {Position} pt2 point
 * @returns {boolean} true if they are equals
 */
function equals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
/**
 * Returns if `point` is on the segment between `start` and `end`.
 * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)
 *
 * @private
 * @param {Position} start coord pair of start of line
 * @param {Position} end coord pair of end of line
 * @param {Position} point coord pair of point to check
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(start, end, point) {
    var x = point[0], y = point[1];
    var startX = start[0], startY = start[1];
    var endX = end[0], endY = end[1];
    var dxc = x - startX;
    var dyc = y - startY;
    var dxl = endX - startX;
    var dyl = endY - startY;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0)
        return false;
    else if (Math.abs(dxl) >= Math.abs(dyl))
        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
    else
        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
exports["default"] = cleanCoords;


/***/ }),

/***/ 2120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bbox = __webpack_require__(4383);
var bboxPolygon = __webpack_require__(3932);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var bboxPolygon__default = /*#__PURE__*/_interopDefaultLegacy(bboxPolygon);

/**
 * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
 *
 * @name envelope
 * @param {GeoJSON} geojson input features
 * @returns {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
 * @example
 * var features = turf.featureCollection([
 *   turf.point([-75.343, 39.984], {"name": "Location A"}),
 *   turf.point([-75.833, 39.284], {"name": "Location B"}),
 *   turf.point([-75.534, 39.123], {"name": "Location C"})
 * ]);
 *
 * var enveloped = turf.envelope(features);
 *
 * //addToMap
 * var addToMap = [features, enveloped];
 */
function envelope(geojson) {
  return bboxPolygon__default['default'](bbox__default['default'](geojson));
}

module.exports = envelope;
module.exports["default"] = envelope;


/***/ }),

/***/ 2141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// http://en.wikipedia.org/wiki/Delaunay_triangulation
// https://github.com/ironwallaby/delaunay
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a set of {@link Point|points} and creates a
 * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
 * or a TIN for short, returned as a collection of Polygons. These are often used
 * for developing elevation contour maps or stepped heat visualizations.
 *
 * If an optional z-value property is provided then it is added as properties called `a`, `b`,
 * and `c` representing its value at each of the points that represent the corners of the
 * triangle.
 *
 * @name tin
 * @param {FeatureCollection<Point>} points input points
 * @param {String} [z] name of the property from which to pull z values
 * This is optional: if not given, then there will be no extra data added to the derived triangles.
 * @returns {FeatureCollection<Polygon>} TIN output
 * @example
 * // generate some random point data
 * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});
 *
 * // add a random property to each point between 0 and 9
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = ~~(Math.random() * 9);
 * }
 * var tin = turf.tin(points, 'z');
 *
 * //addToMap
 * var addToMap = [tin, points]
 * for (var i = 0; i < tin.features.length; i++) {
 *   var properties  = tin.features[i].properties;
 *   properties.fill = '#' + properties.a + properties.b + properties.c;
 * }
 */
function tin(points, z) {
    // break down points
    var isPointZ = false;
    return helpers_1.featureCollection(triangulate(points.features.map(function (p) {
        var point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1],
        };
        if (z) {
            point.z = p.properties[z];
        }
        else if (p.geometry.coordinates.length === 3) {
            isPointZ = true;
            point.z = p.geometry.coordinates[2];
        }
        return point;
    })).map(function (triangle) {
        var a = [triangle.a.x, triangle.a.y];
        var b = [triangle.b.x, triangle.b.y];
        var c = [triangle.c.x, triangle.c.y];
        var properties = {};
        // Add z coordinates to triangle points if user passed
        // them in that way otherwise add it as a property.
        if (isPointZ) {
            a.push(triangle.a.z);
            b.push(triangle.b.z);
            c.push(triangle.c.z);
        }
        else {
            properties = {
                a: triangle.a.z,
                b: triangle.b.z,
                c: triangle.c.z,
            };
        }
        return helpers_1.polygon([[a, b, c, a]], properties);
    }));
}
exports["default"] = tin;
var Triangle = /** @class */ (function () {
    function Triangle(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
        var A = b.x - a.x;
        var B = b.y - a.y;
        var C = c.x - a.x;
        var D = c.y - a.y;
        var E = A * (a.x + b.x) + B * (a.y + b.y);
        var F = C * (a.x + c.x) + D * (a.y + c.y);
        var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
        var dx;
        var dy;
        // If the points of the triangle are collinear, then just find the
        // extremes and use the midpoint as the center of the circumcircle.
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }
    return Triangle;
}());
function byX(a, b) {
    return b.x - a.x;
}
function dedup(edges) {
    var j = edges.length;
    var a;
    var b;
    var i;
    var m;
    var n;
    outer: while (j) {
        b = edges[--j];
        a = edges[--j];
        i = j;
        while (i) {
            n = edges[--i];
            m = edges[--i];
            if ((a === m && b === n) || (a === n && b === m)) {
                edges.splice(j, 2);
                edges.splice(i, 2);
                j -= 2;
                continue outer;
            }
        }
    }
}
function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3) {
        return [];
    }
    // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.
    vertices.sort(byX);
    var i = vertices.length - 1;
    var xmin = vertices[i].x;
    var xmax = vertices[0].x;
    var ymin = vertices[i].y;
    var ymax = ymin;
    var epsilon = 1e-12;
    var a;
    var b;
    var c;
    var A;
    var B;
    var G;
    while (i--) {
        if (vertices[i].y < ymin) {
            ymin = vertices[i].y;
        }
        if (vertices[i].y > ymax) {
            ymax = vertices[i].y;
        }
    }
    // Find a supertriangle, which is a triangle that surrounds all the
    // vertices. This is used like something of a sentinel value to remove
    // cases in the main algorithm, and is removed before we return any
    // results.
    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)
    var dx = xmax - xmin;
    var dy = ymax - ymin;
    var dmax = dx > dy ? dx : dy;
    var xmid = (xmax + xmin) * 0.5;
    var ymid = (ymax + ymin) * 0.5;
    var open = [
        new Triangle({
            __sentinel: true,
            x: xmid - 20 * dmax,
            y: ymid - dmax,
        }, {
            __sentinel: true,
            x: xmid,
            y: ymid + 20 * dmax,
        }, {
            __sentinel: true,
            x: xmid + 20 * dmax,
            y: ymid - dmax,
        }),
    ];
    var closed = [];
    var edges = [];
    var j;
    // Incrementally add each vertex to the mesh.
    i = vertices.length;
    while (i--) {
        // For each open triangle, check to see if the current point is
        // inside it's circumcircle. If it is, remove the triangle and add
        // it's edges to an edge list.
        edges.length = 0;
        j = open.length;
        while (j--) {
            // If this point is to the right of this triangle's circumcircle,
            // then this triangle should never get checked again. Remove it
            // from the open list, add it to the closed list, and skip.
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }
            // If not, skip this triangle.
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r) {
                continue;
            }
            // Remove the triangle and add it's edges to the edge list.
            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
            open.splice(j, 1);
        }
        // Remove any doubled edges.
        dedup(edges);
        // Add a new triangle for each edge.
        j = edges.length;
        while (j) {
            b = edges[--j];
            a = edges[--j];
            c = vertices[i];
            // Avoid adding colinear triangles (which have error-prone
            // circumcircles)
            A = b.x - a.x;
            B = b.y - a.y;
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            if (Math.abs(G) > epsilon) {
                open.push(new Triangle(a, b, c));
            }
        }
    }
    // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.
    Array.prototype.push.apply(closed, open);
    i = closed.length;
    while (i--) {
        if (closed[i].a.__sentinel ||
            closed[i].b.__sentinel ||
            closed[i].c.__sentinel) {
            closed.splice(i, 1);
        }
    }
    return closed;
}


/***/ }),

/***/ 2163:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var clone = __webpack_require__(3711);
var booleanClockwise = __webpack_require__(7333);
var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var booleanClockwise__default = /*#__PURE__*/_interopDefaultLegacy(booleanClockwise);

/**
 * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).
 *
 * @name rewind
 * @param {GeoJSON} geojson input GeoJSON Polygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.reverse=false] enable reverse winding
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} rewind Polygon
 * @example
 * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);
 *
 * var rewind = turf.rewind(polygon);
 *
 * //addToMap
 * var addToMap = [rewind];
 */
function rewind(geojson, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var reverse = options.reverse || false;
  var mutate = options.mutate || false;

  // validation
  if (!geojson) throw new Error("<geojson> is required");
  if (typeof reverse !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");

  // prevent input mutation
  if (mutate === false) geojson = clone__default['default'](geojson);

  // Support Feature Collection or Geometry Collection
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      meta.geomEach(geojson, function (geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "FeatureCollection":
      meta.featureEach(geojson, function (feature) {
        meta.featureEach(rewindFeature(feature, reverse), function (result) {
          results.push(result);
        });
      });
      return helpers.featureCollection(results);
  }
  // Support Feature or Geometry Objects
  return rewindFeature(geojson, reverse);
}

/**
 * Rewind
 *
 * @private
 * @param {Geometry|Feature<any>} geojson Geometry or Feature
 * @param {Boolean} [reverse=false] enable reverse winding
 * @returns {Geometry|Feature<any>} rewind Geometry or Feature
 */
function rewindFeature(geojson, reverse) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;

  // Support all GeoJSON Geometry Objects
  switch (type) {
    case "GeometryCollection":
      meta.geomEach(geojson, function (geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "LineString":
      rewindLineString(invariant.getCoords(geojson), reverse);
      return geojson;
    case "Polygon":
      rewindPolygon(invariant.getCoords(geojson), reverse);
      return geojson;
    case "MultiLineString":
      invariant.getCoords(geojson).forEach(function (lineCoords) {
        rewindLineString(lineCoords, reverse);
      });
      return geojson;
    case "MultiPolygon":
      invariant.getCoords(geojson).forEach(function (lineCoords) {
        rewindPolygon(lineCoords, reverse);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}

/**
 * Rewind LineString - outer ring clockwise
 *
 * @private
 * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates
 * @param {Boolean} [reverse=false] enable reverse winding
 * @returns {void} mutates coordinates
 */
function rewindLineString(coords, reverse) {
  if (booleanClockwise__default['default'](coords) === reverse) coords.reverse();
}

/**
 * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.
 *
 * @private
 * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates
 * @param {Boolean} [reverse=false] enable reverse winding
 * @returns {void} mutates coordinates
 */
function rewindPolygon(coords, reverse) {
  // outer ring
  if (booleanClockwise__default['default'](coords[0]) !== reverse) {
    coords[0].reverse();
  }
  // inner rings
  for (var i = 1; i < coords.length; i++) {
    if (booleanClockwise__default['default'](coords[i]) === reverse) {
      coords[i].reverse();
    }
  }
}

module.exports = rewind;
module.exports["default"] = rewind;


/***/ }),

/***/ 2222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var length = __webpack_require__(8840);
var lineSliceAlong = __webpack_require__(4957);
var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var length__default = /*#__PURE__*/_interopDefaultLegacy(length);
var lineSliceAlong__default = /*#__PURE__*/_interopDefaultLegacy(lineSliceAlong);

/**
 * Divides a {@link LineString} into chunks of a specified length.
 * If the line is shorter than the segment length then the original line is returned.
 *
 * @name lineChunk
 * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split
 * @param {number} segmentLength how long to make each segment
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers
 * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end
 * @returns {FeatureCollection<LineString>} collection of line segments
 * @example
 * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);
 *
 * var chunk = turf.lineChunk(line, 15, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [chunk];
 */
function lineChunk(geojson, segmentLength, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var units = options.units;
  var reverse = options.reverse;

  // Validation
  if (!geojson) throw new Error("geojson is required");
  if (segmentLength <= 0)
    throw new Error("segmentLength must be greater than 0");

  // Container
  var results = [];

  // Flatten each feature to simple LineString
  meta.flattenEach(geojson, function (feature) {
    // reverses coordinates to start the first chunked segment at the end
    if (reverse)
      feature.geometry.coordinates = feature.geometry.coordinates.reverse();

    sliceLineSegments(feature, segmentLength, units, function (segment) {
      results.push(segment);
    });
  });
  return helpers.featureCollection(results);
}

/**
 * Slice Line Segments
 *
 * @private
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {number} segmentLength how long to make each segment
 * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers
 * @param {Function} callback iterate over sliced line segments
 * @returns {void}
 */
function sliceLineSegments(line, segmentLength, units, callback) {
  var lineLength = length__default['default'](line, { units: units });

  // If the line is shorter than the segment length then the orginal line is returned.
  if (lineLength <= segmentLength) return callback(line);

  var numberOfSegments = lineLength / segmentLength;

  // If numberOfSegments is integer, no need to plus 1
  if (!Number.isInteger(numberOfSegments)) {
    numberOfSegments = Math.floor(numberOfSegments) + 1;
  }

  for (var i = 0; i < numberOfSegments; i++) {
    var outline = lineSliceAlong__default['default'](
      line,
      segmentLength * i,
      segmentLength * (i + 1),
      { units: units }
    );
    callback(outline, i);
  }
}

module.exports = lineChunk;
module.exports["default"] = lineChunk;


/***/ }),

/***/ 2307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://en.wikipedia.org/wiki/Rhumb_line
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Takes two {@link Point|points} and finds the bearing angle between them along a Rhumb line
 * i.e. the angle measured in degrees start the north line (0 degrees)
 *
 * @name rhumbBearing
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @param {Object} [options] Optional parameters
 * @param {boolean} [options.final=false] calculates the final bearing if true
 * @returns {number} bearing from north in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984], {"marker-color": "#F00"});
 * var point2 = turf.point([-75.534, 39.123], {"marker-color": "#00F"});
 *
 * var bearing = turf.rhumbBearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2];
 * point1.properties.bearing = bearing;
 * point2.properties.bearing = bearing;
 */
function rhumbBearing(start, end, options) {
    if (options === void 0) { options = {}; }
    var bear360;
    if (options.final) {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(end), invariant_1.getCoord(start));
    }
    else {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(start), invariant_1.getCoord(end));
    }
    var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
    return bear180;
}
/**
 * Returns the bearing from this point to destination point along a rhumb line.
 * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js
 *
 * @private
 * @param   {Array<number>} from - origin point.
 * @param   {Array<number>} to - destination point.
 * @returns {number} Bearing in degrees from north.
 * @example
 * var p1 = new LatLon(51.127, 1.338);
 * var p2 = new LatLon(50.964, 1.853);
 * var d = p1.rhumbBearingTo(p2); // 116.7 m
 */
function calculateRhumbBearing(from, to) {
    //  => phi
    //  => deltaLambda
    //  => deltaPsi
    //  => theta
    var phi1 = helpers_1.degreesToRadians(from[1]);
    var phi2 = helpers_1.degreesToRadians(to[1]);
    var deltaLambda = helpers_1.degreesToRadians(to[0] - from[0]);
    // if deltaLambdaon over 180 take shorter rhumb line across the anti-meridian:
    if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
    }
    if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
    }
    var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    var theta = Math.atan2(deltaLambda, deltaPsi);
    return (helpers_1.radiansToDegrees(theta) + 360) % 360;
}
exports["default"] = rhumbBearing;


/***/ }),

/***/ 2347:
/***/ ((module) => {

/**
 * KMEANS clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * KMEANS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} k - number of clusters
 * @param {function} distance - distance function
 * @returns {KMEANS}
 */
 function KMEANS(dataset, k, distance) {
  this.k = 3; // number of clusters
  this.dataset = []; // set of feature vectors
  this.assignments = []; // set of associated clusters for each feature vector
  this.centroids = []; // vectors for our clusters

  this.init(dataset, k, distance);
}

/**
 * @returns {undefined}
 */
KMEANS.prototype.init = function(dataset, k, distance) {
  this.assignments = [];
  this.centroids = [];

  if (typeof dataset !== 'undefined') {
    this.dataset = dataset;
  }

  if (typeof k !== 'undefined') {
    this.k = k;
  }

  if (typeof distance !== 'undefined') {
    this.distance = distance;
  }
};

/**
 * @returns {undefined}
 */
KMEANS.prototype.run = function(dataset, k) {
  this.init(dataset, k);

  var len = this.dataset.length;

  // initialize centroids
  for (var i = 0; i < this.k; i++) {
    this.centroids[i] = this.randomCentroid();
	}

  var change = true;
  while(change) {

    // assign feature vectors to clusters
    change = this.assign();

    // adjust location of centroids
    for (var centroidId = 0; centroidId < this.k; centroidId++) {
      var mean = new Array(maxDim);
      var count = 0;

      // init mean vector
      for (var dim = 0; dim < maxDim; dim++) {
        mean[dim] = 0;
      }

      for (var j = 0; j < len; j++) {
        var maxDim = this.dataset[j].length;

        // if current cluster id is assigned to point
        if (centroidId === this.assignments[j]) {
          for (var dim = 0; dim < maxDim; dim++) {
            mean[dim] += this.dataset[j][dim];
          }
          count++;
        }
      }

      if (count > 0) {
        // if cluster contain points, adjust centroid position
        for (var dim = 0; dim < maxDim; dim++) {
          mean[dim] /= count;
        }
        this.centroids[centroidId] = mean;
      } else {
        // if cluster is empty, generate new random centroid
        this.centroids[centroidId] = this.randomCentroid();
        change = true;
      }
    }
  }

  return this.getClusters();
};

/**
 * Generate random centroid
 *
 * @returns {Array}
 */
KMEANS.prototype.randomCentroid = function() {
  var maxId = this.dataset.length -1;
  var centroid;
  var id;

  do {
    id = Math.round(Math.random() * maxId);
    centroid = this.dataset[id];
  } while (this.centroids.indexOf(centroid) >= 0);

  return centroid;
}

/**
 * Assign points to clusters
 *
 * @returns {boolean}
 */
KMEANS.prototype.assign = function() {
  var change = false;
  var len = this.dataset.length;
  var closestCentroid;

  for (var i = 0; i < len; i++) {
    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);

    if (closestCentroid != this.assignments[i]) {
      this.assignments[i] = closestCentroid;
      change = true;
    }
  }

  return change;
}

/**
 * Extract information about clusters
 *
 * @returns {undefined}
 */
KMEANS.prototype.getClusters = function() {
  var clusters = new Array(this.k);
  var centroidId;

  for (var pointId = 0; pointId < this.assignments.length; pointId++) {
    centroidId = this.assignments[pointId];

    // init empty cluster
    if (typeof clusters[centroidId] === 'undefined') {
      clusters[centroidId] = [];
    }

    clusters[centroidId].push(pointId);
  }

  return clusters;
};

// utils

/**
 * @params {Array} point
 * @params {Array.<Array>} set
 * @params {Function} f
 * @returns {number}
 */
KMEANS.prototype.argmin = function(point, set, f) {
  var min = Number.MAX_VALUE;
  var arg = 0;
  var len = set.length;
  var d;

  for (var i = 0; i < len; i++) {
    d = f(point, set[i]);
    if (d < min) {
      min = d;
      arg = i;
    }
  }

  return arg;
};

/**
 * Euclidean distance
 *
 * @params {number} p
 * @params {number} q
 * @returns {number}
 */
KMEANS.prototype.distance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    var diff = p[i] - q[i];
    sum += diff * diff;
  }

  return Math.sqrt(sum);
};

if ( true && module.exports) {
  module.exports = KMEANS;
}


/***/ }),

/***/ 2352:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var invariant = __webpack_require__(8506);

var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;

var Coord = function (lon, lat) {
  this.lon = lon;
  this.lat = lat;
  this.x = D2R * lon;
  this.y = D2R * lat;
};

Coord.prototype.view = function () {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};

Coord.prototype.antipode = function () {
  var anti_lat = -1 * this.lat;
  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new Coord(anti_lon, anti_lat);
};

var LineString = function () {
  this.coords = [];
  this.length = 0;
};

LineString.prototype.move_to = function (coord) {
  this.length++;
  this.coords.push(coord);
};

var Arc = function (properties) {
  this.properties = properties || {};
  this.geometries = [];
};

Arc.prototype.json = function () {
  if (this.geometries.length <= 0) {
    return {
      geometry: { type: "LineString", coordinates: null },
      type: "Feature",
      properties: this.properties,
    };
  } else if (this.geometries.length === 1) {
    return {
      geometry: { type: "LineString", coordinates: this.geometries[0].coords },
      type: "Feature",
      properties: this.properties,
    };
  } else {
    var multiline = [];
    for (var i = 0; i < this.geometries.length; i++) {
      multiline.push(this.geometries[i].coords);
    }
    return {
      geometry: { type: "MultiLineString", coordinates: multiline },
      type: "Feature",
      properties: this.properties,
    };
  }
};

// TODO - output proper multilinestring
Arc.prototype.wkt = function () {
  var wkt_string = "";
  var wkt = "LINESTRING(";
  var collect = function (c) {
    wkt += c[0] + " " + c[1] + ",";
  };
  for (var i = 0; i < this.geometries.length; i++) {
    if (this.geometries[i].coords.length === 0) {
      return "LINESTRING(empty)";
    } else {
      var coords = this.geometries[i].coords;
      coords.forEach(collect);
      wkt_string += wkt.substring(0, wkt.length - 1) + ")";
    }
  }
  return wkt_string;
};

/*
 * http://en.wikipedia.org/wiki/Great-circle_distance
 *
 */
var GreatCircle = function (start, end, properties) {
  if (!start || start.x === undefined || start.y === undefined) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  if (!end || end.x === undefined || end.y === undefined) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  this.start = new Coord(start.x, start.y);
  this.end = new Coord(end.x, end.y);
  this.properties = properties || {};

  var w = this.start.x - this.end.x;
  var h = this.start.y - this.end.y;
  var z =
    Math.pow(Math.sin(h / 2.0), 2) +
    Math.cos(this.start.y) *
      Math.cos(this.end.y) *
      Math.pow(Math.sin(w / 2.0), 2);
  this.g = 2.0 * Math.asin(Math.sqrt(z));

  if (this.g === Math.PI) {
    throw new Error(
      "it appears " +
        start.view() +
        " and " +
        end.view() +
        " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
    );
  } else if (isNaN(this.g)) {
    throw new Error(
      "could not calculate great circle between " + start + " and " + end
    );
  }
};

/*
 * http://williams.best.vwh.net/avform.htm#Intermediate
 */
GreatCircle.prototype.interpolate = function (f) {
  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
  var B = Math.sin(f * this.g) / Math.sin(this.g);
  var x =
    A * Math.cos(this.start.y) * Math.cos(this.start.x) +
    B * Math.cos(this.end.y) * Math.cos(this.end.x);
  var y =
    A * Math.cos(this.start.y) * Math.sin(this.start.x) +
    B * Math.cos(this.end.y) * Math.sin(this.end.x);
  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
  var lon = R2D * Math.atan2(y, x);
  return [lon, lat];
};

/*
 * Generate points along the great circle
 */
GreatCircle.prototype.Arc = function (npoints, options) {
  var first_pass = [];
  if (!npoints || npoints <= 2) {
    first_pass.push([this.start.lon, this.start.lat]);
    first_pass.push([this.end.lon, this.end.lat]);
  } else {
    var delta = 1.0 / (npoints - 1);
    for (var i = 0; i < npoints; ++i) {
      var step = delta * i;
      var pair = this.interpolate(step);
      first_pass.push(pair);
    }
  }
  /* partial port of dateline handling from:
      gdal/ogr/ogrgeometryfactory.cpp

      TODO - does not handle all wrapping scenarios yet
    */
  var bHasBigDiff = false;
  var dfMaxSmallDiffLong = 0;
  // from http://www.gdal.org/ogr2ogr.html
  // -datelineoffset:
  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)
  var dfDateLineOffset = options && options.offset ? options.offset : 10;
  var dfLeftBorderX = 180 - dfDateLineOffset;
  var dfRightBorderX = -180 + dfDateLineOffset;
  var dfDiffSpace = 360 - dfDateLineOffset;

  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342
  for (var j = 1; j < first_pass.length; ++j) {
    var dfPrevX = first_pass[j - 1][0];
    var dfX = first_pass[j][0];
    var dfDiffLong = Math.abs(dfX - dfPrevX);
    if (
      dfDiffLong > dfDiffSpace &&
      ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) ||
        (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))
    ) {
      bHasBigDiff = true;
    } else if (dfDiffLong > dfMaxSmallDiffLong) {
      dfMaxSmallDiffLong = dfDiffLong;
    }
  }

  var poMulti = [];
  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
    var poNewLS = [];
    poMulti.push(poNewLS);
    for (var k = 0; k < first_pass.length; ++k) {
      var dfX0 = parseFloat(first_pass[k][0]);
      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
        var dfX1 = parseFloat(first_pass[k - 1][0]);
        var dfY1 = parseFloat(first_pass[k - 1][1]);
        var dfX2 = parseFloat(first_pass[k][0]);
        var dfY2 = parseFloat(first_pass[k][1]);
        if (
          dfX1 > -180 &&
          dfX1 < dfRightBorderX &&
          dfX2 === 180 &&
          k + 1 < first_pass.length &&
          first_pass[k - 1][0] > -180 &&
          first_pass[k - 1][0] < dfRightBorderX
        ) {
          poNewLS.push([-180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        } else if (
          dfX1 > dfLeftBorderX &&
          dfX1 < 180 &&
          dfX2 === -180 &&
          k + 1 < first_pass.length &&
          first_pass[k - 1][0] > dfLeftBorderX &&
          first_pass[k - 1][0] < 180
        ) {
          poNewLS.push([180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        }

        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
          // swap dfX1, dfX2
          var tmpX = dfX1;
          dfX1 = dfX2;
          dfX2 = tmpX;
          // swap dfY1, dfY2
          var tmpY = dfY1;
          dfY1 = dfY2;
          dfY2 = tmpY;
        }
        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
          dfX2 += 360;
        }

        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
            dfY,
          ]);
          poNewLS = [];
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
            dfY,
          ]);
          poMulti.push(poNewLS);
        } else {
          poNewLS = [];
          poMulti.push(poNewLS);
        }
        poNewLS.push([dfX0, first_pass[k][1]]);
      } else {
        poNewLS.push([first_pass[k][0], first_pass[k][1]]);
      }
    }
  } else {
    // add normally
    var poNewLS0 = [];
    poMulti.push(poNewLS0);
    for (var l = 0; l < first_pass.length; ++l) {
      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
    }
  }

  var arc = new Arc(this.properties);
  for (var m = 0; m < poMulti.length; ++m) {
    var line = new LineString();
    arc.geometries.push(line);
    var points = poMulti[m];
    for (var j0 = 0; j0 < points.length; ++j0) {
      line.move_to(points[j0]);
    }
  }
  return arc;
};

/**
 * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.
 * If the `start` and `end` points span the antimeridian, the resulting feature will
 * be split into a `MultiLineString`.
 *
 * @name greatCircle
 * @param {Coord} start source point feature
 * @param {Coord} end destination point feature
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] line feature properties
 * @param {number} [options.npoints=100] number of points
 * @param {number} [options.offset=10] offset controls the likelyhood that lines will
 * be split which cross the dateline. The higher the number the more likely.
 * @returns {Feature<LineString | MultiLineString>} great circle line feature
 * @example
 * var start = turf.point([-122, 48]);
 * var end = turf.point([-77, 39]);
 *
 * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});
 *
 * //addToMap
 * var addToMap = [start, end, greatCircle]
 */
function greatCircle(start, end, options) {
  // Optional parameters
  options = options || {};
  if (typeof options !== "object") throw new Error("options is invalid");
  var properties = options.properties;
  var npoints = options.npoints;
  var offset = options.offset;

  start = invariant.getCoord(start);
  end = invariant.getCoord(end);
  properties = properties || {};
  npoints = npoints || 100;
  offset = offset || 10;

  var generator = new GreatCircle(
    { x: start[0], y: start[1] },
    { x: end[0], y: end[1] },
    properties
  );

  var line = generator.Arc(npoints, { offset: offset });

  return line.json();
}

module.exports = greatCircle;
module.exports["default"] = greatCircle;


/***/ }),

/***/ 2363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var distance = __webpack_require__(9391);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);

/**
 * Takes a bounding box and calculates the minimum square bounding box that
 * would contain the input.
 *
 * @name square
 * @param {BBox} bbox extent in [west, south, east, north] order
 * @returns {BBox} a square surrounding `bbox`
 * @example
 * var bbox = [-20, -20, -15, 0];
 * var squared = turf.square(bbox);
 *
 * //addToMap
 * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]
 */
function square(bbox) {
  var west = bbox[0];
  var south = bbox[1];
  var east = bbox[2];
  var north = bbox[3];

  var horizontalDistance = distance__default['default'](bbox.slice(0, 2), [east, south]);
  var verticalDistance = distance__default['default'](bbox.slice(0, 2), [west, north]);
  if (horizontalDistance >= verticalDistance) {
    var verticalMidpoint = (south + north) / 2;
    return [
      west,
      verticalMidpoint - (east - west) / 2,
      east,
      verticalMidpoint + (east - west) / 2,
    ];
  } else {
    var horizontalMidpoint = (west + east) / 2;
    return [
      horizontalMidpoint - (north - south) / 2,
      south,
      horizontalMidpoint + (north - south) / 2,
      north,
    ];
  }
}

module.exports = square;
module.exports["default"] = square;


/***/ }),

/***/ 2446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var invariant_1 = __webpack_require__(8506);
// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
 * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 *
 * @name booleanPointInPolygon
 * @param {Coord} point input point
 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * turf.booleanPointInPolygon(pt, poly);
 * //= true
 */
function booleanPointInPolygon(point, polygon, options) {
    if (options === void 0) { options = {}; }
    // validation
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    var pt = invariant_1.getCoord(point);
    var geom = invariant_1.getGeom(polygon);
    var type = geom.type;
    var bbox = polygon.bbox;
    var polys = geom.coordinates;
    // Quick elimination if point is not inside bbox
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    // normalize to multipolygon
    if (type === "Polygon") {
        polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) {
                insidePoly = true;
            }
        }
    }
    return insidePoly;
}
exports["default"] = booleanPointInPolygon;
/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @returns {boolean} inRing
 */
function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] &&
        ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&
            (xi - pt[0]) * (xj - pt[0]) <= 0 &&
            (yi - pt[1]) * (yj - pt[1]) <= 0;
        if (onBoundary) {
            return !ignoreBoundary;
        }
        var intersect = yi > pt[1] !== yj > pt[1] &&
            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;
        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
}
/**
 * inBBox
 *
 * @private
 * @param {Position} pt point [x,y]
 * @param {BBox} bbox BBox [west, south, east, north]
 * @returns {boolean} true/false if point is inside BBox
 */
function inBBox(pt, bbox) {
    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);
}


/***/ }),

/***/ 2571:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.get_annotation_confidence = get_annotation_confidence;
exports.get_annotation_class_id = get_annotation_class_id;
exports.mark_deprecated = mark_deprecated;
exports.value_is_lower_than_filter = value_is_lower_than_filter;
exports.value_is_higher_than_filter = value_is_higher_than_filter;
exports.filter_high = filter_high;
exports.assign_closest_line_to_each_point = assign_closest_line_to_each_point;
exports.assign_closest_line_to_single_point = assign_closest_line_to_single_point;
exports.update_distance_from_line_to_each_point = update_distance_from_line_to_each_point;
exports.is_closest_line_to_point = is_closest_line_to_point;
exports.get_point_and_line_annotations = get_point_and_line_annotations;
exports.filter_points_distance_from_line = filter_points_distance_from_line;
exports.findAllPolylineClassDefinitions = findAllPolylineClassDefinitions;
/**
 * Returns the confidence of the passed in ULabelAnnotation.
 * In the case of multiple classifications in the classification_payloads, returns the largest confidence value.
 *
 * @param annotation ULabelAnnotation
 * @returns The largest confidence value inside classification_payloads
 */
function get_annotation_confidence(annotation) {
    var current_confidence = -1;
    for (var type_of_id in annotation.classification_payloads) {
        if (annotation.classification_payloads[type_of_id].confidence > current_confidence) {
            current_confidence = annotation.classification_payloads[type_of_id].confidence;
        }
    }
    return current_confidence;
}
/**
 * Returns the class id of a ULabelAnnotation as a string.
 *
 * @param annotation ULabelAnnotation
 * @returns The class id of the annotation as a string
 */
function get_annotation_class_id(annotation) {
    // Keep track of the most likely class id and its confidence
    var id, confidence;
    // Go through each item in the classification payload
    annotation.classification_payloads.forEach(function (current_payload) {
        // The confidence will be undefined the first time through, so set the id and confidence for a baseline
        // Otherwise replace the id if the conidence is higher
        if (confidence === undefined || current_payload.confidence > confidence) {
            id = current_payload.class_id;
            confidence = current_payload.confidence;
        }
    });
    return id.toString();
}
/**
 * Takes in an annotation and marks it either deprecated or not deprecated.
 *
 * @param annotation ULabelAnnotation
 * @param deprecated boolean
 * @param deprecated_by_key
 */
function mark_deprecated(annotation, deprecated, deprecated_by_key) {
    if (deprecated_by_key === void 0) { deprecated_by_key = "human"; }
    if (annotation.deprecated_by === undefined) {
        annotation.deprecated_by = {};
    }
    annotation.deprecated_by[deprecated_by_key] = deprecated;
    // If the annotation has been deprecated by any method, then deprecate the annotation
    if (Object.values(annotation.deprecated_by).some(function (x) { return x; })) {
        annotation.deprecated = true;
        return;
    }
    // If the annotation hasn't been deprecated by any property, then set deprecated to false
    annotation.deprecated = false;
}
/**
 * If the value is less than the filter then return true, else return false.
 *
 * @param value Value to be compaired against the filter
 * @param filter What the value is compared against
 * @returns True if the value is less than the filter, false otherwise
 */
function value_is_lower_than_filter(value, filter) {
    return value < filter;
}
/**
 * If the value is greater than the filter then return true, else return false.
 *
 * @param value Value to be compaired against the filter
 * @param filter What the value is compared against
 * @returns True if the value is greater than the filter, false otherwise
 */
function value_is_higher_than_filter(value, filter) {
    return value > filter;
}
/**
 * Takes in a list of annotations and either deprecates or undeprecates them based on if their property is higher than the
 * filter value.
 *
 * @param annotations List of annotations to be compared against the filter value
 * @param property The property on the annotation to be compared against the filter. e.g. "confidence"
 * @param filter The value all filters will be compared against
 */
function filter_high(annotations, property, filter, deprecated_by_key) {
    // Loop through each point annotation and deprecate them if they don't pass the filter
    annotations.forEach(function (annotation) {
        // Make sure the annotation is not a human deprecated one
        if (!annotation.deprecated_by["human"]) {
            // Run the annotation through the filter with the passed in property
            var should_deprecate = value_is_higher_than_filter(annotation[property], filter);
            // Mark the point deprecated
            mark_deprecated(annotation, should_deprecate, deprecated_by_key);
        }
    });
}
/**
 * Calculates the distance from a point to a line segment.
 *
 * @param point_x The point's x position
 * @param point_y The point's y position
 * @param line_x1 The first endpoint of the line's x position
 * @param line_y1 The first endpoint of the line's y position
 * @param line_x2 The second endpoint of the line's x position
 * @param line_y2 The second endpoint of the line's y position
 * @returns The distance from the point to the line segment
 */
function calculate_distance_from_point_to_line(point_x, point_y, line_x1, line_y1, line_x2, line_y2) {
    var A = point_x - line_x1;
    var B = point_y - line_y1;
    var C = line_x2 - line_x1;
    var D = line_y2 - line_y1;
    var dot = A * C + B * D;
    var len_sq = C * C + D * D;
    // Initialize the param variable
    var param;
    // Check for a divide by 0 error in the case of 0 length line
    if (len_sq != 0) {
        param = dot / len_sq;
    }
    var xx, yy;
    // If param is still undefined then the line should have 0 length
    // In which case we can set xx and yy equal to any endpoint
    if (param === undefined) {
        xx = line_x1;
        yy = line_y1;
    }
    else if (param < 0) {
        xx = line_x1;
        yy = line_y1;
    }
    else if (param > 1) {
        xx = line_x2;
        yy = line_y2;
    }
    else {
        xx = line_x1 + param * C;
        yy = line_y1 + param * D;
    }
    var dx = point_x - xx;
    var dy = point_y - yy;
    return Math.sqrt(dx * dx + dy * dy);
}
/**
 * Calculates the distance from a point annotation to each segment of a polyline annotation, then returns the smallest distance.
 *
 * @param point_annotation Point annotation to get the distance of
 * @param line_annotation Line annotation the point annotation is being compared against
 * @param offset Offset of a particular annotation in the set. Used when an annotation is being moved by the user
 * @returns The distance from a point to a polyline
 */
function get_distance_from_point_to_line(point_annotation, line_annotation, offset) {
    if (offset === void 0) { offset = null; }
    // Create constants for the point's x and y value
    var point_x = point_annotation.spatial_payload[0][0];
    var point_y = point_annotation.spatial_payload[0][1];
    // Initialize the distance from the point to the polyline
    var distance;
    // Loop through each segment of the polyline
    for (var idx = 0; idx < line_annotation.spatial_payload.length - 1; idx++) {
        // Create constants for the segment's endpoints' x and y values
        var line_x1 = line_annotation.spatial_payload[idx][0];
        var line_y1 = line_annotation.spatial_payload[idx][1];
        var line_x2 = line_annotation.spatial_payload[idx + 1][0];
        var line_y2 = line_annotation.spatial_payload[idx + 1][1];
        // Create offset variables
        var line_offset_x = 0;
        var line_offset_y = 0;
        // Only apply the offset when the line annotation id matches with the offset id
        // Check if offset !== null first to avoid an issue with reading properties of null
        if ((offset !== null) && (line_annotation.id === offset.id)) {
            line_offset_x = offset.diffX;
            line_offset_y = offset.diffY;
        }
        // Calculate the distance from the point to the line segment
        var distance_to_segment = calculate_distance_from_point_to_line(point_x, point_y, line_x1 + line_offset_x, line_y1 + line_offset_y, line_x2 + line_offset_x, line_y2 + line_offset_y);
        // Check if the distance to this segment is undefined or less than the distance to another segment
        if (distance === undefined || distance_to_segment < distance) {
            distance = distance_to_segment;
        }
    }
    return distance;
}
/**
 * Wrapper for assign_closest_line_to_single_point()
 *
 * @param point_annotations Set of point annotations
 * @param line_annotations Set of line annotations
 * @param offset Offset of a particular annotation in the set. Used when an annotation is being moved by the user
 */
function assign_closest_line_to_each_point(point_annotations, line_annotations, offset) {
    if (offset === void 0) { offset = null; }
    // Loop through every point and assign it a distance from line
    point_annotations.forEach(function (current_point) {
        assign_closest_line_to_single_point(current_point, line_annotations, offset);
    });
}
/**
 * Assigns a single point annotation a distance to the closest polyline
 * from each diffrent class of polyline, as well as the distance from
 * the closest line, regardless of class.
 *
 * @param point_annotation single point annotation
 * @param line_annotations set of line annotations
 * @param offset Offset of a particular annotation in the set. Used when an annotation is being moved by the user
 */
function assign_closest_line_to_single_point(point_annotation, line_annotations, offset) {
    if (offset === void 0) { offset = null; }
    // Create a new distance_from object for the point annotation
    var distance_from = { closest_row: { distance: Infinity } };
    // Calculate the distance from each line and populate the distance_from accordingly
    line_annotations.forEach(function (current_line) {
        var line_class_id = get_annotation_class_id(current_line);
        var distance = get_distance_from_point_to_line(point_annotation, current_line, offset);
        // If the distance from the current class is undefined, then set it
        // Otherwise replace the value if the current distance is less than the one set
        if (distance_from[line_class_id] === undefined || distance < distance_from[line_class_id].distance) {
            distance_from[line_class_id] = {
                distance: distance,
                polyline_id: current_line.id,
            };
        }
        // Likewise check to see if the current distance is less than a line of any class
        if (distance < distance_from.closest_row.distance) {
            distance_from.closest_row = {
                distance: distance,
                polyline_id: current_line.id,
            };
        }
    });
    // Assign the distance from object to the current point
    point_annotation.distance_from = distance_from;
}
/**
 * Update the distance from a single line to each point annotation.
 * If a line was previously the closest line to a point, then the distance from that point to ALL lines will be recalculated.
 * Used when a single polyline is modified.
 *
 * @param line_annotation line annotation
 * @param point_annotations all point annotations
 * @param all_line_annotations all line annotations
 * @param offset offset of the line annotation
 */
function update_distance_from_line_to_each_point(line_annotation, point_annotations, all_line_annotations, offset) {
    if (offset === void 0) { offset = null; }
    // Get the class id of the line annotation
    var line_class_id = get_annotation_class_id(line_annotation);
    // Loop through each point and update the distance from the line to the point
    point_annotations.forEach(function (current_point) {
        // Check if the line was the closest line to the point for any class
        if (is_closest_line_to_point(line_annotation.id, current_point)) {
            // Recalculate the distance from the point to all lines, since this may no longer be its closest line
            assign_closest_line_to_single_point(current_point, all_line_annotations, offset);
        }
        else {
            // Otherwise only update the distance from the line to the point
            var distance = get_distance_from_point_to_line(current_point, line_annotation, offset);
            // Check if the line is the closest line of its class to the point
            if (current_point.distance_from[line_class_id] === undefined ||
                distance < current_point.distance_from[line_class_id].distance) {
                current_point.distance_from[line_class_id] = {
                    distance: distance,
                    polyline_id: line_annotation.id,
                };
            }
            // Check if the line is the closest line to the point
            if (current_point.distance_from.closest_row === undefined ||
                distance < current_point.distance_from.closest_row.distance) {
                current_point.distance_from.closest_row = {
                    distance: distance,
                    polyline_id: line_annotation.id,
                };
            }
        }
    });
}
/**
 * Check if a line is the closest line to a point annotation,
 * either the closest line for any class or the closest line for a specific class.
 *
 * @param line_id polyline id
 * @param point_annotation point annotation
 * @returns whether the line is the closest line to the point
 */
function is_closest_line_to_point(line_id, point_annotation) {
    // Check if the distance_from is undefined
    if (point_annotation.distance_from === undefined) {
        console.error("is_closest_line_to_point called on a point without a distance_from object");
    }
    // Loop through each class in the distance_from object
    for (var class_id in point_annotation.distance_from) {
        // Check if the line id matches the closest line id for any class
        if (point_annotation.distance_from[class_id] !== undefined &&
            point_annotation.distance_from[class_id].polyline_id === line_id) {
            return true;
        }
    }
    return false;
}
function get_point_and_line_annotations(ulabel) {
    // Initialize set of all point and line annotations
    var point_annotations = [];
    var line_annotations = [];
    // Go through all annotations to populate a set of all point annotations and a set of all line annotations
    // First loop through each subtask
    for (var _i = 0, _a = Object.entries(ulabel.subtasks); _i < _a.length; _i++) {
        var _b = _a[_i], subtask_key = _b[0], subtask = _b[1];
        // Then go through each annotation in the subtask
        for (var annotation_key in subtask.annotations.access) {
            var annotation = subtask.annotations.access[annotation_key];
            // Check for annotation type and push the annotation into the appropriate array
            switch (annotation.spatial_type) {
                case "point":
                    // Note the annotation's subtask
                    annotation.subtask_key = subtask_key;
                    // Add the point annotation to the set
                    point_annotations.push(annotation);
                    break;
                case "polyline":
                    // Skip over deprecated line annotations
                    if (annotation.deprecated)
                        continue;
                    // Add non-deprecated line annotations to the set
                    line_annotations.push(annotation);
                    break;
            }
        }
    }
    return [point_annotations, line_annotations];
}
/**
 * Using the value of the FilterPointDistanceFromRow's slider, filter all point annotations based on their distance
 * from a polyline annotation.
 *
 * @param ulabel ULabel object
 * @param recalculate_distances whether to recalculate the distance from each point to the nearest line
 * @param offset Offset of a particular annotation. Used when filter is called while an annotation is being moved
 * @param override Used to filter annotations without calling the dom
 */
function filter_points_distance_from_line(ulabel, recalculate_distances, offset, override) {
    if (recalculate_distances === void 0) { recalculate_distances = false; }
    if (offset === void 0) { offset = null; }
    if (override === void 0) { override = null; }
    // Get a set of all point and polyline annotations
    var annotations = get_point_and_line_annotations(ulabel);
    var point_annotations = annotations[0];
    var line_annotations = annotations[1];
    // Initialize variables to hold info required from the dom
    var multi_class_mode = false;
    var show_overlay;
    var should_redraw;
    var distances = { closest_row: undefined };
    // If the override is null grab the necessary info from the dom
    if (override === null) {
        // Used for error checking
        var return_early = false;
        // Try to grab the elements from the dom
        var multi_checkbox = document.querySelector("#filter-slider-distance-multi-checkbox");
        var show_overlay_checkbox = document.querySelector("#filter-slider-distance-toggle-overlay-checkbox");
        var sliders = document.querySelectorAll(".filter-row-distance-slider");
        // Check to make sure each element exists before trying to use
        if (show_overlay_checkbox === null) {
            console.error("filter_points_distance_from_line could not find show_overlay checkbox object");
            return_early = true;
        }
        if (sliders === null || sliders.length === 0) {
            console.error("filter_points_distance_from_line could not find any filter distance slider objects");
            return_early = true;
        }
        if (return_early)
            return;
        // Checkbox may not exist if `disable_multi_class_mode` is set to true
        if (multi_checkbox) {
            multi_class_mode = multi_checkbox.checked;
        }
        show_overlay = show_overlay_checkbox.checked;
        // Loop through each slider and populate distances
        for (var idx = 0; idx < sliders.length; idx++) {
            // Use a regex to get the string after the final - character in the slider id (Which is the class id or the string "closest_row")
            var slider_class_name = /[^-]*$/.exec(sliders[idx].id)[0];
            // Use the class id as a key to store the slider's value
            distances[slider_class_name] = {
                distance: sliders[idx].valueAsNumber,
            };
        }
        // Always redraw when there's no override
        should_redraw = true;
    }
    else {
        multi_class_mode = override.multi_class_mode;
        show_overlay = override.show_overlay;
        distances = override.distances;
        should_redraw = override.should_redraw; // Useful for filtering before annotations have been rendered
    }
    if (recalculate_distances) {
        // Calculate and assign each point a distance from line value
        assign_closest_line_to_each_point(point_annotations, line_annotations, offset);
    }
    // Store which annotations need to be redrawn
    var annotations_ids_to_redraw_by_subtask = {};
    // Initialize the object with the subtask keys
    for (var subtask_key in ulabel.subtasks) {
        annotations_ids_to_redraw_by_subtask[subtask_key] = [];
    }
    // Filter each point based on current mode, distances, and its distance_from property
    if (multi_class_mode) {
        // Loop through each point and deprecate them if they fall outside the range of all lines
        point_annotations.forEach(function (annotation) {
            check_distances: {
                for (var id in distances) {
                    // Ignore the single class slider
                    if (id === "closest_row")
                        continue;
                    // If the annotation is smaller than the filter value for any id, it passes
                    if (annotation.distance_from[id] !== undefined &&
                        annotation.distance_from[id].distance <= distances[id].distance) {
                        if (annotation.deprecated) {
                            // Undeprecate the annotation
                            mark_deprecated(annotation, false, "distance_from_row");
                            annotations_ids_to_redraw_by_subtask[annotation.subtask_key].push(annotation.id);
                        }
                        break check_distances;
                    }
                }
                // Only here if break not called
                if (!annotation.deprecated) {
                    mark_deprecated(annotation, true, "distance_from_row");
                    annotations_ids_to_redraw_by_subtask[annotation.subtask_key].push(annotation.id);
                }
            }
        });
    }
    else {
        // Single-class mode
        point_annotations.forEach(function (annotation) {
            var should_deprecate = annotation.distance_from.closest_row.distance > distances.closest_row.distance;
            // Only change deprecated status and redraw if it needs to be changed
            if (should_deprecate && !annotation.deprecated) {
                mark_deprecated(annotation, true, "distance_from_row");
                annotations_ids_to_redraw_by_subtask[annotation.subtask_key].push(annotation.id);
            }
            else if (!should_deprecate && annotation.deprecated) {
                mark_deprecated(annotation, false, "distance_from_row");
                annotations_ids_to_redraw_by_subtask[annotation.subtask_key].push(annotation.id);
            }
        });
    }
    if (should_redraw) {
        // Redraw each subtask's annotations
        for (var subtask_key in annotations_ids_to_redraw_by_subtask) {
            ulabel.redraw_multiple_spatial_annotations(annotations_ids_to_redraw_by_subtask[subtask_key], subtask_key);
        }
    }
    // Ensure the overlay exists before trying to access it
    if (ulabel.filter_distance_overlay === null || ulabel.filter_distance_overlay === undefined) {
        console.warn("\n            filter_distance_overlay currently does not exist.\n            As such, unable to update distance overlay\n        ");
    }
    else {
        // Update overlay properties first
        ulabel.filter_distance_overlay.update_annotations(line_annotations);
        ulabel.filter_distance_overlay.update_distances(distances);
        ulabel.filter_distance_overlay.update_mode(multi_class_mode);
        ulabel.filter_distance_overlay.update_display_overlay(show_overlay);
        // Then redraw the overlay
        ulabel.filter_distance_overlay.draw_overlay(offset);
    }
}
/**
 * Goes through all subtasks and finds all classes that polylines can be. Then returns a list of them.
 *
 * @returns A list of all classes which can be polylines
 */
function findAllPolylineClassDefinitions(ulabel) {
    // Initialize potential class definitions
    var potential_class_defs = [];
    // Check each subtask to see if polyline is one of its allowed modes
    for (var subtask_key in ulabel.subtasks) {
        // Grab the subtask
        var subtask = ulabel.subtasks[subtask_key];
        if (subtask.allowed_modes.includes("polyline")) {
            // Loop through all the classes in the subtask
            subtask.class_defs.forEach(function (current_class_def) {
                potential_class_defs.push(current_class_def);
            });
        }
    }
    return potential_class_defs;
}


/***/ }),

/***/ 2583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var meta_1 = __webpack_require__(8421);
/**
 * Combines a {@link FeatureCollection} of {@link Point}, {@link LineString}, or {@link Polygon} features
 * into {@link MultiPoint}, {@link MultiLineString}, or {@link MultiPolygon} features.
 *
 * @name combine
 * @param {FeatureCollection<Point|LineString|Polygon>} fc a FeatureCollection of any type
 * @returns {FeatureCollection<MultiPoint|MultiLineString|MultiPolygon>} a FeatureCollection of corresponding type to input
 * @example
 * var fc = turf.featureCollection([
 *   turf.point([19.026432, 47.49134]),
 *   turf.point([19.074497, 47.509548])
 * ]);
 *
 * var combined = turf.combine(fc);
 *
 * //addToMap
 * var addToMap = [combined]
 */
function combine(fc) {
    var groups = {
        MultiPoint: {
            coordinates: [],
            properties: [],
        },
        MultiLineString: {
            coordinates: [],
            properties: [],
        },
        MultiPolygon: {
            coordinates: [],
            properties: [],
        },
    };
    meta_1.featureEach(fc, function (feature) {
        var _a, _b, _c;
        var _d;
        switch ((_d = feature.geometry) === null || _d === void 0 ? void 0 : _d.type) {
            case "Point":
                groups.MultiPoint.coordinates.push(feature.geometry.coordinates);
                groups.MultiPoint.properties.push(feature.properties);
                break;
            case "MultiPoint":
                (_a = groups.MultiPoint.coordinates).push.apply(_a, feature.geometry.coordinates);
                groups.MultiPoint.properties.push(feature.properties);
                break;
            case "LineString":
                groups.MultiLineString.coordinates.push(feature.geometry.coordinates);
                groups.MultiLineString.properties.push(feature.properties);
                break;
            case "MultiLineString":
                (_b = groups.MultiLineString.coordinates).push.apply(_b, feature.geometry.coordinates);
                groups.MultiLineString.properties.push(feature.properties);
                break;
            case "Polygon":
                groups.MultiPolygon.coordinates.push(feature.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature.properties);
                break;
            case "MultiPolygon":
                (_c = groups.MultiPolygon.coordinates).push.apply(_c, feature.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature.properties);
                break;
            default:
                break;
        }
    });
    return helpers_1.featureCollection(Object.keys(groups)
        .filter(function (key) {
        return groups[key].coordinates.length;
    })
        .sort()
        .map(function (key) {
        var geometry = { type: key, coordinates: groups[key].coordinates };
        var properties = { collectedProperties: groups[key].properties };
        return helpers_1.feature(geometry, properties);
    }));
}
exports["default"] = combine;


/***/ }),

/***/ 2748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BACK_Z_INDEX: () => (/* binding */ BACK_Z_INDEX),
/* harmony export */   BBOX3_SVG: () => (/* binding */ BBOX3_SVG),
/* harmony export */   BBOX_SVG: () => (/* binding */ BBOX_SVG),
/* harmony export */   BUTTON_LOADER_HTML: () => (/* binding */ BUTTON_LOADER_HTML),
/* harmony export */   COLORS: () => (/* binding */ COLORS),
/* harmony export */   CONTOUR_SVG: () => (/* binding */ CONTOUR_SVG),
/* harmony export */   DELETE_BBOX_SVG: () => (/* binding */ DELETE_BBOX_SVG),
/* harmony export */   DELETE_POLYGON_SVG: () => (/* binding */ DELETE_POLYGON_SVG),
/* harmony export */   DEMO_ANNOTATION: () => (/* binding */ DEMO_ANNOTATION),
/* harmony export */   FRONT_Z_INDEX: () => (/* binding */ FRONT_Z_INDEX),
/* harmony export */   GLOBAL_SVG: () => (/* binding */ GLOBAL_SVG),
/* harmony export */   POINT_SVG: () => (/* binding */ POINT_SVG),
/* harmony export */   POLYGON_SVG: () => (/* binding */ POLYGON_SVG),
/* harmony export */   POLYLINE_SVG: () => (/* binding */ POLYLINE_SVG),
/* harmony export */   TBAR_SVG: () => (/* binding */ TBAR_SVG),
/* harmony export */   WHOLE_IMAGE_SVG: () => (/* binding */ WHOLE_IMAGE_SVG),
/* harmony export */   get_init_style: () => (/* binding */ get_init_style)
/* harmony export */ });
// z-indices for canvases
const FRONT_Z_INDEX = 100;
const BACK_Z_INDEX = 75;
const DEMO_ANNOTATION = { id: "7c64913a-9d8c-475a-af1a-658944e37c31", new: true, created_by: "TestUser", created_at: "2020-12-21T02:41:47.304Z", deprecated: false, spatial_type: "contour", spatial_payload: [[4, 25], [4, 25], [4, 24], [4, 23], [4, 22], [4, 22], [5, 22], [5, 21], [5, 20], [6, 20], [6, 19], [7, 19], [7, 18], [8, 18], [8, 18], [10, 18], [11, 18], [11, 17], [12, 17], [12, 16], [12, 16], [13, 16], [14, 15], [16, 14], [16, 14], [17, 14], [18, 14], [18, 13], [19, 13], [20, 13], [20, 13], [21, 13], [22, 13], [23, 13], [24, 13], [24, 13], [25, 13], [26, 13], [27, 13], [28, 13], [28, 13], [29, 13], [30, 13], [31, 13], [32, 13], [34, 13], [36, 14], [36, 14], [37, 15], [40, 15], [40, 16], [41, 16], [42, 17], [43, 17], [44, 18], [44, 18], [45, 18], [46, 18], [47, 18], [47, 18], [48, 18], [48, 18], [49, 19], [50, 20], [52, 20], [52, 20], [53, 21], [54, 21], [55, 21], [56, 21], [57, 21], [58, 22], [59, 22], [60, 22], [60, 22], [61, 22], [63, 22], [64, 22], [64, 22], [65, 22], [66, 22], [67, 22], [68, 22], [68, 21], [69, 21], [70, 20], [70, 19], [71, 19], [71, 18], [72, 18], [72, 18], [72, 18], [73, 18], [75, 17], [75, 16], [76, 16], [76, 16], [76, 15], [77, 14], [78, 14], [79, 14], [79, 13], [79, 12], [80, 12], [81, 12], [82, 11], [83, 11], [84, 10], [85, 10], [86, 10], [87, 10], [88, 10], [88, 10], [89, 10], [90, 10], [91, 10], [92, 10], [92, 10], [93, 10], [94, 10], [94, 10], [95, 10], [96, 10], [96, 11], [96, 11], [98, 11], [98, 12], [99, 12], [100, 13], [100, 14], [101, 14], [101, 15], [102, 15], [104, 16], [104, 17], [104, 18], [105, 18], [106, 18], [106, 18], [107, 18], [107, 19], [107, 20], [108, 20], [108, 21], [108, 21], [108, 22], [109, 22], [109, 22], [109, 23]], classification_payloads: null, annotation_meta: "is_assigned_to_each_annotation" };
const BBOX_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="bbox.svg"
   aria-labelledby="unique-title-id-bbox unique-desc-id-bbox">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="319.49724"
     inkscape:cy="182.97951"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1848"
     inkscape:window-height="1016"
     inkscape:window-x="1992"
     inkscape:window-y="111"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:1.48994207;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker-start:url(#DotL);marker-mid:url(#DotL);paint-order:stroke fill markers"
       d="m 10,207 v 80 h 80 v -80 z"
       id="path3715"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc" />
  </g>
</svg>
`;
const DELETE_BBOX_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="bbox.svg"
   aria-labelledby="unique-title-id-bbox unique-desc-id-bbox">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="319.49724"
     inkscape:cy="182.97951"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1848"
     inkscape:window-height="1016"
     inkscape:window-x="1992"
     inkscape:window-y="111"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:1.48994207;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker-start:url(#DotL);marker-mid:url(#DotL);paint-order:stroke fill markers"
       d="m 10,207 v 80 h 80 v -80 z"
       id="path3715"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc" />
  </g>
  </g>
    <g id="dontSymbol">
      <path
         d="M 50,50 m -48,0 a 41,41 0 1,0 96,0 a 41,41 0 1,0 -96,0"
         style="fill:none;stroke:#ff0000;stroke-width:2"
      />
      <path
         d="M 16,16 L 84,84"
         style="fill:none;stroke:#ff0000;stroke-width:2"
      />
  </g>
</svg>
`;
const POINT_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="point.svg">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1156"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1154"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1152"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1150"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1148"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path946"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.1443229"
     inkscape:cx="138.27833"
     inkscape:cy="159.299"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1043"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <circle
       style="fill:#fedbdb;fill-opacity:0;stroke:#000000;stroke-width:3.34195209;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:normal"
       id="path884"
       cx="50"
       cy="247"
       r="23.329023" />
    <circle
       style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.06185877;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:normal"
       id="path886"
       cx="50"
       cy="247"
       r="6.9690704" />
  </g>
</svg>
`;
const POLYGON_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="polygon.svg"
   aria-labelledby="unique-title-id-polygon unique-desc-id-polygon">
  <defs
     id="defs7239">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL2"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4588"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="446.28295"
     inkscape:cy="182.97951"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1848"
     inkscape:window-height="1016"
     inkscape:window-x="1992"
     inkscape:window-y="111"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:1.48994207;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker-start:url(#DotL2);marker-mid:url(#DotL2);paint-order:stroke fill markers"
       d="m 41.284493,204.35565 -33.5734849,28.74943 7.6220859,56.71655 76.946838,-12.1256 -41.921509,-38.137 z"
       id="path3715"
       inkscape:connector-curvature="0" />
  </g>
</svg>
`;
const DELETE_POLYGON_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="polygon.svg"
   aria-labelledby="unique-title-id-polygon unique-desc-id-polygon">
  <defs
     id="defs7239">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL2"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4588"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="446.28295"
     inkscape:cy="182.97951"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1848"
     inkscape:window-height="1016"
     inkscape:window-x="1992"
     inkscape:window-y="111"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:1.48994207;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker-start:url(#DotL2);marker-mid:url(#DotL2);paint-order:stroke fill markers"
       d="m 41.284493,204.35565 -33.5734849,28.74943 7.6220859,56.71655 76.946838,-12.1256 -41.921509,-38.137 z"
       id="path3715"
       inkscape:connector-curvature="0" />
  </g>
  </g>
    <g id="dontSymbol">
      <path
         d="M 50,50 m -48,0 a 41,41 0 1,0 96,0 a 41,41 0 1,0 -96,0"
         style="fill:none;stroke:#ff0000;stroke-width:2"
      />
      <path
         d="M 16,16 L 84,84"
         style="fill:none;stroke:#ff0000;stroke-width:2"
      />
  </g>
</svg>
`;
const CONTOUR_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="contour.svg">
  <defs
     id="defs7240">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4589"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="194.1401"
     inkscape:cy="180.12237"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1848"
     inkscape:window-height="1016"
     inkscape:window-x="1992"
     inkscape:window-y="111"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;stroke:#000000;stroke-width:5.465;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 81.075893,208.17559 c -34.584822,16.06399 -59.342262,13.60715 -61.988096,34.01786 -2.645833,20.41071 1.700893,48.38095 11.150298,49.51488 9.449403,1.13393 31.938986,1.13393 37.986607,-6.4256 6.047618,-7.55952 12.284226,-19.65476 12.095237,-30.80505 -0.188987,-11.1503 -6.425594,-34.01786 -34.206844,-52.34971"
       id="path865"
       inkscape:connector-curvature="0" />
  </g>
</svg>
`;
const TBAR_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="tbar.svg">
  <defs
     id="defs7241">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4590"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="194.1401"
     inkscape:cy="180.12237"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1043"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;stroke:#000000;stroke-width:5.54668236;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 34.757974,262.61957 54.396902,-54.3973"
       id="path848"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:5.92665672;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 7.3110211,235.09974 63.120496,290.9085"
       id="path850"
       inkscape:connector-curvature="0" />
  </g>
</svg>
`;
const GLOBAL_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="global_v2.svg">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1156"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1154"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1152"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1150"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1148"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path946"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="5.310344"
     inkscape:cy="177.26523"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1043"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714288;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 30.000035,244.14279 V 226.99993 H 47.142863"
       id="path883"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714288;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 47.142863,286.99993 H 30.000035 v -17.14286"
       id="path883-3"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714288;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 89.999929,269.85707 v 17.14286 H 72.857102"
       id="path883-3-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714288;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 72.857102,226.99993 h 17.142827 v 17.14286"
       id="path883-3-7"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.66666669"
       d="M 20.000052,234.14279 V 216.99993 H 37.14284"
       id="path883-2"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.66666669"
       d="M 30,276.99993 H 20.000052 V 259.85707"
       id="path883-3-70"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.66666669"
       d="M 62.857016,216.99993 H 79.999804 V 227"
       id="path883-3-7-3"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.53431374"
       d="M 10.00007,224.14279 V 206.99993 H 27.142858"
       id="path883-2-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.53431374"
       d="M 19.5,266.99993 H 10.00007 V 249.85707"
       id="path883-3-70-0"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.27714133;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.53431374"
       d="M 52.857035,206.99993 H 69.999821 V 216.5"
       id="path883-3-7-3-2"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
  </g>
</svg>
`;
const WHOLE_IMAGE_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="whole_image.svg">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1156"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1154"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1152"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1150"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1148"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path946"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="102.54275"
     inkscape:cy="180.12237"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1043"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;stroke:#000000;stroke-width:1.49000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 15,232 V 212 H 35"
       id="path883"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.49000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 35,282 H 15 v -20"
       id="path883-3"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.49000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 85,262 v 20 H 65"
       id="path883-3-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1.49000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 65,212 h 20 v 20"
       id="path883-3-7"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
  </g>
</svg>
`;
const POLYLINE_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="polygon.svg">
  <defs
     id="defs7238">
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1156"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1154"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1152"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path1150"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="marker1148"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         id="path946"
         d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         transform="scale(0.8) translate(7.4, 1)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="DotL"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path4587"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
    <marker
       inkscape:stockid="DotL"
       orient="auto"
       refY="0"
       refX="0"
       id="marker7235"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path7233"
         d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
         transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="227.89989"
     inkscape:cy="182.97951"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1043"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7241">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-197)">
    <path
       style="fill:none;stroke:#000000;stroke-width:1.49000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#marker1148);marker-mid:url(#marker1152);marker-end:url(#marker1156)"
       d="M 15.497022,283.01488 28.915179,250.31994 67.657737,240.11458 87.879463,210.06547"
       id="path883"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
  </g>
</svg>
`;
const BBOX3_SVG = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="100mm"
   height="100mm"
   viewBox="0 0 100 100"
   version="1.1"
   id="svg7244"
   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"
   sodipodi:docname="bbox3.svg">
<defs
  id="defs7338">
 <marker
    inkscape:isstock="true"
    style="overflow:visible"
    id="marker3387"
    refX="0"
    refY="0"
    orient="auto"
    inkscape:stockid="DotL">
   <path
      transform="matrix(0.8,0,0,0.8,5.92,0.8)"
      style="fill:#757575;fill-opacity:0.98039216;fill-rule:evenodd;stroke:#757575;stroke-width:1.00000003pt;stroke-opacity:0.98039216"
      d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
      id="path3385"
      inkscape:connector-curvature="0" />
 </marker>
 <marker
    inkscape:isstock="true"
    style="overflow:visible"
    id="marker2383"
    refX="0"
    refY="0"
    orient="auto"
    inkscape:stockid="DotL">
   <path
      transform="matrix(0.8,0,0,0.8,5.92,0.8)"
      style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
      d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
      id="path2381"
      inkscape:connector-curvature="0" />
 </marker>
 <marker
    inkscape:isstock="true"
    style="overflow:visible"
    id="marker2313"
    refX="0"
    refY="0"
    orient="auto"
    inkscape:stockid="DotL">
   <path
      transform="matrix(0.8,0,0,0.8,5.92,0.8)"
      style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
      d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
      id="path2211"
      inkscape:connector-curvature="0" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1651"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path1649"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1315"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path1313"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1145"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path943"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1156"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path1254"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1152"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path1160"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0.0"
    refX="0.0"
    id="marker1148"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      id="path951"
      d="M -2.5,-1.0 C -2.5,1.7600000 -4.7400000,4.0 -7.5,4.0 C -10.260000,4.0 -12.5,1.7600000 -12.5,-1.0 C -12.5,-3.7600000 -10.260000,-6.0 -7.5,-6.0 C -4.7400000,-6.0 -2.5,-3.7600000 -2.5,-1.0 z "
      style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
      transform="scale(0.8) translate(7.4, 1)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0"
    refX="0"
    id="DotL"
    style="overflow:visible"
    inkscape:isstock="true"
    inkscape:collect="always">
   <path
      inkscape:connector-curvature="0"
      id="path4591"
      d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
      style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
      transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
 </marker>
 <marker
    inkscape:stockid="DotL"
    orient="auto"
    refY="0"
    refX="0"
    id="marker7235"
    style="overflow:visible"
    inkscape:isstock="true">
   <path
      inkscape:connector-curvature="0"
      id="path7234"
      d="m -2.5,-1 c 0,2.76 -2.24,5 -5,5 -2.76,0 -5,-2.24 -5,-5 0,-2.76 2.24,-5 5,-5 2.76,0 5,2.24 5,5 z"
      style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.00000003pt;stroke-opacity:1"
      transform="matrix(0.8,0,0,0.8,5.92,0.8)" />
 </marker>
</defs>
<sodipodi:namedview
  id="base"
  pagecolor="#ffffff"
  bordercolor="#666666"
  borderopacity="1.0"
  inkscape:pageopacity="0.0"
  inkscape:pageshadow="2"
  inkscape:zoom="1.4"
  inkscape:cx="-23.528679"
  inkscape:cy="177.26523"
  inkscape:document-units="mm"
  inkscape:current-layer="layer2"
  showgrid="false"
  inkscape:window-width="1920"
  inkscape:window-height="1043"
  inkscape:window-x="0"
  inkscape:window-y="0"
  inkscape:window-maximized="1" />
<metadata
  id="metadata7241">
 <rdf:RDF>
   <cc:Work
      rdf:about="">
     <dc:format>image/svg+xml</dc:format>
     <dc:type
        rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
     <dc:title />
   </cc:Work>
 </rdf:RDF>
</metadata>
<g
  inkscape:label="Layer 1"
  inkscape:groupmode="layer"
  id="layer1"
  transform="translate(0,-197)">
 <path
    style="fill:none;stroke:#454545;stroke-width:1.55600691;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
    d="M 10.756538,266.99254 H 70.756863"
    id="path2551"
    inkscape:connector-curvature="0"
    sodipodi:nodetypes="cc" />
 <path
    style="fill:none;stroke:#454545;stroke-width:1.55600691;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.98039216;marker-mid:url(#marker3387)"
    d="m 70.756864,206.99233 -10e-7,60.16215 18.4441,19.83814"
    id="path2553"
    inkscape:connector-curvature="0"
    sodipodi:nodetypes="ccc" />
</g>
<g
  inkscape:groupmode="layer"
  id="layer2"
  inkscape:label="Layer 2">
 <path
    style="fill:none;stroke:#000000;stroke-width:1.55600691;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-mid:url(#marker2383)"
    d="M 30.756486,89.992787 10.756538,69.992546 V 9.9923299 h 60.000325 l 18.44426,21.5559081"
    id="path973-1"
    inkscape:connector-curvature="0"
    sodipodi:nodetypes="ccccc" />
 <path
    style="fill:none;stroke:#000000;stroke-width:1.55600691;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#marker1145);marker-mid:url(#marker1315);marker-end:url(#marker1651)"
    d="M 10.756538,9.9923299 30.756484,31.548238"
    id="path880"
    inkscape:connector-curvature="0" />
 <path
    style="fill:none;stroke:#000000;stroke-width:1.56000698;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-mid:url(#marker1145)"
    d="M 30.756646,89.992617 H 89.200963 V 31.548238"
    id="path2155"
    inkscape:connector-curvature="0"
    sodipodi:nodetypes="ccc" />
 <path
    style="fill:none;stroke:#000000;stroke-width:1.55600691;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#marker1145);marker-mid:url(#marker1145);marker-end:url(#marker1145)"
    d="M 89.201121,31.548238 H 30.756484 l 2e-6,58.444549"
    id="path2153"
    inkscape:connector-curvature="0" />
</g>
</svg>
`;

let get_init_style = (prntid) => {
    const NONSP_SZ = 400;
    return `
div#${prntid} {
   display: none;
}
div#${prntid} * {
   box-sizing: content-box;
   text-align: center;
}
div#${prntid}.ulabel-night {
   background-color: black;
}
div#${prntid} div.full_ulabel_container_ {
   font-family: sans-serif;
}

div#${prntid} .ulabel-hidden {
   display: none !important;
}

div#${prntid} div.annbox_cls, div#${prntid} div.toolbox_cls {
   height: 100%;
}
div#${prntid} div.annbox_cls {
   width: calc(100% - 320px);
   background-color: black;
   overflow: scroll;
   position: absolute;
   top: 0;
   left: 0;
}
div#${prntid} div.annbox_cls img.image_frame {
   position: absolute;
   top: 0;
   left: 0;
   max-width: none;
   max-height: none;
}


/* Frame annotation dialog */
div#${prntid} div.frame_annotation_dialog {
   width: 60px;
   overflow: hidden;
   position: absolute;
   z-index: 80;
   background-color: rgb(255, 255, 255);
   border: 1px solid rgb(143, 143, 143);
   transition: opacity 0.1s, width 0.3s, height 0.3s, min-height 0.3s;
   opacity: 0.5;
   top: 40px;
}
div#${prntid} div.frame_annotation_dialog.fad_ind__0 {
   right: 360px;
}
div#${prntid} div.frame_annotation_dialog.fad_ind__1 {
   right: 445px;
}
div#${prntid} div.frame_annotation_dialog.fad_ind__2 {
   right: 530px;
}
div#${prntid} div.frame_annotation_dialog.fad_ind__3 {
   right: 615px;
}
div#${prntid} div.frame_annotation_dialog div.hide_overflow_container {
   width: 100%;
   /* position: absolute;
   right: 0; */
   overflow: hidden;
}
div#${prntid} div.frame_annotation_dialog.active:hover, div#${prntid} div.frame_annotation_dialog.active.permopen {
   max-width: none;
   width: ${NONSP_SZ}px;
   overflow: visible;
}
div#${prntid} div.frame_annotation_dialog.active {
   z-index: 125;
   opacity: 1.0;
}
div#${prntid}.ulabel-night div.frame_annotation_dialog {
   background-color: rgb(37, 37, 37);
   border: 1px solid rgb(102, 102, 102);
   text-align: right;
}
div.front_dialogs {
   position: absolute;
   top: 0;
   right: 0;
   z-index: -1;
}
div#${prntid} div.frame_annotation_dialog div.row_container {
   position: relative;
   width: ${NONSP_SZ}px;
   left: ${60 - NONSP_SZ}px;
   overflow: visible;
   transition: left 0.3s;
}
div#${prntid} div.frame_annotation_dialog:hover div.row_container, div#${prntid} div.frame_annotation_dialog.active.permopen div.row_container {
   left: 0;
   overflow: visible;
}
/* ROWS */
div#${prntid} div.frame_annotation_dialog div.fad_row {
   width: ${NONSP_SZ}px;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_row_inner {
   width: ${NONSP_SZ}px;
   text-align: right;
}

/* NAME */
div#${prntid} div.fad_st_name {
   font-size: 8px;
   padding: 4px;
   width: 52px;
   overflow: hidden;
   text-align: center;
   display: inline-block;
}
div#${prntid}.ulabel-night div.fad_st_name {
   color: white;
}

/* ADD BUTTON */
div#${prntid} div.fad_st_add {
   width: 60px;
   height: 50px;
   display: none;
   position: relative;
}
div#${prntid} div.frame_annotation_dialog.active div.fad_st_add {
   display: inline-block;
}
div#${prntid} div.frame_annotation_dialog div.fad_row.add a.add-glob-button {
   position: absolute;
   font-size: 20px;
   width: 25px;
   height: 25px;
   border-radius: 12.5px;
   text-decoration: none;
   background-color: rgba(128, 128, 128, 0.198);
   color: gray;
   border: 1px solid gray;
   top: 25px;
   left: 30px;
   transform: translateX(-50%) translateY(-50%);
   line-height: 25px;
   text-align: center;
}
/* div#${prntid} div.frame_annotation_dialog div.fad_row.add a.add-glob-button span.plus {
   display: block;
   text-align: center;
   width: 25px;
   height: 25px;
   position: absolute;
   top: 12.5px;
   left: 12.5px;
   transform: translateX(-50%) translateY(-50%);
   color: black;
} */
div#${prntid} div.frame_annotation_dialog div.fad_row.add a.add-glob-button:hover {
   border-color: black;
   color: black;
}
div#${prntid}.ulabel-night div.frame_annotation_dialog div.fad_row.add a.add-glob-button:hover {
   border-color: white;
   color: white;
}
div#${prntid}.ulabel-night div.frame_annotation_dialog div.fad_row.add a.add-glob-button span.plus {
   color: white;
}
div#${prntid} div.frame_annotation_dialog.active div.fad_row.add {
   display: inline-block;
}

div#${prntid} div.frame_annotation_dialog div.fad_annotation_rows {
   width: ${NONSP_SZ}px;
   display: inline-block;
}

div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons {
   display: inline-block;
   vertical-align: top;
   min-height: 60px;
   width: ${NONSP_SZ - 60}px;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_type_icon {
   display: inline-block;
   vertical-align: top;
   height: 60px;
   width: 60px;
   position: relative;
   text-align: center;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_type_icon svg {
   height: 50px;
   width: 50px;
   padding: 5px;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container {
   display: inline-block;
   vertical-align: top;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container.text {
   width: ${NONSP_SZ - 180}px;
   margin: 0;
   border: none;
   padding: none;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container.text textarea {
   box-sizing: border-box;
   width: calc(100% - 2px);
   height: 58px;
   min-height: 58px;
   resize: vertical;
   background-color: rgba(0,0,0,0);
}
div#${prntid}.ulabel-night div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container.text textarea {
   color: white;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container.button {
   width: 30px;
   height: 30px;
   padding: 15px;
   padding-right: 20px;
   padding-left: 0;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons div.fad_inp_container.button.frst {
   padding-left: 20px;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons a.fad_button {
   display: block;
   width: 28px;
   height: 28px;
   background-color: rgba(128, 128, 128, 0.198);
   border-radius: 14px;
   border: 1px solid gray;
   color: gray;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons a.fad_button:hover {
   border-color: black;
   color: black;
}
div#${prntid}.ulabel-night div.frame_annotation_dialog div.fad_row div.fad_buttons a.fad_button:hover {
   border-color: white;
   color: white;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons a.fad_button.reclf {
   position: relative;
}
div#${prntid} div.frame_annotation_dialog div.fad_row div.fad_buttons a.fad_button.delete {
   text-decoration: none;
   text-align: center;
   line-height: 28px;
   font-size: 22px;
}

div#${prntid} div.canvasses {
   position: absolute;
   top: 0; 
   left: 0;
   padding-right: 100%;
   padding-bottom: 100%;
}
div#${prntid} canvas.canvas_cls {
   position: absolute;
   top: 0;
   left: 0;
}
div#${prntid} canvas.annotation_canvas {
   pointer-events: none;
}

div#${prntid} .id_dialog {
   width: 400px;
   height: 400px;
   background-color: rgba(0, 0, 0, 0.0);
   position: absolute;
   display: none;
}
/* .id_dialog.thumb {
   transform: scale(0.375);
   opacity: 0.5;
}
.id_dialog.thumb:hover {
   opacity: 1.0;
} */
div#${prntid} .ender_outer {
   display: block;
   position: absolute;
   width: 50px;
   height: 50px;
   background-color: transparent;
   box-shadow: 0 0 0 2px white;
   border-radius: 25px;
   z-index: ${FRONT_Z_INDEX};
}
div#${prntid} .ender_inner {
   display: block;
   position: absolute;
   left: 20px;
   top: 20px;
   width: 10px;
   height: 10px;
   background-color: transparent;
   border-radius: 10px;
}
div#${prntid} .brush_circle {
   display: block;
   position: absolute;
   width: 50px;
   height: 50px;
   background-color: white;
   opacity: 0.4;
   border-radius: 25px;
   z-index: ${FRONT_Z_INDEX};
}

/* ================== TOOLBOX ================== */

div#${prntid} div.zpcont {
   height: 90px;
   position: relative;
   background-color: white;
}

div#${prntid}.ulabel-night div.zpcont {
   background-color: rgb(24, 24, 24);
}

div#${prntid} div.zpcont:hover, div#${prntid}.ulabel-night div.zpcont:hover {
   background-color: rgba(0,0,0,0);
}

div#${prntid} div.linestyle {
   padding: 10px 30px;
}

div#${prntid} canvas.demo-canvas {
   width: 120px;
   height: 40px;
   border: 1px solid lightgray;
}
div#${prntid}.ulabel-night canvas.demo-canvas {
   border: 1px solid rgb(87, 87, 87);
}
div#${prntid} div.line-expl {
   width: 185px;
}

div#${prntid} div.line-expl a {
   display: inline-block;
   vertical-align: middle;
}
div#${prntid} div.line-expl canvas {
   display: inline-block;
   vertical-align: middle;
   width: 120px;
   height: 40px;
}
div#${prntid} div.lstyl-row div.line-expl, div#${prntid} div.lstyl-row div.setting {
   display: inline-block;
   vertical-align: middle;
}
div#${prntid} div.setting {
   width: calc(100% - 185px);
   text-align: right;
}
div#${prntid} div.lstyl-row div.setting a {
   display: inline-block;
   border-radius: 5px;
   padding: 3px 6px;
   margin-bottom: 5px;
   text-decoration: none;
   color: black;
   font-size: 14px;
}
div#${prntid}.ulabel-night div.lstyl-row div.setting a {
   color: white;
}
div#${prntid} div.lstyl-row div.setting a {
   background-color: rgba(100, 148, 237, 0.479);
   color: black;
}
div#${prntid} div.lstyl-row div.setting a[href="#"] {
   background-color: rgba(0,0,0,0);
   color: black;
}
div#${prntid}.ulabel-night div.lstyl-row div.setting a[href="#"] {
   color: white;
}
div#${prntid} div.lstyl-row div.setting a[href="#"]:hover {
   background-color: rgba(255, 181, 44, 0.397);
}

div#${prntid} div.dialogs_container {
   position: absolute;
   top: 0;
   left: 0;
}

div.toolbox_inner_cls {
   height: calc(100% - 38px);
   overflow-y: scroll;
   overflow-x: hidden;
}


/* ========== Tab Buttons ========== */

div#${prntid} div.toolbox-tabs {
   position: absolute;
   bottom: 0;
   width: 100%;
   opacity: 0.8;
}
div#${prntid} div.toolbox-tabs div.tb-st-tab {
   display: block;
   width: 100%;
   padding: 5px 0;
   background-color: rgba(0, 3, 161, 0.144);
}
div#${prntid} div.toolbox-tabs div.tb-st-tab.sel {
   display: block;
   width: 100%;
   background-color: rgba(0, 3, 161, 0.561);
}
div#${prntid} div.toolbox-tabs div.tb-st-tab * {
   vertical-align: middle;
}
div#${prntid} div.toolbox-tabs div.tb-st-tab a.tb-st-switch {
   display: inline-block;
   width: 70px;
   padding: 0 15px;
   text-decoration: none;
   color: rgb(37, 37, 37);
}
div#${prntid}.ulabel-night div.toolbox-tabs div.tb-st-tab a.tb-st-switch {
   color: rgb(150, 150, 150);
}
div#${prntid} div.toolbox-tabs div.tb-st-tab.sel a.tb-st-switch {
   color: rgb(238, 238, 238);
}
div#${prntid}.ulabel-night div.toolbox-tabs div.tb-st-tab.sel a.tb-st-switch {
   color: rgb(238, 238, 238);
}
div#${prntid} div.toolbox-tabs div.tb-st-tab a.tb-st-switch[href]:hover {
   color: cornflowerblue;
}
div#${prntid}.ulabel-night div.toolbox-tabs div.tb-st-tab a.tb-st-switch[href]:hover {
   color: rgb(238, 238, 238);
}
div#${prntid} div.toolbox-tabs div.tb-st-tab span.tb-st-range {
   display: inline-block;
   width: calc(100% - 100px);
   text-align: center;
}
div#${prntid} div.toolbox-tabs div.tb-st-tab span.tb-st-range input {
   width: 80%;
   transform: rotate(180deg);
}

/* ========== Annotation Box Dialogs ========== */

div#${prntid} div.global_edit_suggestion {
   display: none;
   position: absolute;
   width: 150px;
   /*height: 75px;*/
   height: 0px;
   text-align: center;
   z-index: 1;
   /* background-color: white; */
   transform: scale(0.66666);
   overflow: visible;
}
div#${prntid} div.global_edit_suggestion.mcm {
   width: 225px;
   transform: scale(0.5);
}
div#${prntid} a.global_sub_suggestion {
   width: 60px;
   height: 60px;
   margin-left: 7.5px;
   margin-right: 7.5px;
   display: inline-block;
   border-radius: 37.5px;
   background-color: white;
   overflow: hidden;
   transform: translateY(-50%);
}
div#${prntid} a.global_sub_suggestion img {
   display: block;
   width: 40px;
   height: 40px;
   padding: 10px;
}
div#${prntid} a.global_sub_suggestion span.bigx {
   position: absolute;
   display: block;
   font-size: 4em;
   text-align: center;
   width: 60px;
   top: 50%;
   -ms-transform: translateY(-50%);
   transform: translateY(-50%);
   color: black;
   text-decoration: none;
}
div#${prntid} a.global_sub_suggestion.reid_suggestion {
   opacity: 0.3;
   background-color: black;
}
div#${prntid} a.global_sub_suggestion.reid_suggestion:hover {
   opacity: 0; 
}

div#${prntid} a.tbid-opt {
   display: inline-block;
   text-decoration: none;
   padding: 5px 8px;
   border-radius: 5px;
   color: black;
}
div#${prntid} div.colprev {
   display: inline-block;
   vertical-align: middle;
   height: 15px;
   width: 15px;
}
div#${prntid} span.tb-cls-nam {
   display: inline-block;
   vertical-align: middle;
}
div#${prntid}.ulabel-night span.tb-cls-nam {
   color: white;
}
div#${prntid} a.tbid-opt:hover {
   background-color: rgba(255, 181, 44, 0.397);
}
div#${prntid} a.tbid-opt.sel {
   background-color: rgba(100, 148, 237, 0.459);
}
div#${prntid} div.toolbox-name-header {
   background-color: rgb(0, 128, 202);
   margin: 0;
}
div#${prntid}.ulabel-night div.toolbox-name-header {
   background-color: rgb(0, 60, 95);
}
div#${prntid} div.toolbox-name-header h1 {
   margin: 0;
   padding: 0;
   font-size: 15px;
   display: inline-block;
   padding: 10px 15px;
   width: calc(70% - 30px);
   vertical-align: middle;
}
div#${prntid} div.toolbox-name-header h1 a {
   color: white;
   font-weight: 100;
   text-decoration: none;
}
div#${prntid} div.toolbox-name-header h1 {
   color: rgb(212, 212, 212);
   font-size: 12px;
   font-weight: 100;
}
div#${prntid}.ulabel-night div.toolbox-name-header h1 span.version-number {
   color: rgb(190, 190, 190);
}
div#${prntid} div.night-button-cont {
   text-align: right;
   display: inline-block;
   vertical-align: middle;
   position: relative;
   padding-right: 10px;
   width: calc(30% - 10px);
}
div#${prntid} a.night-button {
   display: inline-block;
   padding: 10px;
   opacity: 0.7;
}
div#${prntid} div.night-button-track {
   width: 35px;
   height: 12px;
   border-radius: 6px;
   position: relative;
   display: inline-block;
   background-color: rgba(0, 0, 0, 0.52);
}
div#${prntid} div.night-status {
   width: 20px;
   height: 20px;
   border-radius: 10px;
   position: absolute;
   background-color: rgb(139, 139, 139);
   left: -4px;
   top: -4px;
   transition: left 0.2s;
}
div#${prntid} a.night-button:hover {
   opacity: 1;
}
div#${prntid}.ulabel-night div.night-button-track {
   background-color: rgba(255, 255, 255, 0.52);
}
div#${prntid}.ulabel-night div.night-status {
   left: 19px;
}


div#${prntid}.ulabel-night *::-webkit-scrollbar {
   background-color: black;
}
div#${prntid}.ulabel-night *::-webkit-scrollbar-track {
   background-color: black;
}
div#${prntid}.ulabel-night *::-webkit-scrollbar-thumb {
   border: 1px solid rgb(110, 110, 110);
   background-color: rgb(51, 51, 51);
}
div#${prntid}.ulabel-night *::-webkit-scrollbar-thumb:hover {
   background-color: rgb(90, 90, 90);
} 
div#${prntid}.ulabel-night *::-webkit-scrollbar-corner {
   background-color:rgb(0, 60, 95);
}

div#${prntid} a.repo-anchor {
   text-transform: uppercase;
}


div#${prntid} a.id-dialog-clickable-indicator {
   position: absolute; 
   top: 0;
   left: 0;
   display: block;
   border-radius: 200px;
   height: 400px;
   width: 400px;
   overflow: hidden;
}
div#${prntid} a.id-dialog-clickable-indicator svg {
   position: absolute;
   top: 0;
   left: 0;
}

div#${prntid} .editable {
   display: none;
   position: absolute;
   width: 50px;
   height: 50px;
   background-color: gray;
   opacity: 0.7;
   border-radius: 25px;
   z-index: 0;
}
div#${prntid} .editable.soft {
   opacity: 0.4;
}
div#${prntid} .editable:hover {
   background-color: white;
   opacity: 1.0;
}
div#${prntid} .editable.soft:hover {
   opacity: 0.7;
}

div#${prntid} div.toolbox-refs {
   text-align: center;
}
div#${prntid} div.toolbox-refs a {
   color: rgb(5, 50, 133);
   display: inline-block;
   margin-top: 10px;
}
div#${prntid} div.toolbox-refs a:hover {
   color: rgb(44, 77, 139);
}
div#${prntid}.ulabel-night div.toolbox-refs a {
   color: rgb(176, 202, 250);
}
div#${prntid}.ulabel-night div.toolbox-refs a:hover {
   color: rgb(123, 160, 228);
}

div#${prntid} .submit-button-container {
   display: flex;
   flex-direction: column;
}
div#${prntid} .submit-button-row {
   display: flex;
   align-items: center;
   gap: 0.5em;
   overflow-x: auto;
   margin-bottom: -0.5em;
}
div#${prntid} .submit-button {
   display: flex;
   justify-content: center;
   align-items: center;
   color: white;
   background-color: rgba(255, 166, 0, 0.739); 
   margin-right: auto;
   margin-left: auto;
   margin-top: 0.5em;
   margin-bottom: 0.5em;
   cursor: pointer;
}

/* Dual ring loader */
.lds-dual-ring {
    position: absolute;
    display: block;
    width: 18px;
    height: 18px;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
}
.lds-dual-ring:after {
    content: " ";
    display: block;
    width: 14.4px;
    height: 14.4px;
    margin: 1.8px;
    border-radius: 50%;
    border: 1.35px solid #fff;
    border-color: #fff transparent #fff transparent;
    animation: lds-dual-ring 1.2s linear infinite;
}
@keyframes lds-dual-ring {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}
`;
};

const BUTTON_LOADER_HTML = `<div class="lds-dual-ring"></div>`;

// TODO more of these
const COLORS = [
    "orange",
    "crimson",
    "dodgerblue",
    "midnightblue",
    "seagreen",
    "tan",
    "blueviolet",
    "chocolate",
    "darksalmon",
    "deeppink",
    "fuchsia",
];




/***/ }),

/***/ 2779:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a {@link Feature} or {@link FeatureCollection} and returns the mean center. Can be weighted.
 *
 * @name centerMean
 * @param {GeoJSON} geojson GeoJSON to be centered
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
 * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
 * @param {Object} [options.id={}] Translate GeoJSON Id to Point
 * @param {string} [options.weight] the property name used to weight the center
 * @returns {Feature<Point>} a Point feature at the mean center point of all input features
 * @example
 * var features = turf.featureCollection([
 *   turf.point([-97.522259, 35.4691], {value: 10}),
 *   turf.point([-97.502754, 35.463455], {value: 3}),
 *   turf.point([-97.508269, 35.463245], {value: 5})
 * ]);
 *
 * var options = {weight: "value"}
 * var mean = turf.centerMean(features, options);
 *
 * //addToMap
 * var addToMap = [features, mean]
 * mean.properties['marker-size'] = 'large';
 * mean.properties['marker-color'] = '#000';
 */
function centerMean(geojson, // To-Do include Typescript AllGeoJSON
options) {
    if (options === void 0) { options = {}; }
    var sumXs = 0;
    var sumYs = 0;
    var sumNs = 0;
    meta_1.geomEach(geojson, function (geom, featureIndex, properties) {
        var weight = options.weight ? properties === null || properties === void 0 ? void 0 : properties[options.weight] : undefined;
        weight = weight === undefined || weight === null ? 1 : weight;
        if (!helpers_1.isNumber(weight))
            throw new Error("weight value must be a number for feature index " + featureIndex);
        weight = Number(weight);
        if (weight > 0) {
            meta_1.coordEach(geom, function (coord) {
                sumXs += coord[0] * weight;
                sumYs += coord[1] * weight;
                sumNs += weight;
            });
        }
    });
    return helpers_1.point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
}
exports["default"] = centerMean;


/***/ }),

/***/ 2903:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = rbush;
module.exports["default"] = rbush;

var quickselect = __webpack_require__(3351);

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ 3045:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterPointDistanceFromRow = exports.KeypointSliderItem = exports.RecolorActiveItem = exports.AnnotationResizeItem = exports.ClassCounterToolboxItem = exports.AnnotationIDToolboxItem = exports.ZoomPanToolboxItem = exports.BrushToolboxItem = exports.ModeSelectionToolboxItem = exports.ToolboxItem = exports.ToolboxTab = exports.Toolbox = void 0;
var configuration_1 = __webpack_require__(496);
var annotation_operators_1 = __webpack_require__(2571);
var html_builder_1 = __webpack_require__(4493);
var overlays_1 = __webpack_require__(8505);
var utilities_1 = __webpack_require__(8286);
// For ResizeToolboxItem
var ValidResizeValues;
(function (ValidResizeValues) {
    ValidResizeValues["VANISH"] = "v";
    ValidResizeValues["SMALL"] = "s";
    ValidResizeValues["LARGE"] = "l";
    ValidResizeValues["INCREMENT"] = "inc";
    ValidResizeValues["DECREMENT"] = "dec";
})(ValidResizeValues || (ValidResizeValues = {}));
var toolboxDividerDiv = "<div class=toolbox-divider></div>";
var vanish_size = 0.01;
/** Chains the replaceAll method and the toLowerCase method.
 *  Optionally concatenates a string at the end of the method.
  */
String.prototype.replaceLowerConcat = function (before, after, concat_string) {
    if (concat_string === void 0) { concat_string = null; }
    if (typeof (concat_string) === "string") {
        return this.replaceAll(before, after).toLowerCase().concat(concat_string);
    }
    return this.replaceAll(before, after).toLowerCase();
};
/**
 * Manager for toolbox. Contains ToolboxTab items.
 */
var Toolbox = /** @class */ (function () {
    function Toolbox(tabs, items) {
        if (tabs === void 0) { tabs = []; }
        if (items === void 0) { items = []; }
        this.tabs = tabs;
        this.items = items;
    }
    Toolbox.create_toolbox = function (ulabel, toolbox_item_order) {
        // Grab the default toolbox if one wasn't provided
        if (toolbox_item_order == null) {
            toolbox_item_order = ulabel.config.toolbox_order;
        }
        // There's no point to having an empty toolbox, so throw an error if the toolbox is empty.
        // The toolbox won't actually break if there aren't any items in the toolbox, so this
        // error isn't strictly neccesary.
        if (toolbox_item_order.length === 0) {
            throw new Error("No Toolbox Items Given");
        }
        this.add_styles();
        var toolbox_instance_list = [];
        // Go through the items in toolbox_item_order and add their instance to the toolbox instance list
        for (var i = 0; i < toolbox_item_order.length; i++) {
            var args = void 0, toolbox_key = void 0;
            // If the value of toolbox_item_order[i] is a number then that means the it is one of the
            // enumerated toolbox items, so set it to the key, otherwise the element must be an array
            // of which the first element of that array must be the enumerated value, and the arguments
            // must be the second value
            if (typeof (toolbox_item_order[i]) === "number") {
                toolbox_key = toolbox_item_order[i];
            }
            else {
                toolbox_key = toolbox_item_order[i][0];
                args = toolbox_item_order[i][1];
            }
            var toolbox_item_class = ulabel.config.toolbox_map.get(toolbox_key);
            if (args == null) {
                toolbox_instance_list.push(new toolbox_item_class(ulabel));
            }
            else {
                toolbox_instance_list.push(new toolbox_item_class(ulabel, args));
            }
        }
        return toolbox_instance_list;
    };
    Toolbox.add_styles = function () {
        var css = "\n        #toolbox {\n            width: 320px;\n            background-color: white;\n            overflow-y: hidden;\n            position: absolute;\n            top: 0;\n            right: 0;\n        }\n\n        .ulabel-night #toolbox {\n            color: white;\n        }\n\n        .ulabel-night #toolbox div.toolbox_inner_cls {\n            background-color: black;\n        }\n\n        .ulabel-night div.toolbox_cls {\n            background-color: rgb(24, 24, 24);\n        }\n\n        .ulabel-night .invert-this-svg svg {\n            filter: invert(90%);\n        }\n\n        #toolbox button {\n            border: 1px solid rgba(128, 128, 128, 0.5);\n            color: white;\n            background-color: rgba(0, 128, 255, 0.7);\n            transition: background-color 250ms;\n            cursor: pointer;\n        }\n        \n        #toolbox button:hover {\n            background-color: rgba(0, 128, 255, 0.9);\n        }\n\n        #toolbox button.circle {\n            position: relative;\n            border-radius: 50%;\n            font-size: 1.2rem;\n            font-weight: bold;\n            width: 20px;\n            height: 20px;\n            padding: 0;\n        }\n\n        #toolbox button.circle:hover {\n            box-shadow: 0 0 4px 2px lightgray, 0 0 white;\n        }\n         \n        /* No shadow effect in night-mode */\n        .ulabel-night #toolbox button.circle:hover {\n            box-shadow: initial;\n        }\n\n        #toolbox input {\n            cursor: pointer;\n        }\n\n        #toolbox label {\n            cursor: pointer;\n        }\n        \n        #toolbox div.toolbox-divider {\n            width: 90%;\n            margin: 0 auto;\n            height: 1px;\n            background-color: lightgray;\n        }\n\n        .ulabel-night #toolbox div.toolbox-divider {\n            background-color: gray;\n        }";
        // Create an id so this specific style tag can be referenced
        var style_id = "toolbox-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    Toolbox.prototype.setup_toolbox_html = function (ulabel, frame_annotation_dialogs, images, ULABEL_VERSION) {
        // Setup base div and ULabel version header
        var toolbox_html = "\n        <div class=\"full_ulabel_container_\">\n            ".concat(frame_annotation_dialogs, "\n            <div id=\"").concat(ulabel.config["annbox_id"], "\" class=\"annbox_cls\">\n                <div id=\"").concat(ulabel.config["imwrap_id"], "\" class=\"imwrap_cls ").concat(ulabel.config["imgsz_class"], "\">\n                    ").concat(images, "\n                </div>\n            </div>\n            <div id=\"").concat(ulabel.config["toolbox_id"], "\" class=\"toolbox_cls\">\n                <div class=\"toolbox-name-header\">\n                    <h1 class=\"toolname\"><a class=\"repo-anchor\" href=\"https://github.com/SenteraLLC/ulabel\">ULabel</a> <span class=\"version-number\">v").concat(ULABEL_VERSION, "</span></h1><!--\n                    --><div class=\"night-button-cont\">\n                        <a href=\"#\" class=\"night-button\">\n                            <div class=\"night-button-track\">\n                                <div class=\"night-status\"></div>\n                            </div>\n                        </a>\n                    </div>\n                </div>\n                <div class=\"toolbox_inner_cls\">\n        ");
        for (var tbitem in this.items) {
            toolbox_html += this.items[tbitem].get_html() + toolboxDividerDiv;
        }
        toolbox_html += "\n                </div>\n                <div class=\"toolbox-tabs\">\n                    ".concat(this.get_toolbox_tabs(ulabel), "\n                </div> \n            </div>\n        </div>");
        return toolbox_html;
    };
    /**
     * Adds tabs for each ULabel subtask to the toolbox.
     */
    Toolbox.prototype.get_toolbox_tabs = function (ulabel) {
        var ret = "";
        for (var st_key in ulabel.subtasks) {
            var selected = st_key == ulabel.get_current_subtask_key();
            var subtask = ulabel.subtasks[st_key];
            var current_tab = new ToolboxTab([], subtask, st_key, selected);
            ret += current_tab.html;
            this.tabs.push(current_tab);
        }
        return ret;
    };
    Toolbox.prototype.redraw_update_items = function (ulabel) {
        for (var _i = 0, _a = this.items; _i < _a.length; _i++) {
            var tbitem = _a[_i];
            tbitem.redraw_update(ulabel);
        }
    };
    return Toolbox;
}());
exports.Toolbox = Toolbox;
var ToolboxTab = /** @class */ (function () {
    function ToolboxTab(toolboxitems, subtask, subtask_key, selected) {
        if (toolboxitems === void 0) { toolboxitems = []; }
        if (selected === void 0) { selected = false; }
        this.toolboxitems = toolboxitems;
        this.subtask = subtask;
        this.subtask_key = subtask_key;
        this.selected = selected;
        var sel = "";
        var href = " href=\"#\"";
        var val = subtask.inactive_opacity * 100;
        if (this.selected) {
            if (this.subtask.read_only) {
                href = "";
            }
            sel = " sel";
            val = 100;
        }
        console.log(subtask.display_name, subtask);
        this.html = "\n        <div class=\"tb-st-tab".concat(sel, "\">\n            <a").concat(href, " id=\"tb-st-switch--").concat(subtask_key, "\" class=\"tb-st-switch\">").concat(this.subtask.display_name, "</a><!--\n            --><span class=\"tb-st-range\">\n                <input id=\"tb-st-range--").concat(subtask_key, "\" type=\"range\" min=0 max=100 value=").concat(val, " />\n            </span>\n        </div>\n        ");
    }
    return ToolboxTab;
}());
exports.ToolboxTab = ToolboxTab;
var ToolboxItem = /** @class */ (function () {
    function ToolboxItem() {
    }
    // TODO (joshua-dean): Find the right way to handle this with abstract classes
    /* eslint-disable @typescript-eslint/no-unused-vars */
    ToolboxItem.prototype.redraw_update = function (ulabel) { };
    ToolboxItem.prototype.frame_update = function (ulabel) { };
    return ToolboxItem;
}());
exports.ToolboxItem = ToolboxItem;
/**
 * Toolbox item for selecting annotation mode.
 */
var ModeSelectionToolboxItem = /** @class */ (function (_super) {
    __extends(ModeSelectionToolboxItem, _super);
    function ModeSelectionToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        _this.add_styles();
        // Buttons to change annotation mode
        $(document).on("click.ulabel", "a.md-btn", function (e) {
            // Grab the current target and the current subtask
            var target_jq = $(e.currentTarget);
            var current_subtask = ulabel.get_current_subtask();
            // Check if button clicked is already selected, or if creation of a new annotation is in progress
            if (target_jq.hasClass("sel") || current_subtask["state"]["is_in_progress"])
                return;
            // Get the new mode and set it to ulabel's current mode
            var new_mode = target_jq.attr("id").split("--")[1];
            current_subtask["state"]["annotation_mode"] = new_mode;
            // Show the BrushToolboxItem when polygon mode is selected
            if (new_mode === "polygon") {
                BrushToolboxItem.show_brush_toolbox_item();
            }
            else {
                BrushToolboxItem.hide_brush_toolbox_item();
                // Turn off erase mode if it's on
                if (current_subtask["state"]["is_in_erase_mode"]) {
                    ulabel.toggle_erase_mode(e);
                }
                // Turn off brush mode if it's on
                if (current_subtask["state"]["is_in_brush_mode"]) {
                    ulabel.toggle_brush_mode(e);
                }
            }
            // Reset the previously selected mode button
            $("a.md-btn.sel").attr("href", "#");
            $("a.md-btn.sel").removeClass("sel");
            // Make the selected class look selected
            target_jq.addClass("sel");
            target_jq.removeAttr("href");
            ulabel.show_annotation_mode(target_jq);
            ulabel.toggle_delete_class_id_in_toolbox();
        });
        $(document).on("keypress.ulabel", function (e) {
            // If creation of a new annotation is in progress, don't change the mode
            if (ulabel.get_current_subtask()["state"]["is_in_progress"])
                return;
            // Check if the correct key was pressed
            if (e.key == ulabel.config.toggle_annotation_mode_keybind) {
                var mode_button_array = [];
                // Loop through all of the mode buttons
                for (var idx in Array.from(document.getElementsByClassName("md-btn"))) {
                    // Grab mode button
                    var mode_button = document.getElementsByClassName("md-btn")[idx];
                    // Continue without adding it to the array if its display is none
                    if (mode_button.style.display == "none") {
                        continue;
                    }
                    mode_button_array.push(mode_button);
                }
                // Grab the currently selected mode button
                var selected_mode_button = Array.from(document.getElementsByClassName("md-btn sel"))[0]; // There's only ever going to be one element in this array, so grab the first one
                var new_button_index = void 0;
                // Loop through all of the mode select buttons that are currently displayed
                // to find which one is the currently selected button.  Once its found add 1
                // to get the index of the next mode select button. If the new button index
                // is the same as the array's length, then loop back and set the new button
                // to 0.
                for (var idx in mode_button_array) {
                    if (mode_button_array[idx] === selected_mode_button) {
                        new_button_index = Number(idx) + 1;
                        if (new_button_index == mode_button_array.length) {
                            new_button_index = 0;
                        }
                    }
                }
                // Grab the button for the mode we want to switch to
                var new_selected_button = mode_button_array[new_button_index];
                new_selected_button.click();
            }
        });
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    ModeSelectionToolboxItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.mode-selection {\n            padding: 10px 30px;\n         }\n         \n         #toolbox div.mode-selection p.current_mode_container {\n            margin-top: 0px;\n            margin-bottom: 5px;\n         }\n         \n         #toolbox div.mode-selection span.current_mode {\n            color: cornflowerblue;\n         }\n         \n         #toolbox div.mode-opt {\n            display: inline-block;\n         }\n         \n         #toolbox div.mode-selection a.md-btn {\n            text-align: center;\n            height: 30px;\n            width: 30px;\n            padding: 10px;\n            margin: 0 auto;\n            text-decoration: none;\n            color: black;\n            font-size: 1.2em;\n            font-family: sans-serif;\n         }\n         \n         #toolbox div.mode-selection a.md-btn svg {\n            height: 30px;\n            width: 30px;\n         }\n         \n         #toolbox div.mode-selection a.md-btn:hover {\n            background-color: rgba(255, 181, 44, 0.397);\n         }\n         \n         #toolbox div.mode-selection a.md-btn.sel {\n            background-color: rgba(100, 148, 237, 0.459);\n         }\n\n        \n        \n        \n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "mode-selection-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    ModeSelectionToolboxItem.prototype.get_html = function () {
        return "\n        <div class=\"mode-selection\">\n            <p class=\"current_mode_container\">\n                <span class=\"cmlbl\">Mode:</span>\n                <span class=\"current_mode\"></span>\n            </p>\n        </div>\n        ";
    };
    ModeSelectionToolboxItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    ModeSelectionToolboxItem.prototype.get_toolbox_item_type = function () {
        return "ModeSelection";
    };
    return ModeSelectionToolboxItem;
}(ToolboxItem));
exports.ModeSelectionToolboxItem = ModeSelectionToolboxItem;
/**
 * Toolbox item for resizing all annotations
 */
var BrushToolboxItem = /** @class */ (function (_super) {
    __extends(BrushToolboxItem, _super);
    function BrushToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        _this.add_styles();
        _this.add_event_listeners();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    BrushToolboxItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.brush button:not(.circle) {\n            padding: 1rem 0.5rem;\n            border: 1px solid gray;\n            border-radius: 10px\n        }\n\n        #toolbox div.brush div.brush-button-holder {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            gap: 0.5rem;\n            margin-bottom: 1rem;\n        }\n\n        #toolbox div.brush span.brush-mode {\n            display: flex;\n        }        \n        \n        #toolbox div.brush button.brush-button.".concat(BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS, " {\n            background-color: #1c2d4d;\n        }\n        ");
        // Create an id so this specific style tag can be referenced
        var style_id = "brush-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    BrushToolboxItem.prototype.add_event_listeners = function () {
        var _this = this;
        $(document).on("click.ulabel", ".brush-button", function (event) {
            // Get the clicked button
            var button = $(event.currentTarget);
            // Use the button id to get what size to resize the annotations to
            var button_id = button.attr("id");
            switch (button_id) {
                case "brush-mode":
                    _this.ulabel.toggle_brush_mode(event);
                    break;
                case "erase-mode":
                    _this.ulabel.toggle_erase_mode(event);
                    break;
                case "brush-inc":
                    _this.ulabel.change_brush_size(1.1);
                    break;
                case "brush-dec":
                    _this.ulabel.change_brush_size(1 / 1.1);
                    break;
            }
            ;
        });
    };
    BrushToolboxItem.prototype.get_html = function () {
        return "\n        <div class=\"brush\">\n            <p class=\"tb-header\">Brush Tool</p>\n            <div class=\"brush-button-holder\">\n                <span class=\"brush-mode\">\n                    <button class=\"brush-button\" id=\"brush-mode\">Brush</button>\n                    <button class=\"brush-button\" id=\"erase-mode\">Erase</button>\n                </span>\n                <span class=\"brush-inc increment\">\n                    <button class=\"brush-button circle inc\" id=\"brush-inc\">+</button>\n                    <button class=\"brush-button circle dec\" id=\"brush-dec\">-</button>\n                </span>\n            </div>\n        </div>\n        ";
    };
    BrushToolboxItem.show_brush_toolbox_item = function () {
        // Remove hidden class from the brush toolbox item
        $(".brush").removeClass("ulabel-hidden");
    };
    BrushToolboxItem.hide_brush_toolbox_item = function () {
        // Add hidden class to the brush toolbox item
        $(".brush").addClass("ulabel-hidden");
    };
    BrushToolboxItem.prototype.after_init = function () {
        // Only show BrushToolboxItem if the current mode is polygon
        if (this.ulabel.get_current_subtask().state["annotation_mode"] !== "polygon") {
            BrushToolboxItem.hide_brush_toolbox_item();
        }
    };
    BrushToolboxItem.prototype.get_toolbox_item_type = function () {
        return "Brush";
    };
    /**
     * CSS class indicating the brush button is active
     */
    BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS = "brush-button-active";
    return BrushToolboxItem;
}(ToolboxItem));
exports.BrushToolboxItem = BrushToolboxItem;
/**
 * Toolbox item for zooming and panning.
 */
var ZoomPanToolboxItem = /** @class */ (function (_super) {
    __extends(ZoomPanToolboxItem, _super);
    function ZoomPanToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        _this.set_frame_range(ulabel);
        _this.add_styles();
        _this.add_event_listeners();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    ZoomPanToolboxItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.zoom-pan {\n            padding: 10px 30px;\n            display: grid;\n            grid-template-rows: auto 1.25rem auto;\n            grid-template-columns: 1fr 1fr;\n            grid-template-areas:\n                \"zoom     pan\"\n                \"zoom-tip pan-tip\"\n                \"recenter recenter\";\n        }\n         \n        #toolbox div.zoom-pan > * {\n            place-self: center;\n        }\n        \n        #toolbox div.zoom-pan button {\n            background-color: lightgray;\n        }\n\n        #toolbox div.zoom-pan button:hover {\n            background-color: rgba(0, 128, 255, 0.9);\n        }\n        \n        #toolbox div.zoom-pan div.set-zoom {\n            grid-area: zoom;\n        }\n        \n        #toolbox div.zoom-pan div.set-pan {\n            grid-area: pan;\n        }\n        \n        #toolbox div.zoom-pan div.set-pan div.pan-container {\n            display: inline-flex;\n            align-items: center;\n        }\n        \n        #toolbox div.zoom-pan p.shortcut-tip {\n            margin: 2px 0;\n            font-size: 10px;\n            color: white;\n        }\n\n        #toolbox div.zoom-pan:hover p.shortcut-tip {\n            color: black;\n        }\n\n        .ulabel-night #toolbox div.zoom-pan p.shortcut-tip {\n            margin: 0;\n            font-size: 10px;\n            color: black;\n        }\n\n        .ulabel-night #toolbox div.zoom-pan:hover p.shortcut-tip {\n            color: white;\n        }\n        \n        #toolbox.ulabel-night div.zoom-pan:hover p.pan-shortcut-tip {\n            color: white;\n        }\n        \n        #toolbox div.zoom-pan p.zoom-shortcut-tip {\n            grid-area: zoom-tip;\n        }\n        \n        #toolbox div.zoom-pan p.pan-shortcut-tip {\n            grid-area: pan-tip;\n        }\n        \n        #toolbox div.zoom-pan span.pan-label {\n            margin-right: 10px;\n        }\n        \n        #toolbox div.zoom-pan span.pan-button-holder {\n            display: inline-grid;\n            position: relative;\n            grid-template-rows: 28px 28px;\n            grid-template-columns: 28px 28px;\n            grid-template-areas:\n                \"left   top\"\n                \"bottom right\";\n            transform: rotate(-45deg);\n            gap: 1px;\n        }\n        \n        #toolbox div.zoom-pan span.pan-button-holder > * {\n            border: 1px solid gray;\n        }\n        \n        #toolbox div.zoom-pan button.ulabel-pan:hover {\n            background-color: cornflowerblue;\n        }\n        \n        #toolbox div.zoom-pan button.ulabel-pan-left {\n            grid-area: left;\n            border-radius: 100% 0 0 0;\n        }\n        \n        #toolbox div.zoom-pan button.ulabel-pan-right {\n            grid-area: right;\n            border-radius: 0 0 100% 0;\n        }\n        \n        #toolbox div.zoom-pan button.ulabel-pan-up {\n            grid-area: top;\n            border-radius: 0 100% 0 0;\n        }\n        \n        #toolbox div.zoom-pan button.ulabel-pan-down {\n            grid-area: bottom;\n            border-radius: 0 0 0 100%;\n        }\n        \n        #toolbox div.zoom-pan span.spokes {\n            background-color: white;\n            width: 16px;\n            height: 16px;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            border-radius: 50%;\n        }\n        \n        .ulabel-night #toolbox div.zoom-pan span.spokes {\n            background-color: black;\n        }\n\n        #toolbox div.zoom-pan div.recenter-container {\n            grid-area: recenter;\n        }\n        \n        .ulabel-night #toolbox div.zoom-pan a {\n            color: lightblue;\n        }\n\n        .ulabel-night #toolbox div.zoom-pan a:active {\n            color: white;\n        }\n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "zoom-pan-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    ZoomPanToolboxItem.prototype.add_event_listeners = function () {
        var _this = this;
        var frames_exist = this.ulabel.config["image_data"].frames.length > 1;
        $(document).on("click.ulabel", ".ulabel-zoom-button", function (event) {
            var _a;
            if ($(event.currentTarget).hasClass("ulabel-zoom-out")) {
                _this.ulabel.state.zoom_val /= 1.1;
            }
            else if ($(event.currentTarget).hasClass("ulabel-zoom-in")) {
                _this.ulabel.state.zoom_val *= 1.1;
            }
            _this.ulabel.rezoom();
            // Only try to update the overlay if it exists
            (_a = _this.ulabel.filter_distance_overlay) === null || _a === void 0 ? void 0 : _a.draw_overlay();
        });
        $(document).on("click.ulabel", ".ulabel-pan", function (event) {
            var annbox = $("#" + _this.ulabel.config.annbox_id);
            if ($(event.currentTarget).hasClass("ulabel-pan-up")) {
                annbox.scrollTop(annbox.scrollTop() - 20);
            }
            else if ($(event.currentTarget).hasClass("ulabel-pan-down")) {
                annbox.scrollTop(annbox.scrollTop() + 20);
            }
            else if ($(event.currentTarget).hasClass("ulabel-pan-left")) {
                annbox.scrollLeft(annbox.scrollLeft() - 20);
            }
            else if ($(event.currentTarget).hasClass("ulabel-pan-right")) {
                annbox.scrollLeft(annbox.scrollLeft() + 20);
            }
        });
        // Add diffrent keypress events if frames exist
        if (frames_exist) {
            $(document).on("keypress.ulabel", function (event) {
                event.preventDefault();
                switch (event.key) {
                    case "ArrowRight":
                    case "ArrowDown":
                        _this.ulabel.update_frame(1);
                        break;
                    case "ArrowUp":
                    case "ArrowLeft":
                        _this.ulabel.update_frame(-1);
                }
            });
        }
        else {
            $(document).on("keydown.ulabel", function (event) {
                var annbox = $("#" + _this.ulabel.config.annbox_id);
                switch (event.key) {
                    case "ArrowLeft":
                        annbox.scrollLeft(annbox.scrollLeft() - 20);
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        annbox.scrollLeft(annbox.scrollLeft() + 20);
                        event.preventDefault();
                        break;
                    case "ArrowUp":
                        annbox.scrollTop(annbox.scrollTop() - 20);
                        event.preventDefault();
                        break;
                    case "ArrowDown":
                        annbox.scrollTop(annbox.scrollTop() + 20);
                        event.preventDefault();
                        break;
                    default:
                }
            });
        }
        $(document).on("click.ulabel", "#recenter-button", function () {
            _this.ulabel.show_initial_crop();
        });
        $(document).on("click.ulabel", "#recenter-whole-image-button", function () {
            _this.ulabel.show_whole_image();
        });
        $(document).on("keypress.ulabel", function (e) {
            if (e.key == _this.ulabel.config.change_zoom_keybind.toLowerCase()) {
                document.getElementById("recenter-button").click();
            }
            if (e.key == _this.ulabel.config.change_zoom_keybind.toUpperCase()) {
                document.getElementById("recenter-whole-image-button").click();
            }
        });
    };
    ZoomPanToolboxItem.prototype.set_frame_range = function (ulabel) {
        if (ulabel.config["image_data"]["frames"].length == 1) {
            this.frame_range = "";
            return;
        }
        this.frame_range = "\n            <div class=\"full-tb htbmain set-frame\">\n                <p class=\"shortcut-tip\">scroll to switch frames</p>\n                <div class=\"zpcont\">\n                    <div class=\"lblpyldcont\">\n                        <span class=\"pzlbl htblbl\">Frame</span> &nbsp;\n                        <input class=\"frame_input\" type=\"range\" min=0 max=".concat(ulabel.config["image_data"].frames.length - 1, " value=0 />\n                    </div>\n                </div>\n            </div>\n            ");
    };
    ZoomPanToolboxItem.prototype.get_html = function () {
        return "\n        <div class=\"zoom-pan\">\n            <div class=\"set-zoom\">  \n                <span>Zoom</span>\n                <span class=\"zoom-button-holder\">\n                    <button class=\"ulabel-zoom-button ulabel-zoom-out circle\">-</button>\n                    <button class=\"ulabel-zoom-button ulabel-zoom-in circle\">+</button>\n                </span>\n            </div>\n            <p class=\"shortcut-tip zoom-shortcut-tip\">ctrl+scroll or shift+drag</p>\n            <div class=\"set-pan\">\n                <div class=\"pan-container\">\n                    <span class=\"pan-label\">Pan</span>\n                    <span class=\"pan-button-holder\">\n                        <button class=\"ulabel-pan ulabel-pan-left\"></button>\n                        <button class=\"ulabel-pan ulabel-pan-right\"></button>\n                        <button class=\"ulabel-pan ulabel-pan-up\"></button>\n                        <button class=\"ulabel-pan ulabel-pan-down\"></button>\n                        <span class=\"spokes\"></span>\n                    </span>\n                </div>\n            </div>\n            <p class=\"shortcut-tip pan-shortcut-tip\">scrollclick+drag or ctrl+drag</p>\n            <div class=\"recenter-container\">\n                <a href=\"#\" id=\"recenter-button\">Re-Center</a>\n                <a href=\"#\" id=\"recenter-whole-image-button\">Whole Image</a>\n            </div>\n            ".concat(this.frame_range, "\n        </div>\n        ");
    };
    ZoomPanToolboxItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    ZoomPanToolboxItem.prototype.get_toolbox_item_type = function () {
        return "ZoomPan";
    };
    return ZoomPanToolboxItem;
}(ToolboxItem));
exports.ZoomPanToolboxItem = ZoomPanToolboxItem;
/**
 * Toolbox item for selection Annotation ID.
 */
var AnnotationIDToolboxItem = /** @class */ (function (_super) {
    __extends(AnnotationIDToolboxItem, _super);
    function AnnotationIDToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        _this.set_instructions(ulabel);
        _this.add_styles();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    AnnotationIDToolboxItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.classification div.id-toolbox-app {\n            margin-bottom: 1rem;\n        }\n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "annotation-id-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    AnnotationIDToolboxItem.prototype.set_instructions = function (ulabel) {
        this.instructions = "";
        if (ulabel.config["instructions_url"] != null) {
            this.instructions = "\n                <a href=\"".concat(ulabel.config["instructions_url"], "\" target=\"_blank\" rel=\"noopener noreferrer\">Instructions</a>\n            ");
        }
    };
    /**
     * Get the html skeleton for this ToolboxItem. The actual ID selection items will be added
     * in html_builder.ts in the function build_id_dialogs()
     *
     * @returns html string
     */
    AnnotationIDToolboxItem.prototype.get_html = function () {
        return "\n        <div class=\"classification\">\n            <p class=\"tb-header\">Annotation ID</p>\n            <div class=\"id-toolbox-app\"></div>\n        </div>\n        <div class=\"toolbox-refs\">\n            ".concat(this.instructions, "\n        </div>\n        ");
    };
    AnnotationIDToolboxItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    AnnotationIDToolboxItem.prototype.get_toolbox_item_type = function () {
        return "AnnotationID";
    };
    return AnnotationIDToolboxItem;
}(ToolboxItem));
exports.AnnotationIDToolboxItem = AnnotationIDToolboxItem;
var ClassCounterToolboxItem = /** @class */ (function (_super) {
    __extends(ClassCounterToolboxItem, _super);
    // TODO (joshua-dean): Find the correct way to handle this
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function ClassCounterToolboxItem() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.inner_HTML = "<p class=\"tb-header\">Annotation Count</p>";
        _this.add_styles();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    ClassCounterToolboxItem.prototype.add_styles = function () {
        // Define the css
        var css = " /* ClassCounterToolboxItem currently requires no styling */ ";
        // Create an id so this specific style tag can be referenced
        var style_id = "class-counter-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    /**
     * Update the Class Counter with the current number of active annotations.
     *
     * @param {ULabelSubtask} subtask Subtask to update the counter for.
     */
    ClassCounterToolboxItem.prototype.update_toolbox_counter = function (subtask) {
        if (subtask == null) {
            return;
        }
        var class_ids = subtask.class_ids;
        var i, j;
        var class_counts = {};
        for (i = 0; i < class_ids.length; i++) {
            class_counts[class_ids[i]] = 0;
        }
        var annotations = subtask.annotations.access;
        var annotation_ids = subtask.annotations.ordering;
        var current_annotation, current_payload;
        for (i = 0; i < annotation_ids.length; i++) {
            current_annotation = annotations[annotation_ids[i]];
            if (current_annotation.deprecated === false) {
                for (j = 0; j < current_annotation.classification_payloads.length; j++) {
                    current_payload = current_annotation.classification_payloads[j];
                    if (current_payload.confidence > 0.0) {
                        class_counts[current_payload.class_id] += 1;
                        break;
                    }
                }
            }
        }
        var f_string = "";
        var class_name, class_count;
        for (i = 0; i < class_ids.length; i++) {
            class_name = subtask.class_defs[i].name;
            // MF-Tassels Hack
            if (class_name.includes("OVERWRITE")) {
                continue;
            }
            class_count = class_counts[subtask.class_defs[i].id];
            f_string += "".concat(class_name, ": ").concat(class_count, "<br>");
        }
        this.inner_HTML = "<p class=\"tb-header\">Annotation Count</p>" + "<p>".concat(f_string, "</p>");
    };
    ClassCounterToolboxItem.prototype.get_html = function () {
        return "\n            <div class=\"toolbox-class-counter\">" + this.inner_HTML + "</div>";
    };
    ClassCounterToolboxItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    ClassCounterToolboxItem.prototype.redraw_update = function (ulabel) {
        this.update_toolbox_counter(ulabel.get_current_subtask());
        $("#" + ulabel.config["toolbox_id"] + " div.toolbox-class-counter").html(this.inner_HTML);
    };
    ClassCounterToolboxItem.prototype.get_toolbox_item_type = function () {
        return "ClassCounter";
    };
    return ClassCounterToolboxItem;
}(ToolboxItem));
exports.ClassCounterToolboxItem = ClassCounterToolboxItem;
/**
 * Toolbox item for resizing all annotations
 */
var AnnotationResizeItem = /** @class */ (function (_super) {
    __extends(AnnotationResizeItem, _super);
    function AnnotationResizeItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.cached_size = 1.5;
        _this.ulabel = ulabel;
        // Get default keybinds
        _this.keybind_configuration = ulabel.config.default_keybinds;
        // First check for a size cookie, if one isn't found then check the config
        // for a default annotation size. If neither are found it will use the size
        // that the annotation was saved as.
        for (var subtask in ulabel.subtasks) {
            var cached_size_property = ulabel.subtasks[subtask].display_name.replaceLowerConcat(" ", "-", "-cached-size");
            var size_cookie = _this.read_size_cookie(ulabel.subtasks[subtask]);
            if ((size_cookie != null) && size_cookie != "NaN") {
                _this.update_annotation_size(ulabel, ulabel.subtasks[subtask], Number(size_cookie));
                _this[cached_size_property] = Number(size_cookie);
            }
            else if (ulabel.config.default_annotation_size != undefined) {
                _this.update_annotation_size(ulabel, ulabel.subtasks[subtask], ulabel.config.default_annotation_size);
                _this[cached_size_property] = ulabel.config.default_annotation_size;
            }
            else {
                var DEFAULT_SIZE = 5;
                _this.update_annotation_size(ulabel, ulabel.subtasks[subtask], DEFAULT_SIZE);
                _this[cached_size_property] = DEFAULT_SIZE;
            }
        }
        _this.add_styles();
        _this.add_event_listeners();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    AnnotationResizeItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.annotation-resize button:not(.circle) {\n            padding: 1rem 0.5rem;\n            border: 1px solid gray;\n            border-radius: 10px\n        }\n\n        #toolbox div.annotation-resize div.annotation-resize-button-holder {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            gap: 0.5rem;\n            margin-bottom: 1rem;\n        }\n\n        #toolbox div.annotation-resize span.annotation-vanish:hover,\n        #toolbox div.annotation-resize span.annotation-size:hover {\n            border-radius: 10px;\n            box-shadow: 0 0 4px 2px lightgray, 0 0 white;\n        }\n\n        /* No box-shadow in night-mode */\n        .ulabel-night #toolbox div.annotation-resize span.annotation-vanish:hover,\n        .ulabel-night #toolbox div.annotation-resize span.annotation-size:hover {\n            box-shadow: initial;\n        }\n\n        #toolbox div.annotation-resize span.annotation-size {\n            display: flex;\n        }\n\n        #toolbox div.annotation-resize span.annotation-size #annotation-resize-s {\n            border-radius: 10px 0 0 10px;\n        }\n\n        #toolbox div.annotation-resize span.annotation-size #annotation-resize-l {\n            border-radius: 0 10px 10px 0;\n        }\n        \n        #toolbox div.annotation-resize span.annotation-inc {\n            display: flex;\n            flex-direction: column;\n            gap: 0.25rem;\n        }\n\n        #toolbox div.annotation-resize button.locked {\n            background-color: #1c2d4d;\n        }\n        \n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "resize-annotation-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    AnnotationResizeItem.prototype.add_event_listeners = function () {
        var _this = this;
        $(document).on("click.ulabel", ".annotation-resize-button", function (event) {
            // Get the current subtask
            var current_subtask_key = _this.ulabel.get_current_subtask_key();
            var current_subtask = _this.ulabel.get_current_subtask();
            // Get the clicked button
            var button = $(event.currentTarget);
            // Use the button id to get what size to resize the annotations to
            var annotation_size = button.attr("id").slice(18);
            // Update the size of all annotations in the subtask
            _this.update_annotation_size(_this.ulabel, current_subtask, annotation_size);
            _this.ulabel.redraw_all_annotations(current_subtask_key, null, false);
        });
        $(document).on("keydown.ulabel", function (event) {
            // Get the current subtask
            var current_subtask = _this.ulabel.get_current_subtask();
            switch (event.key) {
                case _this.keybind_configuration.annotation_vanish.toUpperCase():
                    _this.update_all_subtask_annotation_size(_this.ulabel, ValidResizeValues.VANISH);
                    break;
                case _this.keybind_configuration.annotation_vanish.toLowerCase():
                    _this.update_annotation_size(_this.ulabel, current_subtask, ValidResizeValues.VANISH);
                    break;
                case _this.keybind_configuration.annotation_size_small:
                    _this.update_annotation_size(_this.ulabel, current_subtask, ValidResizeValues.SMALL);
                    break;
                case _this.keybind_configuration.annotation_size_large:
                    _this.update_annotation_size(_this.ulabel, current_subtask, ValidResizeValues.LARGE);
                    break;
                case _this.keybind_configuration.annotation_size_minus:
                    _this.update_annotation_size(_this.ulabel, current_subtask, ValidResizeValues.DECREMENT);
                    break;
                case _this.keybind_configuration.annotation_size_plus:
                    _this.update_annotation_size(_this.ulabel, current_subtask, ValidResizeValues.INCREMENT);
                    break;
                default:
                    // Return if no valid keybind was pressed
                    return;
            }
            // If the sizes were updated resize the annotations
            _this.ulabel.redraw_all_annotations(null, null, false);
        });
    };
    /**
     * Takes in either a number or a ValidResizeValues.value. If given a number it will resize all annotations in the subtask to
     * be that size. The ValidResizeValues will either set the size of all annotations to set values or increment/decrement the
     * current size of the annotations.
     *
     * @param subtask Subtask which holds the annotations to act on
     * @param size How to resize the annotations
     */
    AnnotationResizeItem.prototype.update_annotation_size = function (ulabel, subtask, size) {
        if (subtask === null)
            return;
        var small_size = 1.5;
        var large_size = 5;
        var increment_size = 0.5;
        var subtask_cached_size = subtask.display_name.replaceLowerConcat(" ", "-", "-cached-size");
        var subtask_vanished_flag = subtask.display_name.replaceLowerConcat(" ", "-", "-vanished");
        // If the annotations are currently vanished and a button other than the vanish button is
        // pressed, then we want to ignore the input
        if (this[subtask_vanished_flag] && size !== "v")
            return;
        // If a number was passed in, set all annotations to be the size of the number
        if (typeof (size) === "number") {
            this.loop_through_annotations(subtask, size, "=");
            return;
        }
        // Otherwise handle each ValidResizeValues case here
        switch (size) {
            case ValidResizeValues.SMALL:
                this.loop_through_annotations(subtask, small_size, "=");
                this[subtask_cached_size] = small_size;
                break;
            case ValidResizeValues.LARGE:
                this.loop_through_annotations(subtask, large_size, "=");
                this[subtask_cached_size] = large_size;
                break;
            case ValidResizeValues.DECREMENT:
                this.loop_through_annotations(subtask, increment_size, "-");
                if (this[subtask_cached_size] - increment_size > vanish_size) {
                    this[subtask_cached_size] -= increment_size;
                }
                else {
                    this[subtask_cached_size] = vanish_size;
                }
                break;
            case ValidResizeValues.INCREMENT:
                this.loop_through_annotations(subtask, increment_size, "+");
                this[subtask_cached_size] += increment_size;
                break;
            case ValidResizeValues.VANISH:
                if (this[subtask_vanished_flag]) {
                    // Re-apply the cashed annotation size
                    this.loop_through_annotations(subtask, this[subtask_cached_size], "=");
                    // Filp the state
                    this[subtask_vanished_flag] = !this[subtask_vanished_flag];
                    // Unlock the vanish button
                    $("#annotation-resize-v").removeClass("locked");
                }
                else {
                    // Apply the vanish size to make the annotations to small to see
                    this.loop_through_annotations(subtask, vanish_size, "=");
                    // Filp the state
                    this[subtask_vanished_flag] = !this[subtask_vanished_flag];
                    // Lock the vanish button
                    $("#annotation-resize-v").addClass("locked");
                }
                break;
            default:
                console.error("update_annotation_size called with unknown size");
        }
        // Store the new size as the default if we should be tracking it
        if (ulabel.state.line_size !== null) {
            ulabel.state.line_size = this[subtask_cached_size];
        }
    };
    // Loop through all annotations in a subtask and change their line size
    AnnotationResizeItem.prototype.loop_through_annotations = function (subtask, size, operation) {
        for (var annotation_id in subtask.annotations.access) {
            switch (operation) {
                case "=":
                    subtask.annotations.access[annotation_id].line_size = size;
                    break;
                case "+":
                    subtask.annotations.access[annotation_id].line_size += size;
                    break;
                case "-":
                    // Check to make sure annotation line size won't go 0 or negative.
                    // If it would, set it equal to a small positive number
                    if (subtask.annotations.access[annotation_id].line_size - size <= vanish_size) {
                        subtask.annotations.access[annotation_id].line_size = vanish_size;
                    }
                    else {
                        subtask.annotations.access[annotation_id].line_size -= size;
                    }
                    break;
                default:
                    throw Error("Invalid Operation given to loop_through_annotations");
            }
        }
        if (subtask.annotations.ordering.length > 0) {
            var line_size = subtask.annotations.access[subtask.annotations.ordering[0]].line_size;
            if (line_size !== vanish_size) {
                this.set_size_cookie(line_size, subtask);
            }
        }
    };
    // Loop through all subtasks and apply a size to them all
    AnnotationResizeItem.prototype.update_all_subtask_annotation_size = function (ulabel, size) {
        for (var subtask in ulabel.subtasks) {
            this.update_annotation_size(ulabel, ulabel.subtasks[subtask], size);
        }
    };
    AnnotationResizeItem.prototype.redraw_update = function (ulabel) {
        // Ensure the vanish button reflects the vanish state of the current subtask
        var current_subtask = ulabel.get_current_subtask();
        var subtask_vanished_flag = current_subtask.display_name.replaceLowerConcat(" ", "-", "-vanished");
        if (this[subtask_vanished_flag]) {
            $("#annotation-resize-v").addClass("locked");
        }
        else {
            $("#annotation-resize-v").removeClass("locked");
        }
    };
    AnnotationResizeItem.prototype.set_size_cookie = function (cookie_value, subtask) {
        var d = new Date();
        d.setTime(d.getTime() + (10000 * 24 * 60 * 60 * 1000));
        var subtask_name = subtask.display_name.replaceLowerConcat(" ", "_");
        document.cookie = subtask_name + "_size=" + cookie_value + ";" + d.toUTCString() + ";path=/";
    };
    AnnotationResizeItem.prototype.read_size_cookie = function (subtask) {
        var subtask_name = subtask.display_name.replaceLowerConcat(" ", "_");
        var cookie_name = subtask_name + "_size=";
        var cookie_array = document.cookie.split(";");
        for (var i = 0; i < cookie_array.length; i++) {
            var current_cookie = cookie_array[i];
            // while there's whitespace at the front of the cookie, loop through and remove it
            while (current_cookie.charAt(0) == " ") {
                current_cookie = current_cookie.substring(1);
            }
            if (current_cookie.indexOf(cookie_name) == 0) {
                return current_cookie.substring(cookie_name.length, current_cookie.length);
            }
        }
        return null;
    };
    AnnotationResizeItem.prototype.get_html = function () {
        return "\n        <div class=\"annotation-resize\">\n            <p class=\"tb-header\">Change Annotation Size</p>\n            <div class=\"annotation-resize-button-holder\">\n                <span class=\"annotation-vanish\">\n                    <button class=\"annotation-resize-button\" id=\"annotation-resize-v\">Vanish</button>\n                </span>\n                <span class=\"annotation-size\">\n                    <button class=\"annotation-resize-button\" id=\"annotation-resize-s\">Small</button>\n                    <button class=\"annotation-resize-button\" id=\"annotation-resize-l\">Large</button>\n                </span>\n                <span class=\"annotation-inc increment\">\n                    <button class=\"annotation-resize-button circle inc\" id=\"annotation-resize-inc\">+</button>\n                    <button class=\"annotation-resize-button circle dec\" id=\"annotation-resize-dec\">-</button>\n                </span>\n            </div>\n        </div>\n        ";
    };
    AnnotationResizeItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    AnnotationResizeItem.prototype.get_toolbox_item_type = function () {
        return "AnnotationResize";
    };
    return AnnotationResizeItem;
}(ToolboxItem));
exports.AnnotationResizeItem = AnnotationResizeItem;
/**
 * ToolboxItem for recoloring annotations and applying gradients to annotations based on confidence.
 */
var RecolorActiveItem = /** @class */ (function (_super) {
    __extends(RecolorActiveItem, _super);
    function RecolorActiveItem(ulabel) {
        var _a;
        var _this = _super.call(this) || this;
        _this.most_recent_redraw_time = 0;
        // Save ulabel to this object and grab this component's config from the main config
        _this.ulabel = ulabel;
        _this.config = _this.ulabel.config.recolor_active_toolbox_item;
        // Add styles and event listeners for this component
        _this.add_styles();
        _this.add_event_listeners();
        // Read local storage to see if any colors have been saved
        _this.read_local_storage();
        // Use the config's default only if a value wasn't found inside local storage
        (_a = _this.gradient_turned_on) !== null && _a !== void 0 ? _a : (_this.gradient_turned_on = _this.config.gradient_turned_on);
        return _this;
    }
    RecolorActiveItem.prototype.save_local_storage_color = function (class_id, color) {
        (0, utilities_1.set_local_storage_item)("RecolorActiveItem-".concat(class_id), color);
    };
    RecolorActiveItem.prototype.save_local_storage_gradient = function (gradient_status) {
        (0, utilities_1.set_local_storage_item)("RecolorActiveItem-Gradient", gradient_status);
    };
    RecolorActiveItem.prototype.read_local_storage = function () {
        // Loop through every valid id and see if a color has been saved for it in local storage
        for (var _i = 0, _a = this.ulabel.valid_class_ids; _i < _a.length; _i++) {
            var class_id = _a[_i];
            // Get the color from local storage based on the current class id
            var color = (0, utilities_1.get_local_storage_item)("RecolorActiveItem-".concat(class_id));
            // Update the color if its not null
            // Additionally no need to save the color to local storage since we got it from reading local storage
            if (color !== null)
                this.update_color(class_id, color, false);
        }
        // Then read whether or not the gradient should be on by default
        this.gradient_turned_on = (0, utilities_1.get_local_storage_item)("RecolorActiveItem-Gradient");
    };
    RecolorActiveItem.prototype.replace_color_pie = function () {
        // Only the current subtask's color can be changed, so only the current subtask needs to be updated
        var current_subtask_key = this.ulabel.state.current_subtask;
        var current_subtask = this.ulabel.subtasks[current_subtask_key];
        // Get the back and front id dialog's ids
        var id_dialog_id = current_subtask.state.idd_id;
        var front_id_dialog_id = this.ulabel.subtasks[current_subtask_key].state.idd_id_front;
        // Need the width and inner radius of the pie to re-build it
        var width = this.ulabel.config.outer_diameter;
        var inner_radius = this.ulabel.config.inner_prop * width / 2;
        var color_info = this.ulabel.color_info;
        // Grab the dialogs and their containers
        var subtask_dialog_container_jq = $("#dialogs__" + current_subtask_key);
        var id_dialog_container = $("#id_dialog__".concat(current_subtask_key));
        var front_subtask_dialog_container_jq = $("#front_dialogs__" + current_subtask_key);
        var front_id_dialog_container = $("#id_front_dialog__".concat(current_subtask_key));
        // Build the html
        var dialog_html_v2 = (0, html_builder_1.get_idd_string)(id_dialog_id, width, this.ulabel.subtasks[current_subtask_key].class_ids, inner_radius, color_info);
        var front_dialog_html_v2 = (0, html_builder_1.get_idd_string)(front_id_dialog_id, width, this.ulabel.subtasks[current_subtask_key].class_ids, inner_radius, color_info);
        // Remove the old pies
        id_dialog_container.remove();
        front_id_dialog_container.remove();
        // Add dialog to the document inside their containers
        front_subtask_dialog_container_jq.append(front_dialog_html_v2);
        subtask_dialog_container_jq.append(dialog_html_v2);
        // Re-add the event listener for changing the opacity on hover
        // Set that = this because this references the element inside the event listener instead of the toolbox item
        // TODO (joshua-dean): Don't alias this
        // https://typescript-eslint.io/rules/no-this-alias/
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var that = this;
        $(".id_dialog").on("mousemove.ulabel", function (mouse_event) {
            if (!that.ulabel.subtasks[current_subtask_key].state.idd_thumbnail) {
                that.ulabel.handle_id_dialog_hover(mouse_event);
            }
        });
    };
    RecolorActiveItem.prototype.update_color = function (class_id, color, need_to_save) {
        if (need_to_save === void 0) { need_to_save = true; }
        // Update the color_info for annotations appropriately
        this.ulabel.color_info[class_id] = color;
        // Update the color in the AnnotationId button for this class
        var button_color_square = document.querySelector("#toolbox_sel_".concat(class_id, " > div"));
        if (button_color_square)
            button_color_square.style.backgroundColor = color;
        // Update the id update pie
        this.replace_color_pie();
        // Save the color to local storage if appropriate
        if (need_to_save)
            this.save_local_storage_color(class_id, color);
    };
    RecolorActiveItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        #toolbox div.recolor-active {\n            padding: 0 2rem;\n        }\n\n        #toolbox div.recolor-active div.recolor-tbi-gradient {\n            font-size: 80%;\n        }\n\n        #toolbox div.recolor-active div.gradient-toggle-container {\n            text-align: left;\n            display: flex;\n            align-items: center;\n        }\n\n        #toolbox div.recolor-active div.gradient-slider-container {\n            display: flex;\n            align-items: center;\n        }\n\n        #toolbox div.recolor-active div.gradient-slider-container > input {\n            width: 50%;\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder {\n            margin: 0.5rem;\n            display: grid;\n            grid-template-columns: 2fr 1fr;\n            grid-template-rows: 1fr 1fr 1fr;\n            grid-template-areas:\n                \"yellow picker\"\n                \"red    picker\"\n                \"cyan   picker\";\n            gap: 0.25rem 0.75rem;\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder .color-change-btn {\n            height: 1.5rem;\n            border-radius: 0.5rem;\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder #color-change-yellow {\n            grid-area: yellow;\n            background-color: yellow;\n            border: 1px solid rgb(200, 200, 0);\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder #color-change-red {\n            grid-area: red;\n            background-color: red;\n            border: 1px solid rgb(200, 0, 0);\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder #color-change-cyan {\n            grid-area: cyan;\n            background-color: cyan;\n            border: 1px solid rgb(0, 200, 200);\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder div.color-picker-border {\n            grid-area: picker;\n            background: linear-gradient(to bottom right, red, orange, yellow, green, blue, indigo, violet);\n            border: 1px solid black;\n            border-radius: 0.5rem;\n        }\n\n        #toolbox div.recolor-active div.annotation-recolor-button-holder div.color-picker-border div.color-picker-container {\n            width: calc(100% - 8px);\n            height: calc(100% - 8px);\n            margin: 3px;\n            background-color: black;\n            border: 1px solid black;\n            border-radius: 0.5rem;\n        }\n\n        #toolbox div.recolor-active div.color-picker-container input.color-change-picker {\n            width: 100%;\n            height: 100%;\n            padding: 0;\n            opacity: 0;\n        }";
        // Create an id so this specific style tag can be referenced
        var style_id = "recolor-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    RecolorActiveItem.prototype.add_event_listeners = function () {
        var _this = this;
        // Listener for the static color change buttons
        $(document).on("click.ulabel", ".color-change-btn", function (event) {
            // Grab the color of what button was clicked
            var color = event.target.id.slice(13);
            // Get the currently selected class id
            var active_class_id = (0, utilities_1.get_active_class_id)(_this.ulabel);
            // Overwrite the color info with the new color
            _this.update_color(active_class_id, color);
            // Redraw the annotations with the new color
            // Since this is a listener for a button, no limit needs to be imposed on the redrawing
            _this.redraw(0);
        });
        // Listener for the color picker
        $(document).on("input.ulabel", "input.color-change-picker", function (event) {
            // Get the selected color from the event
            var color = event.currentTarget.value;
            // Get the currently selected class id
            var active_class_id = (0, utilities_1.get_active_class_id)(_this.ulabel);
            // Update the color for this class
            _this.update_color(active_class_id, color);
            // Grab the color picker container and update its background to the selected color
            var color_picker_container = document.getElementById("color-picker-container");
            color_picker_container.style.backgroundColor = color;
            // Redraw the annotations with the new color
            _this.redraw();
        });
        // Event listener for the gradient toggle
        $(document).on("input.ulabel", "#gradient-toggle", function (event) {
            // Redraw all annotations, not just those in the active subtask because all subtasks can be effected by the gradient
            _this.redraw(0);
            // Save whether or not the toggle is checked so when the page is reloaded it can remain in the same state
            _this.save_local_storage_gradient(event.target.checked);
        });
        // Event listener for the gradient max value slider
        $(document).on("input.ulabel", "#gradient-slider", function (event) {
            // Update the slider's label so the user knows exactly which value is selected
            $("div.gradient-slider-value-display").text(event.currentTarget.value + "%");
            // Redraw all annotations because other subtasks can be effected by the gradient slider
            _this.redraw(100, true);
        });
    };
    /**
     * Redraw all annotations in the current subtask. Limits how frequently annotations can be redrawn for performance reasons.
     *
     * @param wait_time Number of milliseconds that must pass since the previous redraw before drawing is allowed again
     * @param redraw_all_annotations False by default. If true, redraws all subtasks. Otherwise only redraws current subtask
     */
    RecolorActiveItem.prototype.redraw = function (wait_time, redraw_all_annotations) {
        if (wait_time === void 0) { wait_time = 100; }
        if (redraw_all_annotations === void 0) { redraw_all_annotations = false; }
        // If less than the wait time has passed since since the most recent redraw, then return without drawing
        if (Date.now() - this.most_recent_redraw_time < wait_time)
            return;
        if (redraw_all_annotations) {
            // Redraw all annotations
            this.ulabel.redraw_all_annotations();
        }
        else {
            // Otherwise only redraw the annotations in the subtask we updated
            var current_subtask_key = this.ulabel.state.current_subtask;
            this.ulabel.redraw_all_annotations(current_subtask_key);
        }
        // Update the most_recent_redraw_time
        this.most_recent_redraw_time = Date.now();
    };
    RecolorActiveItem.prototype.get_html = function () {
        return "\n        <div class=\"recolor-active\">\n            <p class=\"tb-header\">Recolor Annotations</p>\n            <div class=\"recolor-tbi-gradient\">\n                <div class=\"gradient-toggle-container\">\n                    <label for=\"gradient-toggle\" id=\"gradient-toggle-label\">Toggle Gradients:</label>\n                    <input type=\"checkbox\" id=\"gradient-toggle\" name=\"gradient-checkbox\" value=\"gradient\" ".concat(this.gradient_turned_on ? "checked" : "", ">\n                </div>\n                <div class=\"gradient-slider-container\">\n                    <label for=\"gradient-slider\" id=\"gradient-slider-label\">Gradient Max:</label>\n                    <input type=\"range\" id=\"gradient-slider\" value=\"100\">\n                    <div class=\"gradient-slider-value-display\">100%</div>\n                </div>\n            </div>\n            <div class=\"annotation-recolor-button-holder\">\n                <input type=\"button\" class=\"color-change-btn\" id=\"color-change-yellow\">\n                <input type=\"button\" class=\"color-change-btn\" id=\"color-change-red\">\n                <input type=\"button\" class=\"color-change-btn\" id=\"color-change-cyan\">\n                <div class=\"color-picker-border\">\n                    <div class=\"color-picker-container\" id=\"color-picker-container\">\n                        <input type=\"color\" class=\"color-change-picker\" id=\"color-change-pick\">\n                    </div>\n                </div>\n            </div>\n        </div>\n        ");
    };
    RecolorActiveItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    RecolorActiveItem.prototype.get_toolbox_item_type = function () {
        return "RecolorActive";
    };
    return RecolorActiveItem;
}(ToolboxItem));
exports.RecolorActiveItem = RecolorActiveItem;
var KeypointSliderItem = /** @class */ (function (_super) {
    __extends(KeypointSliderItem, _super);
    // TODO (joshua-dean): See if we can narrow this any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function KeypointSliderItem(ulabel, kwargs) {
        var _this = _super.call(this) || this;
        _this.filter_value = 0;
        _this.inner_HTML = "<p class=\"tb-header\">Keypoint Slider</p>";
        _this.ulabel = ulabel;
        // Use properties in kwargs if kwargs is present
        if (kwargs !== undefined) {
            _this.name = kwargs.name;
            _this.filter_function = kwargs.filter_function;
            _this.get_confidence = kwargs.confidence_function;
            _this.mark_deprecated = kwargs.mark_deprecated;
            _this.keybinds = kwargs.keybinds;
        }
        else {
            // Otherwise use defaults
            _this.name = "Keypoint Slider";
            _this.filter_function = annotation_operators_1.value_is_lower_than_filter;
            _this.get_confidence = annotation_operators_1.get_annotation_confidence;
            _this.mark_deprecated = annotation_operators_1.mark_deprecated;
            _this.keybinds = {
                increment: "2",
                decrement: "1",
            };
            kwargs = {};
        }
        // Create slider bar id
        _this.slider_bar_id = _this.name.replaceLowerConcat(" ", "-");
        // If the config has a default value override the filter_value
        var has_filter_override = Object.prototype.hasOwnProperty.call(_this.ulabel.config, _this.name.replaceLowerConcat(" ", "_", "_default_value"));
        if (has_filter_override) {
            // Set the filter value
            _this.filter_value = _this.ulabel.config[_this.name.replaceLowerConcat(" ", "_", "_default_value")];
        }
        // Check the config to see if we should update the annotations with the default filter on load
        if (_this.ulabel.config.filter_annotations_on_load) {
            _this.filter_annotations(_this.ulabel);
        }
        _this.add_styles();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    KeypointSliderItem.prototype.add_styles = function () {
        // Define the css
        var css = "\n        /* Component has no css?? */\n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "keypoint-slider-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    /**
     * Given the ulabel object and a filter value, go through each annotation and decide whether or
     * not to deprecate it.
     *
     * @param ulabel ULabel object
     * @param filter_value The number between 0-100 which annotation's confidence is compared against
     * @param redraw whether or not to redraw the annotations after filtering
     * @returns Annotations that were modified, organized by subtask key
     */
    KeypointSliderItem.prototype.filter_annotations = function (ulabel, filter_value, redraw) {
        if (filter_value === void 0) { filter_value = null; }
        if (redraw === void 0) { redraw = false; }
        if (filter_value === null) {
            // Use stored filter value if none is passed in
            filter_value = Math.round(this.filter_value * 100);
        }
        // Store which annotations need to be redrawn
        var annotations_ids_to_redraw_by_subtask = {};
        // Initialize the object with the subtask keys
        for (var subtask_key in ulabel.subtasks) {
            annotations_ids_to_redraw_by_subtask[subtask_key] = [];
        }
        // Get all point annotations
        var point_and_line_annotations = (0, annotation_operators_1.get_point_and_line_annotations)(ulabel);
        for (var _i = 0, _a = point_and_line_annotations[0]; _i < _a.length; _i++) {
            var annotation = _a[_i];
            // Get the annotation's confidence as decimal between 0-1
            var confidence = this.get_confidence(annotation);
            // filter_value will be a number between 0-100, so convert the confidence to a percentage as well
            confidence = Math.round(confidence * 100);
            // Compare the confidence value against the filter value
            var should_deprecate = this.filter_function(confidence, filter_value);
            // Check if an annotation should be deprecated or undeprecated, else do nothing
            if ((should_deprecate && !annotation.deprecated) ||
                (!should_deprecate && annotation.deprecated)) {
                // Mark this annotation as either deprecated or undeprecated by the confidence filter
                this.mark_deprecated(annotation, should_deprecate, "confidence_filter");
                annotations_ids_to_redraw_by_subtask[annotation.subtask_key].push(annotation.id);
            }
        }
        if (redraw) {
            // Redraw each subtask's annotations
            for (var subtask_key in annotations_ids_to_redraw_by_subtask) {
                ulabel.redraw_multiple_spatial_annotations(annotations_ids_to_redraw_by_subtask[subtask_key], subtask_key);
            }
            // Update class counter
            ulabel.toolbox.redraw_update_items(ulabel);
        }
    };
    KeypointSliderItem.prototype.get_html = function () {
        var _this = this;
        // Create a SliderHandler instance to handle slider interactions
        var slider_handler = new html_builder_1.SliderHandler({
            id: this.name.replaceLowerConcat(" ", "-"),
            class: "keypoint-slider",
            default_value: Math.round(this.filter_value * 100).toString(),
            label_units: "%",
            slider_event: function (slider_value) {
                // Filter the annotations, then redraw them
                _this.filter_annotations(_this.ulabel, slider_value, true);
            },
        });
        return "\n        <div class=\"keypoint-slider\">\n            <p class=\"tb-header\">".concat(this.name, "</p>\n            ") + slider_handler.getSliderHTML() + "\n        </div>\n        ";
    };
    KeypointSliderItem.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    KeypointSliderItem.prototype.get_toolbox_item_type = function () {
        return "KeypointSlider";
    };
    return KeypointSliderItem;
}(ToolboxItem));
exports.KeypointSliderItem = KeypointSliderItem;
var FilterPointDistanceFromRow = /** @class */ (function (_super) {
    __extends(FilterPointDistanceFromRow, _super);
    // TODO (joshua-dean): Resolve kwargs usage and narrow any
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
    function FilterPointDistanceFromRow(ulabel, kwargs) {
        if (kwargs === void 0) { kwargs = null; }
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        // Get this component's config from ulabel's config
        _this.config = _this.ulabel.config.distance_filter_toolbox_item;
        // For each key missing from the config, set the default value
        for (var key in configuration_1.DEFAULT_FILTER_DISTANCE_CONFIG) {
            if (!Object.prototype.hasOwnProperty.call(_this.config, key)) {
                _this.config[key] = configuration_1.DEFAULT_FILTER_DISTANCE_CONFIG[key];
            }
        }
        // Set the component's properties to be the same as the config's properties
        for (var property in _this.config) {
            _this[property] = _this.config[property];
        }
        // Force disable multi-class mode if the config doesn't allow it
        if (_this.disable_multi_class_mode)
            _this.multi_class_mode = false;
        // Get if the options should be collapsed from local storage
        _this.collapse_options = (0, utilities_1.get_local_storage_item)("filterDistanceCollapseOptions");
        // Create an overlay and determine whether or not it should be displayed
        _this.create_overlay();
        // Check if localStorage has a value for showing the overlay
        var show_overlay = (0, utilities_1.get_local_storage_item)("filterDistanceShowOverlay");
        // Guard against null values
        _this.show_overlay = show_overlay !== null ? show_overlay : _this.show_overlay;
        _this.overlay.update_display_overlay(_this.show_overlay);
        // Check if localStorage has a value for filtering during polyline move
        var filter_during_polyline_move = (0, utilities_1.get_local_storage_item)("filterDistanceFilterDuringPolylineMove");
        // Guard against null values
        _this.filter_during_polyline_move = filter_during_polyline_move !== null ? filter_during_polyline_move : _this.filter_during_polyline_move;
        _this.add_styles();
        _this.add_event_listeners();
        return _this;
    }
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    FilterPointDistanceFromRow.prototype.add_styles = function () {
        // Define the css
        var css = "\n            #toolbox div.filter-row-distance {\n                text-align: left;\n            }\n\n            #toolbox p.tb-header {\n                margin: 0.75rem 0 0.5rem;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options {\n                display: inline-block;\n                position: relative;\n                left: 1rem;\n                margin-bottom: 0.5rem;\n                font-size: 80%;\n                user-select: none;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options * {\n                text-align: left;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options.ulabel-collapsed {\n                border: none;\n                margin-bottom: 0;\n                padding: 0; /* Padding takes up too much space without the content */\n\n                /* Needed to prevent the element from moving when ulabel-collapsed is toggled \n                0.75em comes from the previous padding, 2px comes from the removed border */\n                padding-left: calc(0.75em + 2px)\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options legend {\n                border-radius: 0.1rem;\n                padding: 0.1rem 0.3rem;\n                cursor: pointer;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options.ulabel-collapsed legend {\n                padding: 0.1rem 0.28rem;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options.ulabel-collapsed :not(legend) {\n                display: none;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options legend:hover {\n                background-color: rgba(128, 128, 128, 0.3)\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options input[type=\"checkbox\"] {\n                margin: 0;\n            }\n\n            #toolbox div.filter-row-distance fieldset.filter-row-distance-options label {\n                position: relative;\n                top: -0.2rem;\n                font-size: smaller;\n            }";
        // Create an id so this specific style tag can be referenced
        var style_id = "filter-distance-from-row-toolbox-item-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    FilterPointDistanceFromRow.prototype.add_event_listeners = function () {
        var _this = this;
        // Whenever the options legend is clicked, toggle displaying the options
        $(document).on("click.ulabel", "fieldset.filter-row-distance-options > legend", function () { return _this.toggleCollapsedOptions(); });
        // Whenever the multi-class filtering checkbox is clicked, switch the displayed filter mode
        $(document).on("click.ulabel", "#filter-slider-distance-multi-checkbox", function (event) {
            // Update the multi-class state
            _this.multi_class_mode = event.currentTarget.checked;
            // Toggle whether the single-class slider, or the multi-class sliders are visible
            _this.switchFilterMode();
            _this.overlay.update_mode(_this.multi_class_mode);
            // Re-filter the points in the new mode, recalculating all distances if changing to multi-class
            var recalculate_distances = _this.multi_class_mode;
            (0, annotation_operators_1.filter_points_distance_from_line)(_this.ulabel, recalculate_distances);
        });
        $(document).on("change.ulabel", "#filter-slider-distance-toggle-overlay-checkbox", function (event) {
            // Save the new value of `show_overlay`
            _this.show_overlay = event.currentTarget.checked;
            // Update whether or not the overlay is allowed to be drawn
            _this.overlay.update_display_overlay(_this.show_overlay);
            // Try to draw the overlay
            _this.overlay.draw_overlay();
            // Save whether or not the overlay is allowed to be drawn to local storage
            (0, utilities_1.set_local_storage_item)("filterDistanceShowOverlay", _this.show_overlay);
        });
        $(document).on("change.ulabel", "#filter-slider-distance-filter-during-polyline-move-checkbox", function (event) {
            // Save new value of `filter_during_polyline_move`
            _this.filter_during_polyline_move = event.currentTarget.checked;
            // Save to local storage
            (0, utilities_1.set_local_storage_item)("filterDistanceFilterDuringPolylineMove", _this.filter_during_polyline_move);
        });
        $(document).on("keypress.ulabel", function (event) {
            if (event.key !== _this.toggle_overlay_keybind)
                return;
            // Grab the show overlay checkbox and click it
            var show_overlay_checkbox = document.querySelector("#filter-slider-distance-toggle-overlay-checkbox");
            show_overlay_checkbox.click();
        });
    };
    /**
     * Toggle which filter mode is being displayed and which one is being hidden.
     */
    FilterPointDistanceFromRow.prototype.switchFilterMode = function () {
        $("#filter-single-class-mode").toggleClass("ulabel-hidden");
        $("#filter-multi-class-mode").toggleClass("ulabel-hidden");
    };
    /**
     * Toggles whether or not the options should be displayed.
     */
    FilterPointDistanceFromRow.prototype.toggleCollapsedOptions = function () {
        // Toggle the class which collapses the options
        $("fieldset.filter-row-distance-options").toggleClass("ulabel-collapsed");
        // Toggle the state
        this.collapse_options = !this.collapse_options;
        // Save the state to the user's browser so it can be re-loaded in the same state
        (0, utilities_1.set_local_storage_item)("filterDistanceCollapseOptions", this.collapse_options);
    };
    FilterPointDistanceFromRow.prototype.create_overlay = function () {
        // Get only the set of all line annotations
        var line_annotations = (0, annotation_operators_1.get_point_and_line_annotations)(this.ulabel)[1];
        // Initialize an object to hold the distances points are allowed to be from each class as well as any line
        var filter_values = { closest_row: undefined };
        // Grab all filter-distance-sliders on the page
        var sliders = document.querySelectorAll(".filter-row-distance-slider");
        // Loop through each slider and populate filter_values
        for (var idx = 0; idx < sliders.length; idx++) {
            // Use a regex to get the string after the final - character in the slider id (Which is the class id or the string "closest_row")
            var slider_class_name = /[^-]*$/.exec(sliders[idx].id)[0];
            // Use the class id as a key to store the slider's value
            filter_values[slider_class_name] = {
                distance: sliders[idx].valueAsNumber,
            };
        }
        // Create and assign an overlay class instance to ulabel to be able to access it
        this.overlay = new overlays_1.FilterDistanceOverlay(this.ulabel.config["image_width"] * this.ulabel.config["px_per_px"], this.ulabel.config["image_height"] * this.ulabel.config["px_per_px"], line_annotations, this.ulabel.config["px_per_px"]);
        // Apply the generated distances to the overlay
        this.overlay.update_distances(filter_values);
    };
    FilterPointDistanceFromRow.prototype.get_overlay = function () {
        return this.overlay;
    };
    /**
     * Gets all classes that polylines can be and creates a distance filter for each class.
     *
     * @returns {string} HTML for the multi-class filtering mode
     */
    FilterPointDistanceFromRow.prototype.createMultiFilterHTML = function () {
        var _this = this;
        // Get all potential classes
        var class_defs = (0, annotation_operators_1.findAllPolylineClassDefinitions)(this.ulabel);
        var multi_class_html = "";
        // Loop through each class and create their html
        for (var idx = 0; idx < class_defs.length; idx++) {
            // Grab current class for convenience
            var current_id = class_defs[idx].id;
            var current_name = class_defs[idx].name;
            var default_value = void 0;
            if (this.default_values[current_id] !== undefined) {
                default_value = this.default_values[current_id].distance.toString();
            }
            else {
                default_value = this.default_values.closest_row.distance.toString();
            }
            var multi_class_slider_instance = new html_builder_1.SliderHandler({
                id: "filter-row-distance-".concat(current_id),
                class: "filter-row-distance-slider filter-row-distance-class-slider",
                min: this.filter_min.toString(),
                max: this.filter_max.toString(),
                default_value: default_value,
                step: this.step_value.toString(),
                label_units: "px",
                main_label: current_name,
                slider_event: function () { return (0, annotation_operators_1.filter_points_distance_from_line)(_this.ulabel, false); },
            });
            // Add current classes html to multi_class_html
            multi_class_html += multi_class_slider_instance.getSliderHTML();
        }
        return multi_class_html;
    };
    /**
     * Returns the component's html.
     *
     * @returns {String} Component's html
     */
    FilterPointDistanceFromRow.prototype.get_html = function () {
        var _this = this;
        // Get the multi-class filter html
        var multi_class_html = this.createMultiFilterHTML();
        /* Create a SliderHandler instance to take care of creating the single class slider's html
           and its event handlers */
        var single_class_slider_handler = new html_builder_1.SliderHandler({
            class: "filter-row-distance-slider",
            default_value: this.default_values.closest_row.distance.toString(),
            id: "filter-row-distance-closest_row", // `closest_row` will be extracted using regex
            label_units: "px",
            slider_event: function () { return (0, annotation_operators_1.filter_points_distance_from_line)(_this.ulabel, false); },
            min: this.filter_min.toString(),
            max: this.filter_max.toString(),
            step: this.step_value.toString(),
        });
        var multi_class_mode_checkbox = "";
        // If multi-class mode is allowed, create the checkbox
        if (!this.disable_multi_class_mode) {
            multi_class_mode_checkbox = "\n            <div class=\"filter-row-distance-option\">\n                <input\n                    type=\"checkbox\"\n                    id=\"filter-slider-distance-multi-checkbox\"\n                    class=\"filter-row-distance-options-checkbox\"\n                    ".concat(this.multi_class_mode ? "checked" : "", "\n                />\n                <label\n                    for=\"filter-slider-distance-multi-checkbox\"\n                    id=\"filter-slider-distance-multi-checkbox-label\"\n                    class=\"filter-row-distance-label\">\n                    Multi-Class Filtering\n                </label>\n            </div>");
        }
        return "\n        <div class=\"filter-row-distance\">\n            <p class=\"tb-header\">".concat(this.name, "</p>\n            <fieldset class=\"\n                    filter-row-distance-options \n                    ").concat(this.show_options ? "" : "ulabel-hidden", " \n                    ").concat(this.collapse_options ? "ulabel-collapsed" : "", " \n                \">\n                <legend>\n                    Options \u02C5\n                </legend>\n                    ") + multi_class_mode_checkbox + "\n                <div class=\"filter-row-distance-option\">\n                    <input\n                        type=\"checkbox\"\n                        id=\"filter-slider-distance-toggle-overlay-checkbox\"\n                        class=\"filter-row-distance-options-checkbox\"\n                        ".concat(this.show_overlay ? "checked" : "", "\n                    />\n                    <label\n                        for=\"filter-slider-distance-toggle-overlay-checkbox\"\n                        id=\"filter-slider-distance-toggle-overlay-checkbox-label\"\n                        class=\"filter-row-distance-label\">\n                        Show Filter Range\n                    </label>\n                </div>\n                <div class=\"filter-row-distance-option\">\n                    <input\n                        type=\"checkbox\"\n                        id=\"filter-slider-distance-filter-during-polyline-move-checkbox\"\n                        class=\"filter-row-distance-options-checkbox\"\n                        ").concat(this.filter_during_polyline_move ? "checked" : "", "\n                    />\n                    <label\n                        for=\"filter-slider-distance-filter-during-polyline-move-checkbox\"\n                        id=\"filter-slider-distance-filter-during-polyline-move-checkbox-label\"\n                        class=\"filter-row-distance-label\"\n                        title=\"When unchecked, will not update the filter/overlay until polyline moves/edits are complete\">\n                        Filter During Move\n                    </label>\n                </div>\n            </fieldset>\n            <div id=\"filter-single-class-mode\" class=\"").concat(!this.multi_class_mode ? "" : "ulabel-hidden", "\">\n                ").concat(single_class_slider_handler.getSliderHTML(), "\n            </div>\n            <div id=\"filter-multi-class-mode\" class=\"").concat(this.multi_class_mode ? "" : "ulabel-hidden", "\">\n            ") + multi_class_html + "\n            </div>\n        </div>\n        ";
    };
    FilterPointDistanceFromRow.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    FilterPointDistanceFromRow.prototype.get_toolbox_item_type = function () {
        return "FilterDistance";
    };
    return FilterPointDistanceFromRow;
}(ToolboxItem));
exports.FilterPointDistanceFromRow = FilterPointDistanceFromRow;


/***/ }),

/***/ 3066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * ULabel initializer utilities and logic.
 *
 * This also includes "staggered" initializers to test loading.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ulabel_init = ulabel_init;
var canvas_utils_1 = __webpack_require__(5750);
var cookies_1 = __webpack_require__(7941);
var html_builder_1 = __webpack_require__(4493);
var listeners_1 = __webpack_require__(6847);
var loader_1 = __webpack_require__(3607);
/**
 * Make canvases for each subtask
 *
 * @param ulabel ULabel instance to create canvases for
 * @param loaded_img Single loaded image for sizing
 */
function make_image_canvases(ulabel, loaded_img) {
    // Store image dimensions
    ulabel.config["image_height"] = loaded_img.naturalHeight;
    ulabel.config["image_width"] = loaded_img.naturalWidth;
    // Add canvases for each subtask and get their rendering contexts
    for (var st in ulabel.subtasks) {
        $("#" + ulabel.config["imwrap_id"]).append("\n        <div id=\"canvasses__".concat(st, "\" class=\"canvasses\">\n            <canvas \n                id=\"").concat(ulabel.subtasks[st]["canvas_bid"], "\" \n                class=\"").concat(ulabel.config["canvas_class"], " ").concat(ulabel.config["imgsz_class"], " canvas_cls\" \n                height=").concat(ulabel.config["image_height"] * ulabel.config["px_per_px"], " \n                width=").concat(ulabel.config["image_width"] * ulabel.config["px_per_px"], "></canvas>\n            <canvas \n                id=\"").concat(ulabel.subtasks[st]["canvas_fid"], "\" \n                class=\"").concat(ulabel.config["canvas_class"], " ").concat(ulabel.config["imgsz_class"], " canvas_cls\" \n                height=").concat(ulabel.config["image_height"] * ulabel.config["px_per_px"], " \n                width=").concat(ulabel.config["image_width"] * ulabel.config["px_per_px"], " \n                oncontextmenu=\"return false\"></canvas>\n            <div id=\"dialogs__").concat(st, "\" class=\"dialogs_container\"></div>\n        </div>\n        "));
        $("#" + ulabel.config["container_id"] + " div#fad_st__".concat(st)).append("\n            <div id=\"front_dialogs__".concat(st, "\" class=\"front_dialogs\"></div>\n        "));
        // Get canvas contexts
        var canvas_bid = document.getElementById(ulabel.subtasks[st]["canvas_bid"]);
        var canvas_fid = document.getElementById(ulabel.subtasks[st]["canvas_fid"]);
        ulabel.subtasks[st]["state"]["back_context"] = canvas_bid.getContext("2d");
        ulabel.subtasks[st]["state"]["front_context"] = canvas_fid.getContext("2d");
    }
}
/**
 * ULabel initializer logic.
 * Async to ensure correct processing order; many steps are dependent on knowing the image/canvas size.
 *
 * @param ulabel ULabel instance to initialize.
 * @param user_callback User-provided callback to run after initialization.`
 */
function ulabel_init(ulabel, user_callback) {
    return __awaiter(this, void 0, void 0, function () {
        var first_bg_img, image_height, image_width, _i, _a, subtask, _b, _c, anno;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    // Add stylesheet
                    (0, html_builder_1.add_style_to_document)(ulabel);
                    // Set current subtask to first subtask
                    ulabel.state["current_subtask"] = Object.keys(ulabel.subtasks)[0];
                    // Place image element
                    (0, html_builder_1.prep_window_html)(ulabel, ulabel.config.toolbox_order);
                    // Detect night cookie
                    if (cookies_1.NightModeCookie.exists_in_document()) {
                        $("#" + ulabel.config["container_id"]).addClass("ulabel-night");
                    }
                    first_bg_img = document.getElementById("".concat(ulabel.config["image_id_pfx"], "__0"));
                    return [4 /*yield*/, first_bg_img.decode()];
                case 1:
                    _d.sent();
                    make_image_canvases(ulabel, first_bg_img);
                    // Once the image dimensions are known, we can resize annotations if needed
                    if (!ulabel.config.allow_annotations_outside_image) {
                        image_height = ulabel.config["image_height"];
                        image_width = ulabel.config["image_width"];
                        for (_i = 0, _a = Object.values(ulabel.subtasks); _i < _a.length; _i++) {
                            subtask = _a[_i];
                            for (_b = 0, _c = Object.values(subtask.annotations.access); _b < _c.length; _b++) {
                                anno = _c[_b];
                                anno.clamp_annotation_to_image_bounds(image_width, image_height);
                            }
                        }
                    }
                    // This step is hoisted up to show the container before the rest of the initialization
                    $("div#".concat(ulabel.config["container_id"])).css("display", "block");
                    // Create the annotation canvases for the resume_from annotations
                    (0, canvas_utils_1.initialize_annotation_canvases)(ulabel);
                    // Add the ID dialogs' HTML to the document
                    (0, html_builder_1.build_id_dialogs)(ulabel);
                    // Add the HTML for the edit suggestion to the window
                    (0, html_builder_1.build_edit_suggestion)(ulabel);
                    // Add dialog to show annotation confidence
                    (0, html_builder_1.build_confidence_dialog)(ulabel);
                    // Create listers to manipulate and export this object
                    (0, listeners_1.create_ulabel_listeners)(ulabel);
                    ulabel.handle_toolbox_overflow();
                    // Set the canvas elements in the correct stacking order given current subtask
                    ulabel.set_subtask(ulabel.state["current_subtask"]);
                    ulabel.create_overlays();
                    // Indicate that the object is now init!
                    ulabel.is_init = true;
                    ulabel.show_initial_crop();
                    ulabel.update_frame();
                    // Draw demo annotation
                    ulabel.redraw_demo();
                    // Draw resumed from annotations
                    ulabel.redraw_all_annotations();
                    // Update class counter
                    ulabel.toolbox.redraw_update_items(ulabel);
                    loader_1.ULabelLoader.remove_loader_div();
                    // Call the user-provided callback
                    user_callback();
                    ulabel.after_init();
                    console.log("Time taken to construct and initialize: ".concat(Date.now() - ulabel.begining_time));
                    return [2 /*return*/];
            }
        });
    });
}


/***/ }),

/***/ 3093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(4459);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 3126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6743);
var $TypeError = __webpack_require__(9675);

var $call = __webpack_require__(76);
var $actualApply = __webpack_require__(3144);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 3144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6743);

var $apply = __webpack_require__(1002);
var $call = __webpack_require__(76);
var $reflectApply = __webpack_require__(7119);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 3154:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var line_segment_1 = __importDefault(__webpack_require__(7042));
var meta_1 = __webpack_require__(8421);
var geojson_rbush_1 = __importDefault(__webpack_require__(4945));
/**
 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
 *
 * @name lineIntersect
 * @param {GeoJSON} line1 any LineString or Polygon
 * @param {GeoJSON} line2 any LineString or Polygon
 * @returns {FeatureCollection<Point>} point(s) that intersect both
 * @example
 * var line1 = turf.lineString([[126, -11], [129, -21]]);
 * var line2 = turf.lineString([[123, -18], [131, -14]]);
 * var intersects = turf.lineIntersect(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, intersects]
 */
function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    // First, normalize geometries to features
    // Then, handle simple 2-vertex segments
    if (line1.type === "LineString") {
        line1 = helpers_1.feature(line1);
    }
    if (line2.type === "LineString") {
        line2 = helpers_1.feature(line2);
    }
    if (line1.type === "Feature" &&
        line2.type === "Feature" &&
        line1.geometry !== null &&
        line2.geometry !== null &&
        line1.geometry.type === "LineString" &&
        line2.geometry.type === "LineString" &&
        line1.geometry.coordinates.length === 2 &&
        line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) {
            results.push(intersect);
        }
        return helpers_1.featureCollection(results);
    }
    // Handles complex GeoJSON Geometries
    var tree = geojson_rbush_1.default();
    tree.load(line_segment_1.default(line2));
    meta_1.featureEach(line_segment_1.default(line1), function (segment) {
        meta_1.featureEach(tree.search(segment), function (match) {
            var intersect = intersects(segment, match);
            if (intersect) {
                // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                var key = invariant_1.getCoords(intersect).join(",");
                if (!unique[key]) {
                    unique[key] = true;
                    results.push(intersect);
                }
            }
        });
    });
    return helpers_1.featureCollection(results);
}
/**
 * Find a point that intersects LineStrings with two coordinates each
 *
 * @private
 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
 * @returns {Feature<Point>} intersecting GeoJSON Point
 */
function intersects(line1, line2) {
    var coords1 = invariant_1.getCoords(line1);
    var coords2 = invariant_1.getCoords(line2);
    if (coords1.length !== 2) {
        throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
        throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x1 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
            return null;
        }
        return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + uA * (x2 - x1);
        var y = y1 + uA * (y2 - y1);
        return helpers_1.point([x, y]);
    }
    return null;
}
exports["default"] = lineIntersect;


/***/ }),

/***/ 3183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Taken from http://geomalgorithms.com/a02-_lines.html
var distance_1 = __importDefault(__webpack_require__(9391));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
var rhumb_distance_1 = __importDefault(__webpack_require__(9778));
/**
 * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the
 * minimum distance between the point and any segment of the `LineString`.
 *
 * @name pointToLineDistance
 * @param {Feature<Point>|Array<number>} pt Feature or Geometry
 * @param {Feature<LineString>} line GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units="kilometers"] can be anything supported by turf/convertLength
 * (ex: degrees, radians, miles, or kilometers)
 * @param {string} [options.method="geodesic"] wether to calculate the distance based on geodesic (spheroid) or
 * planar (flat) method. Valid options are 'geodesic' or 'planar'.
 * @returns {number} distance between point and line
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[1, 1],[-1, 1]]);
 *
 * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});
 * //=69.11854715938406
 */
function pointToLineDistance(pt, line, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    if (!options.method) {
        options.method = "geodesic";
    }
    if (!options.units) {
        options.units = "kilometers";
    }
    // validation
    if (!pt) {
        throw new Error("pt is required");
    }
    if (Array.isArray(pt)) {
        pt = helpers_1.point(pt);
    }
    else if (pt.type === "Point") {
        pt = helpers_1.feature(pt);
    }
    else {
        invariant_1.featureOf(pt, "Point", "point");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if (Array.isArray(line)) {
        line = helpers_1.lineString(line);
    }
    else if (line.type === "LineString") {
        line = helpers_1.feature(line);
    }
    else {
        invariant_1.featureOf(line, "LineString", "line");
    }
    var distance = Infinity;
    var p = pt.geometry.coordinates;
    meta_1.segmentEach(line, function (segment) {
        var a = segment.geometry.coordinates[0];
        var b = segment.geometry.coordinates[1];
        var d = distanceToSegment(p, a, b, options);
        if (d < distance) {
            distance = d;
        }
    });
    return helpers_1.convertLength(distance, "degrees", options.units);
}
/**
 * Returns the distance between a point P on a segment AB.
 *
 * @private
 * @param {Array<number>} p external point
 * @param {Array<number>} a first segment point
 * @param {Array<number>} b second segment point
 * @param {Object} [options={}] Optional parameters
 * @returns {number} distance
 */
function distanceToSegment(p, a, b, options) {
    var v = [b[0] - a[0], b[1] - a[1]];
    var w = [p[0] - a[0], p[1] - a[1]];
    var c1 = dot(w, v);
    if (c1 <= 0) {
        return calcDistance(p, a, { method: options.method, units: "degrees" });
    }
    var c2 = dot(v, v);
    if (c2 <= c1) {
        return calcDistance(p, b, { method: options.method, units: "degrees" });
    }
    var b2 = c1 / c2;
    var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
    return calcDistance(p, Pb, { method: options.method, units: "degrees" });
}
function dot(u, v) {
    return u[0] * v[0] + u[1] * v[1];
}
function calcDistance(a, b, options) {
    return options.method === "planar"
        ? rhumb_distance_1.default(a, b, options)
        : distance_1.default(a, b, options);
}
exports["default"] = pointToLineDistance;


/***/ }),

/***/ 3206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(41);
var hasDescriptors = __webpack_require__(592)();
var functionsHaveConfigurableNames = (__webpack_require__(4462).functionsHaveConfigurableNames)();

var $TypeError = TypeError;

module.exports = function setFunctionName(fn, name) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	var loose = arguments.length > 2 && !!arguments[2];
	if (!loose || functionsHaveConfigurableNames) {
		if (hasDescriptors) {
			define(fn, 'name', name, true, true);
		} else {
			define(fn, 'name', name);
		}
	}
	return fn;
};


/***/ }),

/***/ 3227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  voronoi: () => (/* reexport */ voronoi)
});

;// ./node_modules/d3-voronoi/src/constant.js
/* harmony default export */ function constant(x) {
  return function() {
    return x;
  };
}

;// ./node_modules/d3-voronoi/src/point.js
function point_x(d) {
  return d[0];
}

function point_y(d) {
  return d[1];
}

;// ./node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

/* harmony default export */ const src_RedBlackTree = (RedBlackTree);

;// ./node_modules/d3-voronoi/src/Edge.js


function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

;// ./node_modules/d3-voronoi/src/Cell.js



function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

;// ./node_modules/d3-voronoi/src/Circle.js



var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

;// ./node_modules/d3-voronoi/src/Beach.js






var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

;// ./node_modules/d3-voronoi/src/Diagram.js






var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new src_RedBlackTree;
  circles = new src_RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
}

;// ./node_modules/d3-voronoi/src/voronoi.js




/* harmony default export */ function voronoi() {
  var x = point_x,
      y = point_y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / epsilon) * epsilon, Math.round(y(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

;// ./node_modules/d3-voronoi/index.js



/***/ }),

/***/ 3284:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
var point_to_line_distance_1 = __importDefault(__webpack_require__(3183));
var object_assign_1 = __importDefault(__webpack_require__(5228));
/**
 * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,
 * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.
 *
 * @name nearestPointToLine
 * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection
 * @param {Feature|Geometry<LineString>} line Line Feature
 * @param {Object} [options] Optional parameters
 * @param {string} [options.units='kilometers'] unit of the output distance property
 * (eg: degrees, radians, miles, or kilometers)
 * @param {Object} [options.properties={}] Translate Properties to Point
 * @returns {Feature<Point>} the closest point
 * @example
 * var pt1 = turf.point([0, 0]);
 * var pt2 = turf.point([0.5, 0.5]);
 * var points = turf.featureCollection([pt1, pt2]);
 * var line = turf.lineString([[1,1], [-1,1]]);
 *
 * var nearest = turf.nearestPointToLine(points, line);
 *
 * //addToMap
 * var addToMap = [nearest, line];
 */
function nearestPointToLine(points, line, options) {
    if (options === void 0) { options = {}; }
    var units = options.units;
    var properties = options.properties || {};
    // validation
    var pts = normalize(points);
    if (!pts.features.length) {
        throw new Error("points must contain features");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if (invariant_1.getType(line) !== "LineString") {
        throw new Error("line must be a LineString");
    }
    var dist = Infinity;
    var pt = null;
    meta_1.featureEach(pts, function (point) {
        var d = point_to_line_distance_1.default(point, line, { units: units });
        if (d < dist) {
            dist = d;
            pt = point;
        }
    });
    /**
     * Translate Properties to final Point, priorities:
     * 1. options.properties
     * 2. inherent Point properties
     * 3. dist custom properties created by NearestPointToLine
     */
    if (pt) {
        pt.properties = object_assign_1.default({ dist: dist }, pt.properties, properties);
    }
    // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }
    return pt;
}
/**
 * Convert Collection to FeatureCollection
 *
 * @private
 * @param {FeatureCollection|GeometryCollection} points Points
 * @returns {FeatureCollection<Point>} points
 */
function normalize(points) {
    var features = [];
    var type = points.geometry ? points.geometry.type : points.type;
    switch (type) {
        case "GeometryCollection":
            meta_1.geomEach(points, function (geom) {
                if (geom.type === "Point") {
                    features.push({ type: "Feature", properties: {}, geometry: geom });
                }
            });
            return { type: "FeatureCollection", features: features };
        case "FeatureCollection":
            points.features = points.features.filter(function (feature) {
                return feature.geometry.type === "Point";
            });
            return points;
        default:
            throw new Error("points must be a Point Collection");
    }
}
exports["default"] = nearestPointToLine;


/***/ }),

/***/ 3351:
/***/ (function(module) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ 3414:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var earcut = __webpack_require__(6570);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var earcut__default = /*#__PURE__*/_interopDefaultLegacy(earcut);

/**
 * Tesselates a {@link Feature<Polygon>} into a {@link FeatureCollection<Polygon>} of triangles
 * using [earcut](https://github.com/mapbox/earcut).
 *
 * @name tesselate
 * @param {Feature<Polygon>} poly the polygon to tesselate
 * @returns {FeatureCollection<Polygon>} a geometrycollection feature
 * @example
 * var poly = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
 * var triangles = turf.tesselate(poly);
 *
 * //addToMap
 * var addToMap = [poly, triangles]
 */
function tesselate(poly) {
  if (
    !poly.geometry ||
    (poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon")
  ) {
    throw new Error("input must be a Polygon or MultiPolygon");
  }

  var fc = { type: "FeatureCollection", features: [] };

  if (poly.geometry.type === "Polygon") {
    fc.features = processPolygon(poly.geometry.coordinates);
  } else {
    poly.geometry.coordinates.forEach(function (coordinates) {
      fc.features = fc.features.concat(processPolygon(coordinates));
    });
  }

  return fc;
}

function processPolygon(coordinates) {
  var data = flattenCoords(coordinates);
  var dim = 2;
  var result = earcut__default['default'](data.vertices, data.holes, dim);

  var features = [];
  var vertices = [];

  result.forEach(function (vert, i) {
    var index = result[i];
    vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
  });

  for (var i = 0; i < vertices.length; i += 3) {
    var coords = vertices.slice(i, i + 3);
    coords.push(vertices[i]);
    features.push(helpers.polygon([coords]));
  }

  return features;
}

function flattenCoords(data) {
  var dim = data[0][0].length,
    result = { vertices: [], holes: [], dimensions: dim },
    holeIndex = 0;

  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }

  return result;
}

module.exports = tesselate;
module.exports["default"] = tesselate;


/***/ }),

/***/ 3467:
/***/ (function(__unused_webpack_module, exports) {

!function(t,e){ true?e(exports):0}(this,function(t){"use strict";const e=134217729,n=33306690738754706e-32;function r(t,e,n,r,o){let f,i,u,c,s=e[0],a=r[0],d=0,l=0;a>s==a>-s?(f=s,s=e[++d]):(f=a,a=r[++l]);let p=0;if(d<t&&l<n)for(a>s==a>-s?(u=f-((i=s+f)-s),s=e[++d]):(u=f-((i=a+f)-a),a=r[++l]),f=i,0!==u&&(o[p++]=u);d<t&&l<n;)a>s==a>-s?(u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d]):(u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l]),f=i,0!==u&&(o[p++]=u);for(;d<t;)u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d],f=i,0!==u&&(o[p++]=u);for(;l<n;)u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l],f=i,0!==u&&(o[p++]=u);return 0===f&&0!==p||(o[p++]=f),p}function o(t){return new Float64Array(t)}const f=33306690738754716e-32,i=22204460492503146e-32,u=11093356479670487e-47,c=o(4),s=o(8),a=o(12),d=o(16),l=o(4);t.orient2d=function(t,o,p,b,y,h){const M=(o-h)*(p-y),x=(t-y)*(b-h),j=M-x;if(0===M||0===x||M>0!=x>0)return j;const m=Math.abs(M+x);return Math.abs(j)>=f*m?j:-function(t,o,f,p,b,y,h){let M,x,j,m,_,v,w,A,F,O,P,g,k,q,z,B,C,D;const E=t-b,G=f-b,H=o-y,I=p-y;_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=I-(F=(v=e*I)-(v-I)))-((q=E*I)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=G-(F=(v=e*G)-(v-G)))-((B=H*G)-w*F-A*F-w*O))),c[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),c[1]=k-(P+_)+(_-B),_=(D=g+P)-g,c[2]=g-(D-_)+(P-_),c[3]=D;let J=function(t,e){let n=e[0];for(let r=1;r<t;r++)n+=e[r];return n}(4,c),K=i*h;if(J>=K||-J>=K)return J;if(M=t-(E+(_=t-E))+(_-b),j=f-(G+(_=f-G))+(_-b),x=o-(H+(_=o-H))+(_-y),m=p-(I+(_=p-I))+(_-y),0===M&&0===x&&0===j&&0===m)return J;if(K=u*h+n*Math.abs(J),(J+=E*m+I*M-(H*j+G*x))>=K||-J>=K)return J;_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=I-(F=(v=e*I)-(v-I)))-((q=M*I)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=G-(F=(v=e*G)-(v-G)))-((B=x*G)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const L=r(4,c,4,l,s);_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=m-(F=(v=e*m)-(v-m)))-((q=E*m)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=j-(F=(v=e*j)-(v-j)))-((B=H*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const N=r(L,s,4,l,a);_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=m-(F=(v=e*m)-(v-m)))-((q=M*m)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=j-(F=(v=e*j)-(v-j)))-((B=x*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const Q=r(N,a,4,l,d);return d[Q-1]}(t,o,p,b,y,h,m)},t.orient2dfast=function(t,e,n,r,o,f){return(e-f)*(n-o)-(t-o)*(r-f)},Object.defineProperty(t,"__esModule",{value:!0})});


/***/ }),

/***/ 3509:
/***/ ((module) => {

/**
 * DBSCAN - Density based clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * DBSCAN class construcotr
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {DBSCAN}
 */
function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
  /** @type {Array} */
  this.dataset = [];
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 2;
  /** @type {function} */
  this.distance = this._euclideanDistance;
  /** @type {Array} */
  this.clusters = [];
  /** @type {Array} */
  this.noise = [];

  // temporary variables used during computation

  /** @type {Array} */
  this._visited = [];
  /** @type {Array} */
  this._assigned = [];
  /** @type {number} */
  this._datasetLength = 0;

  this._init(dataset, epsilon, minPts, distanceFunction);
};

/******************************************************************************/
// public functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {undefined}
 * @access public
 */
DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0; pointId < this._datasetLength; pointId++) {
    // if point is not visited, check if it forms a cluster
    if (this._visited[pointId] !== 1) {
      this._visited[pointId] = 1;

      // if closest neighborhood is too small to form a cluster, mark as noise
      var neighbors = this._regionQuery(pointId);

      if (neighbors.length < this.minPts) {
        this.noise.push(pointId);
      } else {
        // create new cluster and add point
        var clusterId = this.clusters.length;
        this.clusters.push([]);
        this._addToCluster(pointId, clusterId);

        this._expandCluster(clusterId, neighbors);
      }
    }
  }

  return this.clusters;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this.noise = [];

    this._datasetLength = dataset.length;
    this._visited = new Array(this._datasetLength);
    this._assigned = new Array(this._datasetLength);
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Expand cluster to closest points of given neighborhood
 *
 * @param {number} clusterId
 * @param {Array} neighbors
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {

  /**
   * It's very important to calculate length of neighbors array each time,
   * as the number of elements changes over time
   */
  for (var i = 0; i < neighbors.length; i++) {
    var pointId2 = neighbors[i];

    if (this._visited[pointId2] !== 1) {
      this._visited[pointId2] = 1;
      var neighbors2 = this._regionQuery(pointId2);

      if (neighbors2.length >= this.minPts) {
        neighbors = this._mergeArrays(neighbors, neighbors2);
      }
    }

    // add to cluster
    if (this._assigned[pointId2] !== 1) {
      this._addToCluster(pointId2, clusterId);
    }
  }
};

/**
 * Add new point to cluster
 *
 * @param {number} pointId
 * @param {number} clusterId
 */
DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
  this.clusters[clusterId].push(pointId);
  this._assigned[pointId] = 1;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId,
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._regionQuery = function(pointId) {
  var neighbors = [];

  for (var id = 0; id < this._datasetLength; id++) {
    var dist = this.distance(this.dataset[pointId], this.dataset[id]);
    if (dist < this.epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * @param {Array} a
 * @param {Array} b
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._mergeArrays = function(a, b) {
  var len = b.length;

  for (var i = 0; i < len; i++) {
    var P = b[i];
    if (a.indexOf(P) < 0) {
      a.push(P);
    }
  }

  return a;
};

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
DBSCAN.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};

if ( true && module.exports) {
  module.exports = DBSCAN;
}


/***/ }),

/***/ 3574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var lineclip_1 = __webpack_require__(4828);
/**
 * Takes a {@link Feature} and a bbox and clips the feature to the bbox using
 * [lineclip](https://github.com/mapbox/lineclip).
 * May result in degenerate edges when clipping Polygons.
 *
 * @name bboxClip
 * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature feature to clip to the bbox
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @returns {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} clipped Feature
 * @example
 * var bbox = [0, 0, 10, 10];
 * var poly = turf.polygon([[[2, 2], [8, 4], [12, 8], [3, 7], [2, 2]]]);
 *
 * var clipped = turf.bboxClip(poly, bbox);
 *
 * //addToMap
 * var addToMap = [bbox, poly, clipped]
 */
function bboxClip(feature, bbox) {
    var geom = invariant_1.getGeom(feature);
    var type = geom.type;
    var properties = feature.type === "Feature" ? feature.properties : {};
    var coords = geom.coordinates;
    switch (type) {
        case "LineString":
        case "MultiLineString": {
            var lines_1 = [];
            if (type === "LineString") {
                coords = [coords];
            }
            coords.forEach(function (line) {
                lineclip_1.lineclip(line, bbox, lines_1);
            });
            if (lines_1.length === 1) {
                return helpers_1.lineString(lines_1[0], properties);
            }
            return helpers_1.multiLineString(lines_1, properties);
        }
        case "Polygon":
            return helpers_1.polygon(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
            return helpers_1.multiPolygon(coords.map(function (poly) {
                return clipPolygon(poly, bbox);
            }), properties);
        default:
            throw new Error("geometry " + type + " not supported");
    }
}
exports["default"] = bboxClip;
function clipPolygon(rings, bbox) {
    var outRings = [];
    for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
        var ring = rings_1[_i];
        var clipped = lineclip_1.polygonclip(ring, bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] ||
                clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            if (clipped.length >= 4) {
                outRings.push(clipped);
            }
        }
    }
    return outRings;
}


/***/ }),

/***/ 3607:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ULabelLoader = void 0;
/**
 * Animated loader for initial loading screen.
 */
var ULabelLoader = /** @class */ (function () {
    function ULabelLoader() {
    }
    ULabelLoader.add_loader_div = function (container) {
        var loader_overlay = document.createElement("div");
        loader_overlay.classList.add("ulabel-loader-overlay");
        var loader = document.createElement("div");
        loader.classList.add("ulabel-loader");
        var style = ULabelLoader.build_loader_style();
        loader_overlay.appendChild(loader);
        loader_overlay.appendChild(style);
        container.appendChild(loader_overlay);
    };
    ULabelLoader.remove_loader_div = function () {
        var loader = document.querySelector(".ulabel-loader-overlay");
        if (loader) {
            loader.remove();
        }
    };
    ULabelLoader.build_loader_style = function () {
        var css = "\n            .ulabel-loader-overlay {\n                position: fixed;\n                width: 100%;\n                height: 100%;\n                inset: 0;\n                background-color: rgba(0, 0, 0, 0.5);\n                z-index: 100;\n            }\n            .ulabel-loader {\n                border: 16px solid #f3f3f3;\n                border-top: 16px solid #3498db;\n                border-radius: 50%;\n                width: 120px;\n                height: 120px;\n                animation: spin 2s linear infinite;\n                position: fixed;\n                inset: 0;\n                margin: auto;\n            }\n            \n            @keyframes spin {\n                0% { transform: rotate(0deg); }\n                100% { transform: rotate(360deg); }\n            }\n        ";
        var style = document.createElement("style");
        style.innerHTML = css;
        return style;
    };
    return ULabelLoader;
}());
exports.ULabelLoader = ULabelLoader;


/***/ }),

/***/ 3628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(8648);
var originalGetProto = __webpack_require__(1064);

var getDunderProto = __webpack_require__(7176);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 3707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

/**
 * Takes a feature or set of features and returns all positions as {@link Point|points}.
 *
 * @name explode
 * @param {GeoJSON} geojson input features
 * @returns {FeatureCollection<point>} points representing the exploded input features
 * @throws {Error} if it encounters an unknown geometry type
 * @example
 * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
 *
 * var explode = turf.explode(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, explode]
 */
function explode(geojson) {
  var points = [];
  if (geojson.type === "FeatureCollection") {
    meta.featureEach(geojson, function (feature) {
      meta.coordEach(feature, function (coord) {
        points.push(helpers.point(coord, feature.properties));
      });
    });
  } else {
    meta.coordEach(geojson, function (coord) {
      points.push(helpers.point(coord, geojson.properties));
    });
  }
  return helpers.featureCollection(points);
}

module.exports = explode;
module.exports["default"] = explode;


/***/ }),

/***/ 3711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
 * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
 *
 * @name clone
 * @param {GeoJSON} geojson GeoJSON Object
 * @returns {GeoJSON} cloned GeoJSON Object
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
 *
 * var lineCloned = turf.clone(line);
 */
function clone(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    switch (geojson.type) {
        case "Feature":
            return cloneFeature(geojson);
        case "FeatureCollection":
            return cloneFeatureCollection(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
            return cloneGeometry(geojson);
        default:
            throw new Error("unknown GeoJSON type");
    }
}
/**
 * Clone Feature
 *
 * @private
 * @param {Feature<any>} geojson GeoJSON Feature
 * @returns {Feature<any>} cloned Feature
 */
function cloneFeature(geojson) {
    var cloned = { type: "Feature" };
    // Preserve Foreign Members
    Object.keys(geojson).forEach(function (key) {
        switch (key) {
            case "type":
            case "properties":
            case "geometry":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    // Add properties & geometry last
    cloned.properties = cloneProperties(geojson.properties);
    cloned.geometry = cloneGeometry(geojson.geometry);
    return cloned;
}
/**
 * Clone Properties
 *
 * @private
 * @param {Object} properties GeoJSON Properties
 * @returns {Object} cloned Properties
 */
function cloneProperties(properties) {
    var cloned = {};
    if (!properties) {
        return cloned;
    }
    Object.keys(properties).forEach(function (key) {
        var value = properties[key];
        if (typeof value === "object") {
            if (value === null) {
                // handle null
                cloned[key] = null;
            }
            else if (Array.isArray(value)) {
                // handle Array
                cloned[key] = value.map(function (item) {
                    return item;
                });
            }
            else {
                // handle generic Object
                cloned[key] = cloneProperties(value);
            }
        }
        else {
            cloned[key] = value;
        }
    });
    return cloned;
}
/**
 * Clone Feature Collection
 *
 * @private
 * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
 * @returns {FeatureCollection<any>} cloned Feature Collection
 */
function cloneFeatureCollection(geojson) {
    var cloned = { type: "FeatureCollection" };
    // Preserve Foreign Members
    Object.keys(geojson).forEach(function (key) {
        switch (key) {
            case "type":
            case "features":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    // Add features
    cloned.features = geojson.features.map(function (feature) {
        return cloneFeature(feature);
    });
    return cloned;
}
/**
 * Clone Geometry
 *
 * @private
 * @param {Geometry<any>} geometry GeoJSON Geometry
 * @returns {Geometry<any>} cloned Geometry
 */
function cloneGeometry(geometry) {
    var geom = { type: geometry.type };
    if (geometry.bbox) {
        geom.bbox = geometry.bbox;
    }
    if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map(function (g) {
            return cloneGeometry(g);
        });
        return geom;
    }
    geom.coordinates = deepSlice(geometry.coordinates);
    return geom;
}
/**
 * Deep Slice coordinates
 *
 * @private
 * @param {Coordinates} coords Coordinates
 * @returns {Coordinates} all coordinates sliced
 */
function deepSlice(coords) {
    var cloned = coords;
    if (typeof cloned[0] !== "object") {
        return cloned.slice();
    }
    return cloned.map(function (coord) {
        return deepSlice(coord);
    });
}
exports["default"] = clone;


/***/ }),

/***/ 3841:
/***/ ((module) => {

module.exports = function pointInPolygonFlat (point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = (end-start)/2;
    for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];
        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];
        var intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
};


/***/ }),

/***/ 3855:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isolines = __webpack_require__(5784);
var convex = __webpack_require__(1207);
var pointsWithinPolygon = __webpack_require__(6432);
var concave = __webpack_require__(347);
var collect = __webpack_require__(1484);
var flip = __webpack_require__(9387);
var simplify = __webpack_require__(1111);
var bezierSpline = __webpack_require__(301);
var tag = __webpack_require__(7974);
var sample = __webpack_require__(9730);
var envelope = __webpack_require__(2120);
var square = __webpack_require__(2363);
var circle = __webpack_require__(5764);
var midpoint = __webpack_require__(8748);
var center = __webpack_require__(6649);
var centerOfMass = __webpack_require__(6320);
var centroid = __webpack_require__(4408);
var combine = __webpack_require__(2583);
var distance = __webpack_require__(9391);
var explode = __webpack_require__(3707);
var bbox = __webpack_require__(4383);
var tesselate = __webpack_require__(3414);
var bboxPolygon = __webpack_require__(3932);
var booleanPointInPolygon = __webpack_require__(2446);
var nearestPoint = __webpack_require__(9791);
var nearestPointOnLine = __webpack_require__(7696);
var nearestPointToLine = __webpack_require__(3284);
var planepoint = __webpack_require__(8220);
var tin = __webpack_require__(2141);
var bearing = __webpack_require__(1288);
var destination = __webpack_require__(4202);
var kinks = __webpack_require__(5518);
var pointOnFeature = __webpack_require__(6979);
var area = __webpack_require__(7849);
var along = __webpack_require__(9399);
var length = __webpack_require__(8840);
var lineSlice = __webpack_require__(7969);
var lineSliceAlong = __webpack_require__(4957);
var pointGrid = __webpack_require__(7497);
var truncate = __webpack_require__(6834);
var flatten = __webpack_require__(4036);
var lineIntersect = __webpack_require__(3154);
var lineChunk = __webpack_require__(2222);
var unkinkPolygon = __webpack_require__(7911);
var greatCircle = __webpack_require__(2352);
var lineSegment = __webpack_require__(7042);
var lineSplit = __webpack_require__(5848);
var lineArc = __webpack_require__(375);
var polygonToLine = __webpack_require__(4527);
var lineToPolygon = __webpack_require__(8785);
var bboxClip = __webpack_require__(3574);
var lineOverlap = __webpack_require__(4300);
var sector = __webpack_require__(1786);
var rhumbBearing = __webpack_require__(2307);
var rhumbDistance = __webpack_require__(9778);
var rhumbDestination = __webpack_require__(7153);
var polygonTangents = __webpack_require__(4951);
var rewind = __webpack_require__(2163);
var isobands = __webpack_require__(1279);
var transformRotate = __webpack_require__(7948);
var transformScale = __webpack_require__(1925);
var transformTranslate = __webpack_require__(8509);
var lineOffset = __webpack_require__(1972);
var polygonize = __webpack_require__(7804);
var booleanDisjoint = __webpack_require__(1323);
var booleanContains = __webpack_require__(3974);
var booleanCrosses = __webpack_require__(7971);
var booleanClockwise = __webpack_require__(7333);
var booleanOverlap = __webpack_require__(8436);
var booleanPointOnLine = __webpack_require__(5378);
var booleanEqual = __webpack_require__(7447);
var booleanWithin = __webpack_require__(4960);
var booleanIntersects = __webpack_require__(1734);
var clone = __webpack_require__(3711);
var cleanCoords = __webpack_require__(2086);
var clustersDbscan = __webpack_require__(8703);
var clustersKmeans = __webpack_require__(7521);
var pointToLineDistance = __webpack_require__(3183);
var booleanParallel = __webpack_require__(3980);
var shortestPath = __webpack_require__(9736);
var voronoi = __webpack_require__(1356);
var ellipse = __webpack_require__(7420);
var centerMean = __webpack_require__(2779);
var centerMedian = __webpack_require__(6724);
var standardDeviationalEllipse = __webpack_require__(4333);
var angle = __webpack_require__(4309);
var polygonSmooth = __webpack_require__(6775);
var moranIndex = __webpack_require__(7938);
var distanceWeight = __webpack_require__(7484);
var projection = __webpack_require__(1101);
var random = __webpack_require__(4575);
var clusters = __webpack_require__(5943);
var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);
var meta = __webpack_require__(8421);
var difference = __webpack_require__(4927);
var buffer = __webpack_require__(7262);
var union = __webpack_require__(2057);
var intersect = __webpack_require__(9627);
var dissolve = __webpack_require__(7095);
var hexGrid = __webpack_require__(7564);
var mask = __webpack_require__(7300);
var squareGrid = __webpack_require__(4512);
var triangleGrid = __webpack_require__(9269);
var interpolate = __webpack_require__(9933);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var isolines__default = /*#__PURE__*/_interopDefaultLegacy(isolines);
var convex__default = /*#__PURE__*/_interopDefaultLegacy(convex);
var pointsWithinPolygon__default = /*#__PURE__*/_interopDefaultLegacy(pointsWithinPolygon);
var concave__default = /*#__PURE__*/_interopDefaultLegacy(concave);
var collect__default = /*#__PURE__*/_interopDefaultLegacy(collect);
var flip__default = /*#__PURE__*/_interopDefaultLegacy(flip);
var simplify__default = /*#__PURE__*/_interopDefaultLegacy(simplify);
var bezierSpline__default = /*#__PURE__*/_interopDefaultLegacy(bezierSpline);
var tag__default = /*#__PURE__*/_interopDefaultLegacy(tag);
var sample__default = /*#__PURE__*/_interopDefaultLegacy(sample);
var envelope__default = /*#__PURE__*/_interopDefaultLegacy(envelope);
var square__default = /*#__PURE__*/_interopDefaultLegacy(square);
var circle__default = /*#__PURE__*/_interopDefaultLegacy(circle);
var midpoint__default = /*#__PURE__*/_interopDefaultLegacy(midpoint);
var center__default = /*#__PURE__*/_interopDefaultLegacy(center);
var centerOfMass__default = /*#__PURE__*/_interopDefaultLegacy(centerOfMass);
var centroid__default = /*#__PURE__*/_interopDefaultLegacy(centroid);
var combine__default = /*#__PURE__*/_interopDefaultLegacy(combine);
var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);
var explode__default = /*#__PURE__*/_interopDefaultLegacy(explode);
var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var tesselate__default = /*#__PURE__*/_interopDefaultLegacy(tesselate);
var bboxPolygon__default = /*#__PURE__*/_interopDefaultLegacy(bboxPolygon);
var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);
var nearestPoint__default = /*#__PURE__*/_interopDefaultLegacy(nearestPoint);
var nearestPointOnLine__default = /*#__PURE__*/_interopDefaultLegacy(nearestPointOnLine);
var nearestPointToLine__default = /*#__PURE__*/_interopDefaultLegacy(nearestPointToLine);
var planepoint__default = /*#__PURE__*/_interopDefaultLegacy(planepoint);
var tin__default = /*#__PURE__*/_interopDefaultLegacy(tin);
var bearing__default = /*#__PURE__*/_interopDefaultLegacy(bearing);
var destination__default = /*#__PURE__*/_interopDefaultLegacy(destination);
var kinks__default = /*#__PURE__*/_interopDefaultLegacy(kinks);
var pointOnFeature__default = /*#__PURE__*/_interopDefaultLegacy(pointOnFeature);
var area__default = /*#__PURE__*/_interopDefaultLegacy(area);
var along__default = /*#__PURE__*/_interopDefaultLegacy(along);
var length__default = /*#__PURE__*/_interopDefaultLegacy(length);
var lineSlice__default = /*#__PURE__*/_interopDefaultLegacy(lineSlice);
var lineSliceAlong__default = /*#__PURE__*/_interopDefaultLegacy(lineSliceAlong);
var pointGrid__default = /*#__PURE__*/_interopDefaultLegacy(pointGrid);
var truncate__default = /*#__PURE__*/_interopDefaultLegacy(truncate);
var flatten__default = /*#__PURE__*/_interopDefaultLegacy(flatten);
var lineIntersect__default = /*#__PURE__*/_interopDefaultLegacy(lineIntersect);
var lineChunk__default = /*#__PURE__*/_interopDefaultLegacy(lineChunk);
var unkinkPolygon__default = /*#__PURE__*/_interopDefaultLegacy(unkinkPolygon);
var greatCircle__default = /*#__PURE__*/_interopDefaultLegacy(greatCircle);
var lineSegment__default = /*#__PURE__*/_interopDefaultLegacy(lineSegment);
var lineSplit__default = /*#__PURE__*/_interopDefaultLegacy(lineSplit);
var lineArc__default = /*#__PURE__*/_interopDefaultLegacy(lineArc);
var polygonToLine__default = /*#__PURE__*/_interopDefaultLegacy(polygonToLine);
var lineToPolygon__default = /*#__PURE__*/_interopDefaultLegacy(lineToPolygon);
var bboxClip__default = /*#__PURE__*/_interopDefaultLegacy(bboxClip);
var lineOverlap__default = /*#__PURE__*/_interopDefaultLegacy(lineOverlap);
var sector__default = /*#__PURE__*/_interopDefaultLegacy(sector);
var rhumbBearing__default = /*#__PURE__*/_interopDefaultLegacy(rhumbBearing);
var rhumbDistance__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDistance);
var rhumbDestination__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDestination);
var polygonTangents__default = /*#__PURE__*/_interopDefaultLegacy(polygonTangents);
var rewind__default = /*#__PURE__*/_interopDefaultLegacy(rewind);
var isobands__default = /*#__PURE__*/_interopDefaultLegacy(isobands);
var transformRotate__default = /*#__PURE__*/_interopDefaultLegacy(transformRotate);
var transformScale__default = /*#__PURE__*/_interopDefaultLegacy(transformScale);
var transformTranslate__default = /*#__PURE__*/_interopDefaultLegacy(transformTranslate);
var lineOffset__default = /*#__PURE__*/_interopDefaultLegacy(lineOffset);
var polygonize__default = /*#__PURE__*/_interopDefaultLegacy(polygonize);
var booleanDisjoint__default = /*#__PURE__*/_interopDefaultLegacy(booleanDisjoint);
var booleanContains__default = /*#__PURE__*/_interopDefaultLegacy(booleanContains);
var booleanCrosses__default = /*#__PURE__*/_interopDefaultLegacy(booleanCrosses);
var booleanClockwise__default = /*#__PURE__*/_interopDefaultLegacy(booleanClockwise);
var booleanOverlap__default = /*#__PURE__*/_interopDefaultLegacy(booleanOverlap);
var booleanPointOnLine__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointOnLine);
var booleanEqual__default = /*#__PURE__*/_interopDefaultLegacy(booleanEqual);
var booleanWithin__default = /*#__PURE__*/_interopDefaultLegacy(booleanWithin);
var booleanIntersects__default = /*#__PURE__*/_interopDefaultLegacy(booleanIntersects);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var cleanCoords__default = /*#__PURE__*/_interopDefaultLegacy(cleanCoords);
var clustersDbscan__default = /*#__PURE__*/_interopDefaultLegacy(clustersDbscan);
var clustersKmeans__default = /*#__PURE__*/_interopDefaultLegacy(clustersKmeans);
var pointToLineDistance__default = /*#__PURE__*/_interopDefaultLegacy(pointToLineDistance);
var booleanParallel__default = /*#__PURE__*/_interopDefaultLegacy(booleanParallel);
var shortestPath__default = /*#__PURE__*/_interopDefaultLegacy(shortestPath);
var voronoi__default = /*#__PURE__*/_interopDefaultLegacy(voronoi);
var ellipse__default = /*#__PURE__*/_interopDefaultLegacy(ellipse);
var centerMean__default = /*#__PURE__*/_interopDefaultLegacy(centerMean);
var centerMedian__default = /*#__PURE__*/_interopDefaultLegacy(centerMedian);
var standardDeviationalEllipse__default = /*#__PURE__*/_interopDefaultLegacy(standardDeviationalEllipse);
var angle__default = /*#__PURE__*/_interopDefaultLegacy(angle);
var polygonSmooth__default = /*#__PURE__*/_interopDefaultLegacy(polygonSmooth);
var moranIndex__default = /*#__PURE__*/_interopDefaultLegacy(moranIndex);
var distanceWeight__default = /*#__PURE__*/_interopDefaultLegacy(distanceWeight);
var projection__namespace = /*#__PURE__*/_interopNamespace(projection);
var random__namespace = /*#__PURE__*/_interopNamespace(random);
var clusters__namespace = /*#__PURE__*/_interopNamespace(clusters);
var helpers__namespace = /*#__PURE__*/_interopNamespace(helpers);
var invariant__namespace = /*#__PURE__*/_interopNamespace(invariant);
var meta__namespace = /*#__PURE__*/_interopNamespace(meta);
var difference__default = /*#__PURE__*/_interopDefaultLegacy(difference);
var buffer__default = /*#__PURE__*/_interopDefaultLegacy(buffer);
var union__default = /*#__PURE__*/_interopDefaultLegacy(union);
var intersect__default = /*#__PURE__*/_interopDefaultLegacy(intersect);
var dissolve__default = /*#__PURE__*/_interopDefaultLegacy(dissolve);
var hexGrid__default = /*#__PURE__*/_interopDefaultLegacy(hexGrid);
var mask__default = /*#__PURE__*/_interopDefaultLegacy(mask);
var squareGrid__default = /*#__PURE__*/_interopDefaultLegacy(squareGrid);
var triangleGrid__default = /*#__PURE__*/_interopDefaultLegacy(triangleGrid);
var interpolate__default = /*#__PURE__*/_interopDefaultLegacy(interpolate);



Object.keys(projection).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return projection[k];
    }
  });
});
Object.keys(random).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return random[k];
    }
  });
});
Object.keys(clusters).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return clusters[k];
    }
  });
});
Object.keys(helpers).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return helpers[k];
    }
  });
});
Object.keys(invariant).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return invariant[k];
    }
  });
});
Object.keys(meta).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return meta[k];
    }
  });
});
Object.defineProperty(exports, "isolines", ({
  enumerable: true,
  get: function () {
    return isolines__default['default'];
  }
}));
Object.defineProperty(exports, "convex", ({
  enumerable: true,
  get: function () {
    return convex__default['default'];
  }
}));
Object.defineProperty(exports, "pointsWithinPolygon", ({
  enumerable: true,
  get: function () {
    return pointsWithinPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "within", ({
  enumerable: true,
  get: function () {
    return pointsWithinPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "concave", ({
  enumerable: true,
  get: function () {
    return concave__default['default'];
  }
}));
Object.defineProperty(exports, "collect", ({
  enumerable: true,
  get: function () {
    return collect__default['default'];
  }
}));
Object.defineProperty(exports, "flip", ({
  enumerable: true,
  get: function () {
    return flip__default['default'];
  }
}));
Object.defineProperty(exports, "simplify", ({
  enumerable: true,
  get: function () {
    return simplify__default['default'];
  }
}));
Object.defineProperty(exports, "bezier", ({
  enumerable: true,
  get: function () {
    return bezierSpline__default['default'];
  }
}));
Object.defineProperty(exports, "bezierSpline", ({
  enumerable: true,
  get: function () {
    return bezierSpline__default['default'];
  }
}));
Object.defineProperty(exports, "tag", ({
  enumerable: true,
  get: function () {
    return tag__default['default'];
  }
}));
Object.defineProperty(exports, "sample", ({
  enumerable: true,
  get: function () {
    return sample__default['default'];
  }
}));
Object.defineProperty(exports, "envelope", ({
  enumerable: true,
  get: function () {
    return envelope__default['default'];
  }
}));
Object.defineProperty(exports, "square", ({
  enumerable: true,
  get: function () {
    return square__default['default'];
  }
}));
Object.defineProperty(exports, "circle", ({
  enumerable: true,
  get: function () {
    return circle__default['default'];
  }
}));
Object.defineProperty(exports, "midpoint", ({
  enumerable: true,
  get: function () {
    return midpoint__default['default'];
  }
}));
Object.defineProperty(exports, "center", ({
  enumerable: true,
  get: function () {
    return center__default['default'];
  }
}));
Object.defineProperty(exports, "centerOfMass", ({
  enumerable: true,
  get: function () {
    return centerOfMass__default['default'];
  }
}));
Object.defineProperty(exports, "centroid", ({
  enumerable: true,
  get: function () {
    return centroid__default['default'];
  }
}));
Object.defineProperty(exports, "combine", ({
  enumerable: true,
  get: function () {
    return combine__default['default'];
  }
}));
Object.defineProperty(exports, "distance", ({
  enumerable: true,
  get: function () {
    return distance__default['default'];
  }
}));
Object.defineProperty(exports, "explode", ({
  enumerable: true,
  get: function () {
    return explode__default['default'];
  }
}));
Object.defineProperty(exports, "bbox", ({
  enumerable: true,
  get: function () {
    return bbox__default['default'];
  }
}));
Object.defineProperty(exports, "tesselate", ({
  enumerable: true,
  get: function () {
    return tesselate__default['default'];
  }
}));
Object.defineProperty(exports, "bboxPolygon", ({
  enumerable: true,
  get: function () {
    return bboxPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "booleanPointInPolygon", ({
  enumerable: true,
  get: function () {
    return booleanPointInPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "inside", ({
  enumerable: true,
  get: function () {
    return booleanPointInPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "nearest", ({
  enumerable: true,
  get: function () {
    return nearestPoint__default['default'];
  }
}));
Object.defineProperty(exports, "nearestPoint", ({
  enumerable: true,
  get: function () {
    return nearestPoint__default['default'];
  }
}));
Object.defineProperty(exports, "nearestPointOnLine", ({
  enumerable: true,
  get: function () {
    return nearestPointOnLine__default['default'];
  }
}));
Object.defineProperty(exports, "pointOnLine", ({
  enumerable: true,
  get: function () {
    return nearestPointOnLine__default['default'];
  }
}));
Object.defineProperty(exports, "nearestPointToLine", ({
  enumerable: true,
  get: function () {
    return nearestPointToLine__default['default'];
  }
}));
Object.defineProperty(exports, "planepoint", ({
  enumerable: true,
  get: function () {
    return planepoint__default['default'];
  }
}));
Object.defineProperty(exports, "tin", ({
  enumerable: true,
  get: function () {
    return tin__default['default'];
  }
}));
Object.defineProperty(exports, "bearing", ({
  enumerable: true,
  get: function () {
    return bearing__default['default'];
  }
}));
Object.defineProperty(exports, "destination", ({
  enumerable: true,
  get: function () {
    return destination__default['default'];
  }
}));
Object.defineProperty(exports, "kinks", ({
  enumerable: true,
  get: function () {
    return kinks__default['default'];
  }
}));
Object.defineProperty(exports, "pointOnFeature", ({
  enumerable: true,
  get: function () {
    return pointOnFeature__default['default'];
  }
}));
Object.defineProperty(exports, "pointOnSurface", ({
  enumerable: true,
  get: function () {
    return pointOnFeature__default['default'];
  }
}));
Object.defineProperty(exports, "area", ({
  enumerable: true,
  get: function () {
    return area__default['default'];
  }
}));
Object.defineProperty(exports, "along", ({
  enumerable: true,
  get: function () {
    return along__default['default'];
  }
}));
Object.defineProperty(exports, "length", ({
  enumerable: true,
  get: function () {
    return length__default['default'];
  }
}));
Object.defineProperty(exports, "lineDistance", ({
  enumerable: true,
  get: function () {
    return length__default['default'];
  }
}));
Object.defineProperty(exports, "lineSlice", ({
  enumerable: true,
  get: function () {
    return lineSlice__default['default'];
  }
}));
Object.defineProperty(exports, "lineSliceAlong", ({
  enumerable: true,
  get: function () {
    return lineSliceAlong__default['default'];
  }
}));
Object.defineProperty(exports, "pointGrid", ({
  enumerable: true,
  get: function () {
    return pointGrid__default['default'];
  }
}));
Object.defineProperty(exports, "truncate", ({
  enumerable: true,
  get: function () {
    return truncate__default['default'];
  }
}));
Object.defineProperty(exports, "flatten", ({
  enumerable: true,
  get: function () {
    return flatten__default['default'];
  }
}));
Object.defineProperty(exports, "lineIntersect", ({
  enumerable: true,
  get: function () {
    return lineIntersect__default['default'];
  }
}));
Object.defineProperty(exports, "lineChunk", ({
  enumerable: true,
  get: function () {
    return lineChunk__default['default'];
  }
}));
Object.defineProperty(exports, "unkinkPolygon", ({
  enumerable: true,
  get: function () {
    return unkinkPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "greatCircle", ({
  enumerable: true,
  get: function () {
    return greatCircle__default['default'];
  }
}));
Object.defineProperty(exports, "lineSegment", ({
  enumerable: true,
  get: function () {
    return lineSegment__default['default'];
  }
}));
Object.defineProperty(exports, "lineSplit", ({
  enumerable: true,
  get: function () {
    return lineSplit__default['default'];
  }
}));
Object.defineProperty(exports, "lineArc", ({
  enumerable: true,
  get: function () {
    return lineArc__default['default'];
  }
}));
Object.defineProperty(exports, "polygonToLine", ({
  enumerable: true,
  get: function () {
    return polygonToLine__default['default'];
  }
}));
Object.defineProperty(exports, "polygonToLineString", ({
  enumerable: true,
  get: function () {
    return polygonToLine__default['default'];
  }
}));
Object.defineProperty(exports, "lineStringToPolygon", ({
  enumerable: true,
  get: function () {
    return lineToPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "lineToPolygon", ({
  enumerable: true,
  get: function () {
    return lineToPolygon__default['default'];
  }
}));
Object.defineProperty(exports, "bboxClip", ({
  enumerable: true,
  get: function () {
    return bboxClip__default['default'];
  }
}));
Object.defineProperty(exports, "lineOverlap", ({
  enumerable: true,
  get: function () {
    return lineOverlap__default['default'];
  }
}));
Object.defineProperty(exports, "sector", ({
  enumerable: true,
  get: function () {
    return sector__default['default'];
  }
}));
Object.defineProperty(exports, "rhumbBearing", ({
  enumerable: true,
  get: function () {
    return rhumbBearing__default['default'];
  }
}));
Object.defineProperty(exports, "rhumbDistance", ({
  enumerable: true,
  get: function () {
    return rhumbDistance__default['default'];
  }
}));
Object.defineProperty(exports, "rhumbDestination", ({
  enumerable: true,
  get: function () {
    return rhumbDestination__default['default'];
  }
}));
Object.defineProperty(exports, "polygonTangents", ({
  enumerable: true,
  get: function () {
    return polygonTangents__default['default'];
  }
}));
Object.defineProperty(exports, "rewind", ({
  enumerable: true,
  get: function () {
    return rewind__default['default'];
  }
}));
Object.defineProperty(exports, "isobands", ({
  enumerable: true,
  get: function () {
    return isobands__default['default'];
  }
}));
Object.defineProperty(exports, "transformRotate", ({
  enumerable: true,
  get: function () {
    return transformRotate__default['default'];
  }
}));
Object.defineProperty(exports, "transformScale", ({
  enumerable: true,
  get: function () {
    return transformScale__default['default'];
  }
}));
Object.defineProperty(exports, "transformTranslate", ({
  enumerable: true,
  get: function () {
    return transformTranslate__default['default'];
  }
}));
Object.defineProperty(exports, "lineOffset", ({
  enumerable: true,
  get: function () {
    return lineOffset__default['default'];
  }
}));
Object.defineProperty(exports, "polygonize", ({
  enumerable: true,
  get: function () {
    return polygonize__default['default'];
  }
}));
Object.defineProperty(exports, "booleanDisjoint", ({
  enumerable: true,
  get: function () {
    return booleanDisjoint__default['default'];
  }
}));
Object.defineProperty(exports, "booleanContains", ({
  enumerable: true,
  get: function () {
    return booleanContains__default['default'];
  }
}));
Object.defineProperty(exports, "booleanCrosses", ({
  enumerable: true,
  get: function () {
    return booleanCrosses__default['default'];
  }
}));
Object.defineProperty(exports, "booleanClockwise", ({
  enumerable: true,
  get: function () {
    return booleanClockwise__default['default'];
  }
}));
Object.defineProperty(exports, "booleanOverlap", ({
  enumerable: true,
  get: function () {
    return booleanOverlap__default['default'];
  }
}));
Object.defineProperty(exports, "booleanPointOnLine", ({
  enumerable: true,
  get: function () {
    return booleanPointOnLine__default['default'];
  }
}));
Object.defineProperty(exports, "booleanEqual", ({
  enumerable: true,
  get: function () {
    return booleanEqual__default['default'];
  }
}));
Object.defineProperty(exports, "booleanWithin", ({
  enumerable: true,
  get: function () {
    return booleanWithin__default['default'];
  }
}));
Object.defineProperty(exports, "booleanIntersects", ({
  enumerable: true,
  get: function () {
    return booleanIntersects__default['default'];
  }
}));
Object.defineProperty(exports, "clone", ({
  enumerable: true,
  get: function () {
    return clone__default['default'];
  }
}));
Object.defineProperty(exports, "cleanCoords", ({
  enumerable: true,
  get: function () {
    return cleanCoords__default['default'];
  }
}));
Object.defineProperty(exports, "clustersDbscan", ({
  enumerable: true,
  get: function () {
    return clustersDbscan__default['default'];
  }
}));
Object.defineProperty(exports, "clustersKmeans", ({
  enumerable: true,
  get: function () {
    return clustersKmeans__default['default'];
  }
}));
Object.defineProperty(exports, "pointToLineDistance", ({
  enumerable: true,
  get: function () {
    return pointToLineDistance__default['default'];
  }
}));
Object.defineProperty(exports, "booleanParallel", ({
  enumerable: true,
  get: function () {
    return booleanParallel__default['default'];
  }
}));
Object.defineProperty(exports, "shortestPath", ({
  enumerable: true,
  get: function () {
    return shortestPath__default['default'];
  }
}));
Object.defineProperty(exports, "voronoi", ({
  enumerable: true,
  get: function () {
    return voronoi__default['default'];
  }
}));
Object.defineProperty(exports, "ellipse", ({
  enumerable: true,
  get: function () {
    return ellipse__default['default'];
  }
}));
Object.defineProperty(exports, "centerMean", ({
  enumerable: true,
  get: function () {
    return centerMean__default['default'];
  }
}));
Object.defineProperty(exports, "centerMedian", ({
  enumerable: true,
  get: function () {
    return centerMedian__default['default'];
  }
}));
Object.defineProperty(exports, "standardDeviationalEllipse", ({
  enumerable: true,
  get: function () {
    return standardDeviationalEllipse__default['default'];
  }
}));
Object.defineProperty(exports, "angle", ({
  enumerable: true,
  get: function () {
    return angle__default['default'];
  }
}));
Object.defineProperty(exports, "polygonSmooth", ({
  enumerable: true,
  get: function () {
    return polygonSmooth__default['default'];
  }
}));
Object.defineProperty(exports, "moranIndex", ({
  enumerable: true,
  get: function () {
    return moranIndex__default['default'];
  }
}));
Object.defineProperty(exports, "distanceWeight", ({
  enumerable: true,
  get: function () {
    return distanceWeight__default['default'];
  }
}));
exports.projection = projection__namespace;
exports.random = random__namespace;
exports.clusters = clusters__namespace;
Object.defineProperty(exports, "bearingToAngle", ({
  enumerable: true,
  get: function () {
    return helpers.bearingToAzimuth;
  }
}));
Object.defineProperty(exports, "convertDistance", ({
  enumerable: true,
  get: function () {
    return helpers.convertLength;
  }
}));
Object.defineProperty(exports, "degrees2radians", ({
  enumerable: true,
  get: function () {
    return helpers.degreesToRadians;
  }
}));
Object.defineProperty(exports, "distanceToDegrees", ({
  enumerable: true,
  get: function () {
    return helpers.lengthToDegrees;
  }
}));
Object.defineProperty(exports, "distanceToRadians", ({
  enumerable: true,
  get: function () {
    return helpers.lengthToRadians;
  }
}));
exports.helpers = helpers__namespace;
Object.defineProperty(exports, "radians2degrees", ({
  enumerable: true,
  get: function () {
    return helpers.radiansToDegrees;
  }
}));
Object.defineProperty(exports, "radiansToDistance", ({
  enumerable: true,
  get: function () {
    return helpers.radiansToLength;
  }
}));
exports.invariant = invariant__namespace;
exports.meta = meta__namespace;
Object.defineProperty(exports, "difference", ({
  enumerable: true,
  get: function () {
    return difference__default['default'];
  }
}));
Object.defineProperty(exports, "buffer", ({
  enumerable: true,
  get: function () {
    return buffer__default['default'];
  }
}));
Object.defineProperty(exports, "union", ({
  enumerable: true,
  get: function () {
    return union__default['default'];
  }
}));
Object.defineProperty(exports, "intersect", ({
  enumerable: true,
  get: function () {
    return intersect__default['default'];
  }
}));
Object.defineProperty(exports, "dissolve", ({
  enumerable: true,
  get: function () {
    return dissolve__default['default'];
  }
}));
Object.defineProperty(exports, "hexGrid", ({
  enumerable: true,
  get: function () {
    return hexGrid__default['default'];
  }
}));
Object.defineProperty(exports, "mask", ({
  enumerable: true,
  get: function () {
    return mask__default['default'];
  }
}));
Object.defineProperty(exports, "squareGrid", ({
  enumerable: true,
  get: function () {
    return squareGrid__default['default'];
  }
}));
Object.defineProperty(exports, "triangleGrid", ({
  enumerable: true,
  get: function () {
    return triangleGrid__default['default'];
  }
}));
Object.defineProperty(exports, "interpolate", ({
  enumerable: true,
  get: function () {
    return interpolate__default['default'];
  }
}));


/***/ }),

/***/ 3932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
 *
 * @name bboxPolygon
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @param {Object} [options={}] Optional parameters
 * @param {Properties} [options.properties={}] Translate properties to Polygon
 * @param {string|number} [options.id={}] Translate Id to Polygon
 * @returns {Feature<Polygon>} a Polygon representation of the bounding box
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [poly]
 */
function bboxPolygon(bbox, options) {
    if (options === void 0) { options = {}; }
    // Convert BBox positions to Numbers
    // No performance loss for including Number()
    // https://github.com/Turfjs/turf/issues/1119
    var west = Number(bbox[0]);
    var south = Number(bbox[1]);
    var east = Number(bbox[2]);
    var north = Number(bbox[3]);
    if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return helpers_1.polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox, id: options.id });
}
exports["default"] = bboxPolygon;


/***/ }),

/***/ 3974:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bbox_1 = __importDefault(__webpack_require__(4383));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var boolean_point_on_line_1 = __importDefault(__webpack_require__(5378));
var invariant_1 = __webpack_require__(8506);
/**
 * Boolean-contains returns True if the second geometry is completely contained by the first geometry.
 * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)
 * must not intersect the exterior of the primary (geometry a).
 * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.
 *
 * @name booleanContains
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 * var point = turf.point([1, 2]);
 *
 * turf.booleanContains(line, point);
 * //=true
 */
function booleanContains(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    var coords1 = geom1.coordinates;
    var coords2 = geom2.coordinates;
    switch (type1) {
        case "Point":
            switch (type2) {
                case "Point":
                    return compareCoords(coords1, coords2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch (type2) {
                case "Point":
                    return isPointInMultiPoint(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch (type2) {
                case "Point":
                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointOnLine(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch (type2) {
                case "Point":
                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });
                case "LineString":
                    return isLineInPoly(geom1, geom2);
                case "Polygon":
                    return isPolyInPoly(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
exports["default"] = booleanContains;
function isPointInMultiPoint(multiPoint, pt) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isPointInMultiPoint = isPointInMultiPoint;
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
        var coord2 = _a[_i];
        var matchFound = false;
        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
            var coord1 = _c[_b];
            if (compareCoords(coord2, coord1)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;
function isMultiPointOnLine(lineString, multiPoint) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default(coord, lineString)) {
            return false;
        }
    }
    if (haveFoundInteriorPoint) {
        return true;
    }
    return false;
}
exports.isMultiPointOnLine = isMultiPointOnLine;
function isMultiPointInPoly(polygon, multiPoint) {
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInPoly = isMultiPointInPoly;
function isLineOnLine(lineString1, lineString2) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
        var coords = _a[_i];
        if (boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, {
            ignoreEndVertices: true,
        })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, {
            ignoreEndVertices: false,
        })) {
            return false;
        }
    }
    return haveFoundInteriorPoint;
}
exports.isLineOnLine = isLineOnLine;
function isLineInPoly(polygon, linestring) {
    var output = false;
    var i = 0;
    var polyBbox = bbox_1.default(polygon);
    var lineBbox = bbox_1.default(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    for (i; i < linestring.coordinates.length - 1; i++) {
        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if (boolean_point_in_polygon_1.default({ type: "Point", coordinates: midPoint }, polygon, {
            ignoreBoundary: true,
        })) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isLineInPoly = isLineInPoly;
/**
 * Is Polygon2 in Polygon1
 * Only takes into account outer rings
 *
 * @private
 * @param {Geometry|Feature<Polygon>} feature1 Polygon1
 * @param {Geometry|Feature<Polygon>} feature2 Polygon2
 * @returns {boolean} true/false
 */
function isPolyInPoly(feature1, feature2) {
    // Handle Nulls
    if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
    }
    var poly1Bbox = bbox_1.default(feature1);
    var poly2Bbox = bbox_1.default(feature2);
    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
    }
    var coords = invariant_1.getGeom(feature2).coordinates;
    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
        var ring = coords_1[_i];
        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
            var coord = ring_1[_a];
            if (!boolean_point_in_polygon_1.default(coord, feature1)) {
                return false;
            }
        }
    }
    return true;
}
exports.isPolyInPoly = isPolyInPoly;
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) {
        return false;
    }
    if (bbox1[2] < bbox2[2]) {
        return false;
    }
    if (bbox1[1] > bbox2[1]) {
        return false;
    }
    if (bbox1[3] < bbox2[3]) {
        return false;
    }
    return true;
}
exports.doBBoxOverlap = doBBoxOverlap;
/**
 * compareCoords
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {boolean} true/false if coord pairs match
 */
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
exports.compareCoords = compareCoords;
function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
exports.getMidpoint = getMidpoint;


/***/ }),

/***/ 3980:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clean_coords_1 = __importDefault(__webpack_require__(2086));
var line_segment_1 = __importDefault(__webpack_require__(7042));
var rhumb_bearing_1 = __importDefault(__webpack_require__(2307));
var helpers_1 = __webpack_require__(8967);
/**
 * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`
 *
 * @name booleanParallel
 * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false if the lines are parallel
 * @example
 * var line1 = turf.lineString([[0, 0], [0, 1]]);
 * var line2 = turf.lineString([[1, 0], [1, 1]]);
 *
 * turf.booleanParallel(line1, line2);
 * //=true
 */
function booleanParallel(line1, line2) {
    // validation
    if (!line1)
        throw new Error("line1 is required");
    if (!line2)
        throw new Error("line2 is required");
    var type1 = getType(line1, "line1");
    if (type1 !== "LineString")
        throw new Error("line1 must be a LineString");
    var type2 = getType(line2, "line2");
    if (type2 !== "LineString")
        throw new Error("line2 must be a LineString");
    var segments1 = line_segment_1.default(clean_coords_1.default(line1)).features;
    var segments2 = line_segment_1.default(clean_coords_1.default(line2)).features;
    for (var i = 0; i < segments1.length; i++) {
        var segment1 = segments1[i].geometry.coordinates;
        if (!segments2[i])
            break;
        var segment2 = segments2[i].geometry.coordinates;
        if (!isParallel(segment1, segment2))
            return false;
    }
    return true;
}
/**
 * Compares slopes and return result
 *
 * @private
 * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature
 * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature
 * @returns {boolean} if slopes are equal
 */
function isParallel(segment1, segment2) {
    var slope1 = helpers_1.bearingToAzimuth(rhumb_bearing_1.default(segment1[0], segment1[1]));
    var slope2 = helpers_1.bearingToAzimuth(rhumb_bearing_1.default(segment2[0], segment2[1]));
    return slope1 === slope2;
}
/**
 * Returns Feature's type
 *
 * @private
 * @param {Geometry|Feature<any>} geojson Geometry or Feature
 * @param {string} name of the variable
 * @returns {string} Feature's type
 */
function getType(geojson, name) {
    if (geojson.geometry && geojson.geometry.type)
        return geojson.geometry.type;
    if (geojson.type)
        return geojson.type; // if GeoJSON geometry
    throw new Error("Invalid GeoJSON object for " + name);
}
exports["default"] = booleanParallel;


/***/ }),

/***/ 3984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var supportsDescriptors = (__webpack_require__(8452).supportsDescriptors);
var getPolyfill = __webpack_require__(5330);
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
	if (!supportsDescriptors || !getProto) {
		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill = getPolyfill();
	var proto = getProto(regex);
	var descriptor = gOPD(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};


/***/ }),

/***/ 4035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(8075);
var hasToStringTag = __webpack_require__(9092)();
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};


/***/ }),

/***/ 4036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

/**
 * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).
 *
 * @name flatten
 * @param {GeoJSON} geojson any valid GeoJSON Object
 * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features
 * @example
 * var multiGeometry = turf.multiPolygon([
 *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
 *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
 *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
 * ]);
 *
 * var flatten = turf.flatten(multiGeometry);
 *
 * //addToMap
 * var addToMap = [flatten]
 */
function flatten(geojson) {
  if (!geojson) throw new Error("geojson is required");

  var results = [];
  meta.flattenEach(geojson, function (feature) {
    results.push(feature);
  });
  return helpers.featureCollection(results);
}

module.exports = flatten;
module.exports["default"] = flatten;


/***/ }),

/***/ 4039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(1333);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 4202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
function destination(origin, distance, bearing, options) {
    if (options === void 0) { options = {}; }
    // Handle input
    var coordinates1 = invariant_1.getCoord(origin);
    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
    var bearingRad = helpers_1.degreesToRadians(bearing);
    var radians = helpers_1.lengthToRadians(distance, options.units);
    // Main
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    var longitude2 = longitude1 +
        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = helpers_1.radiansToDegrees(longitude2);
    var lat = helpers_1.radiansToDegrees(latitude2);
    return helpers_1.point([lng, lat], options.properties);
}
exports["default"] = destination;


/***/ }),

/***/ 4262:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TinyQueue)
/* harmony export */ });

class TinyQueue {
    constructor(data = [], compare = defaultCompare) {
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;

        if (this.length > 0) {
            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
        }
    }

    push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    }

    pop() {
        if (this.length === 0) return undefined;

        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;

        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }

        return top;
    }

    peek() {
        return this.data[0];
    }

    _up(pos) {
        const {data, compare} = this;
        const item = data[pos];

        while (pos > 0) {
            const parent = (pos - 1) >> 1;
            const current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    }

    _down(pos) {
        const {data, compare} = this;
        const halfLength = this.length >> 1;
        const item = data[pos];

        while (pos < halfLength) {
            let left = (pos << 1) + 1;
            let best = data[left];
            const right = left + 1;

            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


/***/ }),

/***/ 4300:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var geojson_rbush_1 = __importDefault(__webpack_require__(4945));
var line_segment_1 = __importDefault(__webpack_require__(7042));
var nearest_point_on_line_1 = __importDefault(__webpack_require__(7696));
var boolean_point_on_line_1 = __importDefault(__webpack_require__(5378));
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
var deep_equal_1 = __importDefault(__webpack_require__(4982));
/**
 * Takes any LineString or Polygon and returns the overlapping lines between both features.
 *
 * @name lineOverlap
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)
 * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
 * @example
 * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);
 * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);
 *
 * var overlapping = turf.lineOverlap(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, overlapping]
 */
function lineOverlap(line1, line2, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options))
        throw new Error("options is invalid");
    var tolerance = options.tolerance || 0;
    // Containers
    var features = [];
    // Create Spatial Index
    var tree = geojson_rbush_1.default();
    // To-Do -- HACK way to support typescript
    var line = line_segment_1.default(line1);
    tree.load(line);
    var overlapSegment;
    // Line Intersection
    // Iterate over line segments
    meta_1.segmentEach(line2, function (segment) {
        var doesOverlaps = false;
        if (!segment) {
            return;
        }
        // Iterate over each segments which falls within the same bounds
        meta_1.featureEach(tree.search(segment), function (match) {
            if (doesOverlaps === false) {
                var coordsSegment = invariant_1.getCoords(segment).sort();
                var coordsMatch = invariant_1.getCoords(match).sort();
                // Segment overlaps feature
                if (deep_equal_1.default(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    // Overlaps already exists - only append last coordinate of segment
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                    // Match segments which don't share nodes (Issue #901)
                }
                else if (tolerance === 0
                    ? boolean_point_on_line_1.default(coordsSegment[0], match) &&
                        boolean_point_on_line_1.default(coordsSegment[1], match)
                    : nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <=
                        tolerance &&
                        nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <=
                            tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                }
                else if (tolerance === 0
                    ? boolean_point_on_line_1.default(coordsMatch[0], segment) &&
                        boolean_point_on_line_1.default(coordsMatch[1], segment)
                    : nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <=
                        tolerance &&
                        nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <=
                            tolerance) {
                    // Do not define (doesOverlap = true) since more matches can occur within the same segment
                    // doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, match);
                    else
                        overlapSegment = match;
                }
            }
        });
        // Segment doesn't overlap - add overlaps to results & reset
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            overlapSegment = undefined;
        }
    });
    // Add last segment if exists
    if (overlapSegment)
        features.push(overlapSegment);
    return helpers_1.featureCollection(features);
}
/**
 * Concat Segment
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<LineString>} segment 2-vertex LineString
 * @returns {Feature<LineString>} concat linestring
 */
function concatSegment(line, segment) {
    var coords = invariant_1.getCoords(segment);
    var lineCoords = invariant_1.getCoords(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;
    if (deep_equal_1.default(coords[0], start))
        geom.unshift(coords[1]);
    else if (deep_equal_1.default(coords[0], end))
        geom.push(coords[1]);
    else if (deep_equal_1.default(coords[1], start))
        geom.unshift(coords[0]);
    else if (deep_equal_1.default(coords[1], end))
        geom.push(coords[0]);
    return line;
}
exports["default"] = lineOverlap;


/***/ }),

/***/ 4309:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bearing_1 = __importDefault(__webpack_require__(1288));
var helpers_1 = __webpack_require__(8967);
var rhumb_bearing_1 = __importDefault(__webpack_require__(2307));
/**
 * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)
 * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.
 *
 * @name angle
 * @param {Coord} startPoint Start Point Coordinates
 * @param {Coord} midPoint Mid Point Coordinates
 * @param {Coord} endPoint End Point Coordinates
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)
 * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection
 * @returns {number} Angle between the provided points, or its explementary.
 * @example
 * turf.angle([5, 5], [5, 6], [3, 4]);
 * //=45
 */
function angle(startPoint, midPoint, endPoint, options) {
    if (options === void 0) { options = {}; }
    // Optional Parameters
    if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
    }
    // Validation
    if (!startPoint) {
        throw new Error("startPoint is required");
    }
    if (!midPoint) {
        throw new Error("midPoint is required");
    }
    if (!endPoint) {
        throw new Error("endPoint is required");
    }
    // Rename to shorter variables
    var A = startPoint;
    var O = midPoint;
    var B = endPoint;
    // Main
    var azimuthAO = helpers_1.bearingToAzimuth(options.mercator !== true ? bearing_1.default(A, O) : rhumb_bearing_1.default(A, O));
    var azimuthBO = helpers_1.bearingToAzimuth(options.mercator !== true ? bearing_1.default(B, O) : rhumb_bearing_1.default(B, O));
    var angleAO = Math.abs(azimuthAO - azimuthBO);
    // Explementary angle
    if (options.explementary === true) {
        return 360 - angleAO;
    }
    return angleAO;
}
exports["default"] = angle;


/***/ }),

/***/ 4333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);
var centerMean = __webpack_require__(2779);
var pointsWithinPolygon = __webpack_require__(6432);
var ellipse = __webpack_require__(7420);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var centerMean__default = /*#__PURE__*/_interopDefaultLegacy(centerMean);
var pointsWithinPolygon__default = /*#__PURE__*/_interopDefaultLegacy(pointsWithinPolygon);
var ellipse__default = /*#__PURE__*/_interopDefaultLegacy(ellipse);

/**
 * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,
 * also known as a directional distribution. The standard deviational ellipse
 * aims to show the direction and the distribution of a dataset by drawing
 * an ellipse that contains about one standard deviations worth (~ 70%) of the
 * data.
 *
 * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)
 * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)
 *
 * **Bibliography**
 *
 *  Robert S. Yuill, The Standard Deviational Ellipse; An Updated Tool for
 * Spatial Description, _Geografiska Annaler_ 53, no. 1 (1971): 2839,
 * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.
 *
 *  Paul Hanly Furfey, A Note on Lefevers Standard Deviational Ellipse,
 * _American Journal of Sociology_ 33, no. 1 (1927): 9498,
 * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.
 *
 *
 * @name standardDeviationalEllipse
 * @param {FeatureCollection<Point>} points GeoJSON points
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.weight] the property name used to weight the center
 * @param {number} [options.steps=64] number of steps for the polygon
 * @param {Object} [options.properties={}] properties to pass to the resulting ellipse
 * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.
 * @example
 *
 * var bbox = [-74, 40.72, -73.98, 40.74];
 * var points = turf.randomPoint(400, {bbox: bbox});
 * var sdEllipse = turf.standardDeviationalEllipse(points);
 *
 * //addToMap
 * var addToMap = [points, sdEllipse];
 *
 */
function standardDeviationalEllipse(points, options) {
  // Optional params
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var steps = options.steps || 64;
  var weightTerm = options.weight;
  var properties = options.properties || {};

  // Validation:
  if (!helpers.isNumber(steps)) throw new Error("steps must be a number");
  if (!helpers.isObject(properties)) throw new Error("properties must be a number");

  // Calculate mean center & number of features:
  var numberOfFeatures = meta.coordAll(points).length;
  var meanCenter = centerMean__default['default'](points, { weight: weightTerm });

  // Calculate angle of rotation:
  // [X, Y] = mean center of all [x, y].
  // theta = arctan( (A + B) / C )
  // A = sum((x - X)^2) - sum((y - Y)^2)
  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))
  // C = 2(sum((x - X)(y - Y)))

  var xDeviationSquaredSum = 0;
  var yDeviationSquaredSum = 0;
  var xyDeviationSum = 0;

  meta.featureEach(points, function (point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(invariant.getCoords(point), invariant.getCoords(meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });

  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  var bigC = 2 * xyDeviationSum;
  var theta = Math.atan((bigA + bigB) / bigC);
  var thetaDeg = (theta * 180) / Math.PI;

  // Calculate axes:
  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))
  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))
  var sigmaXsum = 0;
  var sigmaYsum = 0;
  var weightsum = 0;
  meta.featureEach(points, function (point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(invariant.getCoords(point), invariant.getCoords(meanCenter));
    sigmaXsum +=
      Math.pow(
        deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
        2
      ) * weight;
    sigmaYsum +=
      Math.pow(
        deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
        2
      ) * weight;
    weightsum += weight;
  });

  var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);
  var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);

  var theEllipse = ellipse__default['default'](meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps: steps,
    properties: properties,
  });
  var pointsWithinEllipse = pointsWithinPolygon__default['default'](
    points,
    helpers.featureCollection([theEllipse])
  );
  var standardDeviationalEllipseProperties = {
    meanCenterCoordinates: invariant.getCoords(meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures: numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse:
      (100 * meta.coordAll(pointsWithinEllipse).length) / numberOfFeatures,
  };
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;

  return theEllipse;
}

/**
 * Get x_i - X and y_i - Y
 *
 * @private
 * @param {Array} coordinates Array of [x_i, y_i]
 * @param {Array} center Array of [X, Y]
 * @returns {Object} { x: n, y: m }
 */
function getDeviations(coordinates, center) {
  return {
    x: coordinates[0] - center[0],
    y: coordinates[1] - center[1],
  };
}

module.exports = standardDeviationalEllipse;
module.exports["default"] = standardDeviationalEllipse;


/***/ }),

/***/ 4383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    meta_1.coordEach(geojson, function (coord) {
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
bbox["default"] = bbox;
exports["default"] = bbox;


/***/ }),

/***/ 4392:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VALID_HTML_COLORS = void 0;
exports.VALID_HTML_COLORS = { "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff",
    "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2",
    "brown": "#a52a2a", "burlywood": "#deb887",
    "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff",
    "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400",
    "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f", "darkorange": "#ff8c00", "darkorchid": "#9932cc",
    "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f",
    "darkturquoise": "#00ced1", "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000",
    "greenyellow": "#adff2f",
    "honeydew": "#f0fff0", "hotpink": "#ff69b4",
    "indianred ": "#cd5c5c", "indigo": "#4b0082", "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6",
    "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2", "lightgrey": "#d3d3d3", "lightgreen": "#90ee90",
    "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899",
    "lightsteelblue": "#b0c4de", "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6",
    "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee", "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead", "navy": "#000080",
    "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080",
    "rebeccapurple": "#663399", "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1",
    "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d",
    "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00", "yellowgreen": "#9acd32" };


/***/ }),

/***/ 4408:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
/**
 * Takes one or more features and calculates the centroid using the mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.
 *
 * @name centroid
 * @param {GeoJSON} geojson GeoJSON to be centered
 * @param {Object} [options={}] Optional Parameters
 * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties
 * @returns {Feature<Point>} the centroid of the input features
 * @example
 * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
 *
 * var centroid = turf.centroid(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, centroid]
 */
function centroid(geojson, options) {
    if (options === void 0) { options = {}; }
    var xSum = 0;
    var ySum = 0;
    var len = 0;
    meta_1.coordEach(geojson, function (coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return helpers_1.point([xSum / len, ySum / len], options.properties);
}
exports["default"] = centroid;


/***/ }),

/***/ 4459:
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 4462:
/***/ ((module) => {

"use strict";


var functionsHaveNames = function functionsHaveNames() {
	return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
	try {
		gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		gOPD = null;
	}
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	if (!functionsHaveNames() || !gOPD) {
		return false;
	}
	var desc = gOPD(function () {}, 'name');
	return !!desc && !!desc.configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;


/***/ }),

/***/ 4493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SliderHandler = void 0;
exports.add_style_to_document = add_style_to_document;
exports.prep_window_html = prep_window_html;
exports.build_class_change_svg = build_class_change_svg;
exports.get_idd_string = get_idd_string;
exports.build_id_dialogs = build_id_dialogs;
exports.build_edit_suggestion = build_edit_suggestion;
exports.build_confidence_dialog = build_confidence_dialog;
var toolbox_1 = __webpack_require__(3045);
var version_1 = __webpack_require__(1424);
var annotation_1 = __webpack_require__(5573);
var blobs_1 = __webpack_require__(2748);
var loader_1 = __webpack_require__(3607);
var error_logging_1 = __webpack_require__(5638);
/**
 * Creates a style document, populates it with the styles in get_init_style, and appends it to the page.
 */
function add_style_to_document(ulabel) {
    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    head.appendChild(style);
    style.appendChild(document.createTextNode((0, blobs_1.get_init_style)(ulabel.config["container_id"])));
}
/**
 * Creates a mode button that when clicked switches the current annotation type.
 *
 * @param md_key Key for which button is being constructed. Valid Keys: bbox, point, polygon, tbar, polyline, contour, bbox3, whole-image, global
 * @param md_name Mode name which shows when selected.
 * @param svg_blob svg which shows up on the button
 * @param cur_md Current annotation mode
 * @param subtasks ULabel's Subtasks object
 * @returns html for a mode button
 */
function get_md_button(md_key, md_name, svg_blob, cur_md, subtasks) {
    var sel = "";
    var href = " href=\"#\"";
    if (cur_md == md_key) {
        sel = " sel";
        href = "";
    }
    var subtask_classes = "";
    for (var st_key in subtasks) {
        if (subtasks[st_key]["allowed_modes"].includes(md_key)) {
            subtask_classes += " md-en4--" + st_key;
        }
    }
    return "<div class=\"mode-opt\">\n        <a".concat(href, " id=\"md-btn--").concat(md_key, "\" class=\"md-btn").concat(sel).concat(subtask_classes, " invert-this-svg\" amdname=\"").concat(md_name, "\">\n            ").concat(svg_blob, "\n        </a>\n    </div>");
}
/**
 * Loads image data from ULabel's config and returns html string for image data.
 *
 * @returns html for image data
 */
function get_images_html(ulabel) {
    var images_html = "";
    var display;
    for (var i = 0; i < ulabel.config["image_data"].frames.length; i++) {
        if (i != 0) {
            display = "none";
        }
        else {
            display = "block";
        }
        images_html += "\n            <img id=\"".concat(ulabel.config["image_id_pfx"], "__").concat(i, "\" src=\"").concat(ulabel.config["image_data"].frames[i], "\" class=\"imwrap_cls ").concat(ulabel.config["imgsz_class"], " image_frame\" style=\"z-index: 50; display: ").concat(display, ";\" />\n        ");
    }
    return images_html;
}
/**
 * Constructs html string for whole-image and global dialogs.
 *
 * @returns html for whole-image and global dialogs
 */
function get_frame_annotation_dialogs(ulabel) {
    var frame_annotation_dialog = "";
    var tot = 0;
    for (var st_key in ulabel.subtasks) {
        if (!ulabel.subtasks[st_key].allowed_modes.includes("whole-image") &&
            !ulabel.subtasks[st_key].allowed_modes.includes("global")) {
            continue;
        }
        tot += 1;
    }
    var ind = 0;
    for (var st_key in ulabel.subtasks) {
        if (!ulabel.subtasks[st_key].allowed_modes.includes("whole-image") &&
            !ulabel.subtasks[st_key].allowed_modes.includes("global")) {
            continue;
        }
        frame_annotation_dialog += "\n            <div id=\"fad_st__".concat(st_key, "\" class=\"frame_annotation_dialog fad_st__").concat(st_key, " fad_ind__").concat(tot - ind - 1, "\">\n                <div class=\"hide_overflow_container\">\n                    <div class=\"row_container\">\n                        <div class=\"fad_row name\">\n                            <div class=\"fad_row_inner\">\n                                <div class=\"fad_st_name\">").concat(ulabel.subtasks[st_key].display_name, "</div>\n                            </div>\n                        </div>\n                        <div class=\"fad_row add\">\n                            <div class=\"fad_row_inner\">\n                                <div class=\"fad_st_add\">\n                                    <a class=\"add-glob-button\" href=\"#\">+</a>\n                                </div>\n                            </div>\n                        </div><div class=\"fad_annotation_rows\"></div>\n                    </div>\n                </div>\n            </div>\n        ");
        ind += 1;
        if (ind > 4) {
            throw new Error("At most 4 subtasks can have allow 'whole-image' or 'global' annotations.");
        }
    }
    return frame_annotation_dialog;
}
function prep_window_html(ulabel, toolbox_item_order) {
    // Bring image and annotation scaffolding in
    // TODO multi-image with spacing etc.
    if (toolbox_item_order === void 0) { toolbox_item_order = null; }
    // const tabs = ULabel.get_toolbox_tabs(ul);
    var images = get_images_html(ulabel);
    var frame_annotation_dialogs = get_frame_annotation_dialogs(ulabel);
    // const toolbox = configuration.create_toolbox();
    var toolbox = new toolbox_1.Toolbox([], toolbox_1.Toolbox.create_toolbox(ulabel, toolbox_item_order));
    var tool_html = toolbox.setup_toolbox_html(ulabel, frame_annotation_dialogs, images, version_1.ULABEL_VERSION);
    // Set the container's html to the toolbox html we just created
    $("#" + ulabel.config["container_id"]).html(tool_html);
    var container = document.getElementById(ulabel.config["container_id"]);
    loader_1.ULabelLoader.add_loader_div(container);
    // Build toolbox for the current subtask only
    var current_subtask = Object.keys(ulabel.subtasks)[0];
    // Initialize toolbox based on configuration
    var sp_id = ulabel.config["toolbox_id"];
    var curmd = ulabel.subtasks[current_subtask]["state"]["annotation_mode"];
    var md_buttons = [
        get_md_button("bbox", "Bounding Box", blobs_1.BBOX_SVG, curmd, ulabel.subtasks),
        get_md_button("point", "Point", blobs_1.POINT_SVG, curmd, ulabel.subtasks),
        get_md_button("polygon", "Polygon", blobs_1.POLYGON_SVG, curmd, ulabel.subtasks),
        get_md_button("tbar", "T-Bar", blobs_1.TBAR_SVG, curmd, ulabel.subtasks),
        get_md_button("polyline", "Polyline", blobs_1.POLYLINE_SVG, curmd, ulabel.subtasks),
        get_md_button("contour", "Contour", blobs_1.CONTOUR_SVG, curmd, ulabel.subtasks),
        get_md_button("bbox3", "Bounding Cube", blobs_1.BBOX3_SVG, curmd, ulabel.subtasks),
        get_md_button("whole-image", "Whole Frame", blobs_1.WHOLE_IMAGE_SVG, curmd, ulabel.subtasks),
        get_md_button("global", "Global", blobs_1.GLOBAL_SVG, curmd, ulabel.subtasks),
        get_md_button("delete_polygon", "Delete", blobs_1.DELETE_POLYGON_SVG, curmd, ulabel.subtasks),
        get_md_button("delete_bbox", "Delete", blobs_1.DELETE_BBOX_SVG, curmd, ulabel.subtasks),
    ];
    // Append but don't wait
    $("#" + sp_id + " .toolbox_inner_cls .mode-selection").append(md_buttons.join("<!-- -->"));
    // Show current mode label
    ulabel.show_annotation_mode(null);
    // Make sure that entire toolbox is shown
    if ($("#" + ulabel.config["toolbox_id"] + " .toolbox_inner_cls").height() > $("#" + ulabel.config["container_id"]).height()) {
        $("#" + ulabel.config["toolbox_id"]).css("overflow-y", "scroll");
    }
    ulabel.toolbox = toolbox;
    // Check an array to see if it contains a ZoomPanToolboxItem
    var contains_zoom_pan = function (array) {
        // check if the array is empty
        if (array.length == 0)
            return false;
        // Loop through everything in the array and check if its the ZoomPanToolboxItem
        for (var idx in array) {
            if (array[idx] instanceof toolbox_1.ZoomPanToolboxItem) {
                return true;
            }
        }
        // If the ZoomPanToolboxItem wasn't found then return false
        return false;
    };
    // Check if initial_crop exists and has the appropriate properties
    var initial_crop_is_valid = function (initial_crop) {
        // If initial_crop doesn't exist, return false
        if (initial_crop == null)
            return false;
        // If initial_crop has the appropriate properties, return true
        if ("width" in initial_crop &&
            "height" in initial_crop &&
            "left" in initial_crop &&
            "top" in initial_crop) {
            return true;
        }
        // If initial_crop exists but doesn't have the appropriate properties,
        // then raise an error and return false
        (0, error_logging_1.log_message)("initial_crop missing necessary properties. Ignoring.", error_logging_1.LogLevel.INFO);
        return false;
    };
    // Make sure the toolbox contains the ZoomPanToolboxItem
    if (contains_zoom_pan(ulabel.toolbox.items)) {
        // Make sure the initial_crop exists and contains the necessary properties
        if (initial_crop_is_valid(ulabel.config.initial_crop)) {
            // Grab the initial crop button and rename it
            var initial_crop_button = document.getElementById("recenter-button");
            initial_crop_button.innerHTML = "Initial Crop";
        }
        else {
            // Grab the whole image button and set its display to none
            var whole_image_button = document.getElementById("recenter-whole-image-button");
            whole_image_button.style.display = "none";
        }
    }
}
/**
 * Builds the svg used to change the class of an annotation.
 *
 * @param class_ids Array of all class ids in the subtask
 * @param color_info Color info used to know which color each id is
 * @param id_dialog_id id of the id dialog
 * @param extra_info Optional parameters. Width - size of svg. inner_radius - size of inner black circle. opacity - opacity of unselected pie section
 * @returns
 */
function build_class_change_svg(class_ids, color_info, id_dialog_id, extra_info) {
    var _a, _b, _c;
    if (extra_info === void 0) { extra_info = {}; }
    // Use defaults if custom values aren't used
    var width = (_a = extra_info.width) !== null && _a !== void 0 ? _a : 500;
    var inner_radius = (_b = extra_info.inner_radius) !== null && _b !== void 0 ? _b : 0.3;
    var opacity = (_c = extra_info.opacity) !== null && _c !== void 0 ? _c : 0.4;
    // Define constants independent of which id is being processed
    var outer_radius = 0.5 * width;
    var center_coordinate = width / 2; // X and Y will always be the same, so just use a single number to store X and Y coordinate
    var proportion = 1 / class_ids.length; // Proportion of the circle each section will take up
    var proportion_gap = 1 - proportion; // Proportion of the circle not taken up by an individual section
    var back_radius = inner_radius + (outer_radius - inner_radius) / 2;
    var back_stroke = 2 * Math.PI * back_radius * proportion;
    var back_stroke_width = outer_radius - inner_radius;
    var back_gap = 2 * Math.PI * back_radius * proportion_gap;
    var front_radius = inner_radius + proportion * (outer_radius - inner_radius) / 2;
    var front_stroke = 2 * Math.PI * front_radius * proportion;
    var front_stroke_width = proportion * (outer_radius - inner_radius);
    var front_gap = 2 * Math.PI * front_radius * proportion_gap;
    // Create the beginning of the svg where the height always equals the width
    var svg = "<svg width=\"".concat(width, "\" height=\"").concat(width, "\">");
    // Build each id's section of the class change pie
    for (var idx = 0; idx < class_ids.length; idx++) {
        // Grab the current id being used
        var current_id = class_ids[idx];
        // Get the current id's color from color info
        var current_color = color_info[current_id];
        // Define constants dependent on the current index
        var cumulative_proportion = idx * proportion;
        var back_offset = 2 * Math.PI * back_radius * cumulative_proportion;
        var front_offset = 2 * Math.PI * front_radius * cumulative_proportion;
        // TODO: Should names also go on the id dialog?
        svg += "\n        <circle\n            r=\"".concat(back_radius, "\" cx=\"").concat(center_coordinate, "\" cy=\"").concat(center_coordinate, "\" \n            stroke=\"").concat(current_color, "\" \n            fill-opacity=\"0\"\n            stroke-opacity=\"").concat(opacity, "\"\n            stroke-width=\"").concat(back_stroke_width, "\" \n            stroke-dasharray=\"").concat(back_stroke, " ").concat(back_gap, "\" \n            stroke-dashoffset=\"").concat(back_offset, "\" />\n        <circle\n            id=\"").concat(id_dialog_id, "__circ_").concat(current_id, "\"\n            r=\"").concat(front_radius, "\" cx=\"").concat(center_coordinate, "\" cy=\"").concat(center_coordinate, "\"\n            fill-opacity=\"0\"\n            stroke=\"").concat(current_color, "\" \n            stroke-opacity=\"1.0\"\n            stroke-width=\"").concat(front_stroke_width, "\" \n            stroke-dasharray=\"").concat(front_stroke, " ").concat(front_gap, "\" \n            stroke-dashoffset=\"").concat(front_offset, "\" /> ");
    }
    // Finally close the svg
    svg += "</svg>";
    return svg;
}
/**
 * Builds and returns html string for the id dialog.
 *
 * @param idd_id id of the id dialog
 * @param width Size of the id dialog
 * @param class_ids Array of class ids in the subtask
 * @param inner_rad Radius of the black inner circle
 * @param color_info Color info used to know which color each id is
 * @returns
 */
function get_idd_string(idd_id, width, class_ids, inner_rad, color_info) {
    // TODO noconflict
    var dialog_html = "\n    <div id=\"".concat(idd_id, "\" class=\"id_dialog\" style=\"width: ").concat(width, "px; height: ").concat(width, "px;\">\n        <a class=\"id-dialog-clickable-indicator\" href=\"#\"></a>");
    // Build the svg html and add it to the div
    dialog_html += build_class_change_svg(class_ids, color_info, idd_id, { width: width, inner_radius: inner_rad });
    var outer_radius = 0.5 * width;
    // Create a centcirc div at the end and close off the div
    dialog_html += "<div class=\"centcirc\" style=\"position: absolute; top: ".concat(outer_radius - inner_rad, "px; left:").concat(outer_radius - inner_rad, "px; width: ").concat(2 * inner_rad, "px; height: ").concat(2 * inner_rad, "px; background-color: black; border-radius: ").concat(inner_rad, "px;\" ></div></div>");
    return dialog_html;
}
/**
 * Builds the id dialog for each subtask and appends them to the page.
 */
function build_id_dialogs(ulabel) {
    var full_toolbox_html = "<div class=\"toolbox-id-app-payload\">";
    var width = ulabel.config.outer_diameter;
    // TODO real names here!
    var inner_rad = ulabel.config.inner_prop * width / 2;
    var outer_rad = 0.5 * width;
    var tbid = ulabel.config.toolbox_id;
    for (var st in ulabel.subtasks) {
        var idd_id = ulabel.subtasks[st]["state"]["idd_id"];
        var idd_id_front = ulabel.subtasks[st]["state"]["idd_id_front"];
        var color_info = ulabel.color_info;
        var subtask_dialog_container_jq = $("#dialogs__" + st);
        var front_subtask_dialog_container_jq = $("#front_dialogs__" + st);
        var dialog_html_v2 = get_idd_string(idd_id, width, ulabel.subtasks[st]["class_ids"], inner_rad, color_info);
        var front_dialog_html_v2 = get_idd_string(idd_id_front, width, ulabel.subtasks[st]["class_ids"], inner_rad, color_info);
        // TODO noconflict
        var toolbox_html = "<div id=\"tb-id-app--".concat(st, "\" class=\"tb-id-app\">");
        var class_ids = JSON.parse(JSON.stringify(ulabel.subtasks[st]["class_ids"]));
        // Add the reserved DELETE_CLASS_ID if it is present in the class_defs
        if (ulabel.subtasks[st]["class_defs"].at(-1)["id"] === annotation_1.DELETE_CLASS_ID) {
            class_ids.push(annotation_1.DELETE_CLASS_ID);
        }
        for (var i = 0; i < class_ids.length; i++) {
            var this_id = class_ids[i].toString();
            var this_color = ulabel.color_info[this_id];
            // let this_color: string = ulabel.subtasks[st]["class_defs"][i]["color"];
            var this_name = ulabel.subtasks[st]["class_defs"][i]["name"];
            var sel = "";
            var href = " href=\"#\"";
            if (i == 0) {
                sel = " sel";
                href = "";
            }
            if (ulabel.config["allow_soft_id"]) {
                var msg = "Only hard id is currently supported";
                throw new Error(msg);
            }
            else {
                toolbox_html += "\n                    <a".concat(href, " id=\"").concat(tbid, "_sel_").concat(this_id, "\" class=\"tbid-opt").concat(sel, "\">\n                        <div class=\"colprev ").concat(tbid, "_colprev_").concat(this_id, "\" style=\"background-color: ").concat(this_color, "\"></div> <span class=\"tb-cls-nam\">").concat(this_name, "</span>\n                    </a>\n                ");
            }
        }
        toolbox_html += "\n        </div>";
        // Add dialog to the document
        front_subtask_dialog_container_jq.append(front_dialog_html_v2);
        subtask_dialog_container_jq.append(dialog_html_v2);
        // Wait to add full toolbox
        full_toolbox_html += toolbox_html;
        ulabel.subtasks[st]["state"]["visible_dialogs"][idd_id] = {
            left: 0.0,
            top: 0.0,
            pin: "center",
        };
    }
    // Add all toolbox html at once
    $("#" + ulabel.config["toolbox_id"] + " div.id-toolbox-app").html(full_toolbox_html);
    // Style revisions based on the size
    var idci = $("#" + ulabel.config["container_id"] + " a.id-dialog-clickable-indicator");
    idci.css({
        "height": "".concat(width, "px"),
        "width": "".concat(width, "px"),
        "border-radius": "".concat(outer_rad, "px"),
    });
}
function build_edit_suggestion(ulabel) {
    // TODO noconflict
    // DONE Migrated to subtasks
    for (var stkey in ulabel.subtasks) {
        var local_id = "edit_suggestion__".concat(stkey);
        var global_id = "global_edit_suggestion__".concat(stkey);
        var subtask_dialog_container_jq = $("#dialogs__" + stkey);
        // Local edit suggestion
        subtask_dialog_container_jq.append("\n            <a href=\"#\" id=\"".concat(local_id, "\" class=\"edit_suggestion editable\"></a>\n        "));
        $("#" + local_id).css({
            "height": ulabel.config["edit_handle_size"] + "px",
            "width": ulabel.config["edit_handle_size"] + "px",
            "border-radius": ulabel.config["edit_handle_size"] / 2 + "px",
        });
        // Global edit suggestion
        var id_edit = "";
        var mcm_ind = "";
        if (!ulabel.subtasks[stkey]["single_class_mode"]) {
            id_edit = "--><a href=\"#\" class=\"reid_suggestion global_sub_suggestion gedit-target\"></a><!--";
            mcm_ind = " mcm";
        }
        subtask_dialog_container_jq.append("\n            <div id=\"".concat(global_id, "\" class=\"global_edit_suggestion glob_editable gedit-target").concat(mcm_ind, "\">\n                <a href=\"#\" class=\"move_suggestion global_sub_suggestion movable gedit-target\">\n                    <img class=\"movable gedit-target\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAdVBMVEX///8jHyAAAAD7+/sfGxwcFxhta2s3NDUEAABxcHBqaWnr6+seGRoSCw0yLzC0s7O6ubl4dncLAAN9fHz19fUsKCkWERInIyTW1dV5eHjBwMCko6ODgoJAPj7o5+jw7/BYVleLiopHRUXKysqtrK1PTE0/PD0MlkEbAAAF+ElEQVR4nO2d63aiMBRGIYJTWhyrKPZia2sv7/+IQ7QWYhLITcmXyf41yzWLOXs+GsDmHJLkqsz32X5+3X/yuhSkTEuyGLuMyzElKYVMxy7kUhRHwUaxGLuUyzA9CYaaYtEKhpkiIxii4pQVDO9ELc4FQ0uRSzC0FAUJhpXi7Y1QMJwUC5lgKClO5YJhpNgrGEKKwlU0pBQHEqTcQCv2LDIdReATVXqZOFO8HbtQU5QSRE5RMUHcFJUTRE1RYRVlFOFWVE1BPEVtQbRLv8Yig5miQYIHRZjlxijBgyLIRWMxdLMthzyOXbwKH+aCjeLH2OUrsJ1ZGM62Y5evwKK2MKwRTtNPq7P0c+zyFZisc2PBfD0Zu3wV7kpeUfSzyX+WZ3djF68Gr0jul5zO8v78dM5LEMFGMWUVyVMi+L1F8sR+mKcwgo1i1lUk98lEYDhJmBRhTtEj3RSbBCWGXUWoBCltik2CUsNWESxByinFg6DU8KQIlyDlrmwuB/lRUG7YKDb/EzOcVbTLakHI18Pxz3LD5OGLkMVqvDId0WMYCNEQn2iITzTEJxriEw3xiYb4REN8oiE+0RCfaIhPNMQnGuITDfGJhvhEQ3yiIT7RMABEe6LCojjfpzcD2pmvxC5flllLuSx3Y5d04KMqnh39uEy2L39aXrauDvtcVBZ7wxdkVpO1z5t5XteknpmP9Lk9LA95/uqyJqe85oetZcSwT+PU+VLWvqZ4V5fHEs0aitrOlzzzM8XOLlYTxW7vkp9bI5nN1vqKbHNWvvFP8Wyrta7iefeZf/s/2Y3W2op8e12+8eMKfWK34VoedAZQiPoH841Pe0BXqaBtRb0LVTwwZ+lT01UlbB9TTVE2rGN52aK1kJSolqJk5JFfjzvSGhVSlI5bqd8uXrc6b7LusWFFaYIpebhG6Yo8yMscUOwRvL9O7YpwbWGKijCCpopAgmaKUIImivI+euLn6N+5vGDhUz9YghS9FOWCMz8TpMylvf98inLB5naNqFPZ3p/vHjX+Nb67WJqixSwLlllp9zXhpLYZydCFTdGZYBP4u5XhticWTbqKfaeoLuWLleF36a6UVtFhgmma/bUy/Js5rOU0DMapoFeGPylWTgX9MkxJ1XdjYIZfhvRu5cvxIT0zLN8Sx0f0zTDNkr3D5flwRL8Msy+7kUCiQ/plSIcWBb+W/gfXwyR5DPaepjod1mWK5beVodP70qo9bpjPFlX3wO6eD3O758OVu+fDij2yq2f8wvYZf1U4esbnpvfJU8T8nqbi/3ZY37UJ5y+G9H2pIEEKWIq6CVKgFHsEJQlSgBTNBIEUTQVD+B3wgGCPIsjv8QcF0fdiKAhi7KeRzERXE0TeE6UoKNnXlvq/r01ZEHVvotZJ5v/+Uk5RJ0GK/3uEd+zccF1BhH3eTIr6ggh79Tspmggi9Fv8pqi3yLT43zOz29TmCVIeD31P/go2it+078niC8yL9a59v7vqIJ0v3v146OH7D326RXIB30Nq3FLnKfzN/M3YJbkl/F7uaIhPNMQnGuITDfGJhvhEQ3yiIT7REJ9oiE80xCca4hMN8YmG+ERDfKIhPtEQn2iISfDv5Q7+3eqnAapHRanhT9+Ef/tXB2kHqB4UZYa/jSF+bvDsoTsClzxJDTudL2ApsiNwmxTFhkxrD1SKZ0OMaYqidyM8sR8CpciMof5Jke/YXXLNWTnKisoLNpcD7hPRZyAn6mQt67oaJl8j3OhYDUuho0i8Z1FbGNbSDl6PeLcZijCzmzlxHeTtnQp41agqxWKkj3lbwXW5lfQ/DnJj+K6R6yPqX1QR1Bj9PzZGimavUhkL6WR3OepvNvAD7RSxEqRoKuIJJkmho4i0yLRoXDRwLhMsyiliJkhRTBE1QYpSirgJUhRWVMRVtMvgpR/tQs8zkCL2KXqkVxE/QUrPcqPzIjGfkV40wkiQIkkxlAQpwhTDSZAiGMwUUoIUbkUNK0HKWYqhJUhhFEMUZG7gwjtFj/ymGGaClJ8UQ02QsiBZmpm/KByB+T7bX3ko8T9Zz1H5wFZx8QAAAABJRU5ErkJggg==\">\n                </a><!--\n                ").concat(id_edit, "\n                --><a href=\"#\" class=\"delete_suggestion global_sub_suggestion gedit-target\">\n                    <span class=\"bigx gedit-target\">&#215;</span>\n                </a>\n            </div>\n        "));
        // Register these dialogs with each subtask
        ulabel.subtasks[stkey]["state"]["visible_dialogs"][local_id] = {
            left: 0.0,
            top: 0.0,
            pin: "center",
        };
        ulabel.subtasks[stkey]["state"]["visible_dialogs"][global_id] = {
            left: 0.0,
            top: 0.0,
            pin: "center",
        };
    }
}
/**
 * Builds the dialog that displays the annotation's confidence and appends it to the page.
 */
function build_confidence_dialog(ulabel) {
    for (var stkey in ulabel.subtasks) {
        var local_id = "annotation_confidence__".concat(stkey);
        var global_id = "global_annotation_confidence__".concat(stkey);
        var subtask_dialog_container_jq = $("#dialogs__" + stkey);
        var global_edit_suggestion_jq = $("#global_edit_suggestion__" + stkey);
        // Local confidence dialog
        subtask_dialog_container_jq.append("\n            <p id=\"".concat(local_id, "\" class=\"annotation-confidence editable\"></p>\n        "));
        $("#" + local_id).css({
            height: ulabel.config["edit_handle_size"] + "px",
            width: ulabel.config["edit_handle_size"] + "px",
        });
        // Global edit suggestion
        var id_edit = "";
        var mcm_ind = "";
        if (!ulabel.subtasks[stkey]["single_class_mode"]) {
            // TODO (joshua-dean): Is `id_edit` actually necessary or can we yoink it?
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            id_edit = "--><a href=\"#\" class=\"reid_suggestion global_sub_suggestion gedit-target\"></a><!--";
            mcm_ind = " mcm";
        }
        global_edit_suggestion_jq.append("\n            <div id=\"".concat(global_id, "\" class=\"annotation-confidence gedit-target").concat(mcm_ind, "\">\n                <p class=\"annotation-confidence-title\" style=\"margin: 0.25em; margin-top: 1em; padding-top: 0.3em; opacity: 1;\">Annotation Confidence:</p>\n                <p class=\"annotation-confidence-value\" style=\"margin: 0.25em; opacity: 1;\">\n                    N/A\n                </p>\n            </div>\n        "));
        // Style the dialog
        $("#" + global_id).css({
            "background-color": "black",
            "color": "white",
            "opacity": "0.6",
            "height": "3em",
            "width": "14.5em",
            "margin-top": "-9.5em",
            "border-radius": "1em",
            "font-size": "1.2em",
            "margin-left": "-1.4em",
        });
    }
}
/**
 * Class that allows for creation of sliders. Handles event listeners for increment and decrement buttons, and displaying the value of the slider.
 */
var SliderHandler = /** @class */ (function () {
    function SliderHandler(kwargs) {
        var _this = this;
        this.label_units = "";
        this.min = "0";
        this.max = "100";
        this.step = "1";
        this.step_as_number = 1;
        this.default_value = kwargs.default_value;
        this.id = kwargs.id;
        this.slider_event = kwargs.slider_event;
        // Only check optional properties
        if (typeof kwargs.class !== "undefined") {
            this.class = kwargs.class;
        }
        if (typeof kwargs.main_label !== "undefined") {
            this.main_label = kwargs.main_label;
        }
        if (typeof kwargs.label_units !== "undefined") {
            this.label_units = kwargs.label_units;
        }
        if (typeof kwargs.min !== "undefined") {
            this.min = kwargs.min;
        }
        if (typeof kwargs.max !== "undefined") {
            this.max = kwargs.max;
        }
        if (typeof kwargs.step !== "undefined") {
            this.step = kwargs.step;
        }
        // Useful to have as both string and number
        // String for html creation
        // Number for incrementing and decrementing slider value
        this.step_as_number = Number(this.step);
        this.add_styles();
        /* Add Event Listeners for this component */
        $(document).on("input.ulabel", "#".concat(this.id), function (event) {
            _this.updateLabel();
            _this.slider_event(event.currentTarget.valueAsNumber);
        });
        $(document).on("click.ulabel", "#".concat(this.id, "-inc-button"), function () { return _this.incrementSlider(); });
        $(document).on("click.ulabel", "#".concat(this.id, "-dec-button"), function () { return _this.decrementSlider(); });
    }
    SliderHandler.prototype.add_styles = function () {
        var css = "\n        #toolbox div.ulabel-slider-container {\n            display: flex;\n            flex-wrap: wrap;\n            align-items: center;\n            margin: 0 1.5rem 0.5rem;\n        }\n         \n        #toolbox div.ulabel-slider-container label.ulabel-filter-row-distance-name-label {\n            width: 100%; /* Ensure title takes up full width of container */\n            font-size: 0.95rem;\n            align-items: center;\n        }\n         \n        #toolbox div.ulabel-slider-container > *:not(label.ulabel-filter-row-distance-name-label) {\n            flex: 1;\n        }\n        \n        /*  \n        .ulabel-night #toolbox div.ulabel-slider-container label {\n            color: white;\n        }\n        */\n        #toolbox div.ulabel-slider-container label.ulabel-slider-value-label {\n            font-size: 0.9rem;\n        }\n         \n         \n        #toolbox div.ulabel-slider-container div.ulabel-slider-decrement-button-text {\n            position: relative;\n            bottom: 1.5px;\n        }";
        // Create an id so this specific style tag can be referenced
        var style_id = "slider-handler-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    SliderHandler.prototype.updateLabel = function () {
        var slider = document.querySelector("#".concat(this.id));
        var label = document.querySelector("#".concat(this.id, "-value-label"));
        // Set the label as a concatenation of the value and the units
        label.innerText = slider.value + this.label_units;
    };
    /**
     * Increment the slider's value by the step value and call the slider event with
     * new slider value.
     */
    SliderHandler.prototype.incrementSlider = function () {
        // Get the slider element
        var slider = document.querySelector("#".concat(this.id));
        // Add the step value
        var new_value = slider.valueAsNumber + this.step_as_number;
        // Update the slider's value
        slider.value = new_value.toString();
        // Update the label
        this.updateLabel();
        // Call the slider event with the slider value
        this.slider_event(slider.value);
    };
    /**
     * Decrement the slider's value by the step value and call the slider event with
     * new slider value.
     */
    SliderHandler.prototype.decrementSlider = function () {
        // Get the slider element
        var slider = document.querySelector("#".concat(this.id));
        // Add the step value
        var new_value = slider.valueAsNumber - this.step_as_number;
        // Update the slider's value
        slider.value = new_value.toString();
        // Update the label
        this.updateLabel();
        // Call the slider event with the slider value
        this.slider_event(slider.value);
    };
    SliderHandler.prototype.getSliderHTML = function () {
        return "\n        <div class=\"ulabel-slider-container\">\n            ".concat(this.main_label ?
            "<label for=\"".concat(this.id, "\" class=\"ulabel-filter-row-distance-name-label\">").concat(this.main_label, "</label>") :
            "", "\n            <input \n                id=\"").concat(this.id, "\"\n                class=\"").concat(this.class, "\"\n                type=\"range\"\n                min=\"").concat(this.min, "\"\n                max=\"").concat(this.max, "\"\n                step=\"").concat(this.step ? this.step : "1", "\"\n                value=\"").concat(this.default_value, "\"\n            />\n            <label for=\"").concat(this.id, "\" id=\"").concat(this.id, "-value-label\" class=\"ulabel-slider-value-label\">\n                ").concat(this.default_value).concat(this.label_units ? this.label_units : "", "\n            </label>\n            <div class=\"ulabel-slider-button-container\">\n                <button id=").concat(this.id, "-inc-button class=\"ulabel-slider-button circle\" >\n                    +\n                </button>\n                <button id=").concat(this.id, "-dec-button class=\"ulabel-slider-button circle\">\n                    <!-- Create an extra div here to be able to move the - text up -->\n                    <div class=\"ulabel-slider-decrement-button-text\">\n                        \u2013\n                    </div>\n                </button>\n            </div>\n        </div>\n        ");
    };
    return SliderHandler;
}());
exports.SliderHandler = SliderHandler;


/***/ }),

/***/ 4512:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var rectangle_grid_1 = __importDefault(__webpack_require__(7112));
/**
 * Creates a square grid from a bounding box.
 *
 * @name squareGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide of each cell, in units
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees,
 * radians, miles, or kilometers
 * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,
 * the grid Points will be created only inside it
 * @param {Object} [options.properties={}] passed to each point of the grid
 * @returns {FeatureCollection<Polygon>} grid a grid of polygons
 * @example
 * var bbox = [-95, 30 ,-85, 40];
 * var cellSide = 50;
 * var options = {units: 'miles'};
 *
 * var squareGrid = turf.squareGrid(bbox, cellSide, options);
 *
 * //addToMap
 * var addToMap = [squareGrid]
 */
function squareGrid(bbox, cellSide, options) {
    if (options === void 0) { options = {}; }
    return rectangle_grid_1.default(bbox, cellSide, cellSide, options);
}
exports["default"] = squareGrid;


/***/ }),

/***/ 4527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a
 * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.
 *
 * @name polygonToLine
 * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] translates GeoJSON properties to Feature
 * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString
 * @example
 * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);
 *
 * var line = turf.polygonToLine(poly);
 *
 * //addToMap
 * var addToMap = [line];
 */
function default_1(poly, options) {
    if (options === void 0) { options = {}; }
    var geom = invariant_1.getGeom(poly);
    if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
    }
    switch (geom.type) {
        case "Polygon":
            return polygonToLine(geom, options);
        case "MultiPolygon":
            return multiPolygonToLine(geom, options);
        default:
            throw new Error("invalid poly");
    }
}
exports["default"] = default_1;
/**
 * @private
 */
function polygonToLine(poly, options) {
    if (options === void 0) { options = {}; }
    var geom = invariant_1.getGeom(poly);
    var coords = geom.coordinates;
    var properties = options.properties
        ? options.properties
        : poly.type === "Feature"
            ? poly.properties
            : {};
    return coordsToLine(coords, properties);
}
exports.polygonToLine = polygonToLine;
/**
 * @private
 */
function multiPolygonToLine(multiPoly, options) {
    if (options === void 0) { options = {}; }
    var geom = invariant_1.getGeom(multiPoly);
    var coords = geom.coordinates;
    var properties = options.properties
        ? options.properties
        : multiPoly.type === "Feature"
            ? multiPoly.properties
            : {};
    var lines = [];
    coords.forEach(function (coord) {
        lines.push(coordsToLine(coord, properties));
    });
    return helpers_1.featureCollection(lines);
}
exports.multiPolygonToLine = multiPolygonToLine;
/**
 * @private
 */
function coordsToLine(coords, properties) {
    if (coords.length > 1) {
        return helpers_1.multiLineString(coords, properties);
    }
    return helpers_1.lineString(coords[0], properties);
}
exports.coordsToLine = coordsToLine;


/***/ }),

/***/ 4575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
/**
 * Returns a random position within a {@link bounding box}.
 *
 * @name randomPosition
 * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.
 * @returns {Array<number>} Position [longitude, latitude]
 * @example
 * var position = turf.randomPosition([-180, -90, 180, 90])
 * // => position
 */
function randomPosition(bbox) {
    if (Array.isArray(bbox)) {
        return coordInBBox(bbox);
    }
    if (bbox && bbox.bbox) {
        return coordInBBox(bbox.bbox);
    }
    return [lon(), lat()];
}
exports.randomPosition = randomPosition;
/**
 * Returns a random {@link point}.
 *
 * @name randomPoint
 * @param {number} [count=1] how many geometries will be generated
 * @param {Object} [options={}] Optional parameters
 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
 * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
 * @example
 * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})
 * // => points
 */
function randomPoint(count, options) {
    if (options === void 0) { options = {}; }
    if (count === undefined || count === null) {
        count = 1;
    }
    var features = [];
    for (var i = 0; i < count; i++) {
        features.push(helpers_1.point(randomPosition(options.bbox)));
    }
    return helpers_1.featureCollection(features);
}
exports.randomPoint = randomPoint;
/**
 * Returns a random {@link polygon}.
 *
 * @name randomPolygon
 * @param {number} [count=1] how many geometries will be generated
 * @param {Object} [options={}] Optional parameters
 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
 * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
 * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a
 * vertex can reach out of the center of the Polygon.
 * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons
 * @example
 * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})
 * // => polygons
 */
function randomPolygon(count, options) {
    if (options === void 0) { options = {}; }
    // Default param
    if (count === undefined || count === null) {
        count = 1;
    }
    if (!helpers_1.isNumber(options.num_vertices) || options.num_vertices === undefined) {
        options.num_vertices = 10;
    }
    if (!helpers_1.isNumber(options.max_radial_length) ||
        options.max_radial_length === undefined) {
        options.max_radial_length = 10;
    }
    var features = [];
    var _loop_1 = function (i) {
        var vertices = [];
        var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);
        // Sum Offsets
        circleOffsets.forEach(function (cur, index, arr) {
            arr[index] = index > 0 ? cur + arr[index - 1] : cur;
        });
        // scaleOffsets
        circleOffsets.forEach(function (cur) {
            cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];
            var radialScaler = Math.random();
            vertices.push([
                radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
                radialScaler * (options.max_radial_length || 10) * Math.cos(cur),
            ]);
        });
        vertices[vertices.length - 1] = vertices[0]; // close the ring
        // center the polygon around something
        vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));
        features.push(helpers_1.polygon([vertices]));
    };
    for (var i = 0; i < count; i++) {
        _loop_1(i);
    }
    return helpers_1.featureCollection(features);
}
exports.randomPolygon = randomPolygon;
/**
 * Returns a random {@link linestring}.
 *
 * @name randomLineString
 * @param {number} [count=1] how many geometries will be generated
 * @param {Object} [options={}] Optional parameters
 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
 * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
 * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a
 * vertex can be from its predecessor
 * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a
 * line segment can turn from the previous segment.
 * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings
 * @example
 * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})
 * // => lineStrings
 */
function randomLineString(count, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
    }
    var bbox = options.bbox;
    var num_vertices = options.num_vertices;
    var max_length = options.max_length;
    var max_rotation = options.max_rotation;
    if (count === undefined || count === null) {
        count = 1;
    }
    // Default parameters
    if (!helpers_1.isNumber(num_vertices) ||
        num_vertices === undefined ||
        num_vertices < 2) {
        num_vertices = 10;
    }
    if (!helpers_1.isNumber(max_length) || max_length === undefined) {
        max_length = 0.0001;
    }
    if (!helpers_1.isNumber(max_rotation) || max_rotation === undefined) {
        max_rotation = Math.PI / 8;
    }
    var features = [];
    for (var i = 0; i < count; i++) {
        var startingPoint = randomPosition(bbox);
        var vertices = [startingPoint];
        for (var j = 0; j < num_vertices - 1; j++) {
            var priorAngle = j === 0
                ? Math.random() * 2 * Math.PI
                : Math.tan((vertices[j][1] - vertices[j - 1][1]) /
                    (vertices[j][0] - vertices[j - 1][0]));
            var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
            var distance = Math.random() * max_length;
            vertices.push([
                vertices[j][0] + distance * Math.cos(angle),
                vertices[j][1] + distance * Math.sin(angle),
            ]);
        }
        features.push(helpers_1.lineString(vertices));
    }
    return helpers_1.featureCollection(features);
}
exports.randomLineString = randomLineString;
function vertexToCoordinate(hub) {
    return function (cur) {
        return [cur[0] + hub[0], cur[1] + hub[1]];
    };
}
function rnd() {
    return Math.random() - 0.5;
}
function lon() {
    return rnd() * 360;
}
function lat() {
    return rnd() * 180;
}
function coordInBBox(bbox) {
    return [
        Math.random() * (bbox[2] - bbox[0]) + bbox[0],
        Math.random() * (bbox[3] - bbox[1]) + bbox[1],
    ];
}


/***/ }),

/***/ 4692:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ 4828:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Cohen-Sutherland line clipping algorithm, adapted to efficiently
// handle polylines rather than just segments
Object.defineProperty(exports, "__esModule", ({ value: true }));
function lineclip(points, bbox, result) {
    var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
    var a;
    var b;
    if (!result)
        result = [];
    for (i = 1; i < len; i++) {
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);
        while (true) {
            if (!(codeA | codeB)) {
                // accept
                part.push(a);
                if (codeB !== lastCode) {
                    // segment went outside
                    part.push(b);
                    if (i < len - 1) {
                        // start a new line
                        result.push(part);
                        part = [];
                    }
                }
                else if (i === len - 1) {
                    part.push(b);
                }
                break;
            }
            else if (codeA & codeB) {
                // trivial reject
                break;
            }
            else if (codeA) {
                // a outside, intersect with clip edge
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);
            }
            else {
                // b outside
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length)
        result.push(part);
    return result;
}
exports.lineclip = lineclip;
// Sutherland-Hodgeman polygon clipping algorithm
function polygonclip(points, bbox) {
    var result, edge, prev, prevInside, i, p, inside;
    // clip against each side of the clip rectangle
    for (edge = 1; edge <= 8; edge *= 2) {
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);
        for (i = 0; i < points.length; i++) {
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);
            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside)
                result.push(intersect(prev, p, edge, bbox));
            if (inside)
                result.push(p); // add a point if it's inside
            prev = p;
            prevInside = inside;
        }
        points = result;
        if (!points.length)
            break;
    }
    return result;
}
exports.polygonclip = polygonclip;
// intersect a segment against one of the 4 lines that make up the bbox
function intersect(a, b, edge, bbox) {
    return edge & 8
        ? [a[0] + ((b[0] - a[0]) * (bbox[3] - a[1])) / (b[1] - a[1]), bbox[3]] // top
        : edge & 4
            ? [a[0] + ((b[0] - a[0]) * (bbox[1] - a[1])) / (b[1] - a[1]), bbox[1]] // bottom
            : edge & 2
                ? [bbox[2], a[1] + ((b[1] - a[1]) * (bbox[2] - a[0])) / (b[0] - a[0])] // right
                : edge & 1
                    ? [bbox[0], a[1] + ((b[1] - a[1]) * (bbox[0] - a[0])) / (b[0] - a[0])] // left
                    : null;
}
// bit code reflects the point position relative to the bbox:
//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110
function bitCode(p, bbox) {
    var code = 0;
    if (p[0] < bbox[0])
        code |= 1;
    // left
    else if (p[0] > bbox[2])
        code |= 2; // right
    if (p[1] < bbox[1])
        code |= 4;
    // bottom
    else if (p[1] > bbox[3])
        code |= 8; // top
    return code;
}


/***/ }),

/***/ 4898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var helpers_1 = __webpack_require__(8967);
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
function mathSign(x) {
    return ((x > 0) - (x < 0) || +x);
}
/**
 * Returns the direction of the point q relative to the vector p1 -> p2.
 *
 * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()
 * (same as geos::algorithm::CGAlgorithm::computeOrientation())
 *
 * @param {number[]} p1 - the origin point of the vector
 * @param {number[]} p2 - the final point of the vector
 * @param {number[]} q - the point to compute the direction to
 *
 * @returns {number} - 1 if q is ccw (left) from p1->p2,
 *    -1 if q is cw (right) from p1->p2,
 *     0 if q is colinear with p1->p2
 */
function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
}
exports.orientationIndex = orientationIndex;
/**
 * Checks if two envelopes are equal.
 *
 * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon
 *
 * @param {Feature<Polygon>} env1 - Envelope
 * @param {Feature<Polygon>} env2 - Envelope
 * @returns {boolean} - True if the envelopes are equal
 */
function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function (c) { return c[0]; }), envY1 = env1.geometry.coordinates[0].map(function (c) { return c[1]; }), envX2 = env2.geometry.coordinates[0].map(function (c) { return c[0]; }), envY2 = env2.geometry.coordinates[0].map(function (c) { return c[1]; });
    return (Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&
        Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&
        Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&
        Math.min.apply(null, envY1) === Math.min.apply(null, envY2));
}
exports.envelopeIsEqual = envelopeIsEqual;
/**
 * Check if a envelope is contained in other one.
 *
 * The function assumes that the arguments are envelopes, i.e.: Convex polygon
 * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,
 * this could be further improved.
 *
 * @param {Feature<Polygon>} self - Envelope
 * @param {Feature<Polygon>} env - Envelope
 * @returns {boolean} - True if env is contained in self
 */
function envelopeContains(self, env) {
    return env.geometry.coordinates[0].every(function (c) {
        return boolean_point_in_polygon_1.default(helpers_1.point(c), self);
    });
}
exports.envelopeContains = envelopeContains;
/**
 * Checks if two coordinates are equal.
 *
 * @param {number[]} coord1 - First coordinate
 * @param {number[]} coord2 - Second coordinate
 * @returns {boolean} - True if coordinates are equal
 */
function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}
exports.coordinatesEqual = coordinatesEqual;


/***/ }),

/***/ 4927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var polygonClipping = __webpack_require__(9004);
var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var polygonClipping__default = /*#__PURE__*/_interopDefaultLegacy(polygonClipping);

/**
 * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.
 *
 * @name difference
 * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
 * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
 * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)
 * @example
 * var polygon1 = turf.polygon([[
 *   [128, -26],
 *   [141, -26],
 *   [141, -21],
 *   [128, -21],
 *   [128, -26]
 * ]], {
 *   "fill": "#F00",
 *   "fill-opacity": 0.1
 * });
 * var polygon2 = turf.polygon([[
 *   [126, -28],
 *   [140, -28],
 *   [140, -20],
 *   [126, -20],
 *   [126, -28]
 * ]], {
 *   "fill": "#00F",
 *   "fill-opacity": 0.1
 * });
 *
 * var difference = turf.difference(polygon1, polygon2);
 *
 * //addToMap
 * var addToMap = [polygon1, polygon2, difference];
 */
function difference(polygon1, polygon2) {
  var geom1 = invariant.getGeom(polygon1);
  var geom2 = invariant.getGeom(polygon2);
  var properties = polygon1.properties || {};

  var differenced = polygonClipping__default['default'].difference(
    geom1.coordinates,
    geom2.coordinates
  );
  if (differenced.length === 0) return null;
  if (differenced.length === 1) return helpers.polygon(differenced[0], properties);
  return helpers.multiPolygon(differenced, properties);
}

module.exports = difference;
module.exports["default"] = difference;


/***/ }),

/***/ 4945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rbush = __webpack_require__(5341);
var helpers = __webpack_require__(8967);
var meta = __webpack_require__(8421);
var turfBBox = (__webpack_require__(4383)["default"]);
var featureEach = meta.featureEach;
var coordEach = meta.coordEach;
var polygon = helpers.polygon;
var featureCollection = helpers.featureCollection;

/**
 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
 *
 * @name rbush
 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
 * @returns {RBush} GeoJSON RBush
 * @example
 * var geojsonRbush = require('geojson-rbush').default;
 * var tree = geojsonRbush();
 */
function geojsonRbush(maxEntries) {
    var tree = new rbush(maxEntries);
    /**
     * [insert](https://github.com/mourner/rbush#data-format)
     *
     * @param {Feature} feature insert single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     * tree.insert(poly)
     */
    tree.insert = function (feature) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.insert.call(this, feature);
    };

    /**
     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
     *
     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polys = turf.polygons([
     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],
     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
     * ]);
     * tree.load(polys);
     */
    tree.load = function (features) {
        var load = [];
        // Load an Array of Features
        if (Array.isArray(features)) {
            features.forEach(function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        } else {
            // Load a FeatureCollection
            featureEach(features, function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        }
        return rbush.prototype.load.call(this, load);
    };

    /**
     * [remove](https://github.com/mourner/rbush#removing-data)
     *
     * @param {Feature} feature remove single GeoJSON Feature
     * @param {Function} equals Pass a custom equals function to compare by value for removal.
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.remove(poly);
     */
    tree.remove = function (feature, equals) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.remove.call(this, feature, equals);
    };

    /**
     * [clear](https://github.com/mourner/rbush#removing-data)
     *
     * @returns {RBush} GeoJSON Rbush
     * @example
     * tree.clear()
     */
    tree.clear = function () {
        return rbush.prototype.clear.call(this);
    };

    /**
     * [search](https://github.com/mourner/rbush#search)
     *
     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON
     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.search(poly);
     */
    tree.search = function (geojson) {
        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
        return featureCollection(features);
    };

    /**
     * [collides](https://github.com/mourner/rbush#collisions)
     *
     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON
     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.collides(poly);
     */
    tree.collides = function (geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
    };

    /**
     * [all](https://github.com/mourner/rbush#search)
     *
     * @returns {FeatureCollection} all the features in RBush
     * @example
     * tree.all()
     */
    tree.all = function () {
        var features = rbush.prototype.all.call(this);
        return featureCollection(features);
    };

    /**
     * [toJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @returns {any} export data as JSON object
     * @example
     * var exported = tree.toJSON()
     */
    tree.toJSON = function () {
        return rbush.prototype.toJSON.call(this);
    };

    /**
     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @param {any} json import previously exported data
     * @returns {RBush} GeoJSON RBush
     * @example
     * var exported = {
     *   "children": [
     *     {
     *       "type": "Feature",
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [110, 50]
     *       },
     *       "properties": {},
     *       "bbox": [110, 50, 110, 50]
     *     }
     *   ],
     *   "height": 1,
     *   "leaf": true,
     *   "minX": 110,
     *   "minY": 50,
     *   "maxX": 110,
     *   "maxY": 50
     * }
     * tree.fromJSON(exported)
     */
    tree.fromJSON = function (json) {
        return rbush.prototype.fromJSON.call(this, json);
    };

    /**
     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
     *
     * @private
     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from
     * @returns {Object} converted to {minX, minY, maxX, maxY}
     */
    tree.toBBox = function (geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];
        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);
        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);
        else throw new Error('invalid geojson')

        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
}

module.exports = geojsonRbush;
module.exports["default"] = geojsonRbush;


/***/ }),

/***/ 4951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);
var calcBbox = __webpack_require__(4383);
var explode = __webpack_require__(3707);
var nearestPoint = __webpack_require__(9791);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var calcBbox__default = /*#__PURE__*/_interopDefaultLegacy(calcBbox);
var explode__default = /*#__PURE__*/_interopDefaultLegacy(explode);
var nearestPoint__default = /*#__PURE__*/_interopDefaultLegacy(nearestPoint);

/**
 * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.
 *
 * @name polygonTangents
 * @param {Coord} pt to calculate the tangent points from
 * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from
 * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points
 * @example
 * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
 * var point = turf.point([61, 5]);
 *
 * var tangents = turf.polygonTangents(point, polygon)
 *
 * //addToMap
 * var addToMap = [tangents, point, polygon];
 */
function polygonTangents(pt, polygon) {
  var pointCoords = invariant.getCoords(pt);
  var polyCoords = invariant.getCoords(polygon);

  var rtan;
  var ltan;
  var enext;
  var eprev;
  var bbox = calcBbox__default['default'](polygon);
  var nearestPtIndex = 0;
  var nearest = null;

  // If the point lies inside the polygon bbox then we need to be a bit trickier
  // otherwise points lying inside reflex angles on concave polys can have issues
  if (
    pointCoords[0] > bbox[0] &&
    pointCoords[0] < bbox[2] &&
    pointCoords[1] > bbox[1] &&
    pointCoords[1] < bbox[3]
  ) {
    nearest = nearestPoint__default['default'](pt, explode__default['default'](polygon));
    nearestPtIndex = nearest.properties.featureIndex;
  }
  var type = invariant.getType(polygon);
  switch (type) {
    case "Polygon":
      rtan = polyCoords[0][nearestPtIndex];
      ltan = polyCoords[0][0];
      if (nearest !== null) {
        if (nearest.geometry.coordinates[1] < pointCoords[1])
          ltan = polyCoords[0][nearestPtIndex];
      }
      eprev = isLeft(
        polyCoords[0][0],
        polyCoords[0][polyCoords[0].length - 1],
        pointCoords
      );
      var out = processPolygon(
        polyCoords[0],
        pointCoords,
        eprev,
        enext,
        rtan,
        ltan);
      rtan = out[0];
      ltan = out[1];
      break;
    case "MultiPolygon":
      var closestFeature = 0;
      var closestVertex = 0;
      var verticesCounted = 0;
      for (var i = 0; i < polyCoords[0].length; i++) {
        closestFeature = i;
        var verticeFound = false;
        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
          closestVertex = i2;
          if (verticesCounted === nearestPtIndex) {
            verticeFound = true;
            break;
          }
          verticesCounted++;
        }
        if (verticeFound) break;
      }
      rtan = polyCoords[0][closestFeature][closestVertex];
      ltan = polyCoords[0][closestFeature][closestVertex];
      eprev = isLeft(
        polyCoords[0][0][0],
        polyCoords[0][0][polyCoords[0][0].length - 1],
        pointCoords
      );
      polyCoords.forEach(function (ring) {
        var out = processPolygon(
          ring[0],
          pointCoords,
          eprev,
          enext,
          rtan,
          ltan);
        rtan = out[0];
        ltan = out[1];
      });
      break;
  }
  return helpers.featureCollection([helpers.point(rtan), helpers.point(ltan)]);
}

function processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {
  for (var i = 0; i < polygonCoords.length; i++) {
    var currentCoords = polygonCoords[i];
    var nextCoordPair = polygonCoords[i + 1];
    if (i === polygonCoords.length - 1) {
      nextCoordPair = polygonCoords[0];
    }
    enext = isLeft(currentCoords, nextCoordPair, ptCoords);
    if (eprev <= 0 && enext > 0) {
      if (!isBelow(ptCoords, currentCoords, rtan)) {
        rtan = currentCoords;
      }
    } else if (eprev > 0 && enext <= 0) {
      if (!isAbove(ptCoords, currentCoords, ltan)) {
        ltan = currentCoords;
      }
    }
    eprev = enext;
  }
  return [rtan, ltan];
}

function isAbove(point1, point2, point3) {
  return isLeft(point1, point2, point3) > 0;
}

function isBelow(point1, point2, point3) {
  return isLeft(point1, point2, point3) < 0;
}

function isLeft(point1, point2, point3) {
  return (
    (point2[0] - point1[0]) * (point3[1] - point1[1]) -
    (point3[0] - point1[0]) * (point2[1] - point1[1])
  );
}

module.exports = polygonTangents;
module.exports["default"] = polygonTangents;


/***/ }),

/***/ 4957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bearing = __webpack_require__(1288);
var distance = __webpack_require__(9391);
var destination = __webpack_require__(4202);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bearing__default = /*#__PURE__*/_interopDefaultLegacy(bearing);
var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);
var destination__default = /*#__PURE__*/_interopDefaultLegacy(destination);

/**
 * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},
 * and a specified  distance along the line to a stop point
 * and returns a subsection of the line in-between those points.
 *
 * This can be useful for extracting only the part of a route between two distances.
 *
 * @name lineSliceAlong
 * @param {Feature<LineString>|LineString} line input line
 * @param {number} startDist distance along the line to starting point
 * @param {number} stopDist distance along the line to ending point
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {Feature<LineString>} sliced line
 * @example
 * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);
 * var start = 12.5;
 * var stop = 25;
 * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line, start, stop, sliced]
 */
function lineSliceAlong(line, startDist, stopDist, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");

  var coords;
  var slice = [];

  // Validation
  if (line.type === "Feature") coords = line.geometry.coordinates;
  else if (line.type === "LineString") coords = line.coordinates;
  else throw new Error("input must be a LineString Feature or Geometry");
  var origCoordsLength = coords.length;
  var travelled = 0;
  var overshot, direction, interpolated;
  for (var i = 0; i < coords.length; i++) {
    if (startDist >= travelled && i === coords.length - 1) break;
    else if (travelled > startDist && slice.length === 0) {
      overshot = startDist - travelled;
      if (!overshot) {
        slice.push(coords[i]);
        return helpers.lineString(slice);
      }
      direction = bearing__default['default'](coords[i], coords[i - 1]) - 180;
      interpolated = destination__default['default'](coords[i], overshot, direction, options);
      slice.push(interpolated.geometry.coordinates);
    }

    if (travelled >= stopDist) {
      overshot = stopDist - travelled;
      if (!overshot) {
        slice.push(coords[i]);
        return helpers.lineString(slice);
      }
      direction = bearing__default['default'](coords[i], coords[i - 1]) - 180;
      interpolated = destination__default['default'](coords[i], overshot, direction, options);
      slice.push(interpolated.geometry.coordinates);
      return helpers.lineString(slice);
    }

    if (travelled >= startDist) {
      slice.push(coords[i]);
    }

    if (i === coords.length - 1) {
      return helpers.lineString(slice);
    }

    travelled += distance__default['default'](coords[i], coords[i + 1], options);
  }

  if (travelled < startDist && coords.length === origCoordsLength)
    throw new Error("Start position is beyond line");

  var last = coords[coords.length - 1];
  return helpers.lineString([last, last]);
}

module.exports = lineSliceAlong;
module.exports["default"] = lineSliceAlong;


/***/ }),

/***/ 4960:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bbox_1 = __importDefault(__webpack_require__(4383));
var boolean_point_on_line_1 = __importDefault(__webpack_require__(5378));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var invariant_1 = __webpack_require__(8506);
/**
 * Boolean-within returns true if the first geometry is completely within the second geometry.
 * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)
 * must not intersect the exterior of the secondary (geometry b).
 * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.
 *
 * @name booleanWithin
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 * var point = turf.point([1, 2]);
 *
 * turf.booleanWithin(point, line);
 * //=true
 */
function booleanWithin(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch (type1) {
        case "Point":
            switch (type2) {
                case "MultiPoint":
                    return isPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return boolean_point_on_line_1.default(geom1, geom2, { ignoreEndVertices: true });
                case "Polygon":
                case "MultiPolygon":
                    return boolean_point_in_polygon_1.default(geom1, geom2, { ignoreBoundary: true });
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch (type2) {
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return isMultiPointOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch (type2) {
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isLineInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch (type2) {
                case "Polygon":
                case "MultiPolygon":
                    return isPolyInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointInMultiPoint(point, multiPoint) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var i = 0; i < multiPoint1.coordinates.length; i++) {
        var anyMatch = false;
        for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
                anyMatch = true;
            }
        }
        if (!anyMatch) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(multiPoint, lineString) {
    var foundInsidePoint = false;
    for (var i = 0; i < multiPoint.coordinates.length; i++) {
        if (!boolean_point_on_line_1.default(multiPoint.coordinates[i], lineString)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = boolean_point_on_line_1.default(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });
        }
    }
    return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint, polygon) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for (var i = 0; i < multiPoint.coordinates.length; i++) {
        isInside = boolean_point_in_polygon_1.default(multiPoint.coordinates[1], polygon);
        if (!isInside) {
            output = false;
            break;
        }
        if (!oneInside) {
            isInside = boolean_point_in_polygon_1.default(multiPoint.coordinates[1], polygon, {
                ignoreBoundary: true,
            });
        }
    }
    return output && isInside;
}
function isLineOnLine(lineString1, lineString2) {
    for (var i = 0; i < lineString1.coordinates.length; i++) {
        if (!boolean_point_on_line_1.default(lineString1.coordinates[i], lineString2)) {
            return false;
        }
    }
    return true;
}
function isLineInPoly(linestring, polygon) {
    var polyBbox = bbox_1.default(polygon);
    var lineBbox = bbox_1.default(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    var foundInsidePoint = false;
    for (var i = 0; i < linestring.coordinates.length - 1; i++) {
        if (!boolean_point_in_polygon_1.default(linestring.coordinates[i], polygon)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = boolean_point_in_polygon_1.default(linestring.coordinates[i], polygon, { ignoreBoundary: true });
        }
        if (!foundInsidePoint) {
            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
            foundInsidePoint = boolean_point_in_polygon_1.default(midpoint, polygon, {
                ignoreBoundary: true,
            });
        }
    }
    return foundInsidePoint;
}
/**
 * Is Polygon2 in Polygon1
 * Only takes into account outer rings
 *
 * @private
 * @param {Polygon} geometry1
 * @param {Polygon|MultiPolygon} geometry2
 * @returns {boolean} true/false
 */
function isPolyInPoly(geometry1, geometry2) {
    var poly1Bbox = bbox_1.default(geometry1);
    var poly2Bbox = bbox_1.default(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
        return false;
    }
    for (var i = 0; i < geometry1.coordinates[0].length; i++) {
        if (!boolean_point_in_polygon_1.default(geometry1.coordinates[0][i], geometry2)) {
            return false;
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0])
        return false;
    if (bbox1[2] < bbox2[2])
        return false;
    if (bbox1[1] > bbox2[1])
        return false;
    if (bbox1[3] < bbox2[3])
        return false;
    return true;
}
/**
 * compareCoords
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {boolean} true/false if coord pairs match
 */
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
/**
 * getMidpoint
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {Position} midpoint of pair1 and pair2
 */
function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
exports["default"] = booleanWithin;


/***/ }),

/***/ 4982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var objectKeys = __webpack_require__(1189);
var isArguments = __webpack_require__(7244);
var is = __webpack_require__(7653);
var isRegex = __webpack_require__(4035);
var flags = __webpack_require__(1589);
var isDate = __webpack_require__(9739);

var getTime = Date.prototype.getTime;

function deepEqual(actual, expected, options) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? is(actual, expected) : actual == expected;
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts);
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return true;
}

function objEquiv(a, b, opts) {
  /* eslint max-statements: [2, 50] */
  var i, key;
  if (typeof a !== typeof b) { return false; }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) { return false; }

  if (isArguments(a) !== isArguments(b)) { return false; }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && flags(a) === flags(b);
  }

  if (isDate(a) && isDate(b)) {
    return getTime.call(a) === getTime.call(b);
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b);
  } catch (e) { // happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; }
  }
  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) { return false; }
  }

  return true;
}

module.exports = deepEqual;


/***/ }),

/***/ 5172:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * @requires ./PriorityQueue.js
 */

if ( true && module.exports) {
      var PriorityQueue = __webpack_require__(1283);
}

/**
 * OPTICS - Ordering points to identify the clustering structure
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * OPTICS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {OPTICS}
 */
function OPTICS(dataset, epsilon, minPts, distanceFunction) {
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 1;
  /** @type {function} */
  this.distance = this._euclideanDistance;

  // temporary variables used during computation

  /** @type {Array} */
  this._reachability = [];
  /** @type {Array} */
  this._processed = [];
  /** @type {number} */
  this._coreDistance = 0;
  /** @type {Array} */
  this._orderedList = [];

  this._init(dataset, epsilon, minPts, distanceFunction);
}

/******************************************************************************/
// pulic functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @returns {undefined}
 * @access public
 */
OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
    if (this._processed[pointId] !== 1) {
      this._processed[pointId] = 1;
      this.clusters.push([pointId]);
      var clusterId = this.clusters.length - 1;

      this._orderedList.push(pointId);
      var priorityQueue = new PriorityQueue(null, null, 'asc');
      var neighbors = this._regionQuery(pointId);

      // using priority queue assign elements to new cluster
      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, priorityQueue);
        this._expandCluster(clusterId, priorityQueue);
      }
    }
  }

  return this.clusters;
};

/**
 * Generate reachability plot for all points
 *
 * @returns {array}
 * @access public
 */
OPTICS.prototype.getReachabilityPlot = function() {
  var reachabilityPlot = [];

  for (var i = 0, l = this._orderedList.length; i < l; i++) {
    var pointId = this._orderedList[i];
    var distance = this._reachability[pointId];

    reachabilityPlot.push([pointId, distance]);
  }

  return reachabilityPlot;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this._reachability = new Array(this.dataset.length);
    this._processed = new Array(this.dataset.length);
    this._coreDistance = 0;
    this._orderedList = [];
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Update information in queue
 *
 * @param {number} pointId
 * @param {Array} neighbors
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
  var self = this;

  this._coreDistance = this._distanceToCore(pointId);
  neighbors.forEach(function(pointId2) {
    if (self._processed[pointId2] === undefined) {
      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);
      var newReachableDistance = Math.max(self._coreDistance, dist);

      if (self._reachability[pointId2] === undefined) {
        self._reachability[pointId2] = newReachableDistance;
        queue.insert(pointId2, newReachableDistance);
      } else {
        if (newReachableDistance < self._reachability[pointId2]) {
          self._reachability[pointId2] = newReachableDistance;
          queue.remove(pointId2);
          queue.insert(pointId2, newReachableDistance);
        }
      }
    }
  });
};

/**
 * Expand cluster
 *
 * @param {number} clusterId
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._expandCluster = function(clusterId, queue) {
  var queueElements = queue.getElements();

  for (var p = 0, l = queueElements.length; p < l; p++) {
    var pointId = queueElements[p];
    if (this._processed[pointId] === undefined) {
      var neighbors = this._regionQuery(pointId);
      this._processed[pointId] = 1;

      this.clusters[clusterId].push(pointId);
      this._orderedList.push(pointId);

      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, queue);
        this._expandCluster(clusterId, queue);
      }
    }
  }
};

/**
 * Calculating distance to cluster core
 *
 * @param {number} pointId
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._distanceToCore = function(pointId) {
  var l = this.epsilon;
  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
    var neighbors = this._regionQuery(pointId, coreDistCand);
    if (neighbors.length >= this.minPts) {
      return coreDistCand;
    }
  }

  return;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
OPTICS.prototype._regionQuery = function(pointId, epsilon) {
  epsilon = epsilon || this.epsilon;
  var neighbors = [];

  for (var id = 0, l = this.dataset.length; id < l; id++) {
    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};

if ( true && module.exports) {
  module.exports = OPTICS;
}


/***/ }),

/***/ 5228:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 5330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(7675);

var supportsDescriptors = (__webpack_require__(8452).supportsDescriptors);
var $gOPD = Object.getOwnPropertyDescriptor;

module.exports = function getPolyfill() {
	if (supportsDescriptors && (/a/mig).flags === 'gim') {
		var descriptor = $gOPD(RegExp.prototype, 'flags');
		if (
			descriptor
			&& typeof descriptor.get === 'function'
			&& typeof RegExp.prototype.dotAll === 'boolean'
			&& typeof RegExp.prototype.hasIndices === 'boolean'
		) {
			/* eslint getter-return: 0 */
			var calls = '';
			var o = {};
			Object.defineProperty(o, 'hasIndices', {
				get: function () {
					calls += 'd';
				}
			});
			Object.defineProperty(o, 'sticky', {
				get: function () {
					calls += 'y';
				}
			});
			if (calls === 'dy') {
				return descriptor.get;
			}
		}
	}
	return implementation;
};


/***/ }),

/***/ 5335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
/**
 * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.
 * [LineString] -> LineString|MultiLineString
 *
 * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] Prevent input mutation
 * @returns {Feature<LineString|MultiLineString>} Dissolved lines
 */
function lineDissolve(geojson, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
    }
    var mutate = options.mutate;
    // Validation
    if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    // Clone geojson to avoid side effects
    if (mutate === false || mutate === undefined) {
        geojson = clone_1.default(geojson);
    }
    var result = [];
    var lastLine = meta_1.lineReduce(geojson, function (previousLine, currentLine) {
        // Attempt to merge this LineString with the other LineStrings, updating
        // the reference as it is merged with others and grows.
        var merged = mergeLineStrings(previousLine, currentLine);
        // Accumulate the merged LineString
        if (merged) {
            return merged;
            // Put the unmerged LineString back into the list
        }
        else {
            result.push(previousLine);
            return currentLine;
        }
    });
    // Append the last line
    if (lastLine) {
        result.push(lastLine);
    }
    // Return null if no lines were dissolved
    if (!result.length) {
        return null;
        // Return LineString if only 1 line was dissolved
    }
    else if (result.length === 1) {
        return result[0];
        // Return MultiLineString if multiple lines were dissolved with gaps
    }
    else {
        return helpers_1.multiLineString(result.map(function (line) {
            return line.coordinates;
        }));
    }
}
// [Number, Number] -> String
function coordId(coord) {
    return coord[0].toString() + "," + coord[1].toString();
}
/**
 * LineString, LineString -> LineString
 *
 * @private
 * @param {Feature<LineString>} a line1
 * @param {Feature<LineString>} b line2
 * @returns {Feature<LineString>|null} Merged LineString
 */
function mergeLineStrings(a, b) {
    var coords1 = a.geometry.coordinates;
    var coords2 = b.geometry.coordinates;
    var s1 = coordId(coords1[0]);
    var e1 = coordId(coords1[coords1.length - 1]);
    var s2 = coordId(coords2[0]);
    var e2 = coordId(coords2[coords2.length - 1]);
    // TODO: handle case where more than one of these is true!
    var coords;
    if (s1 === e2) {
        coords = coords2.concat(coords1.slice(1));
    }
    else if (s2 === e1) {
        coords = coords1.concat(coords2.slice(1));
    }
    else if (s1 === s2) {
        coords = coords1.slice(1).reverse().concat(coords2);
    }
    else if (e1 === e2) {
        coords = coords1.concat(coords2.reverse().slice(1));
    }
    else {
        return null;
    }
    return helpers_1.lineString(coords);
}
exports["default"] = lineDissolve;


/***/ }),

/***/ 5341:
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ 5345:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 5378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var invariant_1 = __webpack_require__(8506);
/**
 * Returns true if a point is on a line. Accepts a optional parameter to ignore the
 * start and end vertices of the linestring.
 *
 * @name booleanPointOnLine
 * @param {Coord} pt GeoJSON Point
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
 * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points
 * @returns {boolean} true/false
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
 * //=true
 */
function booleanPointOnLine(pt, line, options) {
    if (options === void 0) { options = {}; }
    // Normalize inputs
    var ptCoords = invariant_1.getCoord(pt);
    var lineCoords = invariant_1.getCoords(line);
    // Main
    for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
            return true;
        }
    }
    return false;
}
// See http://stackoverflow.com/a/4833823/1979085
// See https://stackoverflow.com/a/328122/1048847
/**
 * @private
 * @param {Position} lineSegmentStart coord pair of start of line
 * @param {Position} lineSegmentEnd coord pair of end of line
 * @param {Position} pt coord pair of point to check
 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.
 * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points
 * If true which end to ignore.
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
    var x = pt[0];
    var y = pt[1];
    var x1 = lineSegmentStart[0];
    var y1 = lineSegmentStart[1];
    var x2 = lineSegmentEnd[0];
    var y2 = lineSegmentEnd[1];
    var dxc = pt[0] - x1;
    var dyc = pt[1] - y1;
    var dxl = x2 - x1;
    var dyl = y2 - y1;
    var cross = dxc * dyl - dyc * dxl;
    if (epsilon !== null) {
        if (Math.abs(cross) > epsilon) {
            return false;
        }
    }
    else if (cross !== 0) {
        return false;
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    }
    else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    }
    else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    }
    else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
exports["default"] = booleanPointOnLine;


/***/ }),

/***/ 5518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},
 * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and
 * returns {@link Point|points} at all self-intersections.
 *
 * @name kinks
 * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature
 * @returns {FeatureCollection<Point>} self-intersections
 * @example
 * var poly = turf.polygon([[
 *   [-12.034835, 8.901183],
 *   [-12.060413, 8.899826],
 *   [-12.03638, 8.873199],
 *   [-12.059383, 8.871418],
 *   [-12.034835, 8.901183]
 * ]]);
 *
 * var kinks = turf.kinks(poly);
 *
 * //addToMap
 * var addToMap = [poly, kinks]
 */
function kinks(featureIn) {
    var coordinates;
    var feature;
    var results = {
        type: "FeatureCollection",
        features: [],
    };
    if (featureIn.type === "Feature") {
        feature = featureIn.geometry;
    }
    else {
        feature = featureIn;
    }
    if (feature.type === "LineString") {
        coordinates = [feature.coordinates];
    }
    else if (feature.type === "MultiLineString") {
        coordinates = feature.coordinates;
    }
    else if (feature.type === "MultiPolygon") {
        coordinates = [].concat.apply([], feature.coordinates);
    }
    else if (feature.type === "Polygon") {
        coordinates = feature.coordinates;
    }
    else {
        throw new Error("Input must be a LineString, MultiLineString, " +
            "Polygon, or MultiPolygon Feature or Geometry");
    }
    coordinates.forEach(function (line1) {
        coordinates.forEach(function (line2) {
            for (var i = 0; i < line1.length - 1; i++) {
                // start iteration at i, intersections for k < i have already
                // been checked in previous outer loop iterations
                for (var k = i; k < line2.length - 1; k++) {
                    if (line1 === line2) {
                        // segments are adjacent and always share a vertex, not a kink
                        if (Math.abs(i - k) === 1) {
                            continue;
                        }
                        // first and last segment in a closed lineString or ring always share a vertex, not a kink
                        if (
                        // segments are first and last segment of lineString
                        i === 0 &&
                            k === line1.length - 2 &&
                            // lineString is closed
                            line1[i][0] === line1[line1.length - 1][0] &&
                            line1[i][1] === line1[line1.length - 1][1]) {
                            continue;
                        }
                    }
                    var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
                    if (intersection) {
                        results.features.push(helpers_1.point([intersection[0], intersection[1]]));
                    }
                }
            }
        });
    });
    return results;
}
exports["default"] = kinks;
// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the
    // intersection (treating the lines as infinite) and booleans for whether
    // line segment 1 or line segment 2 contain the point
    var denominator;
    var a;
    var b;
    var numerator1;
    var numerator2;
    var result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false,
    };
    denominator =
        (line2EndY - line2StartY) * (line1EndX - line1StartX) -
            (line2EndX - line2StartX) * (line1EndY - line1StartY);
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        }
        else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
    a = numerator1 / denominator;
    b = numerator2 / denominator;
    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + a * (line1EndX - line1StartX);
    result.y = line1StartY + a * (line1EndY - line1StartY);
    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    }
    else {
        return false;
    }
}


/***/ }),

/***/ 5573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ULabelAnnotation = exports.NONSPATIAL_MODES = exports.MODES_3D = exports.DELETE_CLASS_ID = exports.DELETE_MODES = void 0;
var geometric_utils_1 = __webpack_require__(6697);
var error_logging_1 = __webpack_require__(5638);
// Modes used to draw an area in the which to delete all annotations
exports.DELETE_MODES = ["delete_polygon", "delete_bbox"];
exports.DELETE_CLASS_ID = -1;
exports.MODES_3D = ["global", "bbox3"];
exports.NONSPATIAL_MODES = ["whole-image", "global"];
var ULabelAnnotation = /** @class */ (function () {
    function ULabelAnnotation(
    // Required properties
    annotation_meta, deprecated, deprecated_by, text_payload, 
    // Optional properties
    subtask_key, classification_payloads, containing_box, created_by, distance_from, frame, line_size, id, canvas_id, 
    // Polygons use complex spatial payloads
    // TODO (joshua-dean): narrow this disaster
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    spatial_payload, spatial_type, 
    // Polygons track if each layer is a hole or fill
    spatial_payload_holes, 
    // Track what holes belong to what fill, ie if spatial_payload[0] is a fill with a hole at spatial_payload[1], spatial_payload_child_indices[0] = [1]
    spatial_payload_child_indices, 
    // Lineage tracking fields
    last_edited_by, last_edited_at) {
        if (annotation_meta === void 0) { annotation_meta = {}; }
        if (deprecated === void 0) { deprecated = false; }
        if (deprecated_by === void 0) { deprecated_by = { human: false }; }
        if (text_payload === void 0) { text_payload = ""; }
        this.annotation_meta = annotation_meta;
        this.deprecated = deprecated;
        this.deprecated_by = deprecated_by;
        this.text_payload = text_payload;
        this.subtask_key = subtask_key;
        this.classification_payloads = classification_payloads;
        this.containing_box = containing_box;
        this.created_by = created_by;
        this.distance_from = distance_from;
        this.frame = frame;
        this.line_size = line_size;
        this.id = id;
        this.canvas_id = canvas_id;
        this.spatial_payload = spatial_payload;
        this.spatial_type = spatial_type;
        this.spatial_payload_holes = spatial_payload_holes;
        this.spatial_payload_child_indices = spatial_payload_child_indices;
        this.last_edited_by = last_edited_by;
        this.last_edited_at = last_edited_at;
    }
    ULabelAnnotation.prototype.ensure_compatible_classification_payloads = function (ulabel_class_ids) {
        var found_ids = [];
        var j;
        var conf_not_found_j = null;
        var remaining_confidence = 1.0;
        // Filter out any classification payloads items that use the DELETE_CLASS_ID
        this.classification_payloads = this.classification_payloads.filter(function (payload) {
            return payload.class_id !== exports.DELETE_CLASS_ID;
        });
        for (j = 0; j < this.classification_payloads.length; j++) {
            var this_id = this.classification_payloads[j].class_id;
            if (!ulabel_class_ids.includes(this_id)) {
                (0, error_logging_1.log_message)("Found class id ".concat(this_id, " in \"resume_from\" data but not in \"allowed_classes\""), error_logging_1.LogLevel.ERROR);
            }
            found_ids.push(this_id);
            if (!("confidence" in this.classification_payloads[j])) {
                if (conf_not_found_j !== null) {
                    (0, error_logging_1.log_message)("More than one classification payload was supplied without confidence for a single annotation.", error_logging_1.LogLevel.ERROR);
                }
                else {
                    conf_not_found_j = j;
                }
            }
            else {
                // TODO (joshua-dean): Why is this here? It doesn't do anything
                // eslint-disable-next-line no-self-assign
                this.classification_payloads[j].confidence = this.classification_payloads[j].confidence;
                remaining_confidence -= this.classification_payloads[j]["confidence"];
            }
        }
        if (conf_not_found_j !== null) {
            if (remaining_confidence < 0) {
                (0, error_logging_1.log_message)("Supplied total confidence was greater than 100%", error_logging_1.LogLevel.ERROR);
            }
            this.classification_payloads[conf_not_found_j].confidence = remaining_confidence;
        }
        for (j = 0; j < ulabel_class_ids.length; j++) {
            if (!(found_ids.includes(ulabel_class_ids[j]))) {
                this.classification_payloads.push({
                    class_id: ulabel_class_ids[j],
                    confidence: 0.0,
                });
            }
        }
    };
    // ensure polygon spatial_payloads are updated to support complex polygons
    ULabelAnnotation.prototype.ensure_compatible_spatial_payloads = function () {
        if (this.spatial_type === "polygon") {
            // Catch empty spatial payloads
            if (this.spatial_payload === undefined || this.spatial_payload.length === 0) {
                (0, error_logging_1.log_message)("Empty spatial payload for polygon id ".concat(this.id, ". Skipping annotation."), error_logging_1.LogLevel.WARNING, true);
                return false;
            }
            // Check that spatial_payload[0][0] is an array and not a number
            if (!Array.isArray(this.spatial_payload[0][0]) && typeof this.spatial_payload[0][0] === "number") {
                this.spatial_payload = [this.spatial_payload];
            }
            // Default fields if not provided
            if (this.spatial_payload_holes === undefined ||
                this.spatial_payload_child_indices === undefined) {
                // These will be populated later, during `process_resume_from`
                this.spatial_payload_holes = [false];
                this.spatial_payload_child_indices = [[]];
            }
            var indices_to_remove = [];
            // Simplify each layer of the polygon
            for (var i = 0; i < this.spatial_payload.length; i++) {
                var layer = this.spatial_payload[i];
                // Ensure that the layer is an array
                if (!Array.isArray(layer[0])) {
                    (0, error_logging_1.log_message)("Layer ".concat(i, " of id ").concat(this.id, " has an invalid or empty point array. Removing layer."), error_logging_1.LogLevel.WARNING, true);
                    indices_to_remove.push(i);
                    continue;
                }
                // Ensure that the layer has at least 4 points (3 unique points + 1 duplicate to close the polygon)
                if (layer.length === 3) {
                    // If the last point is NOT the same as the first, add the first point to the end
                    if (layer[0][0] !== layer[2][0] || layer[0][1] !== layer[2][1]) {
                        layer.push([
                            layer[0][0],
                            layer[0][1],
                        ]);
                    }
                }
                if (layer.length < 4) {
                    (0, error_logging_1.log_message)("Layer ".concat(i, " of id ").concat(this.id, " has fewer than 4 points. Removing layer."), error_logging_1.LogLevel.WARNING, true);
                    indices_to_remove.push(i);
                    continue;
                }
                // If the last point is NOT the same as the first, add the first point to the end
                if (layer[0][0] !== layer[layer.length - 1][0] || layer[0][1] !== layer[layer.length - 1][1]) {
                    layer.push([layer[0][0], layer[0][1]]);
                }
                try {
                    this.spatial_payload[i] = geometric_utils_1.GeometricUtils.turf_simplify_complex_polygon([layer])[0];
                }
                catch (error) {
                    (0, error_logging_1.log_message)("Error simplifying polygon layer ".concat(i, " of id ").concat(this.id, ". Removing layer. Error: ").concat(error.message), error_logging_1.LogLevel.WARNING, true);
                    indices_to_remove.push(i);
                }
            }
            // Remove layers that are too small
            for (var _i = 0, indices_to_remove_1 = indices_to_remove; _i < indices_to_remove_1.length; _i++) {
                var idx = indices_to_remove_1[_i];
                this.spatial_payload.splice(idx, 1);
            }
        }
        // Return true if we successfully made it here
        return true;
    };
    /**
     * Ensure each point in an annotation is within the image.
     *
     * @param {number} image_width Width of the image.
     * @param {number} image_height Height of the image.
     * @return {ULabelAnnotation} The annotation with the updated spatial payload.
     */
    ULabelAnnotation.prototype.clamp_annotation_to_image_bounds = function (image_width, image_height) {
        if (!this.is_delete_annotation()) {
            // Ensure each point in the payload is within the image
            // for polygons, we'll need to loop through all points
            var active_spatial_payload = this.spatial_payload;
            var n_iters = this.spatial_type === "polygon" ? this.spatial_payload.length : 1;
            for (var i = 0; i < n_iters; i++) {
                if (this.spatial_type === "polygon") {
                    active_spatial_payload = this.spatial_payload[i];
                }
                for (var j = 0; j < active_spatial_payload.length; j++) {
                    active_spatial_payload[j] = geometric_utils_1.GeometricUtils.clamp_point_to_image(active_spatial_payload[j], image_width, image_height);
                }
            }
        }
        // Return the annotation with the updated spatial payload
        return this;
    };
    /**
     * Check if the annotation is a delete annotation, e.g. annotations drawn by the `delete_polygon`
     * or `delete_bbox` annotation modes.
     *
     * @returns {boolean} True if the annotation is a delete annotation, false otherwise.
     */
    ULabelAnnotation.prototype.is_delete_annotation = function () {
        // Check if the annotation is a delete annotation
        return this.classification_payloads[0]["class_id"] === exports.DELETE_CLASS_ID;
    };
    ULabelAnnotation.from_json = function (json_block) {
        var ret = new ULabelAnnotation();
        Object.assign(ret, json_block);
        // Convert deprecated spatial payloads if necessary
        if (ret.ensure_compatible_spatial_payloads()) {
            return ret;
        }
        // Return null if the spatial payload is not compatible
        return null;
    };
    /**
     * Get the polygon spatial data from an annotation.
     *
     * @param {ULabelAnnotation} annotation  polygon annotation
     * @param {boolean} deep_copy whether to return a deep copy
     * @returns {PolygonSpatialData} polygon spatial data
     */
    ULabelAnnotation.get_polygon_spatial_data = function (annotation, deep_copy) {
        if (deep_copy === void 0) { deep_copy = false; }
        // Check if the annotation is a polygon
        if (annotation.spatial_type !== "polygon") {
            throw new Error("Annotation is not a polygon");
        }
        // Return the data, initializing the arrays if they are undefined
        var ret = {
            spatial_payload: annotation.spatial_payload,
            containing_box: annotation.containing_box ? annotation.containing_box : null,
            spatial_payload_holes: annotation.spatial_payload_holes ? annotation.spatial_payload_holes : [false],
            spatial_payload_child_indices: annotation.spatial_payload_child_indices ? annotation.spatial_payload_child_indices : [[]],
        };
        if (deep_copy) {
            return JSON.parse(JSON.stringify(ret));
        }
        else {
            return ret;
        }
    };
    return ULabelAnnotation;
}());
exports.ULabelAnnotation = ULabelAnnotation;


/***/ }),

/***/ 5638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Error handling utilities for ULabel.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = void 0;
exports.log_message = log_message;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["VERBOSE"] = 0] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
/**
 * Log a message to the console at a level.
 * This was ported from code that didn't use the console log levels,
 * and is kept for compatibility.
 *
 * @param message Message to log
 * @param log_level Level to log at
 */
function log_message(message, log_level, hide_alert) {
    if (log_level === void 0) { log_level = LogLevel.INFO; }
    if (hide_alert === void 0) { hide_alert = false; }
    switch (log_level) {
        case LogLevel.VERBOSE:
            console.debug(message);
            break;
        case LogLevel.INFO:
            console.log(message);
            break;
        case LogLevel.WARNING:
            console.warn(message);
            if (!hide_alert) {
                alert("[WARNING] " + message);
            }
            break;
        case LogLevel.ERROR:
            console.error(message);
            if (!hide_alert) {
                alert("[ERROR] " + message);
            }
            throw new Error(message);
    }
}


/***/ }),

/***/ 5681:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  bbox: () => (/* reexport */ bbox),
  feature: () => (/* reexport */ feature),
  merge: () => (/* reexport */ merge),
  mergeArcs: () => (/* reexport */ mergeArcs),
  mesh: () => (/* reexport */ mesh),
  meshArcs: () => (/* reexport */ meshArcs),
  neighbors: () => (/* reexport */ neighbors),
  quantize: () => (/* reexport */ quantize),
  transform: () => (/* reexport */ transform),
  untransform: () => (/* reexport */ untransform)
});

;// ./node_modules/topojson-client/src/identity.js
/* harmony default export */ function identity(x) {
  return x;
}

;// ./node_modules/topojson-client/src/transform.js


/* harmony default export */ function transform(transform) {
  if (transform == null) return identity;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}

;// ./node_modules/topojson-client/src/bbox.js


/* harmony default export */ function bbox(topology) {
  var t = transform(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}

;// ./node_modules/topojson-client/src/reverse.js
/* harmony default export */ function reverse(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}

;// ./node_modules/topojson-client/src/feature.js



/* harmony default export */ function feature(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature_feature(topology, o); })}
      : feature_feature(topology, o);
}

function feature_feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = transform(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) reverse(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}

;// ./node_modules/topojson-client/src/stitch.js
/* harmony default export */ function stitch(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}

;// ./node_modules/topojson-client/src/mesh.js



/* harmony default export */ function mesh(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: stitch(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}

;// ./node_modules/topojson-client/src/merge.js



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function merge(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = stitch(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}

;// ./node_modules/topojson-client/src/bisect.js
/* harmony default export */ function bisect(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}

;// ./node_modules/topojson-client/src/neighbors.js


/* harmony default export */ function neighbors(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}

;// ./node_modules/topojson-client/src/untransform.js


/* harmony default export */ function untransform(transform) {
  if (transform == null) return identity;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}

;// ./node_modules/topojson-client/src/quantize.js



/* harmony default export */ function quantize(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be 2");
    box = topology.bbox || bbox(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}

;// ./node_modules/topojson-client/src/index.js










/***/ }),

/***/ 5750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Annotation canvas utilities.
 * TODO (joshua-dean): Pull the rest of the canvas functions into here
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initialize_annotation_canvases = initialize_annotation_canvases;
var annotation_1 = __webpack_require__(5573);
var configuration_1 = __webpack_require__(496);
/**
 * If the user doesn't provide a number of annotations per canvas, set it dynamically.
 * This should help with performance.
 *
 * @param config ULabel configuration
 * @param subtasks ULabel subtasks
 */
function dynamically_set_n_annos_per_canvas(config, subtasks) {
    // If they didn't provide a value, we'll still be using the default
    if (config.n_annos_per_canvas === configuration_1.DEFAULT_N_ANNOS_PER_CANVAS) {
        // Count max annotations per subtask
        var max_annos = Math.max.apply(Math, Object.values(subtasks).map(function (subtask) { return subtask.annotations.ordering.length; }));
        // Performance starts to deteriorate when we require many canvases to be drawn on
        // To be safe, check if max_annos / DEFAULT_N_ANNOS_PER_CANVAS is greater than TARGET_MAX_N_CANVASES_PER_SUBTASK
        if (max_annos / configuration_1.DEFAULT_N_ANNOS_PER_CANVAS > configuration_1.TARGET_MAX_N_CANVASES_PER_SUBTASK) {
            // If so, raise the default
            config.n_annos_per_canvas = Math.ceil(max_annos / configuration_1.TARGET_MAX_N_CANVASES_PER_SUBTASK);
        }
    }
}
/**
 * Initialize annotation canvases and assign annotations to them
 *
 * @param ulabel ULabel instance
 * @param subtask_key Subtask key. If null, this will dynamically initialize for all subtasks.
 */
function initialize_annotation_canvases(ulabel, subtask_key) {
    if (subtask_key === void 0) { subtask_key = null; }
    if (subtask_key === null) {
        dynamically_set_n_annos_per_canvas(ulabel.config, ulabel.subtasks);
        for (var subtask_key_1 in ulabel.subtasks) {
            initialize_annotation_canvases(ulabel, subtask_key_1);
        }
        return;
    }
    // TODO (joshua-dean): shouldn't this just be a separate function?
    // Create the canvas for each annotation
    var subtask = ulabel.subtasks[subtask_key];
    for (var annotation_id in subtask.annotations.access) {
        var annotation = subtask.annotations.access[annotation_id];
        if (!annotation_1.NONSPATIAL_MODES.includes(annotation.spatial_type)) {
            annotation["canvas_id"] = ulabel.get_init_canvas_context_id(annotation_id, subtask_key);
        }
    }
}


/***/ }),

/***/ 5764:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var destination_1 = __importDefault(__webpack_require__(4202));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 *
 * @name circle
 * @param {Feature<Point>|number[]} center center point
 * @param {number} radius radius of the circle
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] properties
 * @returns {Feature<Polygon>} circle polygon
 * @example
 * var center = [-75.343, 39.984];
 * var radius = 5;
 * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
 * var circle = turf.circle(center, radius, options);
 *
 * //addToMap
 * var addToMap = [turf.point(center), circle]
 */
function circle(center, radius, options) {
    if (options === void 0) { options = {}; }
    // default params
    var steps = options.steps || 64;
    var properties = options.properties
        ? options.properties
        : !Array.isArray(center) && center.type === "Feature" && center.properties
            ? center.properties
            : {};
    // main
    var coordinates = [];
    for (var i = 0; i < steps; i++) {
        coordinates.push(destination_1.default(center, radius, (i * -360) / steps, options).geometry
            .coordinates);
    }
    coordinates.push(coordinates[0]);
    return helpers_1.polygon([coordinates], properties);
}
exports["default"] = circle;


/***/ }),

/***/ 5784:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bbox = __webpack_require__(4383);
var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);
var objectAssign = __webpack_require__(5228);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var objectAssign__default = /*#__PURE__*/_interopDefaultLegacy(objectAssign);

/**
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Compute the isocontour(s) of a scalar 2D field given
 * a certain threshold by applying the Marching Squares
 * Algorithm. The function returns a list of path coordinates
 */
var defaultSettings = {
  successCallback: null,
  verbose: false,
};

var settings = {};

function isoContours(data, threshold, options) {
  /* process options */
  options = options ? options : {};

  var optionKeys = Object.keys(defaultSettings);

  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val =
      typeof val !== "undefined" && val !== null ? val : defaultSettings[key];

    settings[key] = val;
  }

  if (settings.verbose)
    console.log(
      "MarchingSquaresJS-isoContours: computing isocontour for " + threshold
    );

  var ret = contourGrid2Paths(computeContourGrid(data, threshold));

  if (typeof settings.successCallback === "function")
    settings.successCallback(ret);

  return ret;
}

/*
  Thats all for the public interface, below follows the actual
  implementation
*/

/*
################################
Isocontour implementation below
################################
*/

/* assume that x1 == 1 &&  x0 == 0 */
function interpolateX(y, y0, y1) {
  return (y - y0) / (y1 - y0);
}

/* compute the isocontour 4-bit grid */
function computeContourGrid(data, threshold) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var ContourGrid = { rows: rows, cols: cols, cells: [] };

  for (var j = 0; j < rows; ++j) {
    ContourGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      /* compose the 4-bit corner representation */
      var cval = 0;

      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];

      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }
      cval |= tl >= threshold ? 8 : 0;
      cval |= tr >= threshold ? 4 : 0;
      cval |= br >= threshold ? 2 : 0;
      cval |= bl >= threshold ? 1 : 0;

      /* resolve ambiguity for cval == 5 || 10 via averaging */
      var flipped = false;
      if (cval === 5 || cval === 10) {
        var average = (tl + tr + br + bl) / 4;
        if (cval === 5 && average < threshold) {
          cval = 10;
          flipped = true;
        } else if (cval === 10 && average < threshold) {
          cval = 5;
          flipped = true;
        }
      }

      /* add cell to ContourGrid if it contains edges */
      if (cval !== 0 && cval !== 15) {
        var top, bottom, left, right;
        top = bottom = left = right = 0.5;
        /* interpolate edges of cell */
        if (cval === 1) {
          left = 1 - interpolateX(threshold, tl, bl);
          bottom = 1 - interpolateX(threshold, br, bl);
        } else if (cval === 2) {
          bottom = interpolateX(threshold, bl, br);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 3) {
          left = 1 - interpolateX(threshold, tl, bl);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 4) {
          top = interpolateX(threshold, tl, tr);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 5) {
          top = interpolateX(threshold, tl, tr);
          right = interpolateX(threshold, br, tr);
          bottom = 1 - interpolateX(threshold, br, bl);
          left = 1 - interpolateX(threshold, tl, bl);
        } else if (cval === 6) {
          bottom = interpolateX(threshold, bl, br);
          top = interpolateX(threshold, tl, tr);
        } else if (cval === 7) {
          left = 1 - interpolateX(threshold, tl, bl);
          top = interpolateX(threshold, tl, tr);
        } else if (cval === 8) {
          left = interpolateX(threshold, bl, tl);
          top = 1 - interpolateX(threshold, tr, tl);
        } else if (cval === 9) {
          bottom = 1 - interpolateX(threshold, br, bl);
          top = 1 - interpolateX(threshold, tr, tl);
        } else if (cval === 10) {
          top = 1 - interpolateX(threshold, tr, tl);
          right = 1 - interpolateX(threshold, tr, br);
          bottom = interpolateX(threshold, bl, br);
          left = interpolateX(threshold, bl, tl);
        } else if (cval === 11) {
          top = 1 - interpolateX(threshold, tr, tl);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 12) {
          left = interpolateX(threshold, bl, tl);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 13) {
          bottom = 1 - interpolateX(threshold, br, bl);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 14) {
          left = interpolateX(threshold, bl, tl);
          bottom = interpolateX(threshold, bl, br);
        } else {
          console.log(
            "MarchingSquaresJS-isoContours: Illegal cval detected: " + cval
          );
        }
        ContourGrid.cells[j][i] = {
          cval: cval,
          flipped: flipped,
          top: top,
          right: right,
          bottom: bottom,
          left: left,
        };
      }
    }
  }

  return ContourGrid;
}

function isSaddle(cell) {
  return cell.cval === 5 || cell.cval === 10;
}

function isTrivial(cell) {
  return cell.cval === 0 || cell.cval === 15;
}

function clearCell(cell) {
  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {
    cell.cval = 15;
  }
}

function getXY(cell, edge) {
  if (edge === "top") {
    return [cell.top, 1.0];
  } else if (edge === "bottom") {
    return [cell.bottom, 0.0];
  } else if (edge === "right") {
    return [1.0, cell.right];
  } else if (edge === "left") {
    return [0.0, cell.left];
  }
}

function contourGrid2Paths(grid) {
  var paths = [];
  var path_idx = 0;
  var epsilon = 1e-7;

  grid.cells.forEach(function (g, j) {
    g.forEach(function (gg, i) {
      if (typeof gg !== "undefined" && !isSaddle(gg) && !isTrivial(gg)) {
        var p = tracePath(grid.cells, j, i);
        var merged = false;
        /* we may try to merge paths at this point */
        if (p.info === "mergeable") {
          /*
            search backwards through the path array to find an entry
            that starts with where the current path ends...
          */
          var x = p.path[p.path.length - 1][0],
            y = p.path[p.path.length - 1][1];

          for (var k = path_idx - 1; k >= 0; k--) {
            if (
              Math.abs(paths[k][0][0] - x) <= epsilon &&
              Math.abs(paths[k][0][1] - y) <= epsilon
            ) {
              for (var l = p.path.length - 2; l >= 0; --l) {
                paths[k].unshift(p.path[l]);
              }
              merged = true;
              break;
            }
          }
        }
        if (!merged) paths[path_idx++] = p.path;
      }
    });
  });

  return paths;
}

/*
  construct consecutive line segments from starting cell by
  walking arround the enclosed area clock-wise
  */
function tracePath(grid, j, i) {
  var maxj = grid.length;
  var p = [];
  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];
  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];
  var dx, dy;
  var startEdge = [
    "none",
    "left",
    "bottom",
    "left",
    "right",
    "none",
    "bottom",
    "left",
    "top",
    "top",
    "none",
    "top",
    "right",
    "right",
    "bottom",
    "none",
  ];
  var nextEdge = [
    "none",
    "bottom",
    "right",
    "right",
    "top",
    "top",
    "top",
    "top",
    "left",
    "bottom",
    "right",
    "right",
    "left",
    "bottom",
    "left",
    "none",
  ];
  var edge;

  var currentCell = grid[j][i];

  var cval = currentCell.cval;
  var edge = startEdge[cval];

  var pt = getXY(currentCell, edge);

  /* push initial segment */
  p.push([i + pt[0], j + pt[1]]);
  edge = nextEdge[cval];
  pt = getXY(currentCell, edge);
  p.push([i + pt[0], j + pt[1]]);
  clearCell(currentCell);

  /* now walk arround the enclosed area in clockwise-direction */
  var k = i + dxContour[cval];
  var l = j + dyContour[cval];
  var prev_cval = cval;

  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {
    currentCell = grid[l][k];
    if (typeof currentCell === "undefined") {
      /* path ends here */
      //console.log(k + " " + l + " is undefined, stopping path!");
      break;
    }
    cval = currentCell.cval;
    if (cval === 0 || cval === 15) {
      return { path: p, info: "mergeable" };
    }
    edge = nextEdge[cval];
    dx = dxContour[cval];
    dy = dyContour[cval];
    if (cval === 5 || cval === 10) {
      /* select upper or lower band, depending on previous cells cval */
      if (cval === 5) {
        if (currentCell.flipped) {
          /* this is actually a flipped case 10 */
          if (dyContour[prev_cval] === -1) {
            edge = "left";
            dx = -1;
            dy = 0;
          } else {
            edge = "right";
            dx = 1;
            dy = 0;
          }
        } else {
          /* real case 5 */
          if (dxContour[prev_cval] === -1) {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        }
      } else if (cval === 10) {
        if (currentCell.flipped) {
          /* this is actually a flipped case 5 */
          if (dxContour[prev_cval] === -1) {
            edge = "top";
            dx = 0;
            dy = 1;
          } else {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        } else {
          /* real case 10 */
          if (dyContour[prev_cval] === 1) {
            edge = "left";
            dx = -1;
            dy = 0;
          }
        }
      }
    }
    pt = getXY(currentCell, edge);
    p.push([k + pt[0], l + pt[1]]);
    clearCell(currentCell);
    k += dx;
    l += dy;
    prev_cval = cval;
  }

  return { path: p, info: "closed" };
}

/**
 * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}
 * of the 'property' values
 *
 * @name gridToMatrix
 * @param {FeatureCollection<Point>} grid of points
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
 * @param {boolean} [options.flip=false] returns the matrix upside-down
 * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,
 * the grid points with coordinates on the matrix
 * @returns {Array<Array<number>>} matrix of property values
 * @example
 *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 *   var cellSize = 3;
 *   var grid = turf.pointGrid(extent, cellSize);
 *   // add a random property to each point between 0 and 60
 *   for (var i = 0; i < grid.features.length; i++) {
 *     grid.features[i].properties.elevation = (Math.random() * 60);
 *   }
 *   gridToMatrix(grid);
 *   //= [
 *     [ 1, 13, 10,  9, 10, 13, 18],
 *     [34,  8,  5,  4,  5,  8, 13],
 *     [10,  5,  2,  1,  2,  5,  4],
 *     [ 0,  4, 56, 19,  1,  4,  9],
 *     [10,  5,  2,  1,  2,  5, 10],
 *     [57,  8,  5,  4,  5,  0, 57],
 *     [ 3, 13, 10,  9,  5, 13, 18],
 *     [18, 13, 10,  9, 78, 13, 18]
 *   ]
 */
function gridToMatrix(grid, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip = options.flip;
  var flags = options.flags;

  // validation
  invariant.collectionOf(grid, "Point", "input must contain Points");

  var pointsMatrix = sortPointsByLatLng(grid, flip);

  var matrix = [];
  // create property matrix from sorted points
  // looping order matters here
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point = pointRow[c];
      // Check if zProperty exist
      if (point.properties[zProperty]) row.push(point.properties[zProperty]);
      else row.push(0);
      // add flags
      if (flags === true) point.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }

  return matrix;
}

/**
 * Sorts points by latitude and longitude, creating a 2-dimensional array of points
 *
 * @private
 * @param {FeatureCollection<Point>} points GeoJSON Point features
 * @param {boolean} [flip=false] returns the matrix upside-down
 * @returns {Array<Array<Point>>} points ordered by latitude and longitude
 */
function sortPointsByLatLng(points, flip) {
  var pointsByLatitude = {};

  // divide points by rows with the same latitude
  meta.featureEach(points, function (point) {
    var lat = invariant.getCoords(point)[1];
    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
    pointsByLatitude[lat].push(point);
  });

  // sort points (with the same latitude) by longitude
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {
    var row = pointsByLatitude[lat];
    var rowOrderedByLongitude = row.sort(function (a, b) {
      return invariant.getCoords(a)[0] - invariant.getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });

  // sort rows (of points with the same latitude) by latitude
  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {
    if (flip) return invariant.getCoords(a[0])[1] - invariant.getCoords(b[0])[1];
    else return invariant.getCoords(b[0])[1] - invariant.getCoords(a[0])[1];
  });

  return pointMatrix;
}

/**
 * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of
 * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).
 *
 * @name isolines
 * @param {FeatureCollection<Point>} pointGrid input points
 * @param {Array<number>} breaks values of `zProperty` where to draw isolines
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
 * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines
 * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;
 * the breaks array will define the order in which the isolines are created
 * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines
 * @example
 * // create a grid of points with random z-values in their properties
 * var extent = [0, 30, 20, 50];
 * var cellWidth = 100;
 * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});
 *
 * for (var i = 0; i < pointGrid.features.length; i++) {
 *     pointGrid.features[i].properties.temperature = Math.random() * 10;
 * }
 * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 *
 * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});
 *
 * //addToMap
 * var addToMap = [lines];
 */
function isolines(pointGrid, breaks, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];

  // Input validation
  invariant.collectionOf(pointGrid, "Point", "Input must contain Points");
  if (!breaks) throw new Error("breaks is required");
  if (!Array.isArray(breaks)) throw new Error("breaks must be an Array");
  if (!helpers.isObject(commonProperties))
    throw new Error("commonProperties must be an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties must be an Array");

  // Isoline methods
  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });
  var createdIsoLines = createIsoLines(
    matrix,
    breaks,
    zProperty,
    commonProperties,
    breaksProperties
  );
  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);

  return helpers.featureCollection(scaledIsolines);
}

/**
 * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid
 *
 * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it
 * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be
 * rescaled, with turfjs, to the original area and proportions on the map
 *
 * @private
 * @param {Array<Array<number>>} matrix Grid Data
 * @param {Array<number>} breaks Breaks
 * @param {string} zProperty name of the z-values property
 * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines
 * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline
 * @returns {Array<MultiLineString>} isolines
 */
function createIsoLines(
  matrix,
  breaks,
  zProperty,
  commonProperties,
  breaksProperties
) {
  var results = [];
  for (var i = 1; i < breaks.length; i++) {
    var threshold = +breaks[i]; // make sure it's a number

    var properties = objectAssign__default['default']({}, commonProperties, breaksProperties[i]);
    properties[zProperty] = threshold;
    var isoline = helpers.multiLineString(isoContours(matrix, threshold), properties);

    results.push(isoline);
  }
  return results;
}

/**
 * Translates and scales isolines
 *
 * @private
 * @param {Array<MultiLineString>} createdIsoLines to be rescaled
 * @param {Array<Array<number>>} matrix Grid Data
 * @param {Object} points Points by Latitude
 * @returns {Array<MultiLineString>} isolines
 */
function rescaleIsolines(createdIsoLines, matrix, points) {
  // get dimensions (on the map) of the original grid
  var gridBbox = bbox__default['default'](points); // [ minX, minY, maxX, maxY ]
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];

  // get origin, which is the first point of the last row on the rectangular data on the map
  var x0 = gridBbox[0];
  var y0 = gridBbox[1];

  // get number of cells per side
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;

  // calculate the scaling factor between matrix and rectangular grid on the map
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;

  var resize = function (point) {
    point[0] = point[0] * scaleX + x0;
    point[1] = point[1] * scaleY + y0;
  };

  // resize and shift each point/line of the createdIsoLines
  createdIsoLines.forEach(function (isoline) {
    meta.coordEach(isoline, resize);
  });
  return createdIsoLines;
}

module.exports = isolines;
module.exports["default"] = isolines;


/***/ }),

/***/ 5795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(6549);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 5810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Distance = __webpack_require__(6766),
    eudist = Distance.eudist,
    dist = Distance.dist;

module.exports = {
	kmrand: function kmrand(data, k) {
		var map = {},
		    ks = [],
		    t = k << 2;
		var len = data.length;
		var multi = data[0].length > 0;

		while (ks.length < k && t-- > 0) {
			var d = data[Math.floor(Math.random() * len)];
			var key = multi ? d.join("_") : "" + d;
			if (!map[key]) {
				map[key] = true;
				ks.push(d);
			}
		}

		if (ks.length < k) throw new Error("Error initializating clusters");else return ks;
	},


	/**
  * K-means++ initial centroid selection
  */
	kmpp: function kmpp(data, k) {
		var distance = data[0].length ? eudist : dist;
		var ks = [],
		    len = data.length;
		var multi = data[0].length > 0;
		var map = {};

		// First random centroid
		var c = data[Math.floor(Math.random() * len)];
		var key = multi ? c.join("_") : "" + c;
		ks.push(c);
		map[key] = true;

		// Retrieve next centroids
		while (ks.length < k) {
			// Min Distances between current centroids and data points
			var dists = [],
			    lk = ks.length;
			var dsum = 0,
			    prs = [];

			for (var i = 0; i < len; i++) {
				var min = Infinity;
				for (var j = 0; j < lk; j++) {
					var _dist = distance(data[i], ks[j]);
					if (_dist <= min) min = _dist;
				}
				dists[i] = min;
			}

			// Sum all min distances
			for (var _i = 0; _i < len; _i++) {
				dsum += dists[_i];
			}

			// Probabilities and cummulative prob (cumsum)
			for (var _i2 = 0; _i2 < len; _i2++) {
				prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
			}

			// Sort Probabilities
			prs.sort(function (a, b) {
				return a.pr - b.pr;
			});

			// Cummulative Probabilities
			prs[0].cs = prs[0].pr;
			for (var _i3 = 1; _i3 < len; _i3++) {
				prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
			}

			// Randomize
			var rnd = Math.random();

			// Gets only the items whose cumsum >= rnd
			var idx = 0;
			while (idx < len - 1 && prs[idx++].cs < rnd) {}
			ks.push(prs[idx - 1].v);
			/*
   let done = false;
   while(!done) {
   	// this is our new centroid
   	c = prs[idx-1].v
   	key = multi? c.join("_") : `${c}`;
   	if(!map[key]) {
   		map[key] = true;
   		ks.push(c);
   		done = true;
   	}
   	else {
   		idx++;
   	}
   }
   */
		}

		return ks;
	}
};
//# sourceMappingURL=kinit.js.map


/***/ }),

/***/ 5848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var rbush = __webpack_require__(4945);
var square = __webpack_require__(2363);
var bbox = __webpack_require__(4383);
var truncate = __webpack_require__(6834);
var lineSegment = __webpack_require__(7042);
var lineIntersect = __webpack_require__(3154);
var nearestPointOnLine = __webpack_require__(7696);
var invariant = __webpack_require__(8506);
var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var rbush__default = /*#__PURE__*/_interopDefaultLegacy(rbush);
var square__default = /*#__PURE__*/_interopDefaultLegacy(square);
var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var truncate__default = /*#__PURE__*/_interopDefaultLegacy(truncate);
var lineSegment__default = /*#__PURE__*/_interopDefaultLegacy(lineSegment);
var lineIntersect__default = /*#__PURE__*/_interopDefaultLegacy(lineIntersect);
var nearestPointOnLine__default = /*#__PURE__*/_interopDefaultLegacy(nearestPointOnLine);

/**
 * Split a LineString by another GeoJSON Feature.
 *
 * @name lineSplit
 * @param {Feature<LineString>} line LineString Feature to split
 * @param {Feature<any>} splitter Feature used to split line
 * @returns {FeatureCollection<LineString>} Split LineStrings
 * @example
 * var line = turf.lineString([[120, -25], [145, -25]]);
 * var splitter = turf.lineString([[130, -15], [130, -35]]);
 *
 * var split = turf.lineSplit(line, splitter);
 *
 * //addToMap
 * var addToMap = [line, splitter]
 */
function lineSplit(line, splitter) {
  if (!line) throw new Error("line is required");
  if (!splitter) throw new Error("splitter is required");

  var lineType = invariant.getType(line);
  var splitterType = invariant.getType(splitter);

  if (lineType !== "LineString") throw new Error("line must be LineString");
  if (splitterType === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (splitterType === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");

  // remove excessive decimals from splitter
  // to avoid possible approximation issues in rbush
  var truncatedSplitter = truncate__default['default'](splitter, { precision: 7 });

  switch (splitterType) {
    case "Point":
      return splitLineWithPoint(line, truncatedSplitter);
    case "MultiPoint":
      return splitLineWithPoints(line, truncatedSplitter);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return splitLineWithPoints(line, lineIntersect__default['default'](line, truncatedSplitter));
  }
}

/**
 * Split LineString with MultiPoint
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {FeatureCollection<Point>} splitter Point
 * @returns {FeatureCollection<LineString>} split LineStrings
 */
function splitLineWithPoints(line, splitter) {
  var results = [];
  var tree = rbush__default['default']();

  meta.flattenEach(splitter, function (point) {
    // Add index/id to features (needed for filter)
    results.forEach(function (feature, index) {
      feature.id = index;
    });
    // First Point - doesn't need to handle any previous line results
    if (!results.length) {
      results = splitLineWithPoint(line, point).features;

      // Add Square BBox to each feature for GeoJSON-RBush
      results.forEach(function (feature) {
        if (!feature.bbox) feature.bbox = square__default['default'](bbox__default['default'](feature));
      });
      tree.load(helpers.featureCollection(results));
      // Split with remaining points - lines might needed to be split multiple times
    } else {
      // Find all lines that are within the splitter's bbox
      var search = tree.search(point);

      if (search.features.length) {
        // RBush might return multiple lines - only process the closest line to splitter
        var closestLine = findClosestFeature(point, search);

        // Remove closest line from results since this will be split into two lines
        // This removes any duplicates inside the results & index
        results = results.filter(function (feature) {
          return feature.id !== closestLine.id;
        });
        tree.remove(closestLine);

        // Append the two newly split lines into the results
        meta.featureEach(splitLineWithPoint(closestLine, point), function (line) {
          results.push(line);
          tree.insert(line);
        });
      }
    }
  });
  return helpers.featureCollection(results);
}

/**
 * Split LineString with Point
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<Point>} splitter Point
 * @returns {FeatureCollection<LineString>} split LineStrings
 */
function splitLineWithPoint(line, splitter) {
  var results = [];

  // handle endpoints
  var startPoint = invariant.getCoords(line)[0];
  var endPoint = invariant.getCoords(line)[line.geometry.coordinates.length - 1];
  if (
    pointsEquals(startPoint, invariant.getCoord(splitter)) ||
    pointsEquals(endPoint, invariant.getCoord(splitter))
  )
    return helpers.featureCollection([line]);

  // Create spatial index
  var tree = rbush__default['default']();
  var segments = lineSegment__default['default'](line);
  tree.load(segments);

  // Find all segments that are within bbox of splitter
  var search = tree.search(splitter);

  // Return itself if point is not within spatial index
  if (!search.features.length) return helpers.featureCollection([line]);

  // RBush might return multiple lines - only process the closest line to splitter
  var closestSegment = findClosestFeature(splitter, search);

  // Initial value is the first point of the first segments (beginning of line)
  var initialValue = [startPoint];
  var lastCoords = meta.featureReduce(
    segments,
    function (previous, current, index) {
      var currentCoords = invariant.getCoords(current)[1];
      var splitterCoords = invariant.getCoord(splitter);

      // Location where segment intersects with line
      if (index === closestSegment.id) {
        previous.push(splitterCoords);
        results.push(helpers.lineString(previous));
        // Don't duplicate splitter coordinate (Issue #688)
        if (pointsEquals(splitterCoords, currentCoords))
          return [splitterCoords];
        return [splitterCoords, currentCoords];

        // Keep iterating over coords until finished or intersection is found
      } else {
        previous.push(currentCoords);
        return previous;
      }
    },
    initialValue
  );
  // Append last line to final split results
  if (lastCoords.length > 1) {
    results.push(helpers.lineString(lastCoords));
  }
  return helpers.featureCollection(results);
}

/**
 * Find Closest Feature
 *
 * @private
 * @param {Feature<Point>} point Feature must be closest to this point
 * @param {FeatureCollection<LineString>} lines Collection of Features
 * @returns {Feature<LineString>} closest LineString
 */
function findClosestFeature(point, lines) {
  if (!lines.features.length) throw new Error("lines must contain features");
  // Filter to one segment that is the closest to the line
  if (lines.features.length === 1) return lines.features[0];

  var closestFeature;
  var closestDistance = Infinity;
  meta.featureEach(lines, function (segment) {
    var pt = nearestPointOnLine__default['default'](segment, point);
    var dist = pt.properties.dist;
    if (dist < closestDistance) {
      closestFeature = segment;
      closestDistance = dist;
    }
  });
  return closestFeature;
}

/**
 * Compares two points and returns if they are equals
 *
 * @private
 * @param {Array<number>} pt1 point
 * @param {Array<number>} pt2 point
 * @returns {boolean} true if they are equals
 */
function pointsEquals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}

module.exports = lineSplit;
module.exports["default"] = lineSplit;


/***/ }),

/***/ 5880:
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 5943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
/**
 * Get Cluster
 *
 * @name getCluster
 * @param {FeatureCollection} geojson GeoJSON Features
 * @param {*} filter Filter used on GeoJSON properties to get Cluster
 * @returns {FeatureCollection} Single Cluster filtered by GeoJSON Properties
 * @example
 * var geojson = turf.featureCollection([
 *     turf.point([0, 0], {'marker-symbol': 'circle'}),
 *     turf.point([2, 4], {'marker-symbol': 'star'}),
 *     turf.point([3, 6], {'marker-symbol': 'star'}),
 *     turf.point([5, 1], {'marker-symbol': 'square'}),
 *     turf.point([4, 2], {'marker-symbol': 'circle'})
 * ]);
 *
 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
 * var clustered = turf.clustersKmeans(geojson);
 *
 * // Retrieve first cluster (0)
 * var cluster = turf.getCluster(clustered, {cluster: 0});
 * //= cluster
 *
 * // Retrieve cluster based on custom properties
 * turf.getCluster(clustered, {'marker-symbol': 'circle'}).length;
 * //= 2
 * turf.getCluster(clustered, {'marker-symbol': 'square'}).length;
 * //= 1
 */
function getCluster(geojson, filter) {
    // Validation
    if (!geojson)
        throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection")
        throw new Error("geojson must be a FeatureCollection");
    if (filter === undefined || filter === null)
        throw new Error("filter is required");
    // Filter Features
    var features = [];
    meta_1.featureEach(geojson, function (feature) {
        if (applyFilter(feature.properties, filter))
            features.push(feature);
    });
    return helpers_1.featureCollection(features);
}
exports.getCluster = getCluster;
/**
 * Callback for clusterEach
 *
 * @callback clusterEachCallback
 * @param {FeatureCollection} [cluster] The current cluster being processed.
 * @param {*} [clusterValue] Value used to create cluster being processed.
 * @param {number} [currentIndex] The index of the current element being processed in the array.Starts at index 0
 * @returns {void}
 */
/**
 * clusterEach
 *
 * @name clusterEach
 * @param {FeatureCollection} geojson GeoJSON Features
 * @param {string|number} property GeoJSON property key/value used to create clusters
 * @param {Function} callback a method that takes (cluster, clusterValue, currentIndex)
 * @returns {void}
 * @example
 * var geojson = turf.featureCollection([
 *     turf.point([0, 0]),
 *     turf.point([2, 4]),
 *     turf.point([3, 6]),
 *     turf.point([5, 1]),
 *     turf.point([4, 2])
 * ]);
 *
 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
 * var clustered = turf.clustersKmeans(geojson);
 *
 * // Iterate over each cluster
 * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue, currentIndex) {
 *     //= cluster
 *     //= clusterValue
 *     //= currentIndex
 * })
 *
 * // Calculate the total number of clusters
 * var total = 0
 * turf.clusterEach(clustered, 'cluster', function () {
 *     total++;
 * });
 *
 * // Create an Array of all the values retrieved from the 'cluster' property
 * var values = []
 * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue) {
 *     values.push(clusterValue);
 * });
 */
function clusterEach(geojson, property, callback) {
    // Validation
    if (!geojson)
        throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection")
        throw new Error("geojson must be a FeatureCollection");
    if (property === undefined || property === null)
        throw new Error("property is required");
    // Create clusters based on property values
    var bins = createBins(geojson, property);
    var values = Object.keys(bins);
    for (var index = 0; index < values.length; index++) {
        var value = values[index];
        var bin = bins[value];
        var features = [];
        for (var i = 0; i < bin.length; i++) {
            features.push(geojson.features[bin[i]]);
        }
        callback(helpers_1.featureCollection(features), value, index);
    }
}
exports.clusterEach = clusterEach;
/**
 * Callback for clusterReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback clusterReduceCallback
 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {FeatureCollection} [cluster] The current cluster being processed.
 * @param {*} [clusterValue] Value used to create cluster being processed.
 * @param {number} [currentIndex] The index of the current element being processed in the
 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */
/**
 * Reduce clusters in GeoJSON Features, similar to Array.reduce()
 *
 * @name clusterReduce
 * @param {FeatureCollection} geojson GeoJSON Features
 * @param {string|number} property GeoJSON property key/value used to create clusters
 * @param {Function} callback a method that takes (previousValue, cluster, clusterValue, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var geojson = turf.featureCollection([
 *     turf.point([0, 0]),
 *     turf.point([2, 4]),
 *     turf.point([3, 6]),
 *     turf.point([5, 1]),
 *     turf.point([4, 2])
 * ]);
 *
 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
 * var clustered = turf.clustersKmeans(geojson);
 *
 * // Iterate over each cluster and perform a calculation
 * var initialValue = 0
 * turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue, currentIndex) {
 *     //=previousValue
 *     //=cluster
 *     //=clusterValue
 *     //=currentIndex
 *     return previousValue++;
 * }, initialValue);
 *
 * // Calculate the total number of clusters
 * var total = turf.clusterReduce(clustered, 'cluster', function (previousValue) {
 *     return previousValue++;
 * }, 0);
 *
 * // Create an Array of all the values retrieved from the 'cluster' property
 * var values = turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue) {
 *     return previousValue.concat(clusterValue);
 * }, []);
 */
function clusterReduce(geojson, property, callback, initialValue) {
    var previousValue = initialValue;
    clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined)
            previousValue = cluster;
        else
            previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
    });
    return previousValue;
}
exports.clusterReduce = clusterReduce;
/**
 * Create Bins
 *
 * @private
 * @param {FeatureCollection} geojson GeoJSON Features
 * @param {string|number} property Property values are used to create bins
 * @returns {Object} bins with Feature IDs
 * @example
 * var geojson = turf.featureCollection([
 *     turf.point([0, 0], {cluster: 0, foo: 'null'}),
 *     turf.point([2, 4], {cluster: 1, foo: 'bar'}),
 *     turf.point([5, 1], {0: 'foo'}),
 *     turf.point([3, 6], {cluster: 1}),
 * ]);
 * createBins(geojson, 'cluster');
 * //= { '0': [ 0 ], '1': [ 1, 3 ] }
 */
function createBins(geojson, property) {
    var bins = {};
    meta_1.featureEach(geojson, function (feature, i) {
        var properties = feature.properties || {};
        if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
            var value = properties[property];
            if (Object.prototype.hasOwnProperty.call(bins, value))
                bins[value].push(i);
            else
                bins[value] = [i];
        }
    });
    return bins;
}
exports.createBins = createBins;
/**
 * Apply Filter
 *
 * @private
 * @param {*} properties Properties
 * @param {*} filter Filter
 * @returns {boolean} applied Filter to properties
 */
function applyFilter(properties, filter) {
    if (properties === undefined)
        return false;
    var filterType = typeof filter;
    // String & Number
    if (filterType === "number" || filterType === "string")
        return Object.prototype.hasOwnProperty.call(properties, filter);
    // Array
    else if (Array.isArray(filter)) {
        for (var i = 0; i < filter.length; i++) {
            if (!applyFilter(properties, filter[i]))
                return false;
        }
        return true;
        // Object
    }
    else {
        return propertiesContainsFilter(properties, filter);
    }
}
exports.applyFilter = applyFilter;
/**
 * Properties contains filter (does not apply deepEqual operations)
 *
 * @private
 * @param {*} properties Properties
 * @param {Object} filter Filter
 * @returns {boolean} does filter equal Properties
 * @example
 * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 0})
 * //= true
 * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 1})
 * //= false
 */
function propertiesContainsFilter(properties, filter) {
    var keys = Object.keys(filter);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (properties[key] !== filter[key])
            return false;
    }
    return true;
}
exports.propertiesContainsFilter = propertiesContainsFilter;
/**
 * Filter Properties
 *
 * @private
 * @param {*} properties Properties
 * @param {Array<string>} keys Used to filter Properties
 * @returns {*} filtered Properties
 * @example
 * filterProperties({foo: 'bar', cluster: 0}, ['cluster'])
 * //= {cluster: 0}
 */
function filterProperties(properties, keys) {
    if (!keys)
        return {};
    if (!keys.length)
        return {};
    var newProperties = {};
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (Object.prototype.hasOwnProperty.call(properties, key))
            newProperties[key] = properties[key];
    }
    return newProperties;
}
exports.filterProperties = filterProperties;


/***/ }),

/***/ 6088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var util_1 = __webpack_require__(4898);
/**
 * This class is inspired by GEOS's geos::operation::polygonize::PolygonizeDirectedEdge
 */
var Edge = /** @class */ (function () {
    /**
     * @param {Node} from - start node of the Edge
     * @param {Node} to - end node of the edge
     */
    function Edge(from, to) {
        this.from = from; //< start
        this.to = to; //< End
        this.next = undefined; //< The edge to be computed after
        this.label = undefined; //< Used in order to detect Cut Edges (Bridges)
        this.symetric = undefined; //< The symetric edge of this
        this.ring = undefined; //< EdgeRing in which the Edge is
        this.from.addOuterEdge(this);
        this.to.addInnerEdge(this);
    }
    /**
     * Creates or get the symetric Edge.
     *
     * @returns {Edge} - Symetric Edge.
     */
    Edge.prototype.getSymetric = function () {
        if (!this.symetric) {
            this.symetric = new Edge(this.to, this.from);
            this.symetric.symetric = this;
        }
        return this.symetric;
    };
    /**
     * Removes edge from from and to nodes.
     */
    Edge.prototype.deleteEdge = function () {
        this.from.removeOuterEdge(this);
        this.to.removeInnerEdge(this);
    };
    /**
     * Compares Edge equallity.
     *
     * An edge is equal to another, if the from and to nodes are the same.
     *
     * @param {Edge} edge - Another Edge
     * @returns {boolean} - True if Edges are equal, False otherwise
     */
    Edge.prototype.isEqual = function (edge) {
        return this.from.id === edge.from.id && this.to.id === edge.to.id;
    };
    Edge.prototype.toString = function () {
        return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    };
    /**
     * Returns a LineString representation of the Edge
     *
     * @returns {Feature<LineString>} - LineString representation of the Edge
     */
    Edge.prototype.toLineString = function () {
        return helpers_1.lineString([this.from.coordinates, this.to.coordinates]);
    };
    /**
     * Comparator of two edges.
     *
     * Implementation of geos::planargraph::DirectedEdge::compareTo.
     *
     * @param {Edge} edge - Another edge to compare with this one
     * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,
     *          0 if the Edges are colinear,
     *          1 otherwise
     */
    Edge.prototype.compareTo = function (edge) {
        return util_1.orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    };
    return Edge;
}());
exports["default"] = Edge;


/***/ }),

/***/ 6112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


if ( true && module.exports) {
    module.exports = {
      DBSCAN: __webpack_require__(3509),
      KMEANS: __webpack_require__(2347),
      OPTICS: __webpack_require__(5172),
      PriorityQueue: __webpack_require__(1283)
    };
}


/***/ }),

/***/ 6188:
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 6320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var convex_1 = __importDefault(__webpack_require__(1207));
var centroid_1 = __importDefault(__webpack_require__(4408));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
/**
 * Takes any {@link Feature} or a {@link FeatureCollection} and returns its [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) using this formula: [Centroid of Polygon](https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon).
 *
 * @name centerOfMass
 * @param {GeoJSON} geojson GeoJSON to be centered
 * @param {Object} [options={}] Optional Parameters
 * @param {Object} [options.properties={}] Translate Properties to Feature
 * @returns {Feature<Point>} the center of mass
 * @example
 * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
 *
 * var center = turf.centerOfMass(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, center]
 */
function centerOfMass(geojson, options) {
    if (options === void 0) { options = {}; }
    switch (invariant_1.getType(geojson)) {
        case "Point":
            return helpers_1.point(invariant_1.getCoord(geojson), options.properties);
        case "Polygon":
            var coords = [];
            meta_1.coordEach(geojson, function (coord) {
                coords.push(coord);
            });
            // First, we neutralize the feature (set it around coordinates [0,0]) to prevent rounding errors
            // We take any point to translate all the points around 0
            var centre = centroid_1.default(geojson, { properties: options.properties });
            var translation = centre.geometry.coordinates;
            var sx = 0;
            var sy = 0;
            var sArea = 0;
            var i, pi, pj, xi, xj, yi, yj, a;
            var neutralizedPoints = coords.map(function (point) {
                return [point[0] - translation[0], point[1] - translation[1]];
            });
            for (i = 0; i < coords.length - 1; i++) {
                // pi is the current point
                pi = neutralizedPoints[i];
                xi = pi[0];
                yi = pi[1];
                // pj is the next point (pi+1)
                pj = neutralizedPoints[i + 1];
                xj = pj[0];
                yj = pj[1];
                // a is the common factor to compute the signed area and the final coordinates
                a = xi * yj - xj * yi;
                // sArea is the sum used to compute the signed area
                sArea += a;
                // sx and sy are the sums used to compute the final coordinates
                sx += (xi + xj) * a;
                sy += (yi + yj) * a;
            }
            // Shape has no area: fallback on turf.centroid
            if (sArea === 0) {
                return centre;
            }
            else {
                // Compute the signed area, and factorize 1/6A
                var area = sArea * 0.5;
                var areaFactor = 1 / (6 * area);
                // Compute the final coordinates, adding back the values that have been neutralized
                return helpers_1.point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);
            }
        default:
            // Not a polygon: Compute the convex hull and work with that
            var hull = convex_1.default(geojson);
            if (hull)
                return centerOfMass(hull, { properties: options.properties });
            // Hull is empty: fallback on the centroid
            else
                return centroid_1.default(geojson, { properties: options.properties });
    }
}
exports["default"] = centerOfMass;


/***/ }),

/***/ 6432:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pointInPolygon = __webpack_require__(2446);
var helpers = __webpack_require__(8967);
var meta = __webpack_require__(8421);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(pointInPolygon);

/**
 * Finds {@link Points} or {@link MultiPoint} coordinate positions that fall within {@link (Multi)Polygon(s)}.
 *
 * @name pointsWithinPolygon
 * @param {Feature|FeatureCollection<Point|MultiPoint>} points Point(s) or MultiPoint(s) as input search
 * @param {FeatureCollection|Geometry|Feature<Polygon|MultiPolygon>} polygons (Multi)Polygon(s) to check if points are within
 * @returns {FeatureCollection<Point|MultiPoint>} Point(s) or MultiPoint(s) with positions that land within at least one polygon.  The geometry type will match what was passsed in
 * @example
 * var points = turf.points([
 *     [-46.6318, -23.5523],
 *     [-46.6246, -23.5325],
 *     [-46.6062, -23.5513],
 *     [-46.663, -23.554],
 *     [-46.643, -23.557]
 * ]);
 *
 * var searchWithin = turf.polygon([[
 *     [-46.653,-23.543],
 *     [-46.634,-23.5346],
 *     [-46.613,-23.543],
 *     [-46.614,-23.559],
 *     [-46.631,-23.567],
 *     [-46.653,-23.560],
 *     [-46.653,-23.543]
 * ]]);
 *
 * var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
 *
 * //addToMap
 * var addToMap = [points, searchWithin, ptsWithin]
 * turf.featureEach(ptsWithin, function (currentFeature) {
 *   currentFeature.properties['marker-size'] = 'large';
 *   currentFeature.properties['marker-color'] = '#000';
 * });
 */
function pointsWithinPolygon(points, polygons) {
  var results = [];
  meta.featureEach(points, function (point) {
    var contained = false;
    if (point.geometry.type === "Point") {
      meta.geomEach(polygons, function (polygon) {
        if (pointInPolygon__default['default'](point, polygon)) contained = true;
      });
      if (contained) {
        results.push(point);
      }
    } else if (point.geometry.type === "MultiPoint") {
      var pointsWithin = [];
      meta.geomEach(polygons, function (polygon) {
        meta.coordEach(point, function (pointCoord) {
          if (pointInPolygon__default['default'](pointCoord, polygon)) {
            contained = true;
            pointsWithin.push(pointCoord);
          }
        });
      });
      if (contained) {
        results.push(helpers.multiPoint(pointsWithin));
      }
    } else {
      throw new Error("Input geometry must be a Point or MultiPoint");
    }
  });
  return helpers.featureCollection(results);
}

module.exports = pointsWithinPolygon;
module.exports["default"] = pointsWithinPolygon;


/***/ }),

/***/ 6518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __webpack_require__(4898);
/**
 * Node
 */
var Node = /** @class */ (function () {
    function Node(coordinates) {
        this.id = Node.buildId(coordinates);
        this.coordinates = coordinates; //< {Number[]}
        this.innerEdges = []; //< {Edge[]}
        // We wil store to (out) edges in an CCW order as geos::planargraph::DirectedEdgeStar does
        this.outerEdges = []; //< {Edge[]}
        this.outerEdgesSorted = false; //< {Boolean} flag that stores if the outer Edges had been sorted
    }
    Node.buildId = function (coordinates) {
        return coordinates.join(",");
    };
    Node.prototype.removeInnerEdge = function (edge) {
        this.innerEdges = this.innerEdges.filter(function (e) { return e.from.id !== edge.from.id; });
    };
    Node.prototype.removeOuterEdge = function (edge) {
        this.outerEdges = this.outerEdges.filter(function (e) { return e.to.id !== edge.to.id; });
    };
    /**
     * Outer edges are stored CCW order.
     *
     * @memberof Node
     * @param {Edge} edge - Edge to add as an outerEdge.
     */
    Node.prototype.addOuterEdge = function (edge) {
        this.outerEdges.push(edge);
        this.outerEdgesSorted = false;
    };
    /**
     * Sorts outer edges in CCW way.
     *
     * @memberof Node
     * @private
     */
    Node.prototype.sortOuterEdges = function () {
        var _this = this;
        if (!this.outerEdgesSorted) {
            //this.outerEdges.sort((a, b) => a.compareTo(b));
            // Using this comparator in order to be deterministic
            this.outerEdges.sort(function (a, b) {
                var aNode = a.to, bNode = b.to;
                if (aNode.coordinates[0] - _this.coordinates[0] >= 0 &&
                    bNode.coordinates[0] - _this.coordinates[0] < 0)
                    return 1;
                if (aNode.coordinates[0] - _this.coordinates[0] < 0 &&
                    bNode.coordinates[0] - _this.coordinates[0] >= 0)
                    return -1;
                if (aNode.coordinates[0] - _this.coordinates[0] === 0 &&
                    bNode.coordinates[0] - _this.coordinates[0] === 0) {
                    if (aNode.coordinates[1] - _this.coordinates[1] >= 0 ||
                        bNode.coordinates[1] - _this.coordinates[1] >= 0)
                        return aNode.coordinates[1] - bNode.coordinates[1];
                    return bNode.coordinates[1] - aNode.coordinates[1];
                }
                var det = util_1.orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
                if (det < 0)
                    return 1;
                if (det > 0)
                    return -1;
                var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) +
                    Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) +
                    Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
                return d1 - d2;
            });
            this.outerEdgesSorted = true;
        }
    };
    /**
     * Retrieves outer edges.
     *
     * They are sorted if they aren't in the CCW order.
     *
     * @memberof Node
     * @returns {Edge[]} - List of outer edges sorted in a CCW order.
     */
    Node.prototype.getOuterEdges = function () {
        this.sortOuterEdges();
        return this.outerEdges;
    };
    Node.prototype.getOuterEdge = function (i) {
        this.sortOuterEdges();
        return this.outerEdges[i];
    };
    Node.prototype.addInnerEdge = function (edge) {
        this.innerEdges.push(edge);
    };
    return Node;
}());
exports["default"] = Node;


/***/ }),

/***/ 6549:
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 6570:
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ 6576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(9394);
var define = __webpack_require__(8452);

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 6649:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bbox_1 = __importDefault(__webpack_require__(4383));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
 *
 * @name center
 * @param {GeoJSON} geojson GeoJSON to be centered
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
 * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
 * @param {Object} [options.id={}] Translate GeoJSON Id to Point
 * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
 * @example
 * var features = turf.points([
 *   [-97.522259, 35.4691],
 *   [-97.502754, 35.463455],
 *   [-97.508269, 35.463245]
 * ]);
 *
 * var center = turf.center(features);
 *
 * //addToMap
 * var addToMap = [features, center]
 * center.properties['marker-size'] = 'large';
 * center.properties['marker-color'] = '#000';
 */
function center(geojson, options) {
    if (options === void 0) { options = {}; }
    var ext = bbox_1.default(geojson);
    var x = (ext[0] + ext[2]) / 2;
    var y = (ext[1] + ext[3]) / 2;
    return helpers_1.point([x, y], options.properties, options);
}
exports["default"] = center;


/***/ }),

/***/ 6697:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeometricUtils = void 0;
var turf = __webpack_require__(3855);
var polygonClipping = __webpack_require__(9004);
var GeometricUtils = /** @class */ (function () {
    function GeometricUtils() {
    }
    GeometricUtils.l2_norm = function (pt1, pt2) {
        var ndim = pt1.length;
        var sq = 0;
        for (var i = 0; i < ndim; i++) {
            sq += (pt1[i] - pt2[i]) * (pt1[i] - pt2[i]);
        }
        return Math.sqrt(sq);
    };
    // Get the point at a certain proportion of the segment between two points in a polygon
    GeometricUtils.interpolate_poly_segment = function (pts, i, prop) {
        var pt1 = pts[i % pts.length];
        var pt2 = pts[(i + 1) % pts.length];
        return [
            pt1[0] * (1.0 - prop) + pt2[0] * prop,
            pt1[1] * (1.0 - prop) + pt2[1] * prop,
        ];
    };
    /**
     * Clamp a point to the image boundaries.
     * Ensures the point lies within [0, width) and [0, height).
     * @param pt [x, y] point
     * @param width image width
     * @param height image height
     * @returns [x, y] clamped point
     */
    GeometricUtils.clamp_point_to_image = function (pt, width, height) {
        var x = Math.max(0, Math.min(pt[0], width));
        var y = Math.max(0, Math.min(pt[1], height));
        return [x, y];
    };
    /**
     * Check if a point is within the image bounds.
     * @param pt [x, y] point
     * @param width image width
     * @param height image height
     * @returns true if the point is within the image bounds, false otherwise
     */
    GeometricUtils.point_is_within_image_bounds = function (pt, width, height) {
        return (pt[0] >= 0 && pt[0] < width && pt[1] >= 0 && pt[1] < height);
    };
    // Check if two points are equal
    GeometricUtils.points_are_equal = function (pt1, pt2) {
        return (pt1[0] === pt2[0]) && (pt1[1] === pt2[1]);
    };
    // Given two points, return the line that goes through them in the form of
    //    ax + by + c = 0
    GeometricUtils.get_line_equation_through_points = function (p1, p2) {
        var a = (p2[1] - p1[1]);
        var b = (p1[0] - p2[0]);
        // If the points are the same, no line can be inferred. Return null
        if ((a === 0) && (b === 0))
            return null;
        var c = p1[1] * (p2[0] - p1[0]) - p1[0] * (p2[1] - p1[1]);
        return {
            a: a,
            b: b,
            c: c,
        };
    };
    // Given a line segment in the form of ax + by + c = 0 and two endpoints for it,
    //   return the point on the segment that is closest to the reference point, as well
    //   as the distance away
    GeometricUtils.get_nearest_point_on_segment = function (ref_x, ref_y, eq, kp1, kp2) {
        // Check to make sure eq exists
        if (eq === null)
            return null;
        // For convenience
        var a = eq["a"];
        var b = eq["b"];
        var c = eq["c"];
        // Where is that point on the line, exactly?
        var nrx = (b * (b * ref_x - a * ref_y) - a * c) / (a * a + b * b);
        var nry = (a * (a * ref_y - b * ref_x) - b * c) / (a * a + b * b);
        // Where along the segment is that point?
        var xprop = 0.0;
        if (kp2[0] != kp1[0]) {
            xprop = (nrx - kp1[0]) / (kp2[0] - kp1[0]);
        }
        var yprop = 0.0;
        if (kp2[1] != kp1[1]) {
            yprop = (nry - kp1[1]) / (kp2[1] - kp1[1]);
        }
        // If the point is at an end of the segment, just return null
        if ((xprop < 0) || (xprop > 1) || (yprop < 0) || (yprop > 1)) {
            return null;
        }
        // Distance from point to line
        var dst = Math.abs(a * ref_x + b * ref_y + c) / Math.sqrt(a * a + b * b);
        // Proportion of the length of segment from p1 to the nearest point
        var seg_length = Math.sqrt((kp2[0] - kp1[0]) * (kp2[0] - kp1[0]) + (kp2[1] - kp1[1]) * (kp2[1] - kp1[1]));
        var kprop = Math.sqrt((nrx - kp1[0]) * (nrx - kp1[0]) + (nry - kp1[1]) * (nry - kp1[1])) / seg_length;
        // Return object with info about the point
        return {
            dst: dst,
            prop: kprop,
        };
    };
    // Check if two line segments are on the same line
    GeometricUtils.line_segments_are_on_same_line = function (line1, line2) {
        var eq1 = GeometricUtils.get_line_equation_through_points(line1[0], line1[1]);
        var eq2 = GeometricUtils.get_line_equation_through_points(line2[0], line2[1]);
        return ((eq1["a"] === eq2["a"]) &&
            (eq1["b"] === eq2["b"]) &&
            (eq1["c"] === eq2["c"]));
    };
    // Reduce the number of points in a polyline
    GeometricUtils.turf_simplify_polyline = function (poly, tolerance) {
        if (tolerance === void 0) { tolerance = GeometricUtils.TURF_SIMPLIFY_TOLERANCE_PX; }
        return turf.simplify(turf.lineString(poly), { tolerance: tolerance }).geometry.coordinates;
    };
    // Subtract a polygon from a polyline
    GeometricUtils.subtract_simple_polygon_from_polyline = function (polyline, polygon) {
        var turf_polyline = turf.lineString(polyline);
        var turf_polygon = turf.polygon([polygon]);
        // Use the lineSplit function to split the line at the polygon's vertices
        var split = turf.lineSplit(turf_polyline, turf_polygon);
        if (split.features === undefined || split.features.length === 0) {
            // If there are no splits, the polyline is either completely inside or outside the polygon
            // If the first point of the polyline is inside the polygon, return null
            if (GeometricUtils.point_is_within_simple_polygon(polyline[0], polygon)) {
                return [];
            }
            else {
                return polyline;
            }
        }
        // Discard the parts of the line that are inside the polygon
        var remaining_splits = turf.featureCollection(split.features.filter(function (feature) {
            // If the point at the middle of the lineString is inside the polygon, discard it
            var middle_pt_idx = Math.floor(feature.geometry.coordinates.length / 2);
            return !GeometricUtils.point_is_within_simple_polygon(feature.geometry.coordinates[middle_pt_idx], polygon);
        }));
        // Sort the remaining splits by length
        remaining_splits.features.sort(function (a, b) {
            return turf.length(b) - turf.length(a);
        });
        // Return the longest remaining split
        // TODO: split into multiple polylines?
        return remaining_splits.features[0].geometry.coordinates;
    };
    // Merge parts of poly2 into poly1 if possible by finding their intersection.
    // Returns a new poly1 and poly2, or null on failure.
    GeometricUtils.merge_polygons_at_intersection = function (poly1, poly2) {
        // Find the intersection, if it exists
        var intersection = GeometricUtils.get_polygon_intersection_single(poly1, poly2);
        // If there's no intersection, return null
        if (intersection === null) {
            return null;
        }
        // If there is an intersection, add the non-intersecting parts of poly2 to poly1
        try {
            var non_intersection = polygonClipping.difference([poly2], [intersection]);
            var new_poly = polygonClipping.union([poly1], non_intersection);
            return [new_poly[0][0], intersection];
        }
        catch (e) {
            console.warn("Failed to merge polygons at intersection: ", e);
            return null;
        }
    };
    // Merge two simple polygons into one. Result is a complex polygon ULabelSpatialPayload2D[], with any holes preserved.
    GeometricUtils.merge_polygons = function (complex_poly1, complex_poly2) {
        var ret = [];
        complex_poly1 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly1);
        complex_poly2 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly2);
        ret = turf.union(turf.polygon(complex_poly1), turf.polygon(complex_poly2)).geometry.coordinates;
        // When the two polygons have no intersection, turf.union returns a quad nested list instead of a triple nested list
        // So we can just return complex_poly1
        if (ret[0][0][0][0] === undefined) {
            return GeometricUtils.turf_simplify_complex_polygon(ret);
        }
        else {
            return complex_poly1;
        }
    };
    // Subtract poly2 from poly1. Result is a complex polygon ULabelSpatialPayload2D[], with any holes preserved.
    GeometricUtils.subtract_polygons = function (complex_poly1, complex_poly2) {
        var ret;
        complex_poly1 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly1);
        complex_poly2 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly2);
        var temp = turf.difference(turf.polygon(complex_poly1), turf.polygon(complex_poly2));
        // when temp is null, return
        if (temp === null) {
            return null;
        }
        var temp_coords = temp.geometry.coordinates;
        // When turf.difference creates a fill, it adds it as a new polygon, ie [complex_poly, fill] instead of just complex_poly
        // so we need to append the fill to the complex_poly and return that when turf returns a quad nested list instead of a triple nested list
        if (temp_coords[0][0][0][0] === undefined) {
            ret = temp_coords;
        }
        else {
            // TODO (joshua-dean): See if this casting can be better
            ret = temp_coords[0].concat(temp_coords[1]);
        }
        return GeometricUtils.turf_simplify_complex_polygon(ret);
    };
    // Make sure each layer of a complex polygon is valid, ie that it starts and ends at the same point
    // turf likes the first and last point to reference the same point array in memory
    GeometricUtils.ensure_valid_turf_complex_polygon = function (complex_poly) {
        for (var _i = 0, complex_poly_1 = complex_poly; _i < complex_poly_1.length; _i++) {
            var layer = complex_poly_1[_i];
            layer[layer.length - 1] = layer[0];
        }
        return complex_poly;
    };
    // Return the point on a polygon that's closest to a reference along with its distance
    GeometricUtils.get_nearest_point_on_polygon = function (ref_x, ref_y, spatial_payload, dstmax, include_segments) {
        if (dstmax === void 0) { dstmax = Infinity; }
        if (include_segments === void 0) { include_segments = false; }
        var poly_pts = spatial_payload;
        // Initialize return value to null object
        var ret = {
            access: null,
            distance: null,
            point: null,
        };
        if (!include_segments) {
            // Look through polygon points one by one
            //    no need to look at last, it's the same as first
            for (var kpi = 0; kpi < poly_pts.length; kpi++) {
                var kp = poly_pts[kpi];
                // Distance is measured with l2 norm
                var kpdst = Math.sqrt(Math.pow(kp[0] - ref_x, 2) + Math.pow(kp[1] - ref_y, 2));
                // If this a minimum distance so far, store it
                if (ret["distance"] === null || kpdst < ret["distance"]) {
                    ret["access"] = kpi;
                    ret["distance"] = kpdst;
                    ret["point"] = poly_pts[kpi];
                }
            }
            return ret;
        }
        else {
            for (var kpi = 0; kpi < poly_pts.length - 1; kpi++) {
                var kp1 = poly_pts[kpi];
                var kp2 = poly_pts[kpi + 1];
                var eq = GeometricUtils.get_line_equation_through_points(kp1, kp2);
                var nr = GeometricUtils.get_nearest_point_on_segment(ref_x, ref_y, eq, kp1, kp2);
                if ((nr != null) && (nr["dst"] < dstmax) && (ret["distance"] === null || nr["dst"] < ret["distance"])) {
                    ret["access"] = "" + (kpi + nr["prop"]);
                    ret["distance"] = nr["dst"];
                    ret["point"] = GeometricUtils.interpolate_poly_segment(poly_pts, kpi, nr["prop"]);
                }
            }
            return ret;
        }
    };
    // Return the intersection of two polygons
    GeometricUtils.get_polygon_intersection_single = function (poly1, poly2) {
        // Convert to turf polygons
        try {
            var poly1_turf = turf.polygon([poly1]);
            var poly2_turf = turf.polygon([poly2]);
            // Find intersection
            var intersection = turf.intersect(poly1_turf, poly2_turf);
            if (intersection === null) {
                return null;
            }
            else {
                // Convert back to ULabelSpatialPayload2D
                return intersection.geometry.coordinates[0];
            }
            // TODO (joshua-dean): Comply with this rule
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        }
        catch (e) {
            return null;
        }
    };
    GeometricUtils.complex_polygons_intersect = function (complex_poly1, complex_poly2) {
        complex_poly1 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly1);
        complex_poly2 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly2);
        return turf.booleanOverlap(turf.polygon(complex_poly1), turf.polygon(complex_poly2));
    };
    // Check if polygon is closed, i.e. first and last points are the same and there are at least 3 points
    GeometricUtils.is_polygon_closed = function (poly) {
        var ret = false;
        if (poly.length > 2) {
            try {
                ret = poly[0][0] === poly.at(-1)[0] && poly[0][1] === poly.at(-1)[1];
            }
            catch ( /* empty */_a) { /* empty */ }
        }
        return ret;
    };
    // Check if two polygons are equal
    GeometricUtils.polygons_are_equal = function (poly1, poly2) {
        // Check if the polygons have the same number of points
        if (poly1.length !== poly2.length) {
            return false;
        }
        // Check that each point in poly1 is in poly2
        for (var i = 0; i < poly1.length; i++) {
            var found = false;
            for (var j = 0; j < poly2.length; j++) {
                if (poly1[i][0] === poly2[j][0] && poly1[i][1] === poly2[j][1]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    };
    // Check if two polygons share an edge, ie if they contain an identical line segment
    GeometricUtils.polygons_share_edge = function (poly1, poly2) {
        for (var i = 0; i < poly1.length - 1; i++) {
            var line1 = [poly1[i], poly1[i + 1]];
            // skip if the points are the same
            if (GeometricUtils.points_are_equal(line1[0], line1[1])) {
                continue;
            }
            for (var j = 0; j < poly2.length - 1; j++) {
                var line2 = [poly2[j], poly2[j + 1]];
                // skip if the points are the same
                if (GeometricUtils.points_are_equal(line2[0], line2[1])) {
                    continue;
                }
                if (GeometricUtils.line_segments_are_on_same_line(line1, line2)) {
                    return true;
                }
            }
        }
        return false;
    };
    // Scale a polygon about a center point, or the centroid if no center is provided
    GeometricUtils.scale_polygon = function (poly, scale, center) {
        if (center === void 0) { center = null; }
        var ret = [];
        if (center === null) {
            // use the centroid
            center = GeometricUtils.get_centroid_of_polygon(poly);
        }
        for (var i = 0; i < poly.length; i++) {
            var pt = poly[i];
            var new_x = center[0] + (pt[0] - center[0]) * scale;
            var new_y = center[1] + (pt[1] - center[1]) * scale;
            ret.push([new_x, new_y]);
        }
        return ret;
    };
    // Get the centroid of a polygon
    GeometricUtils.get_centroid_of_polygon = function (poly) {
        var x = 0;
        var y = 0;
        for (var i = 0; i < poly.length; i++) {
            x += poly[i][0];
            y += poly[i][1];
        }
        return [x / poly.length, y / poly.length];
    };
    GeometricUtils.turf_simplify_complex_polygon = function (poly, tolerance) {
        if (tolerance === void 0) { tolerance = GeometricUtils.TURF_SIMPLIFY_TOLERANCE_PX; }
        return turf.simplify(turf.polygon(poly), { tolerance: tolerance }).geometry.coordinates;
    };
    // Check if poly1 is completely within poly2
    GeometricUtils.simple_polygon_is_within_simple_polygon = function (poly1, poly2) {
        if (GeometricUtils.is_polygon_closed(poly1) && GeometricUtils.is_polygon_closed(poly2)) {
            return turf.booleanWithin(turf.polygon([poly1]), turf.polygon([poly2]));
        }
        else {
            return false;
        }
    };
    // Check if complex_poly1 is completely within complex_poly2
    GeometricUtils.complex_polygon_is_within_complex_polygon = function (complex_poly1, complex_poly2) {
        complex_poly1 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly1);
        complex_poly2 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly2);
        return turf.booleanWithin(turf.polygon(complex_poly1), turf.polygon(complex_poly2));
    };
    // Check if any hole of complex_poly1 is completely within complex_poly2
    GeometricUtils.any_complex_polygon_hole_is_within_complex_polygon = function (complex_poly1, complex_poly2) {
        complex_poly1 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly1);
        complex_poly2 = GeometricUtils.ensure_valid_turf_complex_polygon(complex_poly2);
        // Start at 1 to skip the outer polygon
        for (var i = 1; i < complex_poly1.length; i++) {
            if (turf.booleanWithin(turf.polygon([complex_poly1[i]]), turf.polygon(complex_poly2))) {
                return true;
            }
        }
        return false;
    };
    // Check if a point is within a polygon
    GeometricUtils.point_is_within_simple_polygon = function (point, poly) {
        return turf.booleanPointInPolygon(turf.point(point), turf.polygon([poly]));
    };
    // Check if a point is within a ulabel complex polygon
    GeometricUtils.point_is_within_polygon_annotation = function (point, annotation_object) {
        // Check if a point is within any of the filled regions (non-holes)
        for (var i = 0; i < annotation_object["spatial_payload"].length; i++) {
            if (annotation_object["spatial_payload_holes"][i] === false &&
                GeometricUtils.point_is_within_simple_polygon(point, annotation_object["spatial_payload"][i])) {
                return true;
            }
        }
        return false;
    };
    // Convert a bbox to a simple polygon by adding the last point
    GeometricUtils.bbox_to_simple_polygon = function (bbox) {
        // bbox is just two points, so we need to add the other two as well as the final point
        return [
            bbox[0],
            [bbox[1][0], bbox[0][1]],
            bbox[1],
            [bbox[0][0], bbox[1][1]],
            bbox[0],
        ];
    };
    GeometricUtils.get_nearest_point_on_bounding_box = function (ref_x, ref_y, spatial_payload, dstmax) {
        if (dstmax === void 0) { dstmax = Infinity; }
        var ret = {
            access: null,
            distance: null,
            point: null,
        };
        for (var bbi = 0; bbi < 2; bbi++) {
            for (var bbj = 0; bbj < 2; bbj++) {
                var kp = [spatial_payload[bbi][0], spatial_payload[bbj][1]];
                var kpdst = Math.sqrt(Math.pow(kp[0] - ref_x, 2) + Math.pow(kp[1] - ref_y, 2));
                if (kpdst < dstmax && (ret["distance"] === null || kpdst < ret["distance"])) {
                    ret["access"] = "".concat(bbi).concat(bbj);
                    ret["distance"] = kpdst;
                    ret["point"] = kp;
                }
            }
        }
        return ret;
    };
    GeometricUtils.get_nearest_point_on_bbox3 = function (ref_x, ref_y, frame, spatial_payload, dstmax) {
        if (dstmax === void 0) { dstmax = Infinity; }
        var ret = {
            access: null,
            distance: null,
            point: null,
        };
        for (var bbi = 0; bbi < 2; bbi++) {
            for (var bbj = 0; bbj < 2; bbj++) {
                var kp = [spatial_payload[bbi][0], spatial_payload[bbj][1]];
                var kpdst = Math.sqrt(Math.pow(kp[0] - ref_x, 2) + Math.pow(kp[1] - ref_y, 2));
                if (kpdst < dstmax && (ret["distance"] === null || kpdst < ret["distance"])) {
                    ret["access"] = "".concat(bbi).concat(bbj);
                    ret["distance"] = kpdst;
                    ret["point"] = kp;
                }
            }
        }
        var min_k = 0;
        var min = spatial_payload[0][2];
        var max_k = 1;
        var max = spatial_payload[1][2];
        if (max < min) {
            var tmp = min_k;
            min_k = max_k;
            max_k = tmp;
            tmp = min;
            min = max;
            max = tmp;
        }
        if (frame === min) {
            ret["access"] += "" + min_k;
        }
        else if (frame === max) {
            ret["access"] += "" + max_k;
        }
        return ret;
    };
    GeometricUtils.get_nearest_point_on_tbar = function (ref_x, ref_y, spatial_payload, dstmax) {
        if (dstmax === void 0) { dstmax = Infinity; }
        // TODO intelligently test against three grabbable points
        var ret = {
            access: null,
            distance: null,
            point: null,
        };
        for (var tbi = 0; tbi < 2; tbi++) {
            var kp = [spatial_payload[tbi][0], spatial_payload[tbi][1]];
            var kpdst = Math.sqrt(Math.pow(kp[0] - ref_x, 2) + Math.pow(kp[1] - ref_y, 2));
            if (kpdst < dstmax && (ret["distance"] === null || kpdst < ret["distance"])) {
                ret["access"] = "".concat(tbi).concat(tbi);
                ret["distance"] = kpdst;
                ret["point"] = kp;
            }
        }
        return ret;
    };
    // Convert a tbar to a simple polygon
    GeometricUtils.tbar_to_simple_polygon = function (spatial_payload) {
        // A tbar spatial_payload is just two points that define the middle line. To represent it as a polygon,
        // we must calculate the endpoints of the perpendicular line at the end of the tbar.
        var center_start_point = spatial_payload[0];
        var center_end_point = spatial_payload[1];
        var halflen = Math.sqrt((center_start_point[0] - center_end_point[0]) * (center_start_point[0] - center_end_point[0]) + (center_start_point[1] - center_end_point[1]) * (center_start_point[1] - center_end_point[1])) / 2;
        var theta = Math.atan((center_end_point[1] - center_start_point[1]) / (center_end_point[0] - center_start_point[0]));
        var perpendicular_endpoint_1 = [
            center_start_point[0] + halflen * Math.sin(theta),
            center_start_point[1] - halflen * Math.cos(theta),
        ];
        var perpendicular_endpoint_2 = [
            center_start_point[0] - halflen * Math.sin(theta),
            center_start_point[1] + halflen * Math.cos(theta),
        ];
        // Now we make a polygon that starts at the start of the tbar, and goes out and back to each other endpoint
        return [
            center_start_point,
            perpendicular_endpoint_1,
            center_end_point,
            perpendicular_endpoint_2,
            center_start_point,
            center_end_point,
            // End back at the start
            center_start_point,
        ];
    };
    // Tolerance in px for simplifying turf shapes
    GeometricUtils.TURF_SIMPLIFY_TOLERANCE_PX = 2;
    return GeometricUtils;
}());
exports.GeometricUtils = GeometricUtils;


/***/ }),

/***/ 6724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var center_mean_1 = __importDefault(__webpack_require__(2779));
var distance_1 = __importDefault(__webpack_require__(9391));
var centroid_1 = __importDefault(__webpack_require__(4408));
var helpers_1 = __webpack_require__(8967);
var meta_1 = __webpack_require__(8421);
/**
 * Takes a {@link FeatureCollection} of points and calculates the median center,
 * algorithimically. The median center is understood as the point that is
 * requires the least total travel from all other points.
 *
 * Turfjs has four different functions for calculating the center of a set of
 * data. Each is useful depending on circumstance.
 *
 * `@turf/center` finds the simple center of a dataset, by finding the
 * midpoint between the extents of the data. That is, it divides in half the
 * farthest east and farthest west point as well as the farthest north and
 * farthest south.
 *
 * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.
 * The center of mass is where the sheet would balance on a fingertip.
 *
 * `@turf/center-mean` takes the averages of all the coordinates and
 * produces a value that respects that. Unlike `@turf/center`, it is
 * sensitive to clusters and outliers. It lands in the statistical middle of a
 * dataset, not the geographical. It can also be weighted, meaning certain
 * points are more important than others.
 *
 * `@turf/center-median` takes the mean center and tries to find, iteratively,
 * a new point that requires the least amount of travel from all the points in
 * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is
 * attracted to clustered data. It, too, can be weighted.
 *
 * **Bibliography**
 *
 * Harold W. Kuhn and Robert E. Kuenne, An Efficient Algorithm for the
 * Numerical Solution of the Generalized Weber Problem in Spatial
 * Economics, _Journal of Regional Science_ 4, no. 2 (1962): 2133,
 * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.
 *
 * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary
 * Statistics for Geographers_, 3rd ed., New York: The Guilford
 * Press, 2009, 150151.
 *
 * @name centerMedian
 * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.weight] the property name used to weight the center
 * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.
 * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.
 * @returns {Feature<Point>} The median center of the collection
 * @example
 * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);
 * var medianCenter = turf.centerMedian(points);
 *
 * //addToMap
 * var addToMap = [points, medianCenter]
 */
function centerMedian(features, options) {
    if (options === void 0) { options = {}; }
    // Optional params
    options = options || {};
    if (!helpers_1.isObject(options))
        throw new Error("options is invalid");
    var counter = options.counter || 10;
    if (!helpers_1.isNumber(counter))
        throw new Error("counter must be a number");
    var weightTerm = options.weight;
    // Calculate mean center:
    var meanCenter = center_mean_1.default(features, { weight: options.weight });
    // Calculate center of every feature:
    var centroids = helpers_1.featureCollection([]);
    meta_1.featureEach(features, function (feature) {
        var _a;
        centroids.features.push(centroid_1.default(feature, {
            properties: { weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] },
        }));
    });
    var properties = {
        tolerance: options.tolerance,
        medianCandidates: [],
    };
    return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);
}
/**
 * Recursive function to find new candidate medians.
 *
 * @private
 * @param {Position} candidateMedian current candidate median
 * @param {Position} previousCandidate the previous candidate median
 * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining
 * @param {number} counter how many attempts to try before quitting.
 * @returns {Feature<Point>} the median center of the dataset.
 */
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
    var tolerance = properties.tolerance || 0.001;
    var candidateXsum = 0;
    var candidateYsum = 0;
    var kSum = 0;
    var centroidCount = 0;
    meta_1.featureEach(centroids, function (theCentroid) {
        var _a;
        var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;
        var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;
        weight = Number(weight);
        if (!helpers_1.isNumber(weight))
            throw new Error("weight value must be a number");
        if (weight > 0) {
            centroidCount += 1;
            var distanceFromCandidate = weight * distance_1.default(theCentroid, candidateMedian);
            if (distanceFromCandidate === 0)
                distanceFromCandidate = 1;
            var k = weight / distanceFromCandidate;
            candidateXsum += theCentroid.geometry.coordinates[0] * k;
            candidateYsum += theCentroid.geometry.coordinates[1] * k;
            kSum += k;
        }
    });
    if (centroidCount < 1)
        throw new Error("no features to measure");
    var candidateX = candidateXsum / kSum;
    var candidateY = candidateYsum / kSum;
    if (centroidCount === 1 ||
        counter === 0 ||
        (Math.abs(candidateX - previousCandidate[0]) < tolerance &&
            Math.abs(candidateY - previousCandidate[1]) < tolerance)) {
        return helpers_1.point([candidateX, candidateY], {
            medianCandidates: properties.medianCandidates,
        });
    }
    else {
        properties.medianCandidates.push([candidateX, candidateY]);
        return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);
    }
}
exports["default"] = centerMedian;


/***/ }),

/***/ 6743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(9353);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 6766:
/***/ ((module) => {

"use strict";


module.exports = {
	/**
  * Euclidean distance
  */
	eudist: function eudist(v1, v2, sqrt) {
		var len = v1.length;
		var sum = 0;

		for (var i = 0; i < len; i++) {
			var d = (v1[i] || 0) - (v2[i] || 0);
			sum += d * d;
		}
		// Square root not really needed
		return sqrt ? Math.sqrt(sum) : sum;
	},
	mandist: function mandist(v1, v2, sqrt) {
		var len = v1.length;
		var sum = 0;

		for (var i = 0; i < len; i++) {
			sum += Math.abs((v1[i] || 0) - (v2[i] || 0));
		}

		// Square root not really needed
		return sqrt ? Math.sqrt(sum) : sum;
	},


	/**
  * Unidimensional distance
  */
	dist: function dist(v1, v2, sqrt) {
		var d = Math.abs(v1 - v2);
		return sqrt ? d : d * d;
	}
};
//# sourceMappingURL=distance.js.map


/***/ }),

/***/ 6775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);

/**
 * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).
 * Warning: may create degenerate polygons.
 *
 * @name polygonSmooth
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.
 * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons
 * @example
 * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
 *
 * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})
 *
 * //addToMap
 * var addToMap = [smoothed, polygon];
 */
function polygonSmooth(inputPolys, options) {
  var outPolys = [];
  // Optional parameters
  var iterations = options.iterations || 1;
  if (!inputPolys) throw new Error("inputPolys is required");

  meta.geomEach(inputPolys, function (geom, geomIndex, properties) {
    var outCoords;
    var poly;
    var tempOutput;

    switch (geom.type) {
      case "Polygon":
        outCoords = [[]];
        for (var i = 0; i < iterations; i++) {
          tempOutput = [[]];
          poly = geom;
          if (i > 0) poly = helpers.polygon(outCoords).geometry;
          processPolygon(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(helpers.polygon(outCoords, properties));
        break;
      case "MultiPolygon":
        outCoords = [[[]]];
        for (var y = 0; y < iterations; y++) {
          tempOutput = [[[]]];
          poly = geom;
          if (y > 0) poly = helpers.multiPolygon(outCoords).geometry;
          processMultiPolygon(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(helpers.multiPolygon(outCoords, properties));
        break;
      default:
        throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
    }
  });
  return helpers.featureCollection(outPolys);
}

/**
 * @param {poly} poly to process
 * @param {poly} tempOutput to place the results in
 * @private
 */
function processPolygon(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;

  meta.coordEach(
    poly,
    function (
      currentCoord,
      coordIndex,
      featureIndex,
      multiFeatureIndex,
      geometryIndex
    ) {
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y,
      ]);
      tempOutput[geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y,
      ]);
    },
    true
  );
  tempOutput.forEach(function (ring) {
    ring.push(ring[0]);
  });
}

/**
 * @param {poly} poly to process
 * @param {poly} tempOutput to place the results in
 * @private
 */
function processMultiPolygon(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;
  var prevMultiIndex = 0;

  meta.coordEach(
    poly,
    function (
      currentCoord,
      coordIndex,
      featureIndex,
      multiFeatureIndex,
      geometryIndex
    ) {
      if (multiFeatureIndex > prevMultiIndex) {
        prevMultiIndex = multiFeatureIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([[]]);
      }
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput[multiFeatureIndex].push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 =
        poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y,
      ]);
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y,
      ]);
    },
    true
  );

  tempOutput.forEach(function (poly) {
    poly.forEach(function (ring) {
      ring.push(ring[0]);
    });
  });
}

module.exports = polygonSmooth;
module.exports["default"] = polygonSmooth;


/***/ }),

/***/ 6834:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
/**
 * Takes a GeoJSON Feature or FeatureCollection and truncates the precision of the geometry.
 *
 * @name truncate
 * @param {GeoJSON} geojson any GeoJSON Feature, FeatureCollection, Geometry or GeometryCollection.
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.precision=6] coordinate decimal precision
 * @param {number} [options.coordinates=3] maximum number of coordinates (primarly used to remove z coordinates)
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} layer with truncated geometry
 * @example
 * var point = turf.point([
 *     70.46923055566859,
 *     58.11088890802906,
 *     1508
 * ]);
 * var options = {precision: 3, coordinates: 2};
 * var truncated = turf.truncate(point, options);
 * //=truncated.geometry.coordinates => [70.469, 58.111]
 *
 * //addToMap
 * var addToMap = [truncated];
 */
function truncate(geojson, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    var precision = options.precision;
    var coordinates = options.coordinates;
    var mutate = options.mutate;
    // default params
    precision =
        precision === undefined || precision === null || isNaN(precision)
            ? 6
            : precision;
    coordinates =
        coordinates === undefined || coordinates === null || isNaN(coordinates)
            ? 3
            : coordinates;
    // validation
    if (!geojson)
        throw new Error("<geojson> is required");
    if (typeof precision !== "number")
        throw new Error("<precision> must be a number");
    if (typeof coordinates !== "number")
        throw new Error("<coordinates> must be a number");
    // prevent input mutation
    if (mutate === false || mutate === undefined)
        geojson = JSON.parse(JSON.stringify(geojson));
    var factor = Math.pow(10, precision);
    // Truncate Coordinates
    meta_1.coordEach(geojson, function (coords) {
        truncateCoords(coords, factor, coordinates);
    });
    return geojson;
}
/**
 * Truncate Coordinates - Mutates coordinates in place
 *
 * @private
 * @param {Array<any>} coords Geometry Coordinates
 * @param {number} factor rounding factor for coordinate decimal precision
 * @param {number} coordinates maximum number of coordinates (primarly used to remove z coordinates)
 * @returns {Array<any>} mutated coordinates
 */
function truncateCoords(coords, factor, coordinates) {
    // Remove extra coordinates (usually elevation coordinates and more)
    if (coords.length > coordinates)
        coords.splice(coordinates, coords.length);
    // Truncate coordinate decimals
    for (var i = 0; i < coords.length; i++) {
        coords[i] = Math.round(coords[i] * factor) / factor;
    }
    return coords;
}
exports["default"] = truncate;


/***/ }),

/***/ 6840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageFiltersToolboxItem = void 0;
var html_builder_1 = __webpack_require__(4493);
var toolbox_1 = __webpack_require__(3045);
var DEFAULT_FILTER_VALUES = {
    brightness: 100,
    contrast: 100,
    hueRotate: 0,
    invert: 0,
    saturate: 100,
};
/**
 * Toolbox item for applying CSS filters to images
 */
var ImageFiltersToolboxItem = /** @class */ (function (_super) {
    __extends(ImageFiltersToolboxItem, _super);
    function ImageFiltersToolboxItem(ulabel) {
        var _this = _super.call(this) || this;
        _this.ulabel = ulabel;
        // Get default values from config
        _this.filter_values = _this.get_default_filter_values();
        _this.init_sliders();
        _this.add_styles();
        _this.init_listeners();
        return _this;
    }
    /**
     * Get default filter values from config or use built-in defaults
     */
    ImageFiltersToolboxItem.prototype.get_default_filter_values = function () {
        var _a, _b, _c, _d, _e, _f;
        var config_defaults = ((_a = this.ulabel.config.image_filters_toolbox_item) === null || _a === void 0 ? void 0 : _a.default_values) || {};
        return {
            brightness: (_b = config_defaults.brightness) !== null && _b !== void 0 ? _b : DEFAULT_FILTER_VALUES.brightness,
            contrast: (_c = config_defaults.contrast) !== null && _c !== void 0 ? _c : DEFAULT_FILTER_VALUES.contrast,
            hueRotate: (_d = config_defaults.hueRotate) !== null && _d !== void 0 ? _d : DEFAULT_FILTER_VALUES.hueRotate,
            invert: (_e = config_defaults.invert) !== null && _e !== void 0 ? _e : DEFAULT_FILTER_VALUES.invert,
            saturate: (_f = config_defaults.saturate) !== null && _f !== void 0 ? _f : DEFAULT_FILTER_VALUES.saturate,
        };
    };
    ImageFiltersToolboxItem.prototype.init_sliders = function () {
        var _this = this;
        // Brightness slider (0-200%)
        this.brightness_slider = new html_builder_1.SliderHandler({
            id: "image-filter-brightness",
            main_label: "Brightness",
            label_units: "%",
            default_value: String(this.filter_values.brightness),
            min: "0",
            max: "200",
            step: "1",
            slider_event: function (value) {
                _this.filter_values.brightness = Number(value);
                _this.apply_filters();
            },
        });
        // Contrast slider (0-200%)
        this.contrast_slider = new html_builder_1.SliderHandler({
            id: "image-filter-contrast",
            main_label: "Contrast",
            label_units: "%",
            default_value: String(this.filter_values.contrast),
            min: "0",
            max: "200",
            step: "1",
            slider_event: function (value) {
                _this.filter_values.contrast = Number(value);
                _this.apply_filters();
            },
        });
        // Hue rotate slider (0-360 degrees)
        this.hue_rotate_slider = new html_builder_1.SliderHandler({
            id: "image-filter-hue-rotate",
            main_label: "Hue Rotate",
            label_units: "",
            default_value: String(this.filter_values.hueRotate),
            min: "0",
            max: "360",
            step: "1",
            slider_event: function (value) {
                _this.filter_values.hueRotate = Number(value);
                _this.apply_filters();
            },
        });
        // Invert slider (0-100%)
        this.invert_slider = new html_builder_1.SliderHandler({
            id: "image-filter-invert",
            main_label: "Invert",
            label_units: "%",
            default_value: String(this.filter_values.invert),
            min: "0",
            max: "100",
            step: "1",
            slider_event: function (value) {
                _this.filter_values.invert = Number(value);
                _this.apply_filters();
            },
        });
        // Saturate slider (0-200%)
        this.saturate_slider = new html_builder_1.SliderHandler({
            id: "image-filter-saturate",
            main_label: "Saturate",
            label_units: "%",
            default_value: String(this.filter_values.saturate),
            min: "0",
            max: "200",
            step: "1",
            slider_event: function (value) {
                _this.filter_values.saturate = Number(value);
                _this.apply_filters();
            },
        });
    };
    /**
     * Apply CSS filters to all image frames
     */
    ImageFiltersToolboxItem.prototype.apply_filters = function () {
        var filter_string = this.build_filter_string();
        var images = document.querySelectorAll(".image_frame");
        images.forEach(function (img) {
            img.style.filter = filter_string;
        });
    };
    /**
     * Build CSS filter string from current filter values
     */
    ImageFiltersToolboxItem.prototype.build_filter_string = function () {
        var filters = [];
        if (this.filter_values.brightness !== 100) {
            filters.push("brightness(".concat(this.filter_values.brightness, "%)"));
        }
        if (this.filter_values.contrast !== 100) {
            filters.push("contrast(".concat(this.filter_values.contrast, "%)"));
        }
        if (this.filter_values.hueRotate !== 0) {
            filters.push("hue-rotate(".concat(this.filter_values.hueRotate, "deg)"));
        }
        if (this.filter_values.invert !== 0) {
            filters.push("invert(".concat(this.filter_values.invert, "%)"));
        }
        if (this.filter_values.saturate !== 100) {
            filters.push("saturate(".concat(this.filter_values.saturate, "%)"));
        }
        return filters.length > 0 ? filters.join(" ") : "none";
    };
    /**
     * Reset all filters to default values (from config or built-in defaults)
     */
    ImageFiltersToolboxItem.prototype.reset_filters = function () {
        // Reset filter values to defaults
        this.filter_values = this.get_default_filter_values();
        // Update all slider inputs and labels
        this.update_slider_input_and_label("brightness", this.filter_values.brightness, "%");
        this.update_slider_input_and_label("contrast", this.filter_values.contrast, "%");
        this.update_slider_input_and_label("hue-rotate", this.filter_values.hueRotate, "");
        this.update_slider_input_and_label("invert", this.filter_values.invert, "%");
        this.update_slider_input_and_label("saturate", this.filter_values.saturate, "%");
        this.apply_filters();
    };
    /**
     * Helper method to update both slider input value and label
     */
    ImageFiltersToolboxItem.prototype.update_slider_input_and_label = function (filter_type, value, unit) {
        var input = document.querySelector("#image-filter-".concat(filter_type));
        var label = document.querySelector("#image-filter-".concat(filter_type, "-value-label"));
        if (input)
            input.value = String(value);
        if (label)
            label.innerText = "".concat(value).concat(unit);
    };
    /**
     * Get the HTML for this toolbox item
     */
    ImageFiltersToolboxItem.prototype.get_html = function () {
        return "\n        <div id=\"image-filters-container\" class=\"image-filters-toolbox-item\">\n            <div class=\"toolbox-divider\"></div>\n            <div class=\"image-filters-header\">\n                <h3 class=\"image-filters-title\">Image Filters</h3>\n                <button id=\"image-filters-toggle\" class=\"image-filters-toggle-btn\">\u25BC</button>\n            </div>\n            <div id=\"image-filters-content\" class=\"image-filters-content\">\n                ".concat(this.brightness_slider.getSliderHTML(), "\n                ").concat(this.contrast_slider.getSliderHTML(), "\n                ").concat(this.hue_rotate_slider.getSliderHTML(), "\n                ").concat(this.invert_slider.getSliderHTML(), "\n                ").concat(this.saturate_slider.getSliderHTML(), "\n                <button id=\"image-filters-reset\" class=\"image-filters-reset-btn\">Reset Filters</button>\n            </div>\n        </div>\n        ");
    };
    /**
     * Returns a unique string for this toolbox item
     */
    ImageFiltersToolboxItem.prototype.get_toolbox_item_type = function () {
        return "ImageFilters";
    };
    /**
     * Code called after all of ULabel's constructor and initialization code is called
     */
    ImageFiltersToolboxItem.prototype.after_init = function () {
        // Apply the initial filter values from config
        this.apply_filters();
    };
    /**
     * Initialize event listeners for this toolbox item
     */
    ImageFiltersToolboxItem.prototype.init_listeners = function () {
        var _this = this;
        // Toggle button to show/hide filter controls
        $(document).on("click.ulabel", "#image-filters-toggle", function () {
            var content = document.querySelector("#image-filters-content");
            var toggle_btn = document.querySelector("#image-filters-toggle");
            if (content && toggle_btn) {
                var is_hidden = content.style.display === "none";
                content.style.display = is_hidden ? "block" : "none";
                toggle_btn.innerText = is_hidden ? "" : "";
            }
        });
        // Reset button
        $(document).on("click.ulabel", "#image-filters-reset", function () {
            _this.reset_filters();
        });
    };
    /**
     * Redraw/update this toolbox item
     */
    ImageFiltersToolboxItem.prototype.redraw_update_items = function () {
        // Nothing to update dynamically
    };
    /**
     * Add CSS styles for the image filters toolbox item
     */
    ImageFiltersToolboxItem.prototype.add_styles = function () {
        var css = "\n        #toolbox .image-filters-toolbox-item {\n            padding: 0.5rem 0;\n        }\n\n        #toolbox .image-filters-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 0 1.5rem;\n            cursor: pointer;\n        }\n\n        #toolbox .image-filters-title {\n            margin: 0.5rem 0;\n            font-size: 1rem;\n            font-weight: 600;\n        }\n\n        #toolbox .image-filters-toggle-btn {\n            background: none;\n            border: none;\n            color: inherit;\n            font-size: 1rem;\n            cursor: pointer;\n            padding: 0.25rem;\n            width: 24px;\n            height: 24px;\n        }\n\n        #toolbox .image-filters-toggle-btn:hover {\n            background-color: rgba(0, 128, 255, 0.1);\n        }\n\n        #toolbox .image-filters-content {\n            display: block;\n        }\n\n        #toolbox .image-filters-reset-btn {\n            margin: 1rem 1.5rem 0.5rem;\n            padding: 0.5rem 1rem;\n            width: calc(100% - 3rem);\n            border-radius: 4px;\n            font-size: 0.9rem;\n        }\n        ";
        // Create an id so this specific style tag can be referenced
        var style_id = "image-filters-toolbox-styles";
        // Don't add the style tag if it's already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    return ImageFiltersToolboxItem;
}(toolbox_1.ToolboxItem));
exports.ImageFiltersToolboxItem = ImageFiltersToolboxItem;


/***/ }),

/***/ 6847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * ULabel listener utilities.
 *
 * These primarily use JQuery, within the namespace "ulabel".
 * Selectors and `.on` calls are intentionally kept in `create_ulabel_listeners`.
 * Long handlers are broken out into separate functions.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.create_ulabel_listeners = create_ulabel_listeners;
exports.remove_ulabel_listeners = remove_ulabel_listeners;
var cookies_1 = __webpack_require__(7941);
var annotation_1 = __webpack_require__(5573);
var ULABEL_NAMESPACE = ".ulabel";
/**
 * Handle keypress events.
 *
 * @param keypress_event Key event to handle
 * @param ulabel ULabel instance
 */
function handle_keypress_event(keypress_event, ulabel) {
    var current_subtask = ulabel.get_current_subtask();
    switch (keypress_event.key) {
        // Create a point annotation at the mouse's current location
        case ulabel.config.create_point_annotation_keybind:
            // Only allow keypress to create point annotations
            if (current_subtask.state.annotation_mode === "point") {
                // Create an annotation based on the last mouse position
                ulabel.create_point_annotation_at_mouse_location();
            }
            break;
        // Create a bbox annotation around the initial_crop,
        // or the whole image if inital_crop does not exist
        case ulabel.config.create_bbox_on_initial_crop:
            if (current_subtask.state.annotation_mode === "bbox") {
                // Default to an annotation with size of image
                // Create the coordinates for the bbox's spatial payload
                var bbox_top_left = [0, 0];
                var bbox_bottom_right = [
                    ulabel.config.image_width,
                    ulabel.config.image_height,
                ];
                // If an initial crop exists, use that instead
                // TODO (joshua-dean): can't this just be "if (ulabel.config.initial_crop)"?
                if (ulabel.config.initial_crop !== null && ulabel.config.initial_crop !== undefined) {
                    // Convenience
                    var initial_crop = ulabel.config.initial_crop;
                    // Create the coordinates for the bbox's spatial payload
                    bbox_top_left = [initial_crop.left, initial_crop.top];
                    bbox_bottom_right = [initial_crop.left + initial_crop.width, initial_crop.top + initial_crop.height];
                }
                // Create the annotation
                ulabel.create_annotation(current_subtask.state.annotation_mode, [bbox_top_left, bbox_bottom_right]);
            }
            break;
        // Change to brush mode (for now, polygon only)
        case ulabel.config.toggle_brush_mode_keybind:
            ulabel.toggle_brush_mode(ulabel.state["last_move"]);
            break;
        // Change to erase mode (will also set the is_in_brush_mode state)
        case ulabel.config.toggle_erase_mode_keybind:
            ulabel.toggle_erase_mode(ulabel.state["last_move"]);
            break;
        // Increase brush size by 10%
        case ulabel.config.increase_brush_size_keybind:
            ulabel.change_brush_size(1.1);
            break;
        // Decrease brush size by 10%
        case ulabel.config.decrease_brush_size_keybind:
            ulabel.change_brush_size(1 / 1.1);
            break;
        case ulabel.config.change_zoom_keybind.toLowerCase():
            ulabel.show_initial_crop();
            break;
        case ulabel.config.change_zoom_keybind.toUpperCase():
            ulabel.show_whole_image();
            break;
        default:
            // TODO (joshua-dean): break this out
            if (!annotation_1.DELETE_MODES.includes(current_subtask.state.spatial_type)) {
                // Check for class keybinds
                for (var i = 0; i < current_subtask.class_defs.length; i++) {
                    var class_def = current_subtask.class_defs[i];
                    if (class_def.keybind !== null && keypress_event.key === class_def.keybind) {
                        var st_key = ulabel.get_current_subtask_key();
                        var class_button = $("#tb-id-app--".concat(st_key, " a.tbid-opt")).eq(i);
                        if (class_button.hasClass("sel")) {
                            // If the class button is already selected,
                            // check if there is an active annotation, and if so, get it
                            var target_id = null;
                            if (current_subtask.state.active_id !== null) {
                                target_id = current_subtask.state.active_id;
                            }
                            else if (current_subtask.state.move_candidate !== null) {
                                target_id = current_subtask.state.move_candidate["annid"];
                            }
                            // Update the class of the active annotation
                            if (target_id !== null) {
                                // Set the annotation's class to the selected class
                                ulabel.handle_id_dialog_click(ulabel.state["last_move"], target_id, ulabel.get_active_class_id_idx());
                            }
                        }
                        else {
                            // Click the class button if not already selected
                            class_button.trigger("click");
                        }
                        return;
                    }
                }
            }
            break;
    }
}
/**
 * Handle a click on a soft ID toolbox button.
 *
 * @param click_event Click event
 * @param ulabel ULabel instance
 */
function handle_soft_id_toolbox_button_click(click_event, ulabel) {
    var tgt_jq = $(click_event.currentTarget);
    var pfx = "div#tb-id-app--" + ulabel.get_current_subtask_key();
    var current_subtask = ulabel.get_current_subtask();
    if (tgt_jq.attr("href") === "#") {
        var current_id_button = $(pfx + " a.tbid-opt.sel");
        current_id_button.attr("href", "#");
        current_id_button.removeClass("sel");
        var old_id = parseInt(current_id_button.attr("id").split("_").at(-1));
        tgt_jq.addClass("sel");
        tgt_jq.removeAttr("href");
        var idarr = tgt_jq.attr("id").split("_");
        var rawid = parseInt(idarr[idarr.length - 1]);
        ulabel.set_id_dialog_payload_nopin(current_subtask["class_ids"].indexOf(rawid), 1.0);
        ulabel.update_id_dialog_display();
        // Update the class of the active annotation,
        // except when toggling on the delete class
        if (rawid !== annotation_1.DELETE_CLASS_ID) {
            // Get the active annotation, if any
            var target_id = null;
            if (current_subtask.state.active_id !== null) {
                target_id = current_subtask.state.active_id;
            }
            else if (current_subtask.state.move_candidate !== null) {
                target_id = current_subtask.state.move_candidate["annid"];
            }
            // Update the class of the active annotation
            if (target_id !== null) {
                // Set the annotation's class to the selected class
                ulabel.handle_id_dialog_click(ulabel.state["last_move"], target_id, ulabel.get_active_class_id_idx());
            }
            else {
                // If there is not active annotation,
                // still update the brush circle if in brush mode
                ulabel.recolor_brush_circle();
            }
        }
        /*
        If toggling off a delete class while still in delete mode,
        re-toggle the delete class.
        This occurs when using a keybind to change a hovered annotation's
        class while in delete mode.
        */
        if (old_id === annotation_1.DELETE_CLASS_ID &&
            annotation_1.DELETE_MODES.includes(current_subtask.state.annotation_mode)) {
            $("#toolbox_sel_" + annotation_1.DELETE_CLASS_ID).trigger("click");
        }
    }
}
/**
 * Handler for ULabel keydown events.
 *
 * @param keydown_event Event to handle
 * @param ulabel ULabel instance
 * @returns Whether the event was handled
 */
function handle_keydown_event(keydown_event, ulabel) {
    var shift = keydown_event.shiftKey;
    var ctrl = keydown_event.ctrlKey || keydown_event.metaKey;
    var key_is_z = (keydown_event.key === "z" ||
        keydown_event.key === "Z" ||
        keydown_event.code === "KeyZ");
    if (ctrl && key_is_z) {
        keydown_event.preventDefault();
        if (shift) {
            ulabel.redo();
        }
        else {
            ulabel.undo();
        }
        return false;
    }
    else {
        var current_subtask = ulabel.get_current_subtask();
        switch (keydown_event.key.toLowerCase()) {
            case "escape":
                // If in erase or brush mode, cancel the brush
                if (current_subtask.state.is_in_erase_mode) {
                    ulabel.toggle_erase_mode();
                }
                else if (current_subtask.state.is_in_brush_mode) {
                    ulabel.toggle_brush_mode();
                }
                else if (current_subtask.state.starting_complex_polygon) {
                    // If starting a complex polygon, undo
                    ulabel.undo();
                }
                else if (current_subtask.state.is_in_progress) {
                    // If in the middle of drawing an annotation, cancel the annotation
                    ulabel.cancel_annotation();
                }
                break;
            case ulabel.config.fly_to_next_annotation_keybind.toLowerCase():
                // For 'tab', prevent default
                if (keydown_event.key.toLowerCase() === "tab") {
                    keydown_event.preventDefault();
                }
                if (ulabel.config.fly_to_previous_annotation_keybind === null && shift) {
                    ulabel.fly_to_next_annotation(-1, ulabel.config.fly_to_max_zoom);
                }
                else if (!shift) {
                    ulabel.fly_to_next_annotation(1, ulabel.config.fly_to_max_zoom);
                }
                break;
            case ulabel.config.fly_to_previous_annotation_keybind.toLowerCase():
                if (ulabel.config.fly_to_previous_annotation_keybind !== null) {
                    ulabel.fly_to_next_annotation(-1, ulabel.config.fly_to_max_zoom);
                }
                break;
        }
    }
}
/**
 * Create listeners for a ULabel instance.
 * Inline handlers must be arrow functions.
 * Consider breaking out long handlers.
 *
 * @param ulabel ULabel instance
 */
function create_ulabel_listeners(ulabel) {
    // ================= Mouse Events in the ID Dialog =================
    var id_dialog = $(".id_dialog");
    id_dialog.on("mousemove" + ULABEL_NAMESPACE, function (mouse_event) {
        if (!ulabel.get_current_subtask()["state"]["idd_thumbnail"]) {
            ulabel.handle_id_dialog_hover(mouse_event);
        }
    });
    // ================= Mouse Events in the Annotation Container =================
    var annbox = $("#" + ulabel.config["annbox_id"]);
    // Detect and record mousedown
    annbox.on("mousedown" + ULABEL_NAMESPACE, function (click_event) { return ulabel.handle_mouse_down(click_event); });
    // Prevent default for auxclick
    $(document).on("auxclick" + ULABEL_NAMESPACE, function (mouse_event) { return ulabel.handle_aux_click(mouse_event); });
    // Detect and record mouseup
    $(document).on("mouseup" + ULABEL_NAMESPACE, function (mouseup_event) { return ulabel.handle_mouse_up(mouseup_event); });
    $(window).on("click" + ULABEL_NAMESPACE, function (click_event) {
        if (click_event.shiftKey) {
            click_event.preventDefault();
        }
    });
    // Mouse movement has meaning in certain cases
    annbox.on("mousemove" + ULABEL_NAMESPACE, function (move_event) { return ulabel.handle_mouse_move(move_event); });
    // ================= Uncategorized =================
    $(document).on("keypress" + ULABEL_NAMESPACE, function (keypress_event) {
        handle_keypress_event(keypress_event, ulabel);
    });
    // This listener does not use jquery because it requires being able to prevent default
    // There are maybe some hacky ways to do this with jquery
    // https://stackoverflow.com/questions/60357083/does-not-use-passive-listeners-to-improve-scrolling-performance-lighthouse-repo
    // Detection ctrl+scroll
    document.getElementById(ulabel.config["annbox_id"]).addEventListener("wheel", function (wheel_event) { return ulabel.handle_wheel(wheel_event); });
    // Create a resize observer to reposition dialogs
    var dialog_resize_observer = new ResizeObserver(function () { return ulabel.reposition_dialogs(); });
    // Observe the changes on the imwrap_id element
    dialog_resize_observer.observe(document.getElementById(ulabel.config["imwrap_id"]));
    // Store a reference
    ulabel.resize_observers.push(dialog_resize_observer);
    // Create a resize observer to handle toolbox overflow
    var tb_overflow_resize_observer = new ResizeObserver(function () { return ulabel.handle_toolbox_overflow(); });
    // Observe the changes on the ulabel container
    tb_overflow_resize_observer.observe(document.getElementById(ulabel.config["container_id"]));
    // Store a reference
    ulabel.resize_observers.push(tb_overflow_resize_observer);
    // create_soft_id_toolbox_button_listener(ulabel);
    $(document).on("click" + ULABEL_NAMESPACE, "#".concat(ulabel.config["toolbox_id"], " a.tbid-opt"), function (click_event) {
        handle_soft_id_toolbox_button_click(click_event, ulabel);
    });
    $(document).on("click" + ULABEL_NAMESPACE, "a.tb-st-switch[href]", function (click_event) {
        var switch_to = $(click_event.target).attr("id").split("--")[1];
        // Ignore if in the middle of annotation
        if (ulabel.get_current_subtask()["state"]["is_in_progress"])
            return;
        ulabel.set_subtask(switch_to);
    });
    // Keybind to switch active subtask
    $(document).on("keypress" + ULABEL_NAMESPACE, function (keypress_event) {
        // Ignore if in the middle of annotation
        if (ulabel.get_current_subtask()["state"]["is_in_progress"])
            return;
        // Check for the right keypress
        if (keypress_event.key === ulabel.config.switch_subtask_keybind) {
            ulabel.switch_to_next_subtask();
        }
    });
    $(document).on("input" + ULABEL_NAMESPACE, "input.frame_input", function () { return ulabel.update_frame(); });
    $(document).on("input" + ULABEL_NAMESPACE, "span.tb-st-range input", function () { return ulabel.readjust_subtask_opacities(); });
    $(document).on("click" + ULABEL_NAMESPACE, "div.fad_row.add a.add-glob-button", function () { return ulabel.create_nonspatial_annotation(); });
    $(document).on("focus" + ULABEL_NAMESPACE, "textarea.nonspatial_note", function () { return $("div.frame_annotation_dialog.active").addClass("permopen"); });
    $(document).on("focusout" + ULABEL_NAMESPACE, "textarea.nonspatial_note", function () { return $("div.frame_annotation_dialog.permopen").removeClass("permopen"); });
    $(document).on("input" + ULABEL_NAMESPACE, "textarea.nonspatial_note", function (input_event) {
        // Update annotation's text field
        var annos = ulabel.get_current_subtask()["annotations"]["access"];
        var text_payload_anno_id = input_event.target.id.substring("note__".length);
        annos[text_payload_anno_id]["text_payload"] = input_event.target.value;
    });
    $(document).on("click" + ULABEL_NAMESPACE, "a.fad_button.delete", function (click_event) {
        ulabel.delete_annotation(click_event.target.id.substring("delete__".length));
    });
    $(document).on("click" + ULABEL_NAMESPACE, "a.fad_button.reclf", function (click_event) {
        // Show idd
        ulabel.show_id_dialog(click_event.pageX, click_event.pageY, click_event.target.id.substring("reclf__".length), false, true);
    });
    $(document).on("mouseenter" + ULABEL_NAMESPACE, "div.fad_annotation_rows div.fad_row", function (mouse_event) {
        // Show thumbnail for idd
        ulabel.suggest_edits(null, $(mouse_event.currentTarget).attr("id").substring("row__".length));
    });
    $(document).on("mouseleave" + ULABEL_NAMESPACE, "div.fad_annotation_rows div.fad_row", function () {
        // Show thumbnail for idd
        if (ulabel.get_current_subtask()["state"]["idd_visible"] &&
            !ulabel.get_current_subtask()["state"]["idd_thumbnail"]) {
            return;
        }
        ulabel.suggest_edits(null);
    });
    $(document).on("keypress" + ULABEL_NAMESPACE, function (keypress_event) {
        // Check the key pressed against the delete annotation keybind in the config
        if (keypress_event.key === ulabel.config.delete_annotation_keybind) {
            // Check the edit_candidate to make sure its not null and isn't nonspatial
            var edit_cand = ulabel.get_current_subtask().state.edit_candidate;
            if (edit_cand !== null && !annotation_1.NONSPATIAL_MODES.includes(edit_cand.spatial_type)) {
                ulabel.delete_annotation(edit_cand.annid);
            }
        }
    });
    // Listener for id_dialog click interactions
    $(document).on("click" + ULABEL_NAMESPACE, "#" + ulabel.config["container_id"] + " a.id-dialog-clickable-indicator", function (click_event) {
        if (!ulabel.get_current_subtask()["state"]["idd_thumbnail"]) {
            ulabel.handle_id_dialog_click(click_event);
        }
    });
    $(document).on("click" + ULABEL_NAMESPACE, ".global_edit_suggestion a.reid_suggestion", function (click_event) {
        var crst = ulabel.get_current_subtask();
        var annid = crst["state"]["idd_associated_annotation"];
        ulabel.hide_global_edit_suggestion();
        ulabel.show_id_dialog(ulabel.get_global_mouse_x(click_event), ulabel.get_global_mouse_y(click_event), annid, false);
    });
    $(document).on("click" + ULABEL_NAMESPACE, "#" + ulabel.config["annbox_id"] + " .delete_suggestion", function () {
        var crst = ulabel.get_current_subtask();
        ulabel.delete_annotation(crst["state"]["move_candidate"]["annid"]);
    });
    // Button to save annotations
    $(document).on("click" + ULABEL_NAMESPACE, "#" + ulabel.config["toolbox_id"] + " a.night-button", function () {
        var root_container = $("#" + ulabel.config["container_id"]);
        if (root_container.hasClass("ulabel-night")) {
            root_container.removeClass("ulabel-night");
            cookies_1.NightModeCookie.destroy_cookie();
        }
        else {
            root_container.addClass("ulabel-night");
            cookies_1.NightModeCookie.set_cookie();
        }
    });
    // Keyboard only events
    $(document).on("keydown" + ULABEL_NAMESPACE, function (keydown_event) {
        handle_keydown_event(keydown_event, ulabel);
    });
    $(window).on("beforeunload" + ULABEL_NAMESPACE, function () {
        if (ulabel.state["edited"]) {
            // Return of anything other than `undefined`
            // will trigger the browser's confirmation dialog
            // Custom messages are not supported
            return 1;
        }
    });
}
/**
 * Remove listeners from a ULabel instance.
 *
 * @param ulabel ULabel instance.
 */
function remove_ulabel_listeners(ulabel) {
    // Remove jquery event listeners with the ulabel namespace
    $(document).off(ULABEL_NAMESPACE);
    $(window).off(ULABEL_NAMESPACE);
    $(".id_dialog").off(ULABEL_NAMESPACE);
    // Go through each resize observer and disconnect them
    if (ulabel.resize_observers != null) {
        ulabel.resize_observers.forEach(function (observer) {
            observer.disconnect();
        });
    }
}


/***/ }),

/***/ 6888:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  topology: () => (/* reexport */ topology)
});

;// ./node_modules/topojson-server/src/object.js
var object_hasOwnProperty = Object.prototype.hasOwnProperty;

;// ./node_modules/topojson-server/src/bounds.js


// Computes the bounding box of the specified hash of GeoJSON objects.
/* harmony default export */ function bounds(objects) {
  var x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  function boundGeometry(geometry) {
    if (geometry != null && object_hasOwnProperty.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
  }

  var boundGeometryType = {
    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },
    Point: function(o) { boundPoint(o.coordinates); },
    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },
    LineString: function(o) { boundLine(o.arcs); },
    MultiLineString: function(o) { o.arcs.forEach(boundLine); },
    Polygon: function(o) { o.arcs.forEach(boundLine); },
    MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }
  };

  function boundPoint(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }

  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }

  for (var key in objects) {
    boundGeometry(objects[key]);
  }

  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;
}

;// ./node_modules/topojson-server/src/hash/hashset.js
/* harmony default export */ function hashset(size, hash, equal, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }

  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
      mask = size - 1;

  for (var i = 0; i < size; ++i) {
    store[i] = empty;
  }

  function add(value) {
    var index = hash(value) & mask,
        match = store[index],
        collisions = 0;
    while (match != empty) {
      if (equal(match, value)) return true;
      if (++collisions >= size) throw new Error("full hashset");
      match = store[index = (index + 1) & mask];
    }
    store[index] = value;
    return true;
  }

  function has(value) {
    var index = hash(value) & mask,
        match = store[index],
        collisions = 0;
    while (match != empty) {
      if (equal(match, value)) return true;
      if (++collisions >= size) break;
      match = store[index = (index + 1) & mask];
    }
    return false;
  }

  function values() {
    var values = [];
    for (var i = 0, n = store.length; i < n; ++i) {
      var match = store[i];
      if (match != empty) values.push(match);
    }
    return values;
  }

  return {
    add: add,
    has: has,
    values: values
  };
}

;// ./node_modules/topojson-server/src/hash/hashmap.js
/* harmony default export */ function hashmap(size, hash, equal, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }

  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
      valstore = new valueType(size),
      mask = size - 1;

  for (var i = 0; i < size; ++i) {
    keystore[i] = keyEmpty;
  }

  function set(key, value) {
    var index = hash(key) & mask,
        matchKey = keystore[index],
        collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index] = value;
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index = (index + 1) & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }

  function maybeSet(key, value) {
    var index = hash(key) & mask,
        matchKey = keystore[index],
        collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index];
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index = (index + 1) & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }

  function get(key, missingValue) {
    var index = hash(key) & mask,
        matchKey = keystore[index],
        collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index];
      if (++collisions >= size) break;
      matchKey = keystore[index = (index + 1) & mask];
    }
    return missingValue;
  }

  function keys() {
    var keys = [];
    for (var i = 0, n = keystore.length; i < n; ++i) {
      var matchKey = keystore[i];
      if (matchKey != keyEmpty) keys.push(matchKey);
    }
    return keys;
  }

  return {
    set: set,
    maybeSet: maybeSet, // set if unset
    get: get,
    keys: keys
  };
}

;// ./node_modules/topojson-server/src/hash/point-equal.js
/* harmony default export */ function point_equal(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}

;// ./node_modules/topojson-server/src/hash/point-hash.js
// TODO if quantized, use simpler Int32 hashing?

var buffer = new ArrayBuffer(16),
    floats = new Float64Array(buffer),
    uints = new Uint32Array(buffer);

/* harmony default export */ function point_hash(point) {
  floats[0] = point[0];
  floats[1] = point[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 0x7fffffff;
}

;// ./node_modules/topojson-server/src/join.js





// Given an extracted (pre-)topology, identifies all of the junctions. These are
// the points at which arcs (lines or rings) will need to be cut so that each
// arc is represented uniquely.
//
// A junction is a point where at least one arc deviates from another arc going
// through the same point. For example, consider the point B. If there is a arc
// through ABC and another arc through CBA, then B is not a junction because in
// both cases the adjacent point pairs are {A,C}. However, if there is an
// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.
//
// For a closed ring ABCA, the first point As adjacent points are the second
// and last point {B,C}. For a line, the first and last point are always
// considered junctions, even if the line is closed; this ensures that a closed
// line is never rotated.
/* harmony default export */ function join(topology) {
  var coordinates = topology.coordinates,
      lines = topology.lines,
      rings = topology.rings,
      indexes = index(),
      visitedByIndex = new Int32Array(coordinates.length),
      leftByIndex = new Int32Array(coordinates.length),
      rightByIndex = new Int32Array(coordinates.length),
      junctionByIndex = new Int8Array(coordinates.length),
      junctionCount = 0, // upper bound on number of junctions
      i, n,
      previousIndex,
      currentIndex,
      nextIndex;

  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
  }

  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i],
        lineStart = line[0],
        lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1; // start
    while (++lineStart <= lineEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1; // end
  }

  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = -1;
  }

  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i],
        ringStart = ring[0] + 1,
        ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }

  function sequence(i, previousIndex, currentIndex, nextIndex) {
    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
    visitedByIndex[currentIndex] = i;
    var leftIndex = leftByIndex[currentIndex];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex];
      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)
        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
        ++junctionCount, junctionByIndex[currentIndex] = 1;
      }
    } else {
      leftByIndex[currentIndex] = previousIndex;
      rightByIndex[currentIndex] = nextIndex;
    }
  }

  function index() {
    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),
        indexes = new Int32Array(coordinates.length);

    for (var i = 0, n = coordinates.length; i < n; ++i) {
      indexes[i] = indexByPoint.maybeSet(i, i);
    }

    return indexes;
  }

  function hashIndex(i) {
    return point_hash(coordinates[i]);
  }

  function equalIndex(i, j) {
    return point_equal(coordinates[i], coordinates[j]);
  }

  visitedByIndex = leftByIndex = rightByIndex = null;

  var junctionByPoint = hashset(junctionCount * 1.4, point_hash, point_equal), j;

  // Convert back to a standard hashset by point for caller convenience.
  for (i = 0, n = coordinates.length; i < n; ++i) {
    if (junctionByIndex[j = indexes[i]]) {
      junctionByPoint.add(coordinates[j]);
    }
  }

  return junctionByPoint;
}

;// ./node_modules/topojson-server/src/cut.js


// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared
// point sequences are identified. The topology can then be subsequently deduped
// to remove exact duplicate arcs.
/* harmony default export */ function cut(topology) {
  var junctions = join(topology),
      coordinates = topology.coordinates,
      lines = topology.lines,
      rings = topology.rings,
      next,
      i, n;

  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i],
        lineMid = line[0],
        lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next = {0: lineMid, 1: line[1]};
        line[1] = lineMid;
        line = line.next = next;
      }
    }
  }

  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i],
        ringStart = ring[0],
        ringMid = ringStart,
        ringEnd = ring[1],
        ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next = {0: ringMid, 1: ring[1]};
          ring[1] = ringMid;
          ring = ring.next = next;
        } else { // For the first junction, we can rotate rather than cut.
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart; // restart; we may have skipped junctions
        }
      }
    }
  }

  return topology;
}

function rotateArray(array, start, end, offset) {
  reverse(array, start, end);
  reverse(array, start, start + offset);
  reverse(array, start + offset, end);
}

function reverse(array, start, end) {
  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {
    t = array[start], array[start] = array[end], array[end] = t;
  }
}

;// ./node_modules/topojson-server/src/dedup.js




// Given a cut topology, combines duplicate arcs.
/* harmony default export */ function dedup(topology) {
  var coordinates = topology.coordinates,
      lines = topology.lines, line,
      rings = topology.rings, ring,
      arcCount = lines.length + rings.length,
      i, n;

  delete topology.lines;
  delete topology.rings;

  // Count the number of (non-unique) arcs to initialize the hashmap safely.
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i]; while (line = line.next) ++arcCount;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i]; while (ring = ring.next) ++arcCount;
  }

  var arcsByEnd = hashmap(arcCount * 2 * 1.4, point_hash, point_equal),
      arcs = topology.arcs = [];

  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    do {
      dedupLine(line);
    } while (line = line.next);
  }

  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    if (ring.next) { // arc is no longer closed
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }

  function dedupLine(arc) {
    var startPoint,
        endPoint,
        startArcs, startArc,
        endArcs, endArc,
        i, n;

    // Does this arc match an existing arc in order?
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i = 0, n = startArcs.length; i < n; ++i) {
        startArc = startArcs[i];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }

    // Does this arc match an existing arc in reverse order?
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i = 0, n = endArcs.length; i < n; ++i) {
        endArc = endArcs[i];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }

    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);
    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }

  function dedupRing(arc) {
    var endPoint,
        endArcs,
        endArc,
        i, n;

    // Does this arc match an existing line in order, or reverse order?
    // Rings are closed, so their start point and end point is the same.
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i = 0, n = endArcs.length; i < n; ++i) {
        endArc = endArcs[i];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }

    // Otherwise, does this arc match an existing ring in order, or reverse order?
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i = 0, n = endArcs.length; i < n; ++i) {
        endArc = endArcs[i];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }

    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }

  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0],
        ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, ++ib) if (!point_equal(coordinates[ia], coordinates[ib])) return false;
    return true;
  }

  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0],
        ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, --jb) if (!point_equal(coordinates[ia], coordinates[jb])) return false;
    return true;
  }

  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0],
        ja = arcA[1], jb = arcB[1],
        n = ja - ia;
    if (n !== jb - ib) return false;
    var ka = findMinimumOffset(arcA),
        kb = findMinimumOffset(arcB);
    for (var i = 0; i < n; ++i) {
      if (!point_equal(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
    }
    return true;
  }

  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0],
        ja = arcA[1], jb = arcB[1],
        n = ja - ia;
    if (n !== jb - ib) return false;
    var ka = findMinimumOffset(arcA),
        kb = n - findMinimumOffset(arcB);
    for (var i = 0; i < n; ++i) {
      if (!point_equal(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
    }
    return true;
  }

  // Rings are rotated to a consistent, but arbitrary, start point.
  // This is necessary to detect when a ring and a rotated copy are dupes.
  function findMinimumOffset(arc) {
    var start = arc[0],
        end = arc[1],
        mid = start,
        minimum = mid,
        minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point = coordinates[mid];
      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point;
      }
    }
    return minimum - start;
  }

  return topology;
}

;// ./node_modules/topojson-server/src/delta.js
// Given an array of arcs in absolute (but already quantized!) coordinates,
// converts to fixed-point delta encoding.
// This is a destructive operation that modifies the given arcs!
/* harmony default export */ function delta(arcs) {
  var i = -1,
      n = arcs.length;

  while (++i < n) {
    var arc = arcs[i],
        j = 0,
        k = 1,
        m = arc.length,
        point = arc[0],
        x0 = point[0],
        y0 = point[1],
        x1,
        y1;

    while (++j < m) {
      point = arc[j], x1 = point[0], y1 = point[1];
      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
    }

    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.

    arc.length = k;
  }

  return arcs;
}

;// ./node_modules/topojson-server/src/extract.js


// Extracts the lines and rings from the specified hash of geometry objects.
//
// Returns an object with three properties:
//
// * coordinates - shared buffer of [x, y] coordinates
// * lines - lines extracted from the hash, of the form [start, end]
// * rings - rings extracted from the hash, of the form [start, end]
//
// For each ring or line, start and end represent inclusive indexes into the
// coordinates buffer. For rings (and closed lines), coordinates[start] equals
// coordinates[end].
//
// For each line or polygon geometry in the input hash, including nested
// geometries as in geometry collections, the `coordinates` array is replaced
// with an equivalent `arcs` array that, for each line (for line string
// geometries) or ring (for polygon geometries), points to one of the above
// lines or rings.
/* harmony default export */ function extract(objects) {
  var index = -1,
      lines = [],
      rings = [],
      coordinates = [];

  function extractGeometry(geometry) {
    if (geometry && object_hasOwnProperty.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
  }

  var extractGeometryType = {
    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },
    LineString: function(o) { o.arcs = extractLine(o.arcs); },
    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },
    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },
    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }
  };

  function extractLine(line) {
    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
    var arc = {0: index - n + 1, 1: index};
    lines.push(arc);
    return arc;
  }

  function extractRing(ring) {
    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
    var arc = {0: index - n + 1, 1: index};
    rings.push(arc);
    return arc;
  }

  function extractMultiRing(rings) {
    return rings.map(extractRing);
  }

  for (var key in objects) {
    extractGeometry(objects[key]);
  }

  return {
    type: "Topology",
    coordinates: coordinates,
    lines: lines,
    rings: rings,
    objects: objects
  };
}

;// ./node_modules/topojson-server/src/geometry.js
// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
// Any null input geometry objects are represented as {type: null} in the output.
// Any feature.{id,properties,bbox} are transferred to the output geometry object.
// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
/* harmony default export */ function geometry(inputs) {
  var outputs = {}, key;
  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}

function geomifyObject(input) {
  return input == null ? {type: null}
      : (input.type === "FeatureCollection" ? geomifyFeatureCollection
      : input.type === "Feature" ? geomifyFeature
      : geomifyGeometry)(input);
}

function geomifyFeatureCollection(input) {
  var output = {type: "GeometryCollection", geometries: input.features.map(geomifyFeature)};
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}

function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  for (key in input.properties) { output.properties = input.properties; break; }
  return output;
}

function geomifyGeometry(input) {
  if (input == null) return {type: null};
  var output = input.type === "GeometryCollection" ? {type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry)}
      : input.type === "Point" || input.type === "MultiPoint" ? {type: input.type, coordinates: input.coordinates}
      : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}

;// ./node_modules/topojson-server/src/prequantize.js


/* harmony default export */ function prequantize(objects, bbox, n) {
  var x0 = bbox[0],
      y0 = bbox[1],
      x1 = bbox[2],
      y1 = bbox[3],
      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,
      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;

  function quantizePoint(input) {
    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
  }

  function quantizePoints(input, m) {
    var i = -1,
        j = 0,
        n = input.length,
        output = new Array(n), // pessimistic
        pi,
        px,
        py,
        x,
        y;

    while (++i < n) {
      pi = input[i];
      x = Math.round((pi[0] - x0) * kx);
      y = Math.round((pi[1] - y0) * ky);
      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points
    }

    output.length = j;
    while (j < m) j = output.push([output[0][0], output[0][1]]);
    return output;
  }

  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }

  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }

  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }

  function quantizeGeometry(o) {
    if (o != null && object_hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
  }

  var quantizeGeometryType = {
    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },
    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },
    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },
    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },
    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },
    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },
    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }
  };

  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }

  return {
    scale: [1 / kx, 1 / ky],
    translate: [x0, y0]
  };
}

;// ./node_modules/topojson-server/src/topology.js










// Constructs the TopoJSON Topology for the specified hash of features.
// Each object in the specified hash must be a GeoJSON object,
// meaning FeatureCollection, a Feature or a geometry object.
/* harmony default export */ function topology(objects, quantization) {
  var bbox = bounds(objects = geometry(objects)),
      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),
      topology = dedup(cut(extract(objects))),
      coordinates = topology.coordinates,
      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);

  objects = topology.objects; // for garbage collection
  topology.bbox = bbox;
  topology.arcs = topology.arcs.map(function(arc, i) {
    indexByArc.set(arc, i);
    return coordinates.slice(arc[0], arc[1] + 1);
  });

  delete topology.coordinates;
  coordinates = null;

  function indexGeometry(geometry) {
    if (geometry && object_hasOwnProperty.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
  }

  var indexGeometryType = {
    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },
    LineString: function(o) { o.arcs = indexArcs(o.arcs); },
    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },
    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },
    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }
  };

  function indexArcs(arc) {
    var indexes = [];
    do {
      var index = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index : ~index);
    } while (arc = arc.next);
    return indexes;
  }

  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }

  for (var key in objects) {
    indexGeometry(objects[key]);
  }

  if (transform) {
    topology.transform = transform;
    topology.arcs = delta(topology.arcs);
  }

  return topology;
}

function hashArc(arc) {
  var i = arc[0], j = arc[1], t;
  if (j < i) t = i, i = j, j = t;
  return i + 31 * j;
}

function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1],
      ib = arcB[0], jb = arcB[1], t;
  if (ja < ia) t = ia, ia = ja, ja = t;
  if (jb < ib) t = ib, ib = jb, jb = t;
  return ia === ib && ja === jb;
}

;// ./node_modules/topojson-server/src/index.js



/***/ }),

/***/ 6897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(453);
var define = __webpack_require__(41);
var hasDescriptors = __webpack_require__(592)();
var gOPD = __webpack_require__(5795);

var $TypeError = GetIntrinsic('%TypeError%');
var $floor = GetIntrinsic('%Math.floor%');

/** @typedef {(...args: unknown[]) => unknown} Func */

/** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ 6979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var explode = __webpack_require__(3707);
var centroid = __webpack_require__(6649);
var nearestPoint = __webpack_require__(9791);
var booleanPointInPolygon = __webpack_require__(2446);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var explode__default = /*#__PURE__*/_interopDefaultLegacy(explode);
var centroid__default = /*#__PURE__*/_interopDefaultLegacy(centroid);
var nearestPoint__default = /*#__PURE__*/_interopDefaultLegacy(nearestPoint);
var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);

/**
 * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.
 *
 * * Given a {@link Polygon}, the point will be in the area of the polygon
 * * Given a {@link LineString}, the point will be along the string
 * * Given a {@link Point}, the point will the same as the input
 *
 * @name pointOnFeature
 * @param {GeoJSON} geojson any Feature or FeatureCollection
 * @returns {Feature<Point>} a point on the surface of `input`
 * @example
 * var polygon = turf.polygon([[
 *   [116, -36],
 *   [131, -32],
 *   [146, -43],
 *   [155, -25],
 *   [133, -9],
 *   [111, -22],
 *   [116, -36]
 * ]]);
 *
 * var pointOnPolygon = turf.pointOnFeature(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, pointOnPolygon];
 */
function pointOnFeature(geojson) {
  // normalize
  var fc = normalize(geojson);

  // get centroid
  var cent = centroid__default['default'](fc);

  // check to see if centroid is on surface
  var onSurface = false;
  var i = 0;
  while (!onSurface && i < fc.features.length) {
    var geom = fc.features[i].geometry;
    var x, y, x1, y1, x2, y2, k;
    var onLine = false;
    if (geom.type === "Point") {
      if (
        cent.geometry.coordinates[0] === geom.coordinates[0] &&
        cent.geometry.coordinates[1] === geom.coordinates[1]
      ) {
        onSurface = true;
      }
    } else if (geom.type === "MultiPoint") {
      var onMultiPoint = false;
      k = 0;
      while (!onMultiPoint && k < geom.coordinates.length) {
        if (
          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
          cent.geometry.coordinates[1] === geom.coordinates[k][1]
        ) {
          onSurface = true;
          onMultiPoint = true;
        }
        k++;
      }
    } else if (geom.type === "LineString") {
      k = 0;
      while (!onLine && k < geom.coordinates.length - 1) {
        x = cent.geometry.coordinates[0];
        y = cent.geometry.coordinates[1];
        x1 = geom.coordinates[k][0];
        y1 = geom.coordinates[k][1];
        x2 = geom.coordinates[k + 1][0];
        y2 = geom.coordinates[k + 1][1];
        if (pointOnSegment(x, y, x1, y1, x2, y2)) {
          onLine = true;
          onSurface = true;
        }
        k++;
      }
    } else if (geom.type === "MultiLineString") {
      var j = 0;
      while (j < geom.coordinates.length) {
        onLine = false;
        k = 0;
        var line = geom.coordinates[j];
        while (!onLine && k < line.length - 1) {
          x = cent.geometry.coordinates[0];
          y = cent.geometry.coordinates[1];
          x1 = line[k][0];
          y1 = line[k][1];
          x2 = line[k + 1][0];
          y2 = line[k + 1][1];
          if (pointOnSegment(x, y, x1, y1, x2, y2)) {
            onLine = true;
            onSurface = true;
          }
          k++;
        }
        j++;
      }
    } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
      if (booleanPointInPolygon__default['default'](cent, geom)) {
        onSurface = true;
      }
    }
    i++;
  }
  if (onSurface) {
    return cent;
  } else {
    var vertices = helpers.featureCollection([]);
    for (i = 0; i < fc.features.length; i++) {
      vertices.features = vertices.features.concat(
        explode__default['default'](fc.features[i]).features
      );
    }
    // Remove distanceToPoint properties from nearestPoint()
    return helpers.point(nearestPoint__default['default'](cent, vertices).geometry.coordinates);
  }
}

/**
 * Normalizes any GeoJSON to a FeatureCollection
 *
 * @private
 * @name normalize
 * @param {GeoJSON} geojson Any GeoJSON
 * @returns {FeatureCollection} FeatureCollection
 */
function normalize(geojson) {
  if (geojson.type !== "FeatureCollection") {
    if (geojson.type !== "Feature") {
      return helpers.featureCollection([helpers.feature(geojson)]);
    }
    return helpers.featureCollection([geojson]);
  }
  return geojson;
}

function pointOnSegment(x, y, x1, y1, x2, y2) {
  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
  return ab === ap + pb;
}

module.exports = pointOnFeature;
module.exports["default"] = pointOnFeature;


/***/ }),

/***/ 7042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
/**
 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a
 * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
 *
 * @name lineSegment
 * @param {GeoJSON} geojson GeoJSON Polygon or LineString
 * @returns {FeatureCollection<LineString>} 2-vertex line segments
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 * var segments = turf.lineSegment(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, segments]
 */
function lineSegment(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    var results = [];
    meta_1.flattenEach(geojson, function (feature) {
        lineSegmentFeature(feature, results);
    });
    return helpers_1.featureCollection(results);
}
/**
 * Line Segment
 *
 * @private
 * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
 * @param {Array} results push to results
 * @returns {void}
 */
function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
        switch (geometry.type) {
            case "Polygon":
                coords = invariant_1.getCoords(geometry);
                break;
            case "LineString":
                coords = [invariant_1.getCoords(geometry)];
        }
        coords.forEach(function (coord) {
            var segments = createSegments(coord, geojson.properties);
            segments.forEach(function (segment) {
                segment.id = results.length;
                results.push(segment);
            });
        });
    }
}
/**
 * Create Segments from LineString coordinates
 *
 * @private
 * @param {Array<Array<number>>} coords LineString coordinates
 * @param {*} properties GeoJSON properties
 * @returns {Array<Feature<LineString>>} line segments
 */
function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function (previousCoords, currentCoords) {
        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}
/**
 * Create BBox between two coordinates (faster than @turf/bbox)
 *
 * @private
 * @param {Array<number>} coords1 Point coordinate
 * @param {Array<number>} coords2 Point coordinate
 * @returns {BBox} [west, south, east, north]
 */
function bbox(coords1, coords2) {
    var x1 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = x1 < x2 ? x1 : x2;
    var south = y1 < y2 ? y1 : y2;
    var east = x1 > x2 ? x1 : x2;
    var north = y1 > y2 ? y1 : y2;
    return [west, south, east, north];
}
exports["default"] = lineSegment;


/***/ }),

/***/ 7095:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);
var meta = __webpack_require__(8421);
var flatten = __webpack_require__(4036);
var polygonClipping = __webpack_require__(9004);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var flatten__default = /*#__PURE__*/_interopDefaultLegacy(flatten);
var polygonClipping__default = /*#__PURE__*/_interopDefaultLegacy(polygonClipping);

/**
 * Dissolves a FeatureCollection of {@link polygon} features, filtered by an optional property name:value.
 * Note that {@link mulitpolygon} features within the collection are not supported
 *
 * @name dissolve
 * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.propertyName] features with the same `propertyName` value will be dissolved.
 * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons
 * @example
 * var features = turf.featureCollection([
 *   turf.polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]], {combine: 'yes'}),
 *   turf.polygon([[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]], {combine: 'yes'}),
 *   turf.polygon([[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]], {combine: 'no'}),
 * ]);
 *
 * var dissolved = turf.dissolve(features, {propertyName: 'combine'});
 *
 * //addToMap
 * var addToMap = [features, dissolved]
 */
function dissolve(fc, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var propertyName = options.propertyName;

  // Input validation
  invariant.collectionOf(fc, "Polygon", "dissolve");

  // Main
  var outFeatures = [];
  if (!options.propertyName) {
    return flatten__default['default'](
      helpers.multiPolygon(
        polygonClipping__default['default'].union.apply(
          null,
          fc.features.map(function (f) {
            return f.geometry.coordinates;
          })
        )
      )
    );
  } else {
    var uniquePropertyVals = {};
    meta.featureEach(fc, function (feature) {
      if (
        !Object.prototype.hasOwnProperty.call(
          uniquePropertyVals,
          feature.properties[propertyName]
        )
      ) {
        uniquePropertyVals[feature.properties[propertyName]] = [];
      }
      uniquePropertyVals[feature.properties[propertyName]].push(feature);
    });
    var vals = Object.keys(uniquePropertyVals);
    for (var i = 0; i < vals.length; i++) {
      var mp = helpers.multiPolygon(
        polygonClipping__default['default'].union.apply(
          null,
          uniquePropertyVals[vals[i]].map(function (f) {
            return f.geometry.coordinates;
          })
        )
      );
      mp.properties[propertyName] = vals[i];
      outFeatures.push(mp);
    }
  }

  return flatten__default['default'](helpers.featureCollection(outFeatures));
}

module.exports = dissolve;
module.exports["default"] = dissolve;


/***/ }),

/***/ 7105:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ULabel: () => (/* binding */ ULabel),
  "default": () => (/* binding */ src)
});

// EXTERNAL MODULE: ./build/annotation.js
var build_annotation = __webpack_require__(5573);
// EXTERNAL MODULE: ./build/subtask.js
var subtask = __webpack_require__(9929);
// EXTERNAL MODULE: ./build/geometric_utils.js
var geometric_utils = __webpack_require__(6697);
// EXTERNAL MODULE: ./build/configuration.js
var configuration = __webpack_require__(496);
// EXTERNAL MODULE: ./build/drawing_utilities.js
var drawing_utilities = __webpack_require__(9219);
// EXTERNAL MODULE: ./build/annotation_operators.js
var annotation_operators = __webpack_require__(2571);
// EXTERNAL MODULE: ./build/listeners.js
var listeners = __webpack_require__(6847);
// EXTERNAL MODULE: ./build/error_logging.js
var error_logging = __webpack_require__(5638);
// EXTERNAL MODULE: ./build/canvas_utils.js
var canvas_utils = __webpack_require__(5750);
// EXTERNAL MODULE: ./build/actions.js
var actions = __webpack_require__(1353);
// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var jquery = __webpack_require__(4692);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);
;// ./node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
;// ./node_modules/uuid/dist/esm-browser/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
;// ./node_modules/uuid/dist/esm-browser/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ const esm_browser_validate = (validate);
;// ./node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_browser_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_browser_stringify = (stringify);
;// ./node_modules/uuid/dist/esm-browser/v4.js



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return esm_browser_stringify(rnds);
}

/* harmony default export */ const esm_browser_v4 = (v4);
// EXTERNAL MODULE: ./src/blobs.js
var blobs = __webpack_require__(2748);
// EXTERNAL MODULE: ./src/version.js
var version = __webpack_require__(1424);
// EXTERNAL MODULE: ./build/toolbox.js
var toolbox = __webpack_require__(3045);
// EXTERNAL MODULE: ./build/initializer.js
var initializer = __webpack_require__(3066);
;// ./src/index.js
/*
Uncertain Labeling Tool
Sentera Inc.
*/













const jQuery = (jquery_default());

// Electron workaround: https://github.com/electron/electron/issues/254
// eslint-disable-next-line @typescript-eslint/no-require-imports, no-undef
window.$ = window.jQuery = __webpack_require__(4692);








jQuery.fn.outer_html = function () {
    return jQuery("<div />").append(this.eq(0).clone()).html();
};

class ULabel {
    static version() {
        return version.ULABEL_VERSION;
    }

    // ================= Static Utilities =================

    // Returns current epoch time in milliseconds
    static get_time() {
        return (new Date()).toISOString();
    }

    static get_allowed_toolbox_item_enum() {
        return configuration.AllowedToolboxItem;
    }

    /*
    Types of drags
        - annotation
            - Bare canvas left mousedown
        - edit
            - Editable left mousedown
        - pan
            - Ctrl-left mousedown
            - Center mousedown
        - zoom
            - Right mousedown
            - Shift-left mousedown
    */
    static get_drag_key_start(mouse_event, ul) {
        if (ul.get_current_subtask()["state"]["active_id"] != null) {
            if (mouse_event.button === 1) {
                return "pan";
            } else if (mouse_event.button === 2) {
                return "right";
            }
            return "annotation";
        }
        switch (mouse_event.button) {
            case 0:
                if (mouse_event.target.id === "brush_circle") {
                    return "brush";
                } else if (mouse_event.target.id === ul.get_current_subtask()["canvas_fid"]) {
                    if (mouse_event.ctrlKey || mouse_event.metaKey) {
                        return "pan";
                    }
                    if (mouse_event.shiftKey) {
                        return "zoom";
                    }
                    return "annotation";
                } else if (jquery_default()(mouse_event.target).hasClass("editable")) {
                    return "edit";
                } else if (jquery_default()(mouse_event.target).hasClass("movable")) {
                    mouse_event.preventDefault();
                    return "move";
                } else {
                    return null;
                }
            case 1:
                return "pan";
            case 2:
                return null;
        }
    }

    /**
     * Removes persistent event listeners from the document and window.
     * Listeners attached directly to html elements are not explicitly removed.
     * Note that ULabel will not function properly after this method is called.
     */
    remove_listeners() {
        (0,listeners.remove_ulabel_listeners)(this);
    }

    static process_allowed_modes(ul, subtask_key, subtask) {
        // TODO(v1) check to make sure these are known modes
        ul.subtasks[subtask_key]["allowed_modes"] = subtask["allowed_modes"];
    }

    static create_unused_class_id(ulabel) {
        // More likely to be valid than always starting at 0, but use 0 if valid_class_ids is undefined
        let current_id = ulabel.valid_class_ids ? ulabel.valid_class_ids.length : 0;

        // Loop until a valid id is found
        while (true) {
            // If the current id is not currently being used, then return it
            if (!ulabel.valid_class_ids.includes(current_id)) return current_id;

            // If the id was being used, then increment the id and try again
            current_id++;
        }
    }

    static process_classes(ulabel, subtask_key, raw_subtask_json) {
        // Check to make sure allowed classes were provided
        if (!("classes" in raw_subtask_json)) {
            (0,error_logging.log_message)(`classes not specified for subtask "${subtask_key}"`, error_logging.LogLevel.ERROR);
        }
        if (typeof raw_subtask_json.classes != "object" || raw_subtask_json.classes.length === undefined || raw_subtask_json.classes.length === 0) {
            (0,error_logging.log_message)(`classes has an invalid value for subtask "${subtask_key}"`, error_logging.LogLevel.ERROR);
        }

        // Create a constant to hold the actual ULabelSubtask
        // The raw subtask is used for reading values that are constant inside this method, the actual subtask is for writing values
        const subtask = ulabel.subtasks[subtask_key];

        // Set to single class mode if applicable
        subtask.single_class_mode = (raw_subtask_json.classes.length === 1);

        // Populate allowed classes vars
        // TODO might be nice to recognize duplicate classes and assign same color... idk
        // TODO better handling of default class ids would definitely be a good idea
        subtask.class_defs = [];
        subtask.class_ids = [];

        // Loop through each class_definition allowed inside this subtask
        for (const class_definition of raw_subtask_json.classes) {
            // Create a class definition based on the provided class_definition that will be saved to the subtask
            let modifed_class_definition = {};
            let name, id, color, keybind;
            switch (typeof class_definition) {
                case "string":
                    modifed_class_definition = {
                        name: class_definition, // When class_definition is a string, that string is the class name
                        id: ULabel.create_unused_class_id(ulabel), // Create an id that's unused by another class
                        color: blobs.COLORS[ulabel.valid_class_ids.length], // Arbitrary yet unique color
                    };
                    break;
                case "object":
                    // If no name is provided, give a generic name based on the total number of currently initialized classes
                    name = class_definition.name ?? `Class ${ulabel.valid_class_ids.length}`;

                    // Skip classes with the reserved DELETE_CLASS_ID
                    if (class_definition.id === build_annotation.DELETE_CLASS_ID) {
                        (0,error_logging.log_message)(
                            `Class id ${build_annotation.DELETE_CLASS_ID} is reserved for delete mode and cannot be used for class definitions`,
                            error_logging.LogLevel.WARNING,
                        );
                        continue;
                    }

                    // Only create an id if one wasn't provided
                    id = class_definition.id ?? ULabel.create_unused_class_id(ulabel);

                    if (ulabel.valid_class_ids.includes(id)) {
                        (0,error_logging.log_message)(`Duplicate class id ${id} detected. This is not supported and may result in unintended side-effects.
                        This may be caused by mixing string and object class definitions, or by assigning the same id to two or more object class definitions.`,
                        error_logging.LogLevel.WARNING);
                    }

                    // Use generic color only if color not provided
                    color = class_definition.color ?? blobs.COLORS[ulabel.valid_class_ids.length];

                    // Save the keybind if it exists, otherwise default to null
                    keybind = class_definition.keybind ?? null;

                    modifed_class_definition = {
                        name: name,
                        id: id,
                        color: color,
                        keybind: keybind,
                    };
                    break;
                default:
                    (0,error_logging.log_message)(`Entry in classes not understood: ${class_definition}\n${class_definition} must either be a string or an object.`, error_logging.LogLevel.ERROR);
            }

            // Save the class definitions and ids on the subtask
            subtask.class_defs.push(modifed_class_definition);
            subtask.class_ids.push(modifed_class_definition.id);

            // Also save the id and color_info on the ULabel object
            ulabel.valid_class_ids.push(modifed_class_definition.id);
            ulabel.color_info[modifed_class_definition.id] = modifed_class_definition.color;
        }

        // If the subtask has any DELETE_MODE enabled, add a class definition for it
        if (subtask.allowed_modes.some((mode) => build_annotation.DELETE_MODES.includes(mode))) {
            subtask.class_defs.push({
                name: "Delete",
                id: build_annotation.DELETE_CLASS_ID,
                // Default to crimson
                color: blobs.COLORS[1],
                keybind: null,
            });
            ulabel.valid_class_ids.push(build_annotation.DELETE_CLASS_ID);
            ulabel.color_info[build_annotation.DELETE_CLASS_ID] = blobs.COLORS[1];
        }
    }

    static process_resume_from(ul, subtask_key, subtask) {
        // Initialize to no annotations
        ul.subtasks[subtask_key]["annotations"] = {
            ordering: [],
            access: {},
        };
        if (subtask["resume_from"] != null) {
            for (var i = 0; i < subtask["resume_from"].length; i++) {
                // Get copy of annotation to import for modification before incorporation
                let cand = build_annotation.ULabelAnnotation.from_json(JSON.parse(JSON.stringify(subtask["resume_from"][i])));
                if (cand === null) {
                    continue;
                }

                // Ensure the id is unique
                if (
                    (cand.id === undefined) || (cand.id in ul.subtasks[subtask_key]["annotations"]["access"])
                ) {
                    cand.id = ul.make_new_annotation_id();
                }

                // Set to default line size if there is none, check for null and undefined using ==
                if (
                    (cand.line_size === undefined) || (cand.line_size == null)
                ) {
                    cand.line_size = ul.get_initial_line_size();
                }

                // Add created by attribute if there is none
                if (
                    (cand.created_by === undefined)
                ) {
                    cand.created_by = "unknown";
                }

                // Add created at attribute if there is none
                if (
                    (cand.created_at === undefined)
                ) {
                    cand.created_at = null;
                }

                // Add last edited by attribute if there is none
                if (
                    (cand.last_edited_by === undefined)
                ) {
                    cand.last_edited_by = "unknown";
                }

                // Add last edited at attribute if there is none
                if (
                    (cand.last_edited_at === undefined)
                ) {
                    cand.last_edited_at = null;
                }

                // Add deprecated at attribute if there is none
                if (
                    (cand.deprecated === undefined)
                ) {
                    (0,annotation_operators.mark_deprecated)(cand, false);
                }

                // Throw error if no spatial type is found
                if (
                    (cand.spatial_type === undefined)
                ) {
                    (0,error_logging.log_message)(`Failed to import annotation without a spatial type (id: ${cand.id})`, error_logging.LogLevel.ERROR);
                }

                // Throw error if no spatial payload is found, if the spatial type requires one
                if (
                    (cand.spatial_payload === undefined) && !build_annotation.NONSPATIAL_MODES.includes(cand.spatial_type)
                ) {
                    (0,error_logging.log_message)(`Failed to import ${cand.spatial_type} annotation without a spatial payload (id: ${cand.id})`, error_logging.LogLevel.ERROR);
                } else if (
                    cand.spatial_type === "polygon" && cand.spatial_payload.length < 1
                ) {
                    (0,error_logging.log_message)(`Skipping attempted import of polygon annotation without any points (id: ${cand.id})`, error_logging.LogLevel.WARNING, true);
                    continue;
                }

                // Set frame to zero if not provided
                if (
                    (cand.frame === undefined)
                ) {
                    cand.frame = 0;
                }

                // Set annotation_meta if not provided
                if (
                    (cand.annotation_meta === undefined)
                ) {
                    cand.annotation_meta = {};
                }

                // Throw error if no classification payload is found
                if (
                    (cand.classification_payloads === undefined)
                ) {
                    (0,error_logging.log_message)(`Failed to import ${cand.spatial_type} annotation without a classification payload (id: ${cand.id})`, error_logging.LogLevel.ERROR);
                }

                // Ensure that classification payloads are compatible with config
                cand.ensure_compatible_classification_payloads(ul.subtasks[subtask_key].class_ids);

                cand.classification_payloads.sort(
                    (a, b) => {
                        return (
                            ul.subtasks[subtask_key].class_ids.find((e) => e === a.class_id) -
                            ul.subtasks[subtask_key].class_ids.find((e) => e === b.class_id)
                        );
                    },
                );

                // Push to ordering and add to access
                ul.subtasks[subtask_key]["annotations"]["ordering"].push(cand.id);
                ul.subtasks[subtask_key]["annotations"]["access"][cand.id] = cand;

                if (cand.spatial_type === "polygon") {
                    // If missing any of `spatial_payload_holes` or `spatial_payload_child_indices`,
                    // or if they don't match the length of `spatial_payload`, then rebuild them
                    if (
                        (cand.spatial_payload_holes === undefined) ||
                        (cand.spatial_payload_child_indices === undefined) ||
                        cand.spatial_payload_holes.length !== cand.spatial_payload.length ||
                        cand.spatial_payload_child_indices.length !== cand.spatial_payload.length
                    ) {
                        ul.state.current_subtask = subtask_key;
                        // For polygons, verify all layers
                        ul.verify_all_polygon_complex_layers(cand.id);
                    }
                }

                // Update the containing box for all spatial types
                if (!build_annotation.NONSPATIAL_MODES.includes(cand.spatial_type)) {
                    ul.rebuild_containing_box(cand.id, false, subtask_key);
                }
            }
        }
    }

    static initialize_subtasks(ul) {
        let first_non_ro = null;

        // Initialize a place on the ulabel object to hold annotation color information
        ul.color_info = {};

        // Initialize a place on the ulabel object to hold all classification ids
        ul.valid_class_ids = [];

        // Perform initialization tasks on each subtask individually
        for (const subtask_key in ul.config.subtasks) {
            // For convenience, make a raw subtask var
            let raw_subtask = ul.config.subtasks[subtask_key];
            ul.subtasks[subtask_key] = subtask/* ULabelSubtask */.D.from_json(subtask_key, raw_subtask);

            if (first_non_ro === null && !ul.subtasks[subtask_key]["read_only"]) {
                first_non_ro = subtask_key;
            }

            // Process allowed_modes
            // They are placed in ul.subtasks[subtask_key]["allowed_modes"]
            ULabel.process_allowed_modes(ul, subtask_key, raw_subtask);
            // Process allowed classes
            // They are placed in ul.subtasks[subtask_key]["class_defs"]
            ULabel.process_classes(ul, subtask_key, raw_subtask);
            // Process imported annoations
            // They are placed in ul.subtasks[subtask_key]["annotations"]
            ULabel.process_resume_from(ul, subtask_key, raw_subtask);

            // Label canvasses and initialize context with null
            ul.subtasks[subtask_key]["canvas_fid"] = ul.config["canvas_fid_pfx"] + "__" + subtask_key;
            ul.subtasks[subtask_key]["canvas_bid"] = ul.config["canvas_bid_pfx"] + "__" + subtask_key;

            // Store state of ID dialog element
            // TODO much more here when full interaction is built
            let id_payload = [];
            for (var i = 0; i < ul.subtasks[subtask_key]["class_ids"].length; i++) {
                id_payload.push(1 / ul.subtasks[subtask_key]["class_ids"].length);
            }
            ul.subtasks[subtask_key]["state"] = {
                // Id dialog state
                idd_id: "id_dialog__" + subtask_key,
                idd_id_front: "id_dialog_front__" + subtask_key,
                idd_visible: false,
                idd_associated_annotation: null,
                idd_thumbnail: false,
                id_payload: id_payload,
                delete_mode_id_payload: [{ class_id: -1, confidence: 1 }],
                first_explicit_assignment: false,

                // Annotation state
                annotation_mode: ul.subtasks[subtask_key]["allowed_modes"][0],
                active_id: null,
                is_in_progress: false,
                is_in_edit: false,
                is_in_move: false,
                starting_complex_polygon: false,
                is_in_brush_mode: false,
                is_in_erase_mode: false,
                edit_candidate: null,
                move_candidate: null,
                fly_to_idx: null,

                // Rendering context
                front_context: null,
                back_context: null,
                annotation_contexts: {}, // {canvas_id: {context: ctx, annotation_ids: []}, ...}

                // Generic dialogs
                visible_dialogs: {},
            };
        }
        if (first_non_ro === null) {
            (0,error_logging.log_message)(
                "You must have at least one subtask without 'read_only' set to true.",
                error_logging.LogLevel.ERROR,
            );
        }
    }

    static expand_image_data(ul, raw_img_dat) {
        if (typeof raw_img_dat === "string") {
            return {
                spacing: {
                    x: 1,
                    y: 1,
                    z: 1,
                    units: "pixels",
                },
                frames: [
                    raw_img_dat,
                ],
            };
        } else if (Array.isArray(raw_img_dat)) {
            return {
                spacing: {
                    x: 1,
                    y: 1,
                    z: 1,
                    units: "pixels",
                },
                frames: raw_img_dat,
            };
        } else if ("spacing" in raw_img_dat && "frames" in raw_img_dat) {
            return raw_img_dat;
        } else {
            (0,error_logging.log_message)(
                `Image data object not understood. Must be of form "http://url.to/img" OR ["img1", "img2", ...] OR {spacing: {x: <num>, y: <num>, z: <num>, units: <str>}, frames: ["img1", "img2", ...]}. Provided: ${JSON.stringify(raw_img_dat)}`,
                error_logging.LogLevel.ERROR,
            );
            return null;
        }
    }

    static handle_deprecated_arguments() {
        // Warn users that this method is deprecated
        (0,error_logging.log_message)(`
            Passing in each argument as a seperate parameter to ULabel is now deprecated \n
            Please pass in an object with keyword arguments instead
        `, error_logging.LogLevel.WARNING, true);

        return {
            // Required
            container_id: arguments[0],
            image_data: arguments[1],
            username: arguments[2],
            submit_buttons: arguments[3],
            subtasks: arguments[4],
            // Use default if optional argument is undefined
            task_meta: arguments[5] ?? {},
            annotation_meta: arguments[6] ?? {},
            px_per_px: arguments[7] ?? 1,
            initial_crop: arguments[8] ?? null,
            initial_line_size: arguments[9] ?? 4,
            config_data: arguments[10] ?? null,
            toolbox_order: arguments[11] ?? null,
        };
    }

    // ================= Construction/Initialization =================

    constructor(kwargs) {
        this.begining_time = Date.now();

        // Ensure arguments were recieved
        if (arguments.length === 0) {
            (0,error_logging.log_message)("ULabel was given no arguments", error_logging.LogLevel.WARNING, true);
        } else if (arguments.length > 1) {
            // The old constructor took in up to 11 arguments,
            // so if more than 1 argument is present convert them to the new format
            kwargs = ULabel.handle_deprecated_arguments(...arguments);
        }

        // Declare a list of required properties to error check against
        const required_properties = [
            "container_id",
            "image_data",
            "username",
            "submit_buttons",
            "subtasks",
        ];

        // Ensure kwargs has all required properties
        for (const property of required_properties) {
            if (kwargs[property] == undefined) { // == also checks for null
                (0,error_logging.log_message)(`ULabel did not receive required property ${property}`, error_logging.LogLevel.ERROR);
            }
        }

        // Process image_data
        kwargs["image_data"] = ULabel.expand_image_data(this, kwargs["image_data"]);

        // Process deprecated config_data field by adding each key-value pair to kwargs
        if ("config_data" in kwargs) {
            (0,error_logging.log_message)("The 'config_data' argument is deprecated. Please pass in all configuration values as keyword arguments.", error_logging.LogLevel.WARNING, true);
            for (const key in kwargs["config_data"]) {
                kwargs[key] = kwargs["config_data"][key];
            }
        }

        // Create the config and add ulabel dependent data
        this.config = new configuration.Configuration(kwargs);

        // Useful for the efficient redraw of nonspatial annotations
        this.tmp_nonspatial_element_ids = {};

        // Create object for current ulabel state
        this.state = {
            // Viewer state
            // Add and handle a value for current image
            zoom_val: 1.0,
            last_move: null,
            current_frame: 0,

            // Global annotation state (subtasks also maintain an annotation state)
            current_subtask: null, // The key of the current subtask
            last_brush_stroke: null,
            line_size: this.config.initial_line_size,
            anno_scaling_mode: this.config.anno_scaling_mode,

            // Renderings state
            demo_canvas_context: null,
            edited: false,
        };

        // Create a place on ulabel to store resize observer objects
        this.resize_observers = [];

        // Populate these in an external "static" function
        this.subtasks = {};
        this.color_info = {};
        ULabel.initialize_subtasks(this);

        // Create object for dragging interaction state
        // TODO(v1)
        // There can only be one drag, yes? Maybe pare this down...
        // Would be nice to consolidate this with global state also
        this.drag_state = {
            active_key: null,
            release_button: null,
            annotation: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            brush: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            edit: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            pan: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            zoom: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            move: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            right: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
        };

        for (const st in this.subtasks) {
            for (let i = 0; i < this.subtasks[st]["annotations"]["ordering"].length; i++) {
                let aid = this.subtasks[st]["annotations"]["ordering"][i];
                let amd = this.subtasks[st]["annotations"]["access"][aid]["spatial_type"];
                if (!build_annotation.NONSPATIAL_MODES.includes(amd)) {
                    this.rebuild_containing_box(this.subtasks[st]["annotations"]["ordering"][i], false, st);
                }
            }
        }

        // Indicate that object must be "init" before use!
        this.is_init = false;
        // Track global state
        this.is_shaking = false;
        this.annotation_navigation_toast_timeout = null;
    }

    init(callback) {
        (0,initializer.ulabel_init)(this, callback);
    }

    /**
     * Code to be called after ULabel has finished initializing.
     */
    after_init() {
        // Perform the after_init method for each toolbox item
        for (const toolbox_item of this.toolbox.items) {
            toolbox_item.after_init();
        }
    }

    version() {
        return ULabel.version();
    }

    /**
     * Find all toolbox items that contain overlays, add a reference to them, and add them to the document
     * Currently only FilterDistance has an overlay to check for
     */
    create_overlays() {
        // Create an array that states which ToolboxItems want to create an overlay. Currently only one, but may be expanded
        const possible_overlays = [
            "FilterDistance",
        ];

        for (const toolbox_item of this.toolbox.items) {
            // Store current toolbox name in a constant for convenience
            const toolbox_name = toolbox_item.get_toolbox_item_type();

            // If the current toolboxitem is not included in possible_overlays then continue
            if (!possible_overlays.includes(toolbox_name)) continue;

            switch (toolbox_name) {
                case "FilterDistance":
                    // Give ulabel a referance to the filter overlay for confinience
                    this.filter_distance_overlay = toolbox_item.get_overlay();

                    // Image width and height is undefined when the overlay is created, so update it here
                    this.filter_distance_overlay.set_canvas_size(
                        this.config.image_width * this.config.px_per_px,
                        this.config.image_height * this.config.px_per_px,
                    );

                    jquery_default()("#" + this.config["imwrap_id"]).prepend(this.filter_distance_overlay.get_canvas());

                    // Filter the points with an override
                    (0,annotation_operators.filter_points_distance_from_line)(this, true, null, {
                        should_redraw: this.config.distance_filter_toolbox_item.filter_on_load,
                        multi_class_mode: this.config.distance_filter_toolbox_item.multi_class_mode,
                        show_overlay: this.filter_distance_overlay.get_display_overlay(),
                        distances: this.config.distance_filter_toolbox_item.default_values,
                    });
                    break;
                default:
                    (0,error_logging.log_message)(`Toolbox item ${toolbox_name} is associated with an overlay, yet no overlay logic exists.`, error_logging.LogLevel.WARNING, true);
            }
        }
    }

    handle_toolbox_overflow() {
        try {
            let tabs_height = jquery_default()("#" + this.config["container_id"] + " div.toolbox-tabs").height();
            jquery_default()("#" + this.config["container_id"] + " div.toolbox_inner_cls").css("height", `calc(100% - ${tabs_height + 38}px)`);
            let view_height = jquery_default()("#" + this.config["container_id"] + " div.toolbox_cls")[0].scrollHeight - 38 - tabs_height;
            let want_height = jquery_default()("#" + this.config["container_id"] + " div.toolbox_inner_cls")[0].scrollHeight;
            if (want_height <= view_height) {
                jquery_default()("#" + this.config["container_id"] + " div.toolbox_inner_cls").css("overflow-y", "hidden");
            } else {
                jquery_default()("#" + this.config["container_id"] + " div.toolbox_inner_cls").css("overflow-y", "scroll");
            }
        } catch (e) {
            (0,error_logging.log_message)(`Failed to resize toolbox: ${e.message}`, error_logging.LogLevel.WARNING, true);
        }
    }

    // A ratio of viewport height to image height
    get_viewport_height_ratio(hgt) {
        return jquery_default()("#" + this.config["annbox_id"]).height() / hgt;
    }

    // A ratio of viewport width to image width
    get_viewport_width_ratio(wdt) {
        return jquery_default()("#" + this.config["annbox_id"]).width() / wdt;
    }

    // The zoom ratio which fixes the entire image exactly in the viewport with a predetermined crop
    show_initial_crop() {
        let initial_crop = this.config["initial_crop"];
        if (initial_crop != null) {
            if (
                "width" in initial_crop &&
                "height" in initial_crop &&
                "left" in initial_crop &&
                "top" in initial_crop
            ) {
                let width = this.config["image_width"];
                let height = this.config["image_height"];

                initial_crop["left"] = Math.max(initial_crop["left"], 0);
                initial_crop["top"] = Math.max(initial_crop["top"], 0);
                initial_crop["width"] = Math.min(initial_crop["width"], width - initial_crop["left"]);
                initial_crop["height"] = Math.min(initial_crop["height"], height - initial_crop["top"]);

                width = initial_crop["width"];
                height = initial_crop["height"];

                let lft_cntr = initial_crop["left"] + initial_crop["width"] / 2;
                let top_cntr = initial_crop["top"] + initial_crop["height"] / 2;

                this.set_zoom_val(Math.min(this.get_viewport_height_ratio(height), this.get_viewport_width_ratio(width)));
                this.rezoom(lft_cntr, top_cntr, true);

                // Redraw the filter_distance_overlay if it exists
                this.filter_distance_overlay?.draw_overlay();

                return;
            } else {
                (0,error_logging.log_message)(
                    `Initial crop must contain properties "width", "height", "left", and "top". Ignoring.`,
                    error_logging.LogLevel.WARNING,
                    true,
                );
            }
        }
        this.show_whole_image();
        return;
    }

    // Shows the whole image in the viewport
    show_whole_image() {
        // Grab values from config
        const width = this.config["image_width"];
        const height = this.config["image_height"];
        const top_left_corner_x = 0;
        const top_left_corner_y = 0;

        // Calculate minimum zoom value required to show the whole image
        this.set_zoom_val(Math.min(this.get_viewport_height_ratio(height), this.get_viewport_width_ratio(width)));

        this.rezoom(top_left_corner_x, top_left_corner_y, true);

        this.filter_distance_overlay?.draw_overlay();
    }

    // ================== Cursor Helpers ====================
    /**
     * Deprecated when dynamic line size toolbox item was removed.
     * TODO: Un-deprecated the dynamic line size toolbox item.
     */
    update_cursor() {
        // let color = this.get_non_spatial_annotation_color(null);
        // let thr_width = this.get_line_size() * this.state["zoom_val"]
        // let width = Math.max(Math.min(thr_width, 64), 6);
        // let cursor_svg = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="${width}px" height="${width}px" viewBox="0 0 ${width} ${width}">
        //     <circle cx="${width / 2}" cy="${width / 2}" r="${width / 2}" opacity="0.8" stroke="white" fill="${color}" />
        // </svg>`;

        // let bk_width = Math.max(Math.min(thr_width, 32), 6);
        // let bk_cursor_svg = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="${bk_width}px" height="${bk_width}px" viewBox="0 0 ${bk_width} ${bk_width}">
        //     <circle cx="${bk_width / 2}" cy="${bk_width / 2}" r="${bk_width / 2}" opacity="0.8" stroke="${color}" fill="${color}" />
        // </svg>`;

        // let cursor_b64 = btoa(cursor_svg);
        // let bk_cursor_b64 = btoa(bk_cursor_svg);
        // $("#" + this.config["annbox_id"]).css(
        //     "cursor",
        //     `url(data:image/svg+xml;base64,${cursor_b64}) ${width / 2} ${width / 2}, url(data:image/svg+xml;base64,${bk_cursor_b64}) ${bk_width / 2} ${bk_width / 2}, auto`
        // );
    }

    // ================== Subtask Helpers ===================

    /**
     * Get the current subtask key
     * @returns {string} The current subtask key
     */
    get_current_subtask_key() {
        return this.state["current_subtask"];
    }

    /**
     * Get the current subtask
     * @returns {ULabelSubtask} The current subtask
     */
    get_current_subtask() {
        return this.subtasks[this.get_current_subtask_key()];
    }

    readjust_subtask_opacities() {
        for (const st_key in this.subtasks) {
            let sliderval = jquery_default()("#tb-st-range--" + st_key).val();
            jquery_default()("div#canvasses__" + st_key).css("opacity", sliderval / 100);
        }
    }

    set_subtask(st_key) {
        let old_st = this.get_current_subtask_key();

        // Change object state
        this.state["current_subtask"] = st_key;

        // Bring new set of canvasses out to front
        jquery_default()("div.canvasses").css("z-index", blobs.BACK_Z_INDEX);
        jquery_default()("div#canvasses__" + st_key).css("z-index", blobs.FRONT_Z_INDEX);

        // Show appropriate set of dialogs
        jquery_default()("div.dialogs_container").css("display", "none");
        jquery_default()("div#dialogs__" + st_key).css("display", "block");

        // Show appropriate set of annotation modes
        jquery_default()("a.md-btn").css("display", "none");
        jquery_default()("a.md-btn.md-en4--" + st_key).css("display", "inline-block");

        // Show appropriate set of class options
        jquery_default()("div.tb-id-app").css("display", "none");
        jquery_default()("div#tb-id-app--" + st_key).css("display", "block");

        // Hide/show delete class
        this.toggle_delete_class_id_in_toolbox();

        // Adjust tab buttons in toolbox
        jquery_default()("a#tb-st-switch--" + old_st).attr("href", "#");
        jquery_default()("a#tb-st-switch--" + old_st).parent().removeClass("sel");
        jquery_default()("input#tb-st-range--" + old_st).val(Math.round(100 * this.subtasks[old_st]["inactive_opacity"]));
        jquery_default()("a#tb-st-switch--" + st_key).removeAttr("href");
        jquery_default()("a#tb-st-switch--" + st_key).parent().addClass("sel");
        jquery_default()("input#tb-st-range--" + st_key).val(100);

        // Update toolbox opts
        this.update_annotation_mode();
        this.update_current_class();

        // Update class counter
        this.toolbox.redraw_update_items(this);

        // Set transparancy for inactive layers
        this.readjust_subtask_opacities();

        // Redraw demo
        this.redraw_demo();
    }

    /**
     * Switch to the next subtask in the toolbox
     */
    switch_to_next_subtask() {
        let current_subtask = this.get_current_subtask_key();
        let new_subtask_index = this.toolbox.tabs.findIndex((tab) => tab.subtask_key === current_subtask) + 1;
        // If the current subtask was the last one in the array, then
        // loop around to the first subtask
        if (new_subtask_index === this.toolbox.tabs.length) {
            new_subtask_index = 0;
        }

        this.set_subtask(this.toolbox.tabs[new_subtask_index].subtask_key);
    }

    // ================= Toolbox Functions ==================

    set_annotation_mode(annotation_mode) {
        this.get_current_subtask()["state"]["annotation_mode"] = annotation_mode;
        this.update_annotation_mode();
    }

    update_annotation_mode() {
        jquery_default()("a.md-btn.sel").attr("href", "#");
        jquery_default()("a.md-btn.sel").removeClass("sel");
        const ann_mode = this.get_current_subtask()["state"]["annotation_mode"];
        jquery_default()("a#md-btn--" + ann_mode).addClass("sel");
        jquery_default()("a#md-btn--" + ann_mode).removeAttr("href");
        this.show_annotation_mode();
    }

    update_current_class() {
        this.update_id_toolbox_display();
        // $("a.tbid-opt.sel").attr("href", "#");
        // $("a.tbid-opt.sel").removeClass("sel");
        // $("a#toolbox_sel_" + this.subtasks[this.state["current_subtask"]]["state"]["annotation_mode"]).addClass("sel");
        // $("a#toolbox_sel_" + this.subtasks[this.state["current_subtask"]]["state"]["annotation_mode"]).removeAttr("href");
    }

    /**
     * If FilterDistance toolbox item is active AND a polyline undergoes a change,
     * then filter the points based on the new polyline
     *
     * @param {string} annotation_id - The annotation id of the annotation that changed
     * @param {boolean} redraw_update_items - If true, redraw the toolbox items
     * @param {boolean} force_filter_all - If true, force the filter to occur using all polylines
     * @param {object} offset - The offset (for polyline moves)
     */
    update_filter_distance(annotation_id, redraw_update_items = true, force_filter_all = false, offset = null) {
        // First verify if the FilterDistance toolbox item is active
        if (this.config.toolbox_order.includes(configuration.AllowedToolboxItem.FilterDistance)) {
            // Add id to the offset
            if (offset !== null) {
                offset["id"] = annotation_id;
            }

            if (force_filter_all) {
                // Filter all points from all lines
                // Used when a line is deleted
                (0,annotation_operators.filter_points_distance_from_line)(this, true, offset);
            } else if (annotation_id in this.get_current_subtask().annotations.access) {
                // Update based on changes to a single polyline or point
                let points_and_lines;
                const annotation = this.get_current_subtask().annotations.access[annotation_id];
                switch (annotation.spatial_type) {
                    case "polyline":
                        // Update each point's distance to THIS polyline
                        points_and_lines = (0,annotation_operators.get_point_and_line_annotations)(this);
                        (0,annotation_operators.update_distance_from_line_to_each_point)(annotation, points_and_lines[0], points_and_lines[1], offset);
                        // Filter all points from the updated line
                        (0,annotation_operators.filter_points_distance_from_line)(this, false, offset);
                        break;
                    case "point":
                        // Update THIS point's distance to the nearest lines
                        points_and_lines = (0,annotation_operators.get_point_and_line_annotations)(this);
                        (0,annotation_operators.assign_closest_line_to_each_point)([annotation], points_and_lines[1], offset);
                        // Don't filter the point yet, since that may be unexpected for the user
                        break;
                    default:
                        break;
                }
            }

            // Lastly, redraw the toolbox items if necessary
            if (redraw_update_items) {
                this.toolbox.redraw_update_items(this);
            }
        }
    }

    /**
     * Wrapper for update_filter_distance that is called during a polyline move
     * First checks if `filter_during_polyline_move` is true.
     *
     * @param {string} annotation_id - The annotation id of the annotation that changed
     * @param {boolean} redraw_update_items - If true, redraw the toolbox items
     * @param {boolean} force_filter_all - If true, force the filter to occur without checking the annotation type (used if annotation no longer exists)
     * @param {object} offset - The offset (for polyline moves)
     */
    update_filter_distance_during_polyline_move(annotation_id, redraw_update_items = true, force_filter_all = false, offset = null) {
        if (
            this.config.toolbox_order.includes(configuration.AllowedToolboxItem.FilterDistance) &&
            this.toolbox.items.find((item) => item.get_toolbox_item_type() === "FilterDistance").filter_during_polyline_move
        ) {
            this.update_filter_distance(annotation_id, redraw_update_items, force_filter_all, offset);
        }
    }

    // Show annotation mode
    show_annotation_mode(el = null) {
        if (el === null) {
            el = jquery_default()("a.md-btn.sel");
        }
        let new_name = el.attr("amdname");
        jquery_default()("#" + this.config["toolbox_id"] + " .current_mode").html(new_name);
        const current_stk = this.get_current_subtask_key();
        const current_st = this.get_current_subtask();
        jquery_default()(`div.frame_annotation_dialog:not(.fad_st__${current_stk})`).removeClass("active");
        if (["whole-image", "global"].includes(current_st["state"]["annotation_mode"])) {
            jquery_default()(`div.frame_annotation_dialog.fad_st__${current_stk}`).addClass("active");
        } else {
            jquery_default()("div.frame_annotation_dialog").removeClass("active");
        }
    }

    toggle_delete_class_id_in_toolbox() {
        const current_subtask = this.get_current_subtask();
        // Check if a DELETE_MODE is active
        let show_delete = build_annotation.DELETE_MODES.includes(current_subtask["state"]["annotation_mode"]);
        if (show_delete) {
            // Show the delete class id in the toolbox
            jquery_default()("a#toolbox_sel_" + build_annotation.DELETE_CLASS_ID).css("display", "inline-block");
            // Select the delete class id in the toolbox by clicking it
            jquery_default()("a#toolbox_sel_" + build_annotation.DELETE_CLASS_ID).trigger("click");
        } else {
            // Hide the delete class id in the toolbox
            jquery_default()("a#toolbox_sel_" + build_annotation.DELETE_CLASS_ID).css("display", "none");
            // If the delete class id is selected, select the first class id in the toolbox
            if (jquery_default()("a#toolbox_sel_" + build_annotation.DELETE_CLASS_ID).hasClass("sel")) {
                // Check if we are hovering an annotation
                let target_id = null;
                if (current_subtask.state.active_id !== null) {
                    target_id = current_subtask.state.active_id;
                } else if (current_subtask.state.move_candidate !== null) {
                    target_id = current_subtask.state.move_candidate["annid"];
                }
                // If we are not hovering an annotation, select default to the first class
                if (target_id === null) {
                    jquery_default()("a.tbid-opt").first().trigger("click");
                } else {
                    // If we are hovering an annotation, select the class id of the annotation
                    // which is the class with the highest confidence
                    const classification_payloads = current_subtask.annotations.access[target_id].classification_payloads;
                    const target_class_id = classification_payloads.reduce((acc, curr) => {
                        return curr.confidence > acc.confidence ? curr : acc;
                    })["class_id"];
                    jquery_default()("a#toolbox_sel_" + target_class_id).trigger("click");
                }
            }
        }

        // For all other class ids, show or hide them in the toolbox
        for (const class_id of this.get_current_subtask()["class_ids"]) {
            // Skip the delete class id
            if (class_id === build_annotation.DELETE_CLASS_ID) continue;

            // Show or hide the class id in the toolbox
            if (show_delete) {
                jquery_default()("a#toolbox_sel_" + class_id).css("display", "none");
            } else {
                jquery_default()("a#toolbox_sel_" + class_id).css("display", "inline-block");
            }
        }
    }

    /**
     * Set a new annotation mode
     *
     * @param {string} annotation_mode Annotation mode to set
     * @returns {boolean} - True if the annotation mode was successfully set, false otherwise
     */
    set_and_update_annotation_mode(annotation_mode) {
        // Ensure new mode is allowed
        if (!this.get_current_subtask()["allowed_modes"].includes(annotation_mode)) {
            (0,error_logging.log_message)(`Annotation mode ${annotation_mode} is not allowed for subtask ${this.get_current_subtask_key()}`, error_logging.LogLevel.WARNING);
            return false;
        }
        // Set the new mode via the toolbox
        document.getElementById("md-btn--" + annotation_mode).click();
        return true;
    }

    // Draw demo annotation in demo canvas
    redraw_demo() {
        // this.state["demo_canvas_context"].clearRect(0, 0, this.config["demo_width"] * this.config["px_per_px"], this.config["demo_height"] * this.config["px_per_px"]);
        // this.draw_annotation(DEMO_ANNOTATION, null, "demo");
        // this.update_cursor();
    }

    // ================= Instance Utilities =================

    // A robust measure of zoom
    get_empirical_scale() {
        // Simple ratio of canvas width to image x-dimension
        return jquery_default()("#" + this.config["imwrap_id"]).width() / this.config["image_width"];
    }

    // Get a unique ID for new annotations
    make_new_annotation_id() {
        return esm_browser_v4();
    }

    // Get the start of a spatial payload based on mouse event and current annotation mode
    get_init_spatial(gmx, gmy, annotation_mode, mouse_event) {
        const true_gmx = this.get_global_mouse_x(mouse_event);
        const true_gmy = this.get_global_mouse_y(mouse_event);
        switch (annotation_mode) {
            case "point":
                return [
                    [gmx, gmy],
                ];
            case "bbox":
            case "polyline":
            case "contour":
            case "tbar":
            case "delete_polygon":
            case "delete_bbox":
                return [
                    [gmx, gmy],
                    [gmx, gmy],
                ];
            case "polygon":
                // Get brush spatial payload if in brush mode
                if (this.get_current_subtask()["state"]["is_in_brush_mode"]) {
                    // Don't pass the potentially adjusted mouse coordinates
                    return this.get_brush_circle_spatial_payload(true_gmx, true_gmy);
                }
                return [[
                    [gmx, gmy],
                    [gmx, gmy],
                ]];
            case "bbox3":
                return [
                    [gmx, gmy, this.state["current_frame"]],
                    [gmx, gmy, this.state["current_frame"]],
                ];
            default:
                // TODO broader refactor of error handling and detecting/preventing corruption
                (0,error_logging.log_message)(
                    "Annotation mode is not understood",
                    error_logging.LogLevel.WARNING,
                    true,
                );
                return null;
        }
    }

    get_init_id_payload(spatial_type = null) {
        this.set_id_dialog_payload_to_init(null);
        if (build_annotation.DELETE_MODES.includes(spatial_type)) {
            // Use special id payload for delete modes
            return [{
                class_id: build_annotation.DELETE_CLASS_ID,
                confidence: 1.0,
            }];
        } else {
            return JSON.parse(JSON.stringify(this.get_current_subtask()["state"]["id_payload"]));
        }
    }

    /**
     * Find the next available annotation context and return its ID.
     * If all annotation contexts are in use, create a new canvas and return it's id.
     *
     * @param {string} subtask subtask name
     * @returns {string} The ID of an available canvas
     */
    get_next_available_canvas_id(subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        const canvas_ids = Object.keys(this.subtasks[subtask]["state"]["annotation_contexts"]);
        for (let i = 0; i < canvas_ids.length; i++) {
            // If the canvas has less than n_annos_per_canvas annotations, return its ID
            if (this.subtasks[subtask]["state"]["annotation_contexts"][canvas_ids[i]]["annotation_ids"].length < this.config.n_annos_per_canvas) {
                return canvas_ids[i];
            }
        }
        // If no canvas has less than n_annos_per_canvas annotations, create a new canvas
        return this.create_annotation_canvas(subtask);
    }

    /**
     * Create a new canvas and return its ID
     *
     * @param {string} subtask name
     * @returns {string} The ID of a new canvas
     */
    create_annotation_canvas(subtask) {
        const canvas_id = `canvas__${this.make_new_annotation_id()}`;

        // Add canvas to the "canvasses__${subtask}" div
        jquery_default()("#canvasses__" + subtask).append(`
            <canvas 
                id="${canvas_id}" 
                class="${this.config["canvas_class"]} ${this.config["imgsz_class"]} canvas_cls annotation_canvas" 
                height=${this.config["image_height"] * this.config["px_per_px"]} 
                width=${this.config["image_width"] * this.config["px_per_px"]}></canvas>
        `);
        // Adjust style of the canvas to fit the zoom
        jquery_default()("#" + canvas_id).css("height", `${this.config["image_height"] * this.state["zoom_val"]}px`);
        jquery_default()("#" + canvas_id).css("width", `${this.config["image_width"] * this.state["zoom_val"]}px`);
        // Make sure the front context stays in front
        jquery_default()("#" + canvas_id).css("z-index", blobs.BACK_Z_INDEX);

        // Add the canvas context to the state
        this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id] = {
            annotation_ids: [],
            context: document.getElementById(canvas_id).getContext("2d"),
        };

        return canvas_id;
    }

    /**
     * Get the ID of the next available canvas context and add the annotation ID to it.
     *
     * @param {string} annotation_id annotation ID
     * @param {string} subtask subtask name
     * @returns {string} The ID of the canvas context
     */
    get_init_canvas_context_id(annotation_id, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        // Get the next available canvas id
        const canvas_id = this.get_next_available_canvas_id(subtask);
        // Add the annotation id to the canvas context
        this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id]["annotation_ids"].push(annotation_id);

        return canvas_id;
    }

    // Remove a canvas from the document and the state
    destroy_annotation_context(annotation_id, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }

        // Remove the annotation_id from the canvas context list
        const canvas_id = this.subtasks[subtask]["annotations"]["access"][annotation_id]["canvas_id"];
        const canvas_context = this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id];
        const annotation_ids = canvas_context["annotation_ids"];
        const idx = annotation_ids.indexOf(annotation_id);
        if (idx > -1) {
            annotation_ids.splice(idx, 1);
        }

        if (annotation_ids.length === 0) {
            // If the canvas is empty, remove it from the document and the state
            jquery_default()("#" + canvas_id).remove();
            delete this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id];
        } else {
            // Otherwise, redraw the remaining annotations
            this.redraw_all_annotations_in_annotation_context(canvas_id, subtask);
        }
    }

    // Get the element id for a nonspatial annotation row
    get_nonspatial_annotation_element_id(annotation_id) {
        return `row__${annotation_id}`;
    }

    // ================= Access string utilities =================

    // Access a point in a spatial payload using access string
    // Optional arg at the end is for finding position of a moved splice point through its original access string
    get_with_access_string(annid, access_str, as_though_pre_splice = false) {
        // TODO(3d)
        let bbi, bbj, bbk, bbox_pts, ret, bas, dif, tbi, tbj, tbar_pts, active_index;
        const spatial_type = this.get_current_subtask()["annotations"]["access"][annid]["spatial_type"];
        let spatial_payload = this.get_current_subtask()["annotations"]["access"][annid]["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        switch (spatial_type) {
            case "bbox":
                bbi = parseInt(access_str[0], 10);
                bbj = parseInt(access_str[1], 10);
                bbox_pts = spatial_payload;
                return [bbox_pts[bbi][0], bbox_pts[bbj][1]];
            case "point":
                return spatial_payload;
            case "bbox3":
                // TODO(3d)
                bbi = parseInt(access_str[0], 10);
                bbj = parseInt(access_str[1], 10);
                bbox_pts = spatial_payload;
                ret = [bbox_pts[bbi][0], bbox_pts[bbj][1]];
                if (access_str.length > 2) {
                    bbk = parseInt(access_str[2], 10);
                    ret.push(bbox_pts[bbk][2]);
                }
                return ret;
            case "polygon":
            case "polyline":
                if (spatial_type === "polygon") {
                    // access_str will be an array of two indices, the first of which is the index of the polygon
                    // and the second of which is the index of the point in the polygon
                    // first parse the access string
                    active_index = parseInt(access_str[0], 10);
                    active_spatial_payload = spatial_payload.at(active_index);
                    access_str = access_str[1];
                }
                bas = parseInt(access_str, 10);
                dif = parseFloat(access_str) - bas;
                if (dif < 0.005) {
                    return active_spatial_payload[bas];
                } else {
                    if (as_though_pre_splice) {
                        dif = 0;
                        bas += 1;
                        return active_spatial_payload[bas];
                    } else {
                        return geometric_utils.GeometricUtils.interpolate_poly_segment(
                            active_spatial_payload,
                            bas,
                            dif,
                        );
                    }
                }
            case "tbar":
                // TODO 3 point method
                tbi = parseInt(access_str[0], 10);
                tbj = parseInt(access_str[1], 10);
                tbar_pts = spatial_payload;
                return [tbar_pts[tbi][0], tbar_pts[tbj][1]];
            default:
                (0,error_logging.log_message)(
                    "Unable to apply access string to annotation of type " + spatial_type,
                    error_logging.LogLevel.WARNING,
                    true,
                );
        }
    }

    // Set a point in a spatial payload using access string
    set_with_access_string(annid, access_str, val, undoing = null) {
        // Ensure the values are ints
        // val[0] = Math.round(val[0]);
        // val[1] = Math.round(val[1]);
        // TODO(3d)
        let bbi, bbj, bbk, active_index;
        const spatial_type = this.get_current_subtask()["annotations"]["access"][annid]["spatial_type"];
        let spatial_payload = this.get_current_subtask()["annotations"]["access"][annid]["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        switch (spatial_type) {
            case "bbox":
                bbi = parseInt(access_str[0], 10);
                bbj = parseInt(access_str[1], 10);
                spatial_payload[bbi][0] = val[0];
                spatial_payload[bbj][1] = val[1];
                break;
            case "point":
                spatial_payload[bbi][0] = val[0];
                spatial_payload[bbi][0] = val[0];
                break;
            case "bbox3":
                bbi = parseInt(access_str[0], 10);
                bbj = parseInt(access_str[1], 10);
                spatial_payload[bbi][0] = val[0];
                spatial_payload[bbj][1] = val[1];
                if (access_str.length > 2 && val.length > 2) {
                    bbk = parseInt(access_str[2], 10);
                    spatial_payload[bbk][2] = val[2];
                }
                break;
            case "tbar":
                // TODO 3 points
                bbi = parseInt(access_str[0], 10);
                bbj = parseInt(access_str[1], 10);
                spatial_payload[bbi][0] = val[0];
                spatial_payload[bbj][1] = val[1];
                break;
            case "polygon":
            case "polyline":
                if (spatial_type === "polygon") {
                    // access_str will be an array of two indices, the first of which is the index of the polygon
                    // and the second of which is the index of the point in the polygon
                    // first parse the access string
                    active_index = parseInt(access_str[0], 10);
                    active_spatial_payload = spatial_payload.at(active_index);
                    access_str = access_str[1];
                }
                var bas = parseInt(access_str, 10);
                var dif = parseFloat(access_str) - bas;
                if (dif < 0.005) {
                    var acint = parseInt(access_str, 10);
                    var npts = active_spatial_payload.length;
                    if ((spatial_type === "polygon") && ((acint === 0) || (acint === (npts - 1)))) {
                        active_spatial_payload[0] = [val[0], val[1]];
                        active_spatial_payload[npts - 1] = [val[0], val[1]];
                    } else {
                        active_spatial_payload[acint] = val;
                    }
                } else {
                    if (undoing === true) {
                        active_spatial_payload.splice(bas + 1, 1);
                    } else if (undoing === false) {
                        active_spatial_payload.splice(bas + 1, 0, [val[0], val[1]]);
                    } else {
                        var newpt = geometric_utils.GeometricUtils.interpolate_poly_segment(
                            active_spatial_payload,
                            bas,
                            dif,
                        );
                        active_spatial_payload.splice(bas + 1, 0, newpt);
                    }
                }
                break;
            default:
                (0,error_logging.log_message)(
                    "Unable to apply access string to annotation of type " + spatial_type,
                    error_logging.LogLevel.WARNING,
                    true,
                );
        }
    }

    get_annotation_color(annotation) {
        // Use the annotation's class id to get the color of the annotation
        const class_id = (0,annotation_operators.get_annotation_class_id)(annotation);
        const color = this.color_info[class_id];

        // Log an error and return a default color if the color is undefined
        if (color === undefined) {
            (0,error_logging.log_message)(`get_annotation_color encountered error while getting annotation color with class id ${class_id}`, error_logging.LogLevel.ERROR, true);
            return this.config.default_annotation_color;
        }

        // Return the color after applying a gradient to it based on its confidence
        // If gradients are disabled, get_gradient will return the passed in color
        return (0,drawing_utilities/* get_gradient */.SA)(annotation, color, annotation_operators.get_annotation_confidence, jquery_default()("#gradient-slider").val() / 100);
    }

    get_active_class_color() {
        const color = this.color_info[this.get_active_class_id()];
        if (color === undefined) {
            (0,error_logging.log_message)(`get_active_class_color() encountered error while getting active class color.`, error_logging.LogLevel.ERROR, true);
            return this.config.default_annotation_color;
        }
        return color;
    }

    get_non_spatial_annotation_color(clf_payload, subtask = null) {
        if (this.config["allow_soft_id"]) {
            // not currently supported;
            return this.config["default_annotation_color"];
        }
        let crst = this.get_current_subtask_key();
        if (subtask != null) {
            crst = subtask;
        }
        let col_payload = JSON.parse(JSON.stringify(this.subtasks[crst]["state"]["id_payload"])); // BOOG
        if (clf_payload != null) {
            col_payload = clf_payload;
        }

        for (let i = 0; i < col_payload.length; i++) {
            if (col_payload[i]["confidence"] > 0) {
                return this.subtasks[crst]["class_defs"][i]["color"];
            }
        }
        return this.config["default_annotation_color"];
    }

    // ================= Drawing Functions =================

    draw_bounding_box(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Prep for bbox drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        // Draw the box
        const sp = annotation_object["spatial_payload"][0];
        const ep = annotation_object["spatial_payload"][1];
        ctx.beginPath();
        ctx.moveTo((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.lineTo((sp[0] + diffX) * px_per_px, (ep[1] + diffY) * px_per_px);
        ctx.lineTo((ep[0] + diffX) * px_per_px, (ep[1] + diffY) * px_per_px);
        ctx.lineTo((ep[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.lineTo((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.closePath();
        ctx.stroke();
    }

    draw_point(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Prep for bbox drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        // Draw the box
        const sp = annotation_object["spatial_payload"][0];
        ctx.beginPath();
        ctx.arc((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px, line_size * px_per_px * 0.75, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.beginPath();
        ctx.arc((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px, line_size * px_per_px * 3, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.stroke();
    }

    draw_bbox3(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        let diffZ = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
            if ("diffZ" in offset) {
                diffZ = offset["diffZ"];
            }
        }

        let curfrm = this.state["current_frame"];
        const sp = annotation_object["spatial_payload"][0];
        const ep = annotation_object["spatial_payload"][1];
        if (curfrm < (Math.min(sp[2], ep[2]) + diffZ) || curfrm > (Math.max(sp[2], ep[2]) + diffZ)) {
            return;
        }
        let fill = false;
        if (curfrm === (Math.min(sp[2], ep[2]) + diffZ) || curfrm === (Math.max(sp[2], ep[2]) + diffZ)) {
            fill = true;
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Prep for bbox drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        // Draw the box
        ctx.beginPath();
        ctx.moveTo((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.lineTo((sp[0] + diffX) * px_per_px, (ep[1] + diffY) * px_per_px);
        ctx.lineTo((ep[0] + diffX) * px_per_px, (ep[1] + diffY) * px_per_px);
        ctx.lineTo((ep[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.lineTo((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.closePath();
        ctx.stroke();
        if (fill) {
            ctx.globalAlpha = 0.2;
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    draw_polygon(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Hack to turn off fills during vanish
        let is_in_vanish_mode = line_size <= 0.01;

        // Prep for bbox drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.lineCap = "round";
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        const spatial_type = annotation_object["spatial_type"];
        let spatial_payload = annotation_object["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        // if a polygon, n_iters is the length the spatial payload
        // else n_iters is 1
        let n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;

        // Draw all polygons/polylines
        let layer_is_closed = false;
        for (let i = 0; i < n_iters; i++) {
            if (spatial_type === "polygon") {
                active_spatial_payload = spatial_payload[i];
            }
            // Draw the borders
            const pts = active_spatial_payload;
            if (pts.length > 0) {
                ctx.beginPath();
                ctx.moveTo((pts[0][0] + diffX) * px_per_px, (pts[0][1] + diffY) * px_per_px);
                for (let pti = 1; pti < pts.length; pti++) {
                    ctx.lineTo((pts[pti][0] + diffX) * px_per_px, (pts[pti][1] + diffY) * px_per_px);
                }
                ctx.stroke();
            }

            // If not in vanish mode and polygon is closed, fill it or draw a hole
            layer_is_closed = geometric_utils.GeometricUtils.is_polygon_closed(active_spatial_payload);
            if (!is_in_vanish_mode && spatial_type === "polygon" && layer_is_closed) {
                if (annotation_object["spatial_payload_holes"][i]) {
                    ctx.globalCompositeOperation = "destination-out";
                } else {
                    ctx.globalAlpha = 0.2;
                }
                ctx.closePath();
                ctx.fill();
                // Reset globals
                ctx.globalCompositeOperation = "source-over";
                ctx.globalAlpha = 1.0;
            }
        }

        if (
            spatial_type === "polygon" &&
            !layer_is_closed &&
            this.get_current_subtask()["state"]["is_in_progress"] &&
            !this.get_current_subtask()["state"]["starting_complex_polygon"]
        ) {
            // Clear the lines that fall within the polygon ender
            // Use the first point of the last layer
            const ender_center_pt = spatial_payload.at(-1)[0];
            ctx.globalCompositeOperation = "destination-out";
            ctx.beginPath();
            ctx.arc(
                ender_center_pt[0], // x
                ender_center_pt[1], // y
                this.config["polygon_ender_size"] / 2, // radius
                0, // start angle
                2 * Math.PI, // end angle
            );
            ctx.fill();
            // Reset globals
            ctx.globalCompositeOperation = "source-over";
        }
    }

    draw_contour(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Prep for bbox drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.lineCap = "round";
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        // Draw the box
        const pts = annotation_object["spatial_payload"];
        ctx.beginPath();
        ctx.moveTo((pts[0][0] + diffX) * px_per_px, (pts[0][1] + diffY) * px_per_px);
        for (var pti = 1; pti < pts.length; pti++) {
            ctx.lineTo((pts[pti][0] + diffX) * px_per_px, (pts[pti][1] + diffY) * px_per_px);
        }
        ctx.stroke();
    }

    draw_tbar(annotation_object, ctx, offset = null) {
        const px_per_px = this.config["px_per_px"];
        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        const line_size = this.get_scaled_line_size(annotation_object);

        // Prep for tbar drawing
        const color = this.get_annotation_color(annotation_object);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineJoin = "round";
        ctx.lineWidth = line_size * px_per_px;
        ctx.imageSmoothingEnabled = false;
        ctx.globalCompositeOperation = "source-over";

        // Draw the tall part of the tbar
        const sp = annotation_object["spatial_payload"][0];
        const ep = annotation_object["spatial_payload"][1];
        ctx.beginPath();
        ctx.moveTo((sp[0] + diffX) * px_per_px, (sp[1] + diffY) * px_per_px);
        ctx.lineTo((ep[0] + diffX) * px_per_px, (ep[1] + diffY) * px_per_px);
        ctx.stroke();

        // Draw the cross of the tbar
        let halflen = Math.sqrt(
            (sp[0] - ep[0]) * (sp[0] - ep[0]) + (sp[1] - ep[1]) * (sp[1] - ep[1]),
        ) / 2;
        let theta = Math.atan((ep[1] - sp[1]) / (ep[0] - sp[0]));
        let sb = [
            sp[0] + halflen * Math.sin(theta),
            sp[1] - halflen * Math.cos(theta),
        ];
        let eb = [
            sp[0] - halflen * Math.sin(theta),
            sp[1] + halflen * Math.cos(theta),
        ];

        ctx.lineCap = "square";
        ctx.beginPath();
        ctx.moveTo((sb[0] + diffX) * px_per_px, (sb[1] + diffY) * px_per_px);
        ctx.lineTo((eb[0] + diffX) * px_per_px, (eb[1] + diffY) * px_per_px);
        ctx.stroke();
        ctx.lineCap = "round";
    }

    draw_nonspatial_annotation(annotation_object, svg_obj, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        const annotation_id = annotation_object["id"];
        const element_id = this.get_nonspatial_annotation_element_id(annotation_id);
        if (jquery_default()(`div#${element_id}`).length === 0) {
            jquery_default()(`div#fad_st__${subtask} div.fad_annotation_rows`).append(`
            <div id="row__${annotation_id}" class="fad_row">
                <div class="fad_buttons">
                    <div class="fad_inp_container text">
                        <textarea id="note__${annotation_id}" class="nonspatial_note" placeholder="Notes...">${annotation_object["text_payload"]}</textarea>
                    </div><!--
                    --><div class="fad_inp_container button frst">
                        <a href="#" id="reclf__${annotation_id}" class="fad_button reclf"></a>
                    </div><!--
                    --><div class="fad_inp_container button">
                        <a href="#" id="delete__${annotation_id}" class="fad_button delete">&#215;</a>
                    </div>
                </div><!--
                --><div id="icon__${annotation_id}" class="fad_type_icon invert-this-svg" style="background-color: ${this.get_non_spatial_annotation_color(annotation_object["classification_payloads"], subtask)};">
                    ${svg_obj}
                </div>
            </div>
            `);
        } else {
            jquery_default()(`textarea#note__${annotation_id}`).val(annotation_object["text_payload"]);
            jquery_default()(`div#icon__${annotation_id}`).css("background-color", this.get_non_spatial_annotation_color(annotation_object["classification_payloads"], subtask));
        }
    }

    clear_nonspatial_annotation(annotation_id) {
        jquery_default()(`div#row__${annotation_id}`).remove();
    }

    draw_whole_image_annotation(annotation_object, subtask = null) {
        this.draw_nonspatial_annotation(annotation_object, blobs.WHOLE_IMAGE_SVG, subtask);
    }

    draw_global_annotation(annotation_object, subtask = null) {
        this.draw_nonspatial_annotation(annotation_object, blobs.GLOBAL_SVG, subtask);
    }

    draw_annotation(annotation_object, offset = null, subtask = null) {
        // DEBUG left here for refactor reference, but I don't think it's needed moving forward
        //    there may be a use case for drawing depreacted annotations
        // Don't draw if deprecated
        if (annotation_object["deprecated"]) return;

        // Get actual context from context key and subtask
        let context = null;
        if (subtask === "demo") {
            // Must be demo
            if (annotation_object["canvas_id"] != "demo_canvas_context") {
                (0,error_logging.log_message)("Attempted to draw demo annotation on non-demo canvas.", error_logging.LogLevel.ERROR);
            }
            context = this.state["demo_canvas_context"];
        } else if (build_annotation.NONSPATIAL_MODES.includes(annotation_object["spatial_type"])) {
            // Draw nonspatial annotations on the front context
            context = this.subtasks[subtask]["state"]["front_context"];
        } else {
            // Draw spatial annotations on their own canvas
            context = this.subtasks[subtask]["state"]["annotation_contexts"][annotation_object["canvas_id"]]["context"];
        }

        // Dispatch to annotation type's drawing function
        switch (annotation_object["spatial_type"]) {
            case "bbox":
            case "delete_bbox":
                this.draw_bounding_box(annotation_object, context, offset);
                break;
            case "point":
                this.draw_point(annotation_object, context, offset);
                break;
            case "bbox3":
                // TODO(new3d)
                this.draw_bbox3(annotation_object, context, offset);
                break;
            case "polygon":
            case "polyline":
            case "delete_polygon":
                this.draw_polygon(annotation_object, context, offset);
                break;
            case "contour":
                this.draw_contour(annotation_object, context, offset);
                break;
            case "tbar":
                this.draw_tbar(annotation_object, context, offset);
                break;
            case "whole-image":
                this.draw_whole_image_annotation(annotation_object, subtask);
                break;
            case "global":
                this.draw_global_annotation(annotation_object, subtask);
                break;
            default:
                (0,error_logging.log_message)(
                    "Annotation mode " + annotation_object["spatial_type"] + " not understood",
                    error_logging.LogLevel.WARNING,
                    true,
                );
                break;
        }
    }

    draw_annotation_from_id(id, offset = null, subtask = null) {
        if (subtask === null) {
            // Should never be here tbh
            subtask = this.get_current_subtask_key();
        }
        let frame = this.subtasks[subtask]["annotations"]["access"][id]["frame"];
        // Keep `==` here, we want to catch null and undefined
        if (frame == null || frame == "undefined" || frame == this.state["current_frame"]) {
            this.draw_annotation(this.subtasks[subtask]["annotations"]["access"][id], offset, subtask);
        }
    }

    /**
     * Redraw all annotations in a given annotation context
     *
     * @param {string} canvas_id ID of the canvas to redraw annotations in
     * @param {string} subtask subtask name
     * @param {number} offset used to offset annotations, usually while rendering a move
     * @param {Array<string>} annotation_ids_to_offset  list of annotation ids to offset
     */
    redraw_all_annotations_in_annotation_context(canvas_id, subtask, offset = null, annotation_ids_to_offset = null) {
        // Clear the canvas
        this.clear_annotation_canvas(canvas_id, subtask);
        // Handle redraw of each annotation in the context
        for (const annid of this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id]["annotation_ids"]) {
            // Only draw with offset if the annotation is in the list of annotations to offset, or if the list is null
            if (annotation_ids_to_offset === null || annotation_ids_to_offset.includes(annid)) {
                this.draw_annotation_from_id(annid, offset, subtask);
            } else {
                this.draw_annotation_from_id(annid, null, subtask);
            }
        }
    }

    redraw_all_annotations_in_subtask(subtask, offset = null, nonspatial_only = false) {
        // Clear the canvas
        this.clear_front_canvas(subtask);
        // Handle redrawing of nonspatial annotations
        for (const annid of this.subtasks[subtask]["annotations"]["ordering"]) {
            if (build_annotation.NONSPATIAL_MODES.includes(this.subtasks[subtask]["annotations"]["access"][annid]["spatial_type"])) {
                this.draw_annotation(this.subtasks[subtask]["annotations"]["access"][annid], offset, subtask);
            }
        }
        // Handle redraw of each annotation context
        if (!nonspatial_only) {
            for (const canvas_id in this.subtasks[subtask]["state"]["annotation_contexts"]) {
                this.redraw_all_annotations_in_annotation_context(canvas_id, subtask, offset);
            }
        }
    }

    /**
     * Redraw all annotations in a given subtask, or all subtasks if subtask is null
     *
     * @param {string} subtask subtask name
     * @param {number} offset used to offset annotations, usually while rendering a move
     * @param {boolean} nonspatial_only if true, only redraw nonspatial annotations
     */
    redraw_all_annotations(subtask = null, offset = null, nonspatial_only = false) {
        // TODO(3d)
        if (subtask === null) {
            for (const st in this.subtasks) {
                this.redraw_all_annotations_in_subtask(st, offset, nonspatial_only);
            }
        } else {
            this.redraw_all_annotations_in_subtask(subtask, offset, nonspatial_only);
        }
    }

    /**
     * Redraw an annotation, given its id
     *
     * @param {string} annotation_id ID of the annotation to redraw
     * @param {string} subtask subtask name
     * @param {number} offset used to offset annotations, usually while rendering a move
     */
    redraw_annotation(annotation_id, subtask = null, offset = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        // Check if the annotation is spatial
        let is_spatial = !build_annotation.NONSPATIAL_MODES.includes(this.subtasks[subtask]["annotations"]["access"][annotation_id]["spatial_type"]);
        if (is_spatial) {
            // Clear and redraw all annotations on the canvas where the annotation is drawn
            const canvas_id = this.subtasks[subtask]["annotations"]["access"][annotation_id]["canvas_id"];
            this.redraw_all_annotations_in_annotation_context(canvas_id, subtask, offset, [annotation_id]);
        } else {
            // Nonspatial annotations are drawn on the front context
            this.redraw_all_annotations_in_subtask(subtask, offset, true);
        }
    }

    /**
     * Find each unique annotation context and redraw all annotations in each context
     *
     * @param {Array<string>} annotation_ids IDs of annotations to redraw
     * @param {string} subtask subtask name
     * @param {number} offset used to offset annotations, usually while rendering a move
     */
    redraw_multiple_spatial_annotations(annotation_ids, subtask = null, offset = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }

        // Find all unique annotation contexts
        let unique_contexts = new Set();
        for (const annid of annotation_ids) {
            unique_contexts.add(this.subtasks[subtask]["annotations"]["access"][annid]["canvas_id"]);
        }

        // Redraw all annotations in each unique context
        for (const canvas_id of unique_contexts) {
            this.redraw_all_annotations_in_annotation_context(canvas_id, subtask, offset);
        }
    }

    clear_annotation_canvas(canvas_id, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        this.subtasks[subtask]["state"]["annotation_contexts"][canvas_id]["context"].clearRect(0, 0, this.config["image_width"] * this.config["px_per_px"], this.config["image_height"] * this.config["px_per_px"]);
    }

    clear_front_canvas(subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        this.subtasks[subtask]["state"]["front_context"].clearRect(0, 0, this.config["image_width"] * this.config["px_per_px"], this.config["image_height"] * this.config["px_per_px"]);
    }

    // ================= On-Canvas HTML Dialog Utilities =================

    // When a dialog is created or its position changes, make sure all
    // dialogs that are meant to be visible are in their correct positions
    reposition_dialogs() {
        // Get info about image wrapper
        var imwrap = jquery_default()("#" + this.config["imwrap_id"]);
        const new_dimx = imwrap.width();
        const new_dimy = imwrap.height();

        // Get current subtask for convenience
        let crst = this.get_current_subtask_key();

        // Iterate over all visible dialogs and apply new positions
        for (var id in this.subtasks[crst]["state"]["visible_dialogs"]) {
            let el = this.subtasks[crst]["state"]["visible_dialogs"][id];
            let jqel = jquery_default()("#" + id);
            let new_left = el["left"] * new_dimx;
            let new_top = el["top"] * new_dimy;
            switch (el["pin"]) {
                case "center":
                    new_left -= jqel.width() / 2;
                    new_top -= jqel.height() / 2;
                    break;
                case "top-left":
                    // No need to adjust for a top left pin
                    break;
                default:
                    // TODO top-right, bottom-left, bottom-right
                    // top/bottom-center? center-left/right?
                    break;
            }

            // Enforce that position be on the underlying image
            // TODO

            // Apply new position
            jqel.css("left", new_left + "px");
            jqel.css("top", new_top + "px");
        }
    }

    create_polygon_ender(gmx, gmy, polygon_id) {
        const subtask_key = this.get_current_subtask_key();
        const current_subtask = this.subtasks[subtask_key];
        const annotation = current_subtask["annotations"]["access"][polygon_id];
        const spatial_type = annotation["spatial_type"];

        // Verify polygon spatial type
        if (
            !current_subtask["state"]["is_in_brush_mode"] &&
            (spatial_type === "polygon" || spatial_type === "delete_polygon")
        ) {
            // Create ender id
            const ender_id = "ender_" + polygon_id;

            // Build ender html
            const ender_html = `
            <a href="#" id="${ender_id}" class="ender_outer">
                <span id="${ender_id}_inner" class="ender_inner"></span>
            </a>
            `;
            const polygon_ender_size = this.config["polygon_ender_size"] * this.state["zoom_val"];
            jquery_default()("#dialogs__" + subtask_key).append(ender_html);
            jquery_default()("#" + ender_id).css({
                "width": polygon_ender_size + "px",
                "height": polygon_ender_size + "px",
                "border-radius": polygon_ender_size / 2 + "px",
                // Get the color of the active class
                "box-shadow": "0 0 0 2px " + this.get_annotation_color(annotation),
            });
            jquery_default()("#" + ender_id + "_inner").css({
                "width": polygon_ender_size / 5 + "px",
                "height": polygon_ender_size / 5 + "px",
                "border-radius": polygon_ender_size / 10 + "px",
                "top": 2 * polygon_ender_size / 5 + "px",
                "left": 2 * polygon_ender_size / 5 + "px",
            });

            // Add this id to the list of dialogs with managed positions
            current_subtask["state"]["visible_dialogs"][ender_id] = {
                left: gmx / this.config["image_width"],
                top: gmy / this.config["image_height"],
                pin: "center",
            };
            this.reposition_dialogs();
        }
    }

    destroy_polygon_ender(polygon_id) {
        // Check if the ender exists
        const ender_id = "ender_" + polygon_id;
        const ender_jq = jquery_default()("#" + ender_id);
        if (ender_jq.length) {
            jquery_default()("#" + ender_id).remove();
            delete this.get_current_subtask()["state"]["visible_dialogs"][ender_id];
            this.reposition_dialogs();
        }
    }

    // Move a polygon ender to the mouse location
    move_polygon_ender(gmx, gmy, polygon_id) {
        // Create ender id
        const ender_id = "ender_" + polygon_id;

        // Create ender if it doesn't exist
        if (!(jquery_default()("#" + ender_id).length)) {
            this.create_polygon_ender(gmx, gmy, polygon_id);
            return;
        }

        // Add to list of visible dialogs
        this.get_current_subtask()["state"]["visible_dialogs"][ender_id] = {
            left: gmx / this.config["image_width"],
            top: gmy / this.config["image_height"],
            pin: "center",
        };
        this.reposition_dialogs();
    }

    resize_active_polygon_ender() {
        // Check if there is an active polygon annotation
        const current_subtask = this.get_current_subtask_key();
        const active_id = this.subtasks[current_subtask]["state"]["active_id"];
        if (active_id === null) {
            return;
        }
        // Check that this is a polygon
        const active_annotation = this.subtasks[current_subtask]["annotations"]["access"][active_id];
        if (active_annotation["spatial_type"] !== "polygon") {
            return;
        }
        // Get the ender and resize it with the current zoom
        const ender_id = "ender_" + active_id;
        const polygon_ender_size = this.config["polygon_ender_size"] * this.state["zoom_val"];
        jquery_default()("#" + ender_id).css({
            "width": polygon_ender_size + "px",
            "height": polygon_ender_size + "px",
            "border-radius": polygon_ender_size / 2 + "px",
        });
        jquery_default()("#" + ender_id + "_inner").css({
            "width": polygon_ender_size / 5 + "px",
            "height": polygon_ender_size / 5 + "px",
            "border-radius": polygon_ender_size / 10 + "px",
            "top": 2 * polygon_ender_size / 5 + "px",
            "left": 2 * polygon_ender_size / 5 + "px",
        });
    }

    recolor_active_polygon_ender() {
        // Check if there is an active polygon annotation
        const current_subtask = this.get_current_subtask();
        const active_id = current_subtask["state"]["active_id"];
        if (active_id === null) {
            return;
        }
        // Check that this is a polygon
        const active_annotation = current_subtask["annotations"]["access"][active_id];
        if (active_annotation["spatial_type"] !== "polygon") {
            return;
        }
        // Get the ender and recolor it
        const ender_id = "ender_" + active_id;
        jquery_default()("#" + ender_id).css({
            "box-shadow": "0 0 0 2px " + this.get_annotation_color(active_annotation),
        });
    }

    toggle_brush_mode(mouse_event) {
        // Try and switch to polygon annotation if not already in it
        const current_subtask = this.get_current_subtask_key();
        let is_in_polygon_mode = this.subtasks[current_subtask]["state"]["annotation_mode"] === "polygon";
        // Try and switch to polygon mode if not already in it
        if (!is_in_polygon_mode) {
            is_in_polygon_mode = this.set_and_update_annotation_mode("polygon");
            jquery_default()("#brush-mode").removeClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            jquery_default()("#erase-mode").removeClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
        }
        // If we're in polygon mode, toggle brush mode
        if (is_in_polygon_mode) {
            // If in erase mode, turn it off
            if (this.subtasks[current_subtask]["state"]["is_in_erase_mode"]) {
                this.toggle_erase_mode();
            }
            // Toggle brush mode
            this.subtasks[current_subtask]["state"]["is_in_brush_mode"] = !this.subtasks[current_subtask]["state"]["is_in_brush_mode"];
            if (this.subtasks[current_subtask]["state"]["is_in_brush_mode"]) {
                // Hide edit/id dialogs
                this.suggest_edits();
                // Clear any move candidates
                this.subtasks[current_subtask]["state"]["move_candidate"] = null;
                // If in starting_complex_polygon mode, end it by undoing
                if (this.subtasks[current_subtask]["state"]["starting_complex_polygon"]) {
                    (0,actions/* undo */.tN)(this, true);
                }
                // Show brush circle
                let gmx = this.get_global_mouse_x(mouse_event);
                let gmy = this.get_global_mouse_y(mouse_event);
                this.create_brush_circle(gmx, gmy);
                jquery_default()("#brush-mode").addClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            } else {
                this.destroy_brush_circle();
                jquery_default()("#brush-mode").removeClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            }
        }
    }

    toggle_erase_mode(mouse_event) {
        const current_subtask = this.get_current_subtask();
        // If not in brush mode, turn it on
        if (!current_subtask["state"]["is_in_brush_mode"]) {
            this.toggle_brush_mode(mouse_event);
        }

        // Toggle erase mode
        if (current_subtask["state"]["is_in_erase_mode"]) {
            jquery_default()("#erase-mode").removeClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            // "Erase mode" is a subset of "brush mode"
            if (current_subtask["state"]["is_in_brush_mode"]) {
                jquery_default()("#brush-mode").addClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            }
        } else {
            jquery_default()("#erase-mode").addClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
            jquery_default()("#brush-mode").removeClass(toolbox.BrushToolboxItem.BRUSH_BTN_ACTIVE_CLS);
        }
        current_subtask["state"]["is_in_erase_mode"] = !current_subtask["state"]["is_in_erase_mode"];

        // Update brush circle color
        const brush_circle_id = "brush_circle";
        jquery_default()("#" + brush_circle_id).css({
            "background-color": current_subtask["state"]["is_in_erase_mode"] ? "red" : "white",
        });

        // When turning off erase mode, also turn off brush mode
        if (
            current_subtask["state"]["is_in_brush_mode"] &&
            !current_subtask["state"]["is_in_erase_mode"]
        ) {
            this.toggle_brush_mode();
        }
    }

    // Create a brush circle at the mouse location
    create_brush_circle(gmx, gmy) {
        // Create brush circle id
        const brush_circle_id = "brush_circle";

        // Build brush circle html
        const brush_circle_html = `
        <a id="${brush_circle_id}" class="brush_circle"></a>`;
        jquery_default()("#dialogs__" + this.get_current_subtask_key()).append(brush_circle_html);
        jquery_default()("#" + brush_circle_id).css({
            "width": (this.config["brush_size"] * this.state["zoom_val"]) + "px",
            "height": (this.config["brush_size"] * this.state["zoom_val"]) + "px",
            "border-radius": (this.config["brush_size"] * this.state["zoom_val"]) * 2 + "px",
            "background-color": this.get_current_subtask()["state"]["is_in_erase_mode"] ? "red" : this.get_active_class_color(),
            "left": gmx + "px",
            "top": gmy + "px",
        });

        // Add this id to the list of dialogs with managed positions
        this.get_current_subtask()["state"]["visible_dialogs"][brush_circle_id] = {
            left: gmx / this.config["image_width"],
            top: gmy / this.config["image_height"],
            pin: "center",
        };
        this.reposition_dialogs();
    }

    // Move the brush circle to the mouse location
    move_brush_circle(gmx, gmy) {
        // Create brush circle id
        const brush_circle_id = "brush_circle";

        // Create brush circle if it doesn't exist
        if (!(jquery_default()("#" + brush_circle_id).length)) {
            this.create_brush_circle(gmx, gmy);
            return;
        }

        // Use this function to recalculate current zoom
        this.change_brush_size(1);

        // Add to list of visible dialogs
        this.get_current_subtask()["state"]["visible_dialogs"][brush_circle_id] = {
            left: gmx / this.config["image_width"],
            top: gmy / this.config["image_height"],
            pin: "center",
        };
        this.reposition_dialogs();
    }

    recolor_brush_circle() {
        // Only allow when not in erase mode
        if (
            this.get_current_subtask()["state"]["is_in_brush_mode"] &&
            !this.get_current_subtask()["state"]["is_in_erase_mode"]
        ) {
            // Get brush circle id
            const brush_circle_id = "brush_circle";
            const active_id = this.get_current_subtask()["state"]["active_id"];
            jquery_default()("#" + brush_circle_id).css({
                // Use annotation id if available, else use active class color
                "background-color": active_id !== null ?
                    this.get_annotation_color(this.get_current_subtask()["annotations"]["access"][active_id]) :
                    this.get_active_class_color(),
            });
        }
    }

    // Destroy the brush circle
    destroy_brush_circle() {
        // Get brush circle id
        const brush_circle_id = "brush_circle";
        jquery_default()("#" + brush_circle_id).remove();
        delete this.get_current_subtask()["state"]["visible_dialogs"][brush_circle_id];
        this.reposition_dialogs();
    }

    // Change the brush size by a scale factor
    change_brush_size(scale_factor) {
        if (this.get_current_subtask()["state"]["is_in_brush_mode"]) {
            this.config["brush_size"] *= scale_factor;

            // Get brush circle id
            const brush_circle_id = "brush_circle";

            // Update the brush circle
            jquery_default()("#" + brush_circle_id).css({
                "width": (this.config["brush_size"] * this.state["zoom_val"]) + "px",
                "height": (this.config["brush_size"] * this.state["zoom_val"]) + "px",
                "border-radius": (this.config["brush_size"] * this.state["zoom_val"]) + "px",
            });
        }
    }

    // Create a complex polygon spatial payload at the brush circle location
    get_brush_circle_spatial_payload(gmx, gmy) {
        // Convert to image space
        let imx = gmx / this.config["px_per_px"];
        let imy = gmy / this.config["px_per_px"];

        // Create a spatial payload around the entire radius of the brush circle
        let spatial_payload = [];
        let radius = this.config["brush_size"] / 2;

        for (let i = 0; i < 360; i += 10) {
            let rad = i * Math.PI / 180;
            spatial_payload.push([imx + (radius * Math.cos(rad)), imy + (radius * Math.sin(rad))]);
        }

        // Ensure that first and last points are the same
        if (spatial_payload.length > 0) {
            spatial_payload[spatial_payload.length - 1] = spatial_payload[0];
        }

        // If we can't draw outside the image, then adjust the payload to fit within the image
        if (!this.config.allow_annotations_outside_image) {
            let any_point_inside_image = false;
            for (let i = 0; i < spatial_payload.length; i++) {
                let pt = spatial_payload[i];

                // Check if the point is inside the image
                if (
                    !any_point_inside_image &&
                    geometric_utils.GeometricUtils.point_is_within_image_bounds(pt, this.config["image_width"], this.config["image_height"])
                ) {
                    any_point_inside_image = true;
                }

                // Clamp the point to the image bounds
                spatial_payload[i] = geometric_utils.GeometricUtils.clamp_point_to_image(pt, this.config["image_width"], this.config["image_height"]);
            }

            // If no point is inside the image, then return null
            if (!any_point_inside_image) {
                return null;
            }
        }

        return [spatial_payload];
    }

    // Check if the newest complex layer can merge with each previous layer.
    merge_polygon_complex_layer(annotation_id, layer_idx = null, recursive_call = false, redoing = false, should_record_action = true) {
        const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
        if (annotation["spatial_type"] === "polygon" && annotation["spatial_payload"].length > 1) {
            const og_polygon_spatial_data = build_annotation.ULabelAnnotation.get_polygon_spatial_data(annotation, true);
            if (layer_idx === null) {
                // Start with the newest layer
                layer_idx = annotation["spatial_payload"].length - 1;
            }
            let spatial_payload = annotation["spatial_payload"];
            // Array<bool> where a true is present if that index of the spatial_payload is a hole
            // Doesn't include a value for the last layer yet
            let spatial_payload_holes = annotation["spatial_payload_holes"];

            // Make sure that spatial_payload_child_indices is at least as long as spatial_payload - 1
            let spatial_payload_child_indices = annotation["spatial_payload_child_indices"];
            while (annotation["spatial_payload_child_indices"].length < spatial_payload.length - 1) {
                spatial_payload_child_indices.push([]);
            }

            // get the desired layer
            let layer = spatial_payload[layer_idx];
            let layer_is_hole = false;
            // After merging with a previous layer, we'll check if that layer can merge with any of its previous layers
            let next_layer_idxs = [];
            // loop through all previous layers, starting from the last
            for (let i = layer_idx - 1; i >= 0; i--) {
                let prev_layer = spatial_payload[i];
                // Try and merge the layers
                let ret = geometric_utils.GeometricUtils.merge_polygons_at_intersection(prev_layer, layer);
                // null means the two layers don't intersect
                if (ret === null) {
                    continue;
                }
                // If they do intersect, then replace our layers with the result
                [prev_layer, layer] = ret;
                spatial_payload[i] = prev_layer;
                if (i > 0) {
                    next_layer_idxs.push(i);
                }
                // The last layer is a hole if the layer it merged into is not a hole
                layer_is_hole = !spatial_payload_holes[i];

                // if our last layer is completely inside the previous layer, then we're done
                if (geometric_utils.GeometricUtils.simple_polygon_is_within_simple_polygon(layer, prev_layer)) {
                    // Add layer_idx as a child of i if (a) it is a hole and (b) it's not already there
                    if (layer_is_hole && !spatial_payload_child_indices[i].includes(layer_idx)) {
                        spatial_payload_child_indices[i].push(layer_idx);
                    }
                    break;
                }
            }

            // If the layer still exists, then add it back to the spatial payload
            if (layer.length > 0) {
                spatial_payload[layer_idx] = layer;
                if (layer_idx < spatial_payload_holes.length) {
                    spatial_payload_holes[layer_idx] = layer_is_hole;
                } else {
                    spatial_payload_holes.push(layer_is_hole);
                }
            } else {
                // If the layer is empty, then remove it from the spatial payload
                spatial_payload.splice(layer_idx, 1);
                if (layer_idx < spatial_payload_holes.length) {
                    spatial_payload_holes.splice(layer_idx, 1);
                }
            }

            for (let idx of next_layer_idxs) {
                this.merge_polygon_complex_layer(annotation_id, idx, true);
            }

            if (!recursive_call) {
                (0,actions/* record_action */.h3)(this, {
                    act_type: "merge_polygon_complex_layer",
                    annotation_id: annotation_id,
                    frame: this.state["current_frame"],
                    undo_payload: {
                        og_polygon_spatial_data: og_polygon_spatial_data,
                    },
                    redo_payload: {
                        layer_idx: layer_idx,
                    },
                }, redoing, should_record_action);
            }
        }
    }

    // Undo the merging of layers by replacing the annotation with the undo payload
    merge_polygon_complex_layer__undo(annotation_id, undo_payload) {
        this.replace_polygon_spatial_data(annotation_id, undo_payload["og_polygon_spatial_data"]);
    }

    // Call merge_polygon_complex_layer on all layers of a polygon
    verify_all_polygon_complex_layers(annotation_id) {
        const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
        // Reset the child indices and holes
        annotation["spatial_payload_holes"] = [false];
        annotation["spatial_payload_child_indices"] = [[]];
        // merge_polygon_complex_layer will verify all layers
        // We can start at layer 1 since layer 0 is always a fill
        for (let layer_idx = 1; layer_idx < annotation["spatial_payload"].length; layer_idx++) {
            this.merge_polygon_complex_layer(annotation_id, layer_idx, false, false, false);
        }
    }

    // Simplify a single layer of a complex polygon. Modifies the annotation directly.
    simplify_polygon_complex_layer(annotation_id, active_idx, redoing = false) {
        // Get the annotation
        const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
        // Save the annotation for undo
        const og_polygon_spatial_data = build_annotation.ULabelAnnotation.get_polygon_spatial_data(annotation, true);
        // Get the layer
        const layer = annotation["spatial_payload"][active_idx];
        // layer is a list of points, so we need to wrap it in a list
        // Replace the layer with the simplified layer
        annotation["spatial_payload"][active_idx] = geometric_utils.GeometricUtils.turf_simplify_complex_polygon([layer])[0];

        // Record the action
        (0,actions/* record_action */.h3)(this, {
            act_type: "simplify_polygon_complex_layer",
            annotation_id: annotation_id,
            frame: this.state["current_frame"],
            undo_payload: {
                og_polygon_spatial_data: og_polygon_spatial_data,
            },
            redo_payload: {
                active_idx: active_idx,
            },
        }, redoing);
    }

    // Undo the simplification of a layer by replacing the annotation with the undo payload
    simplify_polygon_complex_layer__undo(annotation_id, undo_payload) {
        this.replace_polygon_spatial_data(annotation_id, undo_payload["og_polygon_spatial_data"]);
    }

    // Delete all annotations that are completely within a delete annotation (a simple polygon).
    delete_annotations_in_polygon(delete_annid, redo_payload = null) {
        let redoing = false;
        let delete_annotation, delete_polygon;
        if (redo_payload !== null) {
            redoing = true;
            delete_polygon = redo_payload["delete_polygon"];
        } else {
            // Get the delete annotation
            delete_annotation = this.get_current_subtask()["annotations"]["access"][delete_annid];
            delete_polygon = delete_annotation["spatial_payload"];
            (0,annotation_operators.mark_deprecated)(delete_annotation, true);
        }

        // Get the list of annotations
        const annotations = this.get_current_subtask()["annotations"]["access"];
        // Track the ids of deprecated annotations for undo
        let deprecated_ids = [];
        // Track id and annotation pairs of modified annotations for undo
        let modified_annotations = {};
        // Loop through all annotations
        for (let [annid, annotation] of Object.entries(annotations)) {
            // Skip deprecated annotations
            if (annotation["deprecated"]) {
                continue;
            }
            // Skip non-spatial annotations and 3D annotations
            const spatial_type = annotation["spatial_type"];
            if (build_annotation.NONSPATIAL_MODES.includes(spatial_type) || build_annotation.MODES_3D.includes(spatial_type)) {
                continue;
            }

            // Save the original annotation for easy access
            let og_annotation = JSON.parse(JSON.stringify(annotation));

            // Check if the annotation is within the delete polygon
            let split_polygons, new_spatial_payload, simple_polygon;
            let needs_redraw = false;
            switch (spatial_type) {
                // Check if the point is within the delete polygon
                case "point":
                    if (geometric_utils.GeometricUtils.point_is_within_simple_polygon(annotation["spatial_payload"][0], delete_polygon)) {
                        (0,annotation_operators.mark_deprecated)(annotation, true);
                        deprecated_ids.push(annid);
                        needs_redraw = true;
                    }
                    break;
                // Subtract the delete polygon from the annotation
                case "polygon":
                case "polyline":
                case "contour":
                    new_spatial_payload = [];
                    switch (spatial_type) {
                        case "polygon":
                            // Separate the polygon into layers
                            split_polygons = this.split_complex_polygon(annid);
                            for (let split_polygon of split_polygons) {
                                let merged_polygon;
                                // Erase the delete polygon from the annotation
                                merged_polygon = geometric_utils.GeometricUtils.subtract_polygons(split_polygon, [delete_polygon]);
                                if (merged_polygon !== null) {
                                    // Extend the new spatial payload
                                    new_spatial_payload = new_spatial_payload.concat(merged_polygon);
                                }
                            }
                            break;
                        case "polyline":
                        case "contour":
                            new_spatial_payload = geometric_utils.GeometricUtils.subtract_simple_polygon_from_polyline(annotation["spatial_payload"], delete_polygon);
                            break;
                    }
                    if (new_spatial_payload.length === 0) {
                        (0,annotation_operators.mark_deprecated)(annotation, true);
                        deprecated_ids.push(annid);
                        needs_redraw = true;
                    } else {
                        // First, we assume that the annotation changed
                        annotation["spatial_payload"] = new_spatial_payload;
                        if (spatial_type === "polygon") {
                            this.verify_all_polygon_complex_layers(annid);
                        }
                        // Update containing box
                        this.rebuild_containing_box(annid);

                        // TODO: need a more robust check for whether the annotation changed
                        modified_annotations[annid] = JSON.parse(JSON.stringify(og_annotation));
                        needs_redraw = true;
                    }
                    break;
                // Convert to a simple polygon and check if it is within the delete polygon
                case "bbox":
                case "tbar":
                    // Convert to a simple polygon
                    switch (spatial_type) {
                        case "bbox":
                            simple_polygon = geometric_utils.GeometricUtils.bbox_to_simple_polygon(annotation["spatial_payload"]);
                            break;
                        case "tbar":
                            simple_polygon = geometric_utils.GeometricUtils.tbar_to_simple_polygon(annotation["spatial_payload"]);
                            break;
                    }
                    // Check if the polygon falls within the delete polygon or intersects it
                    if (
                        geometric_utils.GeometricUtils.simple_polygon_is_within_simple_polygon(simple_polygon, delete_polygon) ||
                        geometric_utils.GeometricUtils.complex_polygons_intersect([simple_polygon], [delete_polygon])
                    ) {
                        (0,annotation_operators.mark_deprecated)(annotation, true);
                        deprecated_ids.push(annid);
                        needs_redraw = true;
                    }
                    break;

                // TODO: handle other spatial types
            }
            // Redraw if needed
            if (needs_redraw) {
                this.redraw_annotation(annid);
                this.update_filter_distance(annid, false);
                this.toolbox.redraw_update_items(this);
            }
        }

        // Record the delete annotation
        (0,actions/* record_action */.h3)(this, {
            act_type: "delete_annotations_in_polygon",
            annotation_id: delete_annid,
            frame: this.state["current_frame"],
            undo_payload: {
                ender_html: jquery_default()("#ender_" + delete_annid).outer_html(),
                deprecated_ids: deprecated_ids,
                modified_annotations: modified_annotations,
            },
            redo_payload: {
                delete_polygon: delete_polygon,
            },
        }, redoing);

        if (!redoing) {
            // Destroy the polygon ender
            this.destroy_polygon_ender(delete_annid);
            // Remove the delete annotation from access and ordering, and delete its canvas context
            this.destroy_annotation_context(delete_annid);
            this.remove_annotation_from_access_and_ordering(delete_annid);
            this.remove_recorded_events_for_annotation(delete_annid);
        }
    }

    // Undo the deletion of annotations by replacing the annotations with the undo payload
    delete_annotations_in_polygon__undo(undo_payload) {
        // Get the list of annotations
        const subtask = this.get_current_subtask_key();
        const annotations = this.subtasks[subtask]["annotations"]["access"];
        // Loop through all deprecated annotations
        let annotation_ids_to_redraw = [];
        let polyline_was_updated = false;
        for (let annid of undo_payload["deprecated_ids"]) {
            if (!polyline_was_updated && annotations[annid].spatial_type === "polyline") {
                polyline_was_updated = true;
            }
            // Undeprecate the annotation
            (0,annotation_operators.mark_deprecated)(annotations[annid], false);
            // Redraw the annotation
            annotation_ids_to_redraw.push(annid);
        }
        // Loop through all modified annotations
        for (let [annid, annotation] of Object.entries(undo_payload["modified_annotations"])) {
            if (!polyline_was_updated && annotation.spatial_type === "polyline") {
                polyline_was_updated = true;
            }
            // Replace the annotation with the undo payload
            annotations[annid] = annotation;
            // Redraw the annotation
            annotation_ids_to_redraw.push(annid);
        }
        // Redraw annotations
        this.redraw_multiple_spatial_annotations(annotation_ids_to_redraw, subtask);
        // If a polyline was updated, re-filter all points
        if (polyline_was_updated) {
            this.update_filter_distance(null, false, true);
        }
        // Update class counter
        this.toolbox.redraw_update_items(this);
    }

    // Convert bbox to polygon and then delete annotations in polygon
    delete_annotations_in_bbox(delete_annid) {
        const delete_annotation = this.get_current_subtask()["annotations"]["access"][delete_annid];
        const delete_bbox = delete_annotation["spatial_payload"];
        const delete_polygon = geometric_utils.GeometricUtils.bbox_to_simple_polygon(delete_bbox);
        delete_annotation["spatial_payload"] = delete_polygon;
        delete_annotation["spatial_type"] = "delete_polygon";
        // All the deletion work is done in delete_annotations_in_polygon
        this.delete_annotations_in_polygon(delete_annid);
    }

    // Remove an annotation from access and ordering
    remove_annotation_from_access_and_ordering(annotation_id) {
        const current_subtask = this.get_current_subtask();
        if (annotation_id in current_subtask["annotations"]["access"]) {
            // Remove the annotation from access
            delete current_subtask["annotations"]["access"][annotation_id];
            // Remove the annotation from ordering
            current_subtask["annotations"]["ordering"] = current_subtask["annotations"]["ordering"].filter((value) => value !== annotation_id);
        }
    }

    // Remove all recorded events associated with a specific annotation id
    remove_recorded_events_for_annotation(annotation_id) {
        // filter action stream
        let new_action_stream = [];
        for (let action of this.get_current_subtask()["actions"]["stream"]) {
            if (
                action.annotation_id !== annotation_id ||
                action.act_type === "delete_annotations_in_polygon"
            ) {
                new_action_stream.push(action);
            }
        }
        this.get_current_subtask()["actions"]["stream"] = new_action_stream;
    }

    /**
     * Replace an entire annotation with a new one. Generally used for undo/redo.
     *
     * @param {string} annotation_id The id of the annotation to replace
     * @param {object} new_annotation The new annotation to replace the old one
     */
    replace_annotation(annotation_id, annotation) {
        this.get_current_subtask()["annotations"]["access"][annotation_id] = annotation;
    }

    /**
     * Replace the spatial data of a polygon annotation with new spatial data. Generally used for undo/redo.
     *
     * @param {string} annotation_id The id of the annotation to replace
     * @param {object} new_spatial_data The new spatial data to replace the old one
     */
    replace_polygon_spatial_data(annotation_id, new_spatial_data) {
        const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
        annotation["spatial_payload"] = new_spatial_data["spatial_payload"];
        annotation["spatial_payload_holes"] = new_spatial_data["spatial_payload_holes"];
        annotation["spatial_payload_child_indices"] = new_spatial_data["spatial_payload_child_indices"];
        annotation["containing_box"] = new_spatial_data["containing_box"];
    }

    // ================= Edit/ID Dialogs =================

    // Edit suggestion: highlight a point in an annotation that can be edited
    show_edit_suggestion(edit_suggestion, currently_exists = false) {
        let esid = "edit_suggestion__" + this.get_current_subtask_key();
        var esjq = jquery_default()("#" + esid);
        esjq.css("display", "block");
        if (currently_exists) {
            esjq.removeClass("soft");
        } else {
            esjq.addClass("soft");
        }
        this.get_current_subtask()["state"]["visible_dialogs"][esid]["left"] = edit_suggestion["point"][0] / this.config["image_width"];
        this.get_current_subtask()["state"]["visible_dialogs"][esid]["top"] = edit_suggestion["point"][1] / this.config["image_height"];
        this.reposition_dialogs();
    }

    hide_edit_suggestion() {
        jquery_default()(".edit_suggestion").css("display", "none");
    }

    // Global edit suggestion: id dialog, move button, and delete button
    show_global_edit_suggestion(annid, offset = null, nonspatial_id = null) {
        const subtask_key = this.get_current_subtask_key();
        const current_subtask = this.subtasks[subtask_key];

        let diffX = 0;
        let diffY = 0;
        if (offset != null) {
            diffX = offset["diffX"];
            diffY = offset["diffY"];
        }

        let idd_x;
        let idd_y;
        if (nonspatial_id === null) {
            let esid = "global_edit_suggestion__" + subtask_key;
            var esjq = jquery_default()("#" + esid);
            esjq.css("display", "block");
            let cbox = current_subtask["annotations"]["access"][annid]["containing_box"];
            let new_lft = (cbox["tlx"] + cbox["brx"] + 2 * diffX) / (2 * this.config["image_width"]);
            let new_top = (cbox["tly"] + cbox["bry"] + 2 * diffY) / (2 * this.config["image_height"]);
            current_subtask["state"]["visible_dialogs"][esid]["left"] = new_lft;
            current_subtask["state"]["visible_dialogs"][esid]["top"] = new_top;
            this.reposition_dialogs();
            idd_x = (cbox["tlx"] + cbox["brx"] + 2 * diffX) / 2;
            idd_y = (cbox["tly"] + cbox["bry"] + 2 * diffY) / 2;
        } else {
            // TODO(new3d)
            idd_x = jquery_default()("#reclf__" + nonspatial_id).offset().left - 85;// this.get_global_element_center_x($("#reclf__" + nonspatial_id));
            idd_y = jquery_default()("#reclf__" + nonspatial_id).offset().top - 85;// this.get_global_element_center_y($("#reclf__" + nonspatial_id));
        }

        // let placeholder = $("#global_edit_suggestion a.reid_suggestion");
        if (!current_subtask["single_class_mode"]) {
            // Show id dialog thumbnail
            this.show_id_dialog(idd_x, idd_y, annid, true, nonspatial_id != null);
        }
    }

    hide_global_edit_suggestion() {
        jquery_default()(".global_edit_suggestion").css("display", "none");
        this.hide_id_dialog();
    }

    // ID dialog: color wheel to change the ID of an annotation
    show_id_dialog(gbx, gby, active_ann, thumbnail = false, nonspatial = false) {
        let stkey = this.get_current_subtask_key();

        // Record which annotation this dialog is associated with
        // TODO
        // am_dialog_associated_ann = active_ann;
        this.get_current_subtask()["state"]["idd_visible"] = true;
        this.get_current_subtask()["state"]["idd_thumbnail"] = thumbnail;
        this.get_current_subtask()["state"]["idd_associated_annotation"] = active_ann;
        this.get_current_subtask()["state"]["idd_which"] = "back";

        let idd_id = this.get_current_subtask()["state"]["idd_id"];
        let idd_niu_id = this.get_current_subtask()["state"]["idd_id_front"];
        let new_height = jquery_default()(`#global_edit_suggestion__${stkey} a.reid_suggestion`)[0].getBoundingClientRect().height;

        if (nonspatial) {
            this.get_current_subtask()["state"]["idd_which"] = "front";
            idd_id = this.get_current_subtask()["state"]["idd_id_front"];
            idd_niu_id = this.get_current_subtask()["state"]["idd_id"];
            new_height = 28;
        } else {
            // Add this id to the list of dialogs with managed positions
            // TODO actually only do this when calling append()
            this.get_current_subtask()["state"]["visible_dialogs"][idd_id] = {
                left: gbx / this.config["image_width"],
                top: gby / this.config["image_height"],
                pin: "center",
            };
        }
        let idd = jquery_default()("#" + idd_id);
        let idd_niu = jquery_default()("#" + idd_niu_id);
        if (nonspatial) {
            let new_home = jquery_default()(`#reclf__${active_ann}`);
            let fad_st = jquery_default()(`#fad_st__${stkey} div.front_dialogs`);
            let ofst = -100;
            let zidx = 2000;
            if (thumbnail) {
                zidx = -1;
                // ofst = -100;
            }
            let top_c = new_home.offset().top - fad_st.offset().top + ofst + new_height / 2;
            let left_c = new_home.offset().left - fad_st.offset().left + ofst + 1 + new_height / 2;
            idd.css({
                "display": "block",
                "position": "absolute",
                "top": (top_c) + "px",
                "left": (left_c) + "px",
                "z-index": zidx,
            });
            idd.parent().css({
                "z-index": zidx,
            });
        }

        // Add or remove thumbnail class if necessary
        let scale_ratio = new_height / this.config["outer_diameter"];
        if (thumbnail) {
            if (!idd.hasClass("thumb")) {
                idd.addClass("thumb");
            }
            jquery_default()("#" + idd_id + ".thumb").css({
                transform: `scale(${scale_ratio})`,
            });
        } else {
            jquery_default()("#" + idd_id + ".thumb").css({
                transform: `scale(1.0)`,
            });
            if (idd.hasClass("thumb")) {
                idd.removeClass("thumb");
            }
        }

        this.reposition_dialogs();

        // Configure the dialog to show the current information for this ann
        this.set_id_dialog_payload_to_init(active_ann);
        this.update_id_dialog_display(nonspatial);

        // Show the dialog
        idd.css("display", "block");
        idd_niu.css("display", "none");
        // TODO(new3d)
        // if (nonspatial) {
        //     idd.css("z-index", 2000);
        // }
    }

    hide_id_dialog() {
        let idd_id = this.get_current_subtask()["state"]["idd_id"];
        let idd_id_front = this.get_current_subtask()["state"]["idd_id_front"];
        this.get_current_subtask()["state"]["idd_visible"] = false;
        this.get_current_subtask()["state"]["idd_associated_annotation"] = null;
        jquery_default()("#" + idd_id).css("display", "none");
        jquery_default()("#" + idd_id_front).css("display", "none");
    }

    // ================= Annotation Utilities =================

    /**
     * Undo the last action.
     */
    undo() {
        (0,actions/* undo */.tN)(this);
    }

    /**
     * Redo the last undone action.
     */
    redo() {
        (0,actions/* redo */.ZS)(this);
    }

    /**
     * Creates an annotation based on passed in parameters. Does not use mouse positions
     *
     * @param {string} spatial_type What type of annotation to create
     * @param {[number, number][]} spatial_payload
     * @param {string} unique_id Optional unique id to use for the annotation. If null, a new unique id will be generated
     */
    create_annotation(spatial_type, spatial_payload, unique_id = null, is_redo = false) {
        // Grab constants for convenience
        const current_subtask = this.get_current_subtask();
        const annotation_access = current_subtask["annotations"]["access"];
        const annotation_ordering = current_subtask["annotations"]["ordering"];

        // Create a new unique id for this annotation
        if (unique_id === null) {
            // Create a unique id if one is not provided
            unique_id = this.make_new_annotation_id();
        }

        // Get the frame
        if (build_annotation.MODES_3D.includes(spatial_type)) {
            this.state["current_frame"] = null;
        }

        // Create the new annotation
        let new_annotation = {
            id: unique_id,
            created_by: this.config.username,
            created_at: ULabel.get_time(),
            last_edited_by: this.config.username,
            last_edited_at: ULabel.get_time(),
            deprecated: false,
            deprecated_by: { human: false },
            spatial_type: spatial_type,
            spatial_payload: spatial_payload,
            classification_payloads: this.get_init_id_payload(spatial_type),
            text_payload: "",
            line_size: this.get_initial_line_size(),
            canvas_id: this.get_init_canvas_context_id(unique_id),
        };

        new_annotation = build_annotation.ULabelAnnotation.from_json(new_annotation);

        // Snap each point to the image bounds
        if (!this.config.allow_annotations_outside_image) {
            new_annotation = new_annotation.clamp_annotation_to_image_bounds(this.config["image_width"], this.config["image_height"]);
        }

        if (spatial_type === "polygon") {
            new_annotation["spatial_payload_holes"] = [false];
            new_annotation["spatial_payload_child_indices"] = [[]];
        }

        // Add the new annotation to the annotation access and ordering
        annotation_access[unique_id] = new_annotation;
        annotation_ordering.push(unique_id);

        // Record the action so it can be undone and redone
        (0,actions/* record_action */.h3)(this, {
            act_type: "create_annotation",
            annotation_id: unique_id,
            frame: this.state["current_frame"],
            undo_payload: {},
            redo_payload: {
                spatial_payload: spatial_payload,
                spatial_type: spatial_type,
            },
        }, is_redo);
    }

    /**
     * Undo annotation creation.
     *
     * @param {string} annotation_id The id of the annotation
     */
    create_annotation__undo(annotation_id) {
        // Destory the canvas context
        this.destroy_annotation_context(annotation_id);
        // Remove the annotation from access and ordering
        this.remove_annotation_from_access_and_ordering(annotation_id);
    }

    /**
     * Recalls create_annotation with the information inside the undo_payload.
     * redo_payload should be an object containing three properties.
     * redo_payload.spatial_payload: [number, number][]
     * redo_payload.spatial_type: string
     *
     * @param {string} annotation_id The id of the annotation
     * @param {Object} redo_payload Payload containing the properties required to recall create_annotation
     */
    create_annotation__redo(annotation_id, redo_payload) {
        // Recreate the annotation with the same annotation_id, spatial_type, and spatial_payload
        this.create_annotation(
            redo_payload.spatial_type,
            redo_payload.spatial_payload,
            annotation_id,
            true,
        );
    }

    create_point_annotation_at_mouse_location() {
        const last_move = this.state["last_move"];
        if (last_move !== null) {
            const spatial_payload = this.get_image_aware_mouse_x_y(last_move);
            // Create a point annotation at the mouse position
            this.create_annotation("point", [spatial_payload]);
        }
    }

    delete_annotation(annotation_id, redoing = false, should_record_action = true) {
        // Grab constants for convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];
        const spatial_type = annotations[annotation_id]["spatial_type"];

        // Deprecate the annotation and redraw it
        (0,annotation_operators.mark_deprecated)(annotations[annotation_id], true);

        if (current_subtask["state"]["active_id"] !== null) {
            current_subtask["state"]["active_id"] = null;
            current_subtask["state"]["is_in_edit"] = false;
            current_subtask["state"]["is_in_move"] = false;
            current_subtask["state"]["is_in_progress"] = false;
            current_subtask["state"]["starting_complex_polygon"] = false;
        }

        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(spatial_type)) {
            frame = null;
        }

        (0,actions/* record_action */.h3)(this, {
            act_type: "delete_annotation",
            annotation_id: annotation_id,
            frame: frame,
            undo_payload: {},
            redo_payload: {},
        }, redoing, should_record_action);
    }

    delete_annotation__undo(annotation_id) {
        // Set the annotation to be undeprecated and redraw it
        (0,annotation_operators.mark_deprecated)(this.get_current_subtask()["annotations"]["access"][annotation_id], false);
    }

    delete_annotation__redo(annotation_id) {
        this.delete_annotation(annotation_id, true);
    }

    /**
     * Get the annotation with nearest active keypoint (e.g. corners for a bbox, endpoints for polylines) to a point
     * @param {*} global_x
     * @param {*} global_y
     * @param {*} max_dist Maximum distance to search
     * @param {*} candidates Candidates to search across
     * @returns
     */
    get_nearest_active_keypoint(global_x, global_y, max_dist, candidates = null) {
        var ret = {
            annid: null,
            access: null,
            distance: max_dist / this.get_empirical_scale(),
            point: null,
        };
        if (candidates === null) {
            candidates = this.get_current_subtask()["annotations"]["ordering"];
        }
        // Iterate through and find any close enough defined points
        var edid = null;
        for (var edi = 0; edi < candidates.length; edi++) {
            edid = candidates[edi];
            let npi = null;
            let curfrm, pts, n_iters, access_idx;
            const spatial_type = this.get_current_subtask()["annotations"]["access"][edid]["spatial_type"];
            let spatial_payload = this.get_current_subtask()["annotations"]["access"][edid]["spatial_payload"];
            let active_spatial_payload = spatial_payload;
            switch (spatial_type) {
                case "bbox":
                    npi = geometric_utils.GeometricUtils.get_nearest_point_on_bounding_box(
                        global_x, global_y, spatial_payload, max_dist,
                    );
                    if (npi["distance"] < ret["distance"]) {
                        ret["annid"] = edid;
                        ret["access"] = npi["access"];
                        ret["distance"] = npi["distance"];
                        ret["point"] = npi["point"];
                    }
                    break;
                case "bbox3":
                    curfrm = this.state["current_frame"];
                    pts = spatial_payload;
                    if ((curfrm >= Math.min(pts[0][2], pts[1][2])) && (curfrm <= Math.max(pts[0][2], pts[1][2]))) {
                        // TODO(new3d) Make sure this function works for bbox3 too
                        npi = geometric_utils.GeometricUtils.get_nearest_point_on_bbox3(
                            global_x, global_y, curfrm, pts, max_dist,
                        );
                        if (npi["distance"] < ret["distance"]) {
                            ret["annid"] = edid;
                            ret["access"] = npi["access"];
                            ret["distance"] = npi["distance"];
                            ret["point"] = npi["point"];
                        }
                    }
                    break;
                case "polygon":
                case "polyline":
                    // for polygons, we'll need to loop through all points
                    n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;

                    for (let i = 0; i < n_iters; i++) {
                        if (spatial_type === "polygon") {
                            active_spatial_payload = spatial_payload[i];
                        }
                        npi = geometric_utils.GeometricUtils.get_nearest_point_on_polygon(
                            global_x, global_y, active_spatial_payload, max_dist, false,
                        );
                        // for polygons, access index is a list of two indices
                        // for polylines, access index is a single index
                        access_idx = spatial_type === "polygon" ? [i, npi["access"]] : npi["access"];
                        if (npi["distance"] < ret["distance"]) {
                            ret["annid"] = edid;
                            ret["access"] = access_idx;
                            ret["distance"] = npi["distance"];
                            ret["point"] = npi["point"];
                        }
                    }
                    break;
                case "tbar":
                    npi = geometric_utils.GeometricUtils.get_nearest_point_on_tbar(
                        global_x, global_y, spatial_payload, max_dist,
                    );
                    if (npi["distance"] < ret["distance"]) {
                        ret["annid"] = edid;
                        ret["access"] = npi["access"];
                        ret["distance"] = npi["distance"];
                        ret["point"] = npi["point"];
                    }
                    break;
                case "contour":
                case "point":
                    // Not editable at the moment
                    break;
            }
        }
        // TODO(3d)
        // Iterate through 3d annotations here (e.g., bbox3)
        if (ret["annid"] === null) {
            return null;
        }
        return ret;
    }

    /**
     * Get annotation segment to a point.
     * @param {*} global_x
     * @param {*} global_y
     * @param {*} max_dist Maximum distance to search
     * @param {*} candidates Candidates to search across
     * @returns
     */
    get_nearest_segment_point(global_x, global_y, max_dist, candidates = null) {
        var ret = {
            annid: null,
            access: null,
            distance: max_dist / this.get_empirical_scale(),
            point: null,
        };
        if (candidates === null) {
            candidates = this.get_current_subtask()["annotations"]["ordering"];
        }
        for (var edi = 0; edi < candidates.length; edi++) {
            var edid = candidates[edi];
            const spatial_type = this.get_current_subtask()["annotations"]["access"][edid]["spatial_type"];
            let spatial_payload = this.get_current_subtask()["annotations"]["access"][edid]["spatial_payload"];
            let active_spatial_payload = spatial_payload;
            let n_iters, access_idx;
            switch (spatial_type) {
                case "bbox":
                case "bbox3":
                case "point":
                    // Can't propose new bounding box or keypoint points
                    break;
                case "polygon":
                case "polyline":
                    // for polygons, we'll need to loop through all points
                    n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;
                    for (let i = 0; i < n_iters; i++) {
                        if (spatial_type === "polygon") {
                            active_spatial_payload = spatial_payload[i];
                        }
                        var npi = geometric_utils.GeometricUtils.get_nearest_point_on_polygon(
                            global_x, global_y, active_spatial_payload, max_dist / this.get_empirical_scale(), true,
                        );
                        // for polygons, access index is a list of two indices
                        // for polylines, access index is a single index
                        access_idx = spatial_type === "polygon" ? [i, npi["access"]] : npi["access"];
                        if (npi["distance"] != null && npi["distance"] < ret["distance"]) {
                            ret["annid"] = edid;
                            ret["access"] = access_idx;
                            ret["distance"] = npi["distance"];
                            ret["point"] = npi["point"];
                        }
                    }
                    break;
                case "contour":
                    // Not editable at the moment (TODO)
                    break;
                case "tbar":
                    // Can't propose new tbar points
                    break;
            }
        }
        if (ret["annid"] === null) {
            return null;
        }
        return ret;
    }

    get_scaled_line_size(annotation) {
        // If a line size isn't provided, use the default line size
        let line_size;
        if ("line_size" in annotation && annotation["line_size"] !== null) {
            line_size = annotation["line_size"];
        } else {
            line_size = this.get_initial_line_size();
        }

        // fixed: line size is independent of zoom level
        // match-zoom: line size increases with increased zoom level
        // inverse-zoom: line size decreases with increased zoom level
        if (this.state.anno_scaling_mode === "match-zoom") {
            line_size *= this.state["zoom_val"];
        } else if (this.state.anno_scaling_mode === "inverse-zoom") {
            line_size /= this.state["zoom_val"];
        }

        return line_size;
    }

    get_initial_line_size() {
        return this.state.line_size;
    }

    // Action Stream Events

    set_saved(saved) {
        this.state["edited"] = !saved;
    }

    create_nonspatial_annotation(annotation_id = null, redo_payload = null) {
        const current_subtask = this.get_current_subtask();
        let redoing = false;
        let annotation_mode = null;
        let init_idpyld = null;
        if (redo_payload === null) {
            annotation_id = this.make_new_annotation_id();
            annotation_mode = current_subtask["state"]["annotation_mode"];
            init_idpyld = this.get_init_id_payload();
        } else {
            redoing = true;
            annotation_mode = redo_payload.annotation_mode;
            init_idpyld = redo_payload.init_payload;
        }

        // Add this annotation to annotations object
        let annframe = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(annotation_mode)) {
            annframe = null;
        }

        let new_annotation = {
            id: annotation_id,
            created_by: this.config.username,
            created_at: ULabel.get_time(),
            last_edited_by: this.config.username,
            last_edited_at: ULabel.get_time(),
            deprecated: false,
            deprecated_by: { human: false },
            spatial_type: annotation_mode,
            spatial_payload: null,
            classification_payloads: JSON.parse(JSON.stringify(init_idpyld)),
            line_size: null,
            containing_box: null,
            frame: annframe,
            text_payload: "",
            annotation_meta: this.config["annotation_meta"],
        };

        current_subtask["annotations"]["access"][annotation_id] = new_annotation;
        current_subtask["annotations"]["ordering"].push(annotation_id);

        if (redoing) {
            this.set_id_dialog_payload_to_init(annotation_id, init_idpyld);
        }

        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(annotation_mode)) {
            frame = null;
        }

        // Record for potential undo/redo
        (0,actions/* record_action */.h3)(this, {
            act_type: "create_nonspatial_annotation",
            annotation_id: annotation_id,
            frame: frame,
            redo_payload: {
                annotation_mode: annotation_mode,
                init_spatial: null,
                finished: true,
                init_payload: this.get_current_subtask()["state"]["id_payload"],
            },
            undo_payload: {},
        }, redoing);
    }

    create_nonspatial_annotation__undo(annotation_id) {
        this.remove_annotation_from_access_and_ordering(annotation_id);
        this.clear_nonspatial_annotation(annotation_id);
    }

    begin_annotation(mouse_event, annotation_id = null, redo_payload = null) {
        // Give the new annotation a unique ID
        let line_size = null;
        let annotation_mode = null;
        let redoing = false;
        let gmx = null;
        let gmy = null;
        let init_spatial = null;
        let init_id_payload = null;
        let containing_box = null;

        const subtask_key = this.get_current_subtask_key();
        const current_subtask = this.subtasks[subtask_key];

        if (redo_payload === null) {
            annotation_id = this.make_new_annotation_id();
            line_size = this.get_initial_line_size();
            annotation_mode = current_subtask["state"]["annotation_mode"];
            [gmx, gmy] = this.get_image_aware_mouse_x_y(mouse_event);
            init_spatial = this.get_init_spatial(gmx, gmy, annotation_mode, mouse_event);
            init_id_payload = this.get_init_id_payload(annotation_mode);
        } else {
            line_size = redo_payload.line_size;
            mouse_event = redo_payload.mouse_event;
            annotation_mode = redo_payload.annotation_mode;
            redoing = true;
            gmx = redo_payload.gmx;
            gmy = redo_payload.gmy;
            init_spatial = redo_payload.init_spatial;
            init_id_payload = redo_payload.init_payload;
        }

        let canvas_id = this.get_init_canvas_context_id(annotation_id, subtask_key);

        // TODO(3d)
        if (build_annotation.NONSPATIAL_MODES.includes(annotation_mode)) {
            line_size = null;
            init_spatial = null;
        } else {
            containing_box = {
                tlx: gmx,
                tly: gmy,
                brx: gmx,
                bry: gmy,
            };
        }

        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(annotation_mode)) {
            frame = null;
        }

        // Add this annotation to annotations object
        current_subtask["annotations"]["access"][annotation_id] = {
            id: annotation_id,
            created_by: this.config.username,
            created_at: ULabel.get_time(),
            last_edited_at: ULabel.get_time(),
            last_edited_by: this.config.username,
            deprecated: false,
            deprecated_by: { human: false },
            spatial_type: annotation_mode,
            spatial_payload: init_spatial,
            classification_payloads: init_id_payload,
            line_size: line_size,
            containing_box: containing_box,
            frame: frame,
            canvas_id: canvas_id,
            text_payload: "",
        };

        if (annotation_mode === "polygon") {
            // First layer is always a fill, not a hole
            current_subtask["annotations"]["access"][annotation_id]["spatial_payload_holes"] = [false];
            current_subtask["annotations"]["access"][annotation_id]["spatial_payload_child_indices"] = [[]];
        }

        // TODO(3d)
        // Load annotation_meta into annotation
        current_subtask["annotations"]["access"][annotation_id]["annotation_meta"] = this.config["annotation_meta"];
        current_subtask["annotations"]["ordering"].push(annotation_id);

        // If a polygon was just started, we need to add a clickable to end the shape
        this.create_polygon_ender(gmx, gmy, annotation_id);

        current_subtask["state"]["active_id"] = annotation_id;
        current_subtask["state"]["is_in_progress"] = true;

        // Record for potential undo/redo
        (0,actions/* record_action */.h3)(this, {
            act_type: "begin_annotation",
            annotation_id: annotation_id,
            frame: frame,
            redo_payload: {
                mouse_event: mouse_event,
                line_size: line_size,
                annotation_mode: annotation_mode,
                gmx: gmx,
                gmy: gmy,
                init_spatial: init_spatial,
                finished: redoing || annotation_mode === "point",
                init_payload: init_id_payload,
            },
            undo_payload: {},
        }, redoing);

        if (redoing) {
            this.set_id_dialog_payload_to_init(annotation_id, init_id_payload);

            if (annotation_mode === "polygon" || annotation_mode === "polyline" || annotation_mode === "delete_polygon") {
                this.continue_annotation(this.state["last_move"]);
            } else {
                this.finish_annotation();
            }
        }
    }

    begin_annotation__undo(annotation_id) {
        const current_subtask = this.get_current_subtask();

        // Set annotation state not in progress, nullify active id
        current_subtask["state"]["is_in_progress"] = false;
        current_subtask["state"]["active_id"] = null;

        // Destroy the annotation's canvas, thus removing it from the screen
        this.destroy_annotation_context(annotation_id);
        this.remove_annotation_from_access_and_ordering(annotation_id);
    }

    update_containing_box(ms_loc, actid, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }
        // TODO(3d)
        if (ms_loc[0] < this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tlx"]) {
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tlx"] = ms_loc[0];
        } else if (ms_loc[0] > this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["brx"]) {
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["brx"] = ms_loc[0];
        }
        if (ms_loc[1] < this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tly"]) {
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tly"] = ms_loc[1];
        } else if (ms_loc[1] > this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["bry"]) {
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["bry"] = ms_loc[1];
        }
    }

    rebuild_containing_box(actid, ignore_final = false, subtask = null) {
        if (subtask === null) {
            subtask = this.get_current_subtask_key();
        }

        // No need to rebuild containing box for image-level annotation types.
        const spatial_type = this.subtasks[subtask]["annotations"]["access"][actid]["spatial_type"];
        if (build_annotation.NONSPATIAL_MODES.includes(spatial_type)) {
            return;
        }

        let spatial_payload = [];
        if (spatial_type === "polygon") {
            // Collapse the list[list[points]] into a single list of points
            for (let active_spatial_payload of this.subtasks[subtask]["annotations"]["access"][actid]["spatial_payload"]) {
                spatial_payload = spatial_payload.concat(active_spatial_payload);
            }
        } else {
            spatial_payload = this.subtasks[subtask]["annotations"]["access"][actid]["spatial_payload"];
        }

        let init_pt = spatial_payload[0];
        if (init_pt === undefined) {
            return;
        }

        this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"] = {
            tlx: init_pt[0],
            tly: init_pt[1],
            brx: init_pt[0],
            bry: init_pt[1],
        };
        let npts = spatial_payload.length;
        if (ignore_final) {
            npts -= 1;
        }
        for (var pti = 1; pti < npts; pti++) {
            this.update_containing_box(spatial_payload[pti], actid, subtask);
        }
        if (spatial_type) {
            let line_size = this.subtasks[subtask]["annotations"]["access"][actid]["line_size"];
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tlx"] -= 3 * line_size;
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["tly"] -= 3 * line_size;
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["brx"] += 3 * line_size;
            this.subtasks[subtask]["annotations"]["access"][actid]["containing_box"]["bry"] += 3 * line_size;
        }
        // TODO modification here for T-Bar would be nice too
    }

    // Check that two containing boxes are equal
    containing_boxes_are_equal(containing_box1, containing_box2) {
        return (
            containing_box1["tlx"] === containing_box2["tlx"] &&
            containing_box1["tly"] === containing_box2["tly"] &&
            containing_box1["brx"] === containing_box2["brx"] &&
            containing_box1["bry"] === containing_box2["bry"]
        );
    }

    continue_annotation(mouse_event, isclick = false, annotation_id = null, redo_payload = null) {
        // Convenience
        const current_subtask = this.get_current_subtask();
        let redoing = false;
        let gmx = null;
        let gmy = null;
        let frm = this.state["current_frame"];
        let is_click_dragging = this.drag_state["active_key"] != null;
        if (redo_payload === null) {
            annotation_id = current_subtask["state"]["active_id"];
            [gmx, gmy] = this.get_image_aware_mouse_x_y(mouse_event);
        } else {
            mouse_event = redo_payload.mouse_event;
            isclick = redo_payload.isclick;
            redoing = true;
            gmx = redo_payload.gmx;
            gmy = redo_payload.gmy;
            frm = redo_payload.frame;
        }

        if (annotation_id !== null) {
            const ms_loc = [
                gmx,
                gmy,
            ];
            // Handle annotation continuation based on the annotation mode
            // TODO(3d)
            // TODO(3d--META) -- This is the farthest I got tagging places that will need to be fixed.
            let n_kpts, ender_pt, ender_dist, ender_thresh;
            let add_keypoint = false;
            const spatial_type = current_subtask["annotations"]["access"][annotation_id]["spatial_type"];
            let spatial_payload = current_subtask["annotations"]["access"][annotation_id]["spatial_payload"];
            let active_spatial_payload = spatial_payload;

            switch (spatial_type) {
                case "bbox":
                case "delete_bbox":
                    spatial_payload[1] = ms_loc;
                    break;
                case "bbox3":
                    spatial_payload[1] = [
                        ms_loc[0],
                        ms_loc[1],
                        frm,
                    ];
                    break;
                case "polygon":
                case "polyline":
                case "delete_polygon":
                    if (spatial_type === "polygon") {
                        // for polygons, the active spatial payload is the last array of points in the spatial payload
                        active_spatial_payload = spatial_payload.at(-1);
                    }
                    // Store number of keypoints for easy access
                    n_kpts = active_spatial_payload.length;

                    if (n_kpts > 0) {
                        // If hovering over the ender, snap to its center
                        ender_pt = [
                            active_spatial_payload[0][0],
                            active_spatial_payload[0][1],
                        ];
                        ender_dist = Math.pow(Math.pow(ms_loc[0] - ender_pt[0], 2) + Math.pow(ms_loc[1] - ender_pt[1], 2), 0.5);
                        ender_thresh = jquery_default()("#ender_" + annotation_id).width() / (2 * this.get_empirical_scale());
                        if (ender_dist < ender_thresh) {
                            active_spatial_payload[n_kpts - 1] = ender_pt;
                        } else { // Else, just redirect line to mouse position
                            active_spatial_payload[n_kpts - 1] = ms_loc;
                        }
                    } else if (current_subtask["state"]["starting_complex_polygon"]) {
                        // When waiting to start a complex polygon, move the ender to the mouse position
                        this.move_polygon_ender(gmx, gmy, annotation_id);
                    }

                    // If this mouse event is a click, add a new member to the list of keypoints
                    //    ender clicks are filtered before they get here
                    if (isclick || (is_click_dragging && this.config.click_and_drag_poly_annotations)) {
                        add_keypoint = true;
                        if (n_kpts === 0) {
                            // We'll need to add this point twice, once for the actual point
                            // and once for rendering future lines.
                            active_spatial_payload.push(ms_loc);
                            // mark that we've successfully started our complex polygon
                            current_subtask["state"]["starting_complex_polygon"] = false;
                        } else if (n_kpts > 1) {
                            // the last point in the active spatial payload is the current mouse position for rendering purposes,
                            // so we check against the second to last point
                            let last_pt = active_spatial_payload[n_kpts - 2];
                            // If the last point is the same as the current point, then we are done
                            if (last_pt[0] === ms_loc[0] && last_pt[1] === ms_loc[1]) {
                                add_keypoint = false;
                            }
                        }

                        // only add a new keypoint if it is different from the last one
                        if (add_keypoint) {
                            active_spatial_payload.push(ms_loc);
                        }
                    }
                    break;
                case "contour":
                    if (geometric_utils.GeometricUtils.l2_norm(ms_loc, spatial_payload.at(-1)) * this.config["px_per_px"] > 3) {
                        spatial_payload.push(ms_loc);
                    }
                    break;
                case "tbar":
                    spatial_payload[1] = ms_loc;
                    break;
                default:
                    (0,error_logging.log_message)(
                        `Annotation mode is not understood: ${spatial_type}`,
                        error_logging.LogLevel.WARNING,
                        true,
                    );
                    break;
            }

            // Only an undoable action if placing a polygon keypoint
            (0,actions/* record_action */.h3)(this, {
                act_type: "continue_annotation",
                annotation_id: annotation_id,
                frame: this.state["current_frame"],
                redo_payload: {
                    mouse_event: mouse_event,
                    isclick: isclick || is_click_dragging,
                    gmx: gmx,
                    gmy: gmy,
                },
                undo_payload: {},
            }, redoing, add_keypoint);

            if (redoing) {
                this.continue_annotation(this.state["last_move"]);
            }
        }
    }

    continue_annotation__undo(annotation_id) {
        const current_subtask = this.get_current_subtask();
        let spatial_payload = current_subtask["annotations"]["access"][annotation_id]["spatial_payload"];
        const spatial_type = current_subtask["annotations"]["access"][annotation_id]["spatial_type"];
        let active_spatial_payload = spatial_payload;
        if (spatial_type === "polygon") {
            // For polygons, the active spatial payload is the last array of points in the spatial payload
            active_spatial_payload = spatial_payload.at(-1);
        }
        // Get the last point in the active spatial payload
        active_spatial_payload.pop();

        // Logic for dealing with complex layers
        if (spatial_type === "polygon" && spatial_payload[0].length > 1) {
            // If the active spatial payload has *one* point remaining, delete the point and start moving the polygon ender
            if (active_spatial_payload.length === 1) {
                active_spatial_payload.pop();
                current_subtask["state"]["starting_complex_polygon"] = true;
            } else if (active_spatial_payload.length === 0) {
                // If the user has undone all points in the active spatial payload, return to the previous layer
                // Set the starting_complex_polygon state to false
                current_subtask["state"]["starting_complex_polygon"] = false;
                // Remove the placeholder annotation
                spatial_payload.pop();
                active_spatial_payload = spatial_payload.at(-1);
                // move the polygon ender
                let last_pt = active_spatial_payload.at(-1);
                this.move_polygon_ender(last_pt[0], last_pt[1], current_subtask["state"]["active_id"]);
            }
        }
        this.continue_annotation(this.state["last_move"]);
    }

    start_complex_polygon(annotation_id = null) {
        const current_subtask = this.get_current_subtask();
        let redoing = false;
        if (annotation_id === null) {
            annotation_id = current_subtask["state"]["active_id"];
        } else {
            current_subtask["state"]["active_id"] = annotation_id;
            redoing = true;

            // Add back the ender
            const [gmx, gmy] = this.get_image_aware_mouse_x_y(this.state["last_move"]);
            this.create_polygon_ender(gmx, gmy, annotation_id);
        }

        const polygon_spatial_data = build_annotation.ULabelAnnotation.get_polygon_spatial_data(current_subtask["annotations"]["access"][annotation_id], true);
        // Prep the next part of the polygon
        current_subtask["annotations"]["access"][annotation_id]["spatial_payload"].push([]);
        // mark that we are starting complex polygon
        current_subtask["state"]["starting_complex_polygon"] = true;
        // mark in progress
        current_subtask["state"]["is_in_progress"] = true;

        (0,actions/* record_action */.h3)(this, {
            act_type: "start_complex_polygon",
            annotation_id: annotation_id,
            frame: this.state["current_frame"],
            undo_payload: {
                // Save polygon spatial data for potential "finish_modify_annotation" undo
                polygon_spatial_data: polygon_spatial_data,
            },
            redo_payload: {},
        }, redoing);
    }

    start_complex_polygon__undo(annotation_id) {
        const current_subtask = this.get_current_subtask();
        // Set the starting_complex_polygon state to false
        current_subtask["state"]["starting_complex_polygon"] = false;
        // Remove the placeholder annotation
        current_subtask["annotations"]["access"][annotation_id]["spatial_payload"].pop();
        // Mark that we're done here
        current_subtask["state"]["active_id"] = null;
        current_subtask["state"]["is_in_progress"] = false;
    }

    // Split a ULabel complex polygon seperate turf polygons for each fill
    split_complex_polygon(active_id) {
        this.verify_complex_polygon_child_indices(active_id);
        // Get annotation
        const annotation = this.get_current_subtask()["annotations"]["access"][active_id];
        const spatial_payload = annotation["spatial_payload"];
        const spatial_payload_holes = annotation["spatial_payload_holes"];
        const spatial_payload_child_indices = annotation["spatial_payload_child_indices"];
        let split_polygons = [];
        for (let idx = 0; idx < spatial_payload.length; idx++) {
            // Check that this is a fill and not a hole
            if (!spatial_payload_holes[idx]) {
                // Start with the fill itself
                let split_polygon = [spatial_payload[idx]];
                // Check that we track its children
                if (idx < spatial_payload_child_indices.length) {
                    // Get the child indices
                    let child_indices_arr = spatial_payload_child_indices[idx];
                    if (child_indices_arr.length > 0) {
                        for (const child_idx of child_indices_arr) {
                            // Add the holes
                            split_polygon.push(spatial_payload[child_idx]);
                        }
                    }
                }
                split_polygons.push(split_polygon);
            }
        }
        return split_polygons;
    }

    // Remove any child indices and spatial_payload_holes that are not longer in the spatial_payload
    verify_complex_polygon_child_indices(active_id) {
        // Get annotation
        const annotation = this.get_current_subtask()["annotations"]["access"][active_id];
        // Get the spatial payload
        const spatial_payload = annotation["spatial_payload"];
        // Verify length
        while (annotation["spatial_payload_child_indices"].length > spatial_payload.length) {
            annotation["spatial_payload_child_indices"].pop();
        }
        for (let child_indices of annotation["spatial_payload_child_indices"]) {
            for (let i of child_indices) {
                if (i >= spatial_payload.length) {
                    child_indices.splice(child_indices.indexOf(i), 1);
                }
            }
        }
        // Verify length of spatial_payload_holes
        while (annotation["spatial_payload_holes"].length > spatial_payload.length) {
            annotation["spatial_payload_holes"].pop();
        }
    }

    // Start annotating or erasing with the brush
    begin_brush(mouse_event) {
        const current_subtask = this.get_current_subtask();
        // First, we check if there is an annotation touching the brush
        let brush_cand_active_id = null;
        const global_x = this.get_global_mouse_x(mouse_event);
        const global_y = this.get_global_mouse_y(mouse_event);
        let brush_polygon = this.get_brush_circle_spatial_payload(global_x, global_y);

        // Loop through all annotations in the ordering until we find a polygon that intersects with the brush
        if (brush_polygon !== null) {
            for (let i = current_subtask["annotations"]["ordering"].length - 1; i >= 0; i--) {
                let active_id = current_subtask["annotations"]["ordering"][i];
                let annotation = current_subtask["annotations"]["access"][active_id];
                // Only undeprecated polygons
                if (!annotation["deprecated"] && annotation["spatial_type"] === "polygon") {
                    // Split into fills + their associated holes
                    let split_polygons = this.split_complex_polygon(active_id);
                    // Check if the brush intersects with or is within any layer
                    for (let split_polygon of split_polygons) {
                        if (
                            geometric_utils.GeometricUtils.complex_polygons_intersect(split_polygon, brush_polygon) ||
                            geometric_utils.GeometricUtils.complex_polygon_is_within_complex_polygon(brush_polygon, split_polygon)
                        ) {
                            brush_cand_active_id = active_id;
                            break;
                        }
                    }
                }
                if (brush_cand_active_id !== null) {
                    break;
                }
            }
        }

        if (brush_cand_active_id !== null) {
            // Set annotation as in progress
            current_subtask["state"]["active_id"] = brush_cand_active_id;
            current_subtask["state"]["is_in_progress"] = true;
            // Update the id_payload
            current_subtask["state"]["id_payload"] = JSON.parse(JSON.stringify(current_subtask["annotations"]["access"][brush_cand_active_id]["classification_payloads"]));
            this.update_id_toolbox_display();
            // Recolor the brush
            this.recolor_brush_circle();
            // Record for potential undo/redo
            (0,actions/* record_action */.h3)(this, {
                act_type: "begin_brush",
                annotation_id: brush_cand_active_id,
                frame: this.state["current_frame"],
                undo_payload: {
                    polygon_spatial_data: build_annotation.ULabelAnnotation.get_polygon_spatial_data(current_subtask["annotations"]["access"][brush_cand_active_id]),
                },
                redo_payload: {},
            });
            this.continue_brush(mouse_event);
        } else if (
            !current_subtask["state"]["is_in_erase_mode"] &&
            brush_polygon !== null
        ) {
            // Start a new annotation if not in erase mode
            this.begin_annotation(mouse_event);
        } else {
            // Move the brush
            this.move_brush_circle(global_x, global_y);
        }

        if (brush_polygon === null && !current_subtask["state"]["is_in_erase_mode"]) {
            // Indicate that the brush is fully outside the image
            this.shake_screen();
        }
    }

    // Reset the annotation
    begin_brush__undo(annotation_id, undo_payload) {
        if (annotation_id !== null) {
            // Reset the annotation
            this.replace_polygon_spatial_data(annotation_id, undo_payload.polygon_spatial_data);
        }
    }

    continue_brush(mouse_event) {
        // Get global mouse position
        const gmx = this.get_global_mouse_x(mouse_event);
        const gmy = this.get_global_mouse_y(mouse_event);

        // Move the brush
        this.move_brush_circle(gmx, gmy);

        // Check if current mouse is far enough from last brush point
        let continue_brush = true;
        const min_brush_distance = this.config["brush_size"] / 8;
        if (this.state["last_brush_stroke"] !== null) {
            let [last_gmx, last_gmy] = this.state["last_brush_stroke"];
            if (Math.abs(gmx - last_gmx) < min_brush_distance && Math.abs(gmy - last_gmy) < min_brush_distance) {
                continue_brush = false;
            }
        }

        if (continue_brush) {
            // Save the last brush stroke
            this.state["last_brush_stroke"] = [gmx, gmy];
            const current_subtask = this.get_current_subtask();
            const active_id = current_subtask["state"]["active_id"];
            let brush_polygon = this.get_brush_circle_spatial_payload(gmx, gmy);

            if (active_id !== null && brush_polygon !== null) {
                // Get the current annotation
                const annotation = current_subtask["annotations"]["access"][active_id];
                // Split the annotation into separate polygons for each fill
                let split_polygons = this.split_complex_polygon(active_id);
                let new_spatial_payload = [];

                if (current_subtask["state"]["is_in_erase_mode"]) {
                    let merged_polygon = null;
                    for (let split_polygon of split_polygons) {
                        // Erase the brush from the annotation
                        merged_polygon = geometric_utils.GeometricUtils.subtract_polygons(split_polygon, brush_polygon);
                        if (merged_polygon !== null) {
                            // Extend the new spatial payload
                            new_spatial_payload = new_spatial_payload.concat(merged_polygon);
                        }
                    }
                } else {
                    // Merge the brush with all intersecting layers
                    let merged_polygon = brush_polygon;
                    let n_merges = 0;
                    for (let split_polygon of split_polygons) {
                        // Check that the fill (first layer) of the split polygon intersects with our merged polygon
                        // or if the split polygon as a whole intersects with our merged polygon
                        // or if any hole in the split polygon is within our merged polygon (handles really small holes)
                        if (
                            geometric_utils.GeometricUtils.complex_polygons_intersect([split_polygon[0]], merged_polygon) ||
                            geometric_utils.GeometricUtils.complex_polygons_intersect(split_polygon, merged_polygon) ||
                            geometric_utils.GeometricUtils.any_complex_polygon_hole_is_within_complex_polygon(split_polygon, merged_polygon)
                        ) {
                            n_merges += 1;
                            // Merge the split polygon with the current merged polygon
                            merged_polygon = geometric_utils.GeometricUtils.merge_polygons(split_polygon, merged_polygon);
                        } else {
                            // If the split doesn't intersect our active merge, just add it back to the new spatial payload
                            new_spatial_payload = new_spatial_payload.concat(split_polygon);
                        }
                    }
                    // Add the merged polygon to the new spatial payload
                    if (n_merges > 0) {
                        new_spatial_payload = new_spatial_payload.concat(merged_polygon);
                    } else {
                        return;
                    }
                }

                if (new_spatial_payload.length === 0) {
                    // Delete the annotation before overwriting payload
                    this.delete_annotation(active_id);
                }
                annotation["spatial_payload"] = new_spatial_payload;
                this.verify_all_polygon_complex_layers(active_id);

                // Record the action without adding to the action stream
                (0,actions/* record_action */.h3)(this, {
                    act_type: "continue_brush",
                    annotation_id: active_id,
                    frame: this.state["current_frame"],
                    undo_payload: {},
                    redo_payload: {},
                }, false, false);
            }
        }
    }

    /**
     * Undo an annotation modification, for example a brush stroke
     *
     * @param {string} annotation_id The id of the annotation to undo
     * @param {object} undo_payload {polygon_spatial_data: object}
     */
    finish_modify_annotation__undo(annotation_id, undo_payload) {
        // Replace the polygon spatial data
        this.replace_polygon_spatial_data(annotation_id, undo_payload.polygon_spatial_data);
    }

    /**
     * Redo an annotation modification, for example a brush stroke
     *
     * @param {string} annotation_id The id of the annotation to redo
     * @param {object} redo_payload {polygon_spatial_data: object}
     */
    finish_modify_annotation__redo(annotation_id, redo_payload) {
        // Store data for undo
        const polygon_spatial_data = build_annotation.ULabelAnnotation.get_polygon_spatial_data(this.get_current_subtask()["annotations"]["access"][annotation_id]);
        // Replace the polygon spatial data
        this.replace_polygon_spatial_data(annotation_id, redo_payload.polygon_spatial_data);
        // Record the action
        (0,actions/* record_action */.h3)(this, {
            act_type: "finish_modify_annotation",
            annotation_id: annotation_id,
            frame: this.state["current_frame"],
            undo_payload: {
                polygon_spatial_data: polygon_spatial_data,
            },
            redo_payload: {
                polygon_spatial_data: redo_payload.polygon_spatial_data,
            },
        }, true);
    }

    begin_edit(mouse_event) {
        // Create constants for convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];

        // Set global params
        const active_id = current_subtask["state"]["edit_candidate"]["annid"];
        current_subtask["state"]["active_id"] = active_id;
        current_subtask["state"]["is_in_edit"] = true;

        const annotation_mode = annotations[active_id]["spatial_type"];
        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(annotation_mode)) {
            frame = null;
        }

        (0,actions/* record_action */.h3)(this, {
            act_type: "begin_edit",
            annotation_id: active_id,
            frame: frame,
            undo_payload: {
                annotation: annotations[active_id],
            },
            redo_payload: {
                annotation: annotations[active_id],
                finished: false,
            },
        });

        this.continue_edit(mouse_event, true);
    }

    continue_edit(mouse_event, is_begin_edit = false) {
        // Convenience and readability
        const current_subtask = this.get_current_subtask();
        const active_id = current_subtask["state"]["active_id"];
        const access_str = current_subtask["state"]["edit_candidate"]["access"];
        if (active_id !== null) {
            const mouse_location = [
                this.get_global_mouse_x(mouse_event),
                this.get_global_mouse_y(mouse_event),
            ];
            const spatial_type = current_subtask["annotations"]["access"][active_id]["spatial_type"];
            let edit_success = true;
            // Clicks are handled elsewhere
            switch (spatial_type) {
                case "bbox":
                case "tbar":
                case "polygon":
                    this.set_with_access_string(active_id, access_str, mouse_location);
                    break;
                case "bbox3":
                    // TODO(new3d) Will not always want to set 3rd val -- editing is possible within an intermediate frame or frames
                    this.set_with_access_string(active_id, access_str, [mouse_location[0], mouse_location[1], this.state["current_frame"]]);
                    break;
                case "polyline":
                    this.set_with_access_string(active_id, access_str, mouse_location);
                    break;
                case "contour":
                case "point":
                    // TODO contour editing
                    (0,error_logging.log_message)(
                        `Annotation mode ${spatial_type} is not currently editable`,
                        error_logging.LogLevel.WARNING,
                        true,
                    );
                    edit_success = false;
                    break;
                default:
                    (0,error_logging.log_message)(
                        `Annotation mode ${spatial_type} is not understood`,
                        error_logging.LogLevel.WARNING,
                        true,
                    );
                    edit_success = false;
                    break;
            }

            if (edit_success) {
                // Record action without adding to the action stream
                (0,actions/* record_action */.h3)(this, {
                    act_type: "continue_edit",
                    annotation_id: active_id,
                    frame: this.state["current_frame"],
                    undo_payload: {},
                    redo_payload: {},
                }, false, false);

                // If this is the first edit, we may need to update the access string
                // if we've added a new point to the spatial payload
                // TODO: less hacky way to do this
                if (is_begin_edit) {
                    current_subtask["state"]["is_in_edit"] = false;
                    this.suggest_edits();
                    current_subtask["state"]["is_in_edit"] = true;
                }

                // Update the edit candidate point
                current_subtask["state"]["edit_candidate"]["point"] = mouse_location;
                this.show_edit_suggestion(current_subtask["state"]["edit_candidate"], true);
            }
        }
    }

    finish_edit() {
        const current_subtask = this.get_current_subtask();
        let actid = current_subtask["state"]["active_id"];
        const access_str = current_subtask["state"]["edit_candidate"]["access"];
        let layer_idx;
        switch (current_subtask["annotations"]["access"][actid]["spatial_type"]) {
            case "polygon":
                // Reset spatial_payload_child_indices
                current_subtask["annotations"]["access"][actid]["spatial_payload_child_indices"] = [];
                // Get the idx of the edited layer and try and merge it
                layer_idx = parseInt(access_str[0], 10);
                this.merge_polygon_complex_layer(actid, layer_idx, false, false, false);
                // Check if any other layers need to be merged
                for (let i = 0; i < current_subtask["annotations"]["access"][actid]["spatial_payload"].length; i++) {
                    if (i !== layer_idx) {
                        this.merge_polygon_complex_layer(actid, i, false, false, false);
                    }
                }
                (0,actions/* record_finish_edit */.DS)(this, actid);
                break;
            case "polyline":
            case "bbox":
            case "bbox3":
            case "tbar":
                (0,actions/* record_finish_edit */.DS)(this, actid);
                break;
            case "contour":
            case "point":
                break;
            default:
                break;
        }

        // Set mode to no active annotation
        this.get_current_subtask()["state"]["active_id"] = null;
        this.get_current_subtask()["state"]["is_in_edit"] = false;
    }

    // The action name used to trigger this is "begin_edit"
    // which is updated by the "record_finish_edit" in "finish_edit"
    begin_edit__undo(annotation_id, undo_payload) {
        this.replace_annotation(annotation_id, undo_payload.annotation);
    }

    // The action name used to trigger this is "begin_edit"
    // which is updated by the "record_finish_edit" in "finish_edit"
    begin_edit__redo(annotation_id, redo_payload) {
        // Save the current annotation for undo
        const current_annotation = JSON.parse(JSON.stringify(this.get_current_subtask()["annotations"]["access"][annotation_id]));
        // Replace the annotation with the redo payload
        this.replace_annotation(annotation_id, redo_payload.annotation);

        const spatial_type = redo_payload.annotation["spatial_type"];
        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(spatial_type)) {
            frame = null;
        }
        (0,actions/* record_action */.h3)(this, {
            act_type: "begin_edit",
            annotation_id: annotation_id,
            frame: frame,
            undo_payload: {
                annotation: current_annotation,
            },
            redo_payload: {
                annotation: redo_payload.annotation,
                finished: true,
            },
        }, true);
    }

    // Cancel the annotation currently in progress
    cancel_annotation(annotation_id = null) {
        let redoing = true;
        if (annotation_id === null) {
            // Get the active id
            annotation_id = this.get_current_subtask()["state"]["active_id"];
            redoing = false;
        }

        let is_complex_layer = false;
        if (annotation_id !== null) {
            const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
            const spatial_type = annotation["spatial_type"];
            // When drawing a complex layer, we will only delete the last layer
            if (
                spatial_type === "polygon" && annotation["spatial_payload"].length > 1
            ) {
                is_complex_layer = true;
                // Reuse the logic for undoing the start of a complex polygon
                this.start_complex_polygon__undo(annotation_id);
            } else {
                // Delete the annotation, without recording the delete action
                // This will also clear is_in_progress and other states
                this.delete_annotation(annotation_id, false, false);
            }

            // Record the cancel action
            (0,actions/* record_action */.h3)(this, {
                act_type: "cancel_annotation",
                annotation_id: annotation_id,
                frame: this.state["current_frame"],
                undo_payload: {
                    suggest_edits: false,
                    drag_state: this.drag_state,
                    is_complex_layer: is_complex_layer,
                    annotation: annotation,
                },
                redo_payload: {},
            }, redoing);
        }
    }

    cancel_annotation__undo(annotation_id, undo_payload) {
        // Mark that the annotation is in progress again
        const current_subtask = this.get_current_subtask();
        current_subtask["state"]["active_id"] = annotation_id;
        current_subtask["state"]["is_in_progress"] = true;

        if (undo_payload.is_complex_layer) {
            // Restore the removed layer
            this.replace_annotation(annotation_id, undo_payload.annotation);
        } else {
            // Undeprecate the annotation
            this.delete_annotation__undo(annotation_id);
        }

        const annotation = current_subtask["annotations"]["access"][annotation_id];
        // If a polygon/delete polygon, show the ender
        if (annotation["spatial_type"] === "polygon") {
            // Get the first point of the last layer for a polygon
            let first_pt = annotation["spatial_payload"].at(-1)[0];
            this.create_polygon_ender(first_pt[0], first_pt[1], annotation_id);
        } else if (annotation["spatial_type"] === "delete_polygon") {
            // Get the first point of a delete polygon
            let first_pt = annotation["spatial_payload"][0];
            this.create_polygon_ender(first_pt[0], first_pt[1], annotation_id);
        } else if (annotation["spatial_type"] === "bbox" || annotation["spatial_type"] === "delete_bbox" || annotation["spatial_type"] === "tbar") {
            // Reset the drag mode to cause mouse moves to move the annotation
            this.drag_state = undo_payload.drag_state;
            // Move to the current mouse location
            this.continue_annotation(this.state["last_move"]);
        }
    }

    finish_annotation(mouse_event = null) {
        // Convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];

        // Initialize required variables
        let active_id = current_subtask["state"]["active_id"];
        let annotation = annotations[active_id];
        let spatial_payload = annotation["spatial_payload"];
        let active_spatial_payload = spatial_payload;
        let should_record_action = false;
        let act_type = "finish_annotation";

        // Record last point and redraw if necessary
        // TODO(3d)
        let n_kpts, start_pt, active_idx, uniquePoints;
        const spatial_type = annotation["spatial_type"];
        switch (spatial_type) {
            case "polygon":
                // For polygons, the active spatial payload is the last array of points in the spatial payload
                active_idx = spatial_payload.length - 1;
                active_spatial_payload = spatial_payload[active_idx];
                n_kpts = active_spatial_payload.length;
                if (n_kpts < 4) {
                    (0,error_logging.log_message)("Canceled polygon with insufficient points:", n_kpts, error_logging.LogLevel.WARNING, true);
                    return;
                }
                start_pt = [
                    active_spatial_payload[0][0],
                    active_spatial_payload[0][1],
                ];
                active_spatial_payload[n_kpts - 1] = start_pt;

                // Record the action
                should_record_action = true;

                // Simplify the polygon
                this.simplify_polygon_complex_layer(active_id, active_idx);
                // Render merged layers. Also handles rebuilding containing box and redrawing
                this.merge_polygon_complex_layer(active_id);
                break;
            case "delete_polygon":
                n_kpts = active_spatial_payload.length;
                if (n_kpts < 4) {
                    (0,error_logging.log_message)("Canceled delete with insufficient points:", n_kpts, error_logging.LogLevel.WARNING, true);
                    return;
                }
                start_pt = [
                    active_spatial_payload[0][0],
                    active_spatial_payload[0][1],
                ];
                active_spatial_payload[n_kpts - 1] = start_pt;
                this.delete_annotations_in_polygon(active_id);
                break;
            case "polyline":
                // Prevent zero-length polylines (must have at least two unique points)
                uniquePoints = new Set(spatial_payload.map((pt) => pt.join(",")));
                if (uniquePoints.size < 2) {
                    (0,error_logging.log_message)("Canceled polyline with insufficient unique points:", spatial_payload, error_logging.LogLevel.WARNING, true);
                    return;
                }

                // Remove last point
                n_kpts = spatial_payload.length;
                if (n_kpts > 2) {
                    spatial_payload.pop();
                }

                should_record_action = true;
                break;
            case "delete_bbox":
                (0,actions/* record_finish */.k8)(this, active_id);
                this.delete_annotations_in_bbox(active_id);
                break;
            case "bbox":
            case "bbox3":
            case "contour":
            case "tbar":
            case "point":
                (0,actions/* record_finish */.k8)(this, active_id);
                break;
            default:
                break;
        }

        let undo_payload = {};
        let redo_payload = {};
        if (should_record_action) {
            // Once we've finished a polygon or polyline, undoing will
            // remove the entire completed annotation rather that undoing each point.
            // Loop through the action stream until and remove every recorded action
            // until we find the start_complex_polygon, begin_brush, or begin_annotation action
            const action_stream = current_subtask["actions"]["stream"];
            while (action_stream.length > 0) {
                // Pop the action to remove it from the stream
                let action = action_stream.pop();
                if (action.act_type === "begin_annotation") {
                    // Now we're done
                    break;
                } else if (action.act_type === "begin_brush" || action.act_type === "start_complex_polygon") {
                    // Save the previous state of the annotation for undoing
                    act_type = "finish_modify_annotation";
                    undo_payload = JSON.parse(action.undo_payload);
                    redo_payload.polygon_spatial_data = build_annotation.ULabelAnnotation.get_polygon_spatial_data(annotations[active_id]);
                    break;
                }
            }
        }

        // Record the finish_annotation or finish_modify_annotation action
        // except for delete modes, which record their action separately
        if (!build_annotation.DELETE_MODES.includes(spatial_type)) {
            (0,actions/* record_action */.h3)(this, {
                act_type: act_type,
                annotation_id: active_id,
                frame: this.state["current_frame"],
                undo_payload: undo_payload,
                redo_payload: redo_payload,
            }, false, should_record_action);
        }

        // TODO build a dialog here when necessary -- will also need to integrate with undo
        // TODO(3d)
        if (current_subtask["single_class_mode"]) {
            annotation["classification_payloads"] = [
                {
                    class_id: current_subtask["class_defs"][0]["id"],
                    confidence: 1.0,
                },
            ];
        }

        // Reset last brush stroke
        this.state["last_brush_stroke"] = null;

        // Set mode to no active annotation, unless shift key is held for a polygon
        // When shift key is held, we start a new complex layer
        if (
            annotation["spatial_type"] === "polygon" &&
            !current_subtask["state"]["is_in_brush_mode"] &&
            mouse_event != null &&
            mouse_event.shiftKey
        ) {
            // Start a new complex layer
            this.start_complex_polygon();
        } else {
            current_subtask["state"]["active_id"] = null;
            current_subtask["state"]["is_in_progress"] = false;
        }
    }

    finish_annotation__undo(annotation_id) {
        // Deprecate the annotation
        (0,annotation_operators.mark_deprecated)(this.get_current_subtask()["annotations"]["access"][annotation_id], true);
    }

    finish_annotation__redo(annotation_id) {
        // Undeprecate the annotation
        (0,annotation_operators.mark_deprecated)(this.get_current_subtask()["annotations"]["access"][annotation_id], false);
        // Record the action
        (0,actions/* record_action */.h3)(this, {
            act_type: "finish_annotation",
            annotation_id: annotation_id,
            frame: this.state["current_frame"],
            undo_payload: {},
            redo_payload: {},
        }, true);
    }

    begin_move(mouse_event) {
        // Convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];
        const active_id = current_subtask["state"]["move_candidate"]["annid"];

        // Set global params
        current_subtask["state"]["active_id"] = active_id;
        current_subtask["state"]["is_in_move"] = true;
        current_subtask["state"]["move_candidate"]["offset"] = {
            id: active_id,
            diffX: 0,
            diffY: 0,
            diffZ: 0,
        };

        const annotation_mode = annotations[active_id]["spatial_type"];
        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(annotation_mode)) {
            frame = null;
        }

        (0,actions/* record_action */.h3)(this, {
            act_type: "begin_move",
            annotation_id: active_id,
            frame: frame,
            undo_payload: {
                diffX: 0,
                diffY: 0,
                diffZ: 0,
            },
            redo_payload: {
                diffX: 0,
                diffY: 0,
                diffZ: 0,
                finished: false,
                move_not_allowed: false,
            },
        });

        this.continue_move(mouse_event);
    }

    continue_move(mouse_event) {
        // Convenience
        const current_subtask = this.get_current_subtask();
        const active_id = current_subtask["state"]["active_id"];

        if (active_id !== null) {
            let offset = {
                id: current_subtask["state"]["move_candidate"]["annid"],
                diffX: (mouse_event.clientX - this.drag_state["move"]["mouse_start"][0]) / this.state["zoom_val"],
                diffY: (mouse_event.clientY - this.drag_state["move"]["mouse_start"][1]) / this.state["zoom_val"],
                diffZ: this.state["current_frame"] - this.drag_state["move"]["mouse_start"][2],
            };

            // Update move candidate
            // this offset is used to render the in-progress move
            current_subtask["state"]["move_candidate"]["offset"] = offset;
        }

        // Record the action without adding to the action stream
        (0,actions/* record_action */.h3)(this, {
            act_type: "continue_move",
            annotation_id: active_id,
            frame: this.state["current_frame"],
            undo_payload: {},
            redo_payload: {},
        }, false, false);
    }

    finish_move(mouse_event) {
        // Actually edit spatial payload this time
        const diffX = (mouse_event.clientX - this.drag_state["move"]["mouse_start"][0]) / this.state["zoom_val"];
        const diffY = (mouse_event.clientY - this.drag_state["move"]["mouse_start"][1]) / this.state["zoom_val"];
        const diffZ = this.state["current_frame"] - this.drag_state["move"]["mouse_start"][2];

        const current_subtask = this.get_current_subtask();
        const active_id = current_subtask["state"]["active_id"];
        const annotation = current_subtask["annotations"]["access"][active_id];
        const spatial_type = annotation["spatial_type"];
        let spatial_payload = annotation["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        // if a polygon, n_iters is the length the spatial payload
        // else n_iters is 1
        let n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;
        let point_outside_image = false;
        let x_outside_image = false;
        let y_outside_image = false;
        for (let i = 0; i < n_iters; i++) {
            // for polygons, we need to move the points in each part of the spatial payload
            if (spatial_type === "polygon") {
                active_spatial_payload = spatial_payload[i];
            }

            // If first and last point reference the same point array in memory, we don't want to add the diff twice
            let n_points = active_spatial_payload.length;
            if (spatial_type === "polygon" && active_spatial_payload[0] === active_spatial_payload[n_points - 1]) {
                n_points -= 1;
            }

            // Move the points
            for (let spi = 0; spi < n_points; spi++) {
                active_spatial_payload[spi][0] += diffX;
                active_spatial_payload[spi][1] += diffY;

                // Check if any point moved outside the image bounds
                if (!point_outside_image) {
                    x_outside_image = active_spatial_payload[spi][0] < 0 || active_spatial_payload[spi][0] > this.config["image_width"];
                    y_outside_image = active_spatial_payload[spi][1] < 0 || active_spatial_payload[spi][1] > this.config["image_height"];
                    point_outside_image = x_outside_image || y_outside_image;
                }
            }

            if (build_annotation.MODES_3D.includes(spatial_type)) {
                for (let spi = 0; spi < active_spatial_payload.length; spi++) {
                    active_spatial_payload[spi][2] += diffZ;
                }
            }
        }

        current_subtask["state"]["active_id"] = null;
        current_subtask["state"]["is_in_move"] = false;

        const move_not_allowed = !this.config.allow_annotations_outside_image && point_outside_image;
        (0,actions/* record_finish_move */.WH)(this, diffX, diffY, diffZ, move_not_allowed);

        // If any point is outside the image bounds, bounce back the move
        if (move_not_allowed) {
            // Revert the move
            (0,actions/* undo */.tN)(this, true);
            // Shake the screen to indicate the move was not allowed
            this.shake_screen();
        }
    }

    // Undo the move of an annotation
    // The action name used to trigger this is "begin_move"
    // which is updated by the "record_finish_move" in "finish_move"
    begin_move__undo(annotation_id, undo_payload) {
        // Convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];

        const diffX = undo_payload.diffX;
        const diffY = undo_payload.diffY;
        const diffZ = undo_payload.diffZ;

        const spatial_type = annotations[annotation_id]["spatial_type"];
        const spatial_payload = annotations[annotation_id]["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        // if a polygon, n_iters is the length the spatial payload
        // else n_iters is 1
        let n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;

        for (let i = 0; i < n_iters; i++) {
            // for polygons, we need to move the points in each part of the spatial payload
            if (spatial_type === "polygon") {
                active_spatial_payload = spatial_payload[i];
            }

            for (var spi = 0; spi < active_spatial_payload.length; spi++) {
                active_spatial_payload[spi][0] += diffX;
                active_spatial_payload[spi][1] += diffY;
                if (active_spatial_payload[spi].length > 2) {
                    active_spatial_payload[spi][2] += diffZ;
                }
            }
        }
    }

    // Redo the move of an annotation
    // The action name used to trigger this is "begin_move"
    // which is updated by the "record_finish_move" in "finish_move"
    begin_move__redo(annotation_id, redo_payload) {
        // If the move wasn't allowed in the first place, we don't want to redo it
        if (redo_payload.move_not_allowed) {
            return;
        }

        // Convenience
        const current_subtask = this.get_current_subtask();
        const annotations = current_subtask["annotations"]["access"];

        const diffX = redo_payload.diffX;
        const diffY = redo_payload.diffY;
        const diffZ = redo_payload.diffZ;

        const spatial_type = annotations[annotation_id]["spatial_type"];
        const spatial_payload = annotations[annotation_id]["spatial_payload"];
        let active_spatial_payload = spatial_payload;

        // if a polygon, n_iters is the length the spatial payload
        // else n_iters is 1
        let n_iters = spatial_type === "polygon" ? spatial_payload.length : 1;

        for (let i = 0; i < n_iters; i++) {
            // for polygons, we need to move the points in each part of the spatial payload
            if (spatial_type === "polygon") {
                active_spatial_payload = spatial_payload[i];
            }

            for (var spi = 0; spi < active_spatial_payload.length; spi++) {
                active_spatial_payload[spi][0] += diffX;
                active_spatial_payload[spi][1] += diffY;
                if (active_spatial_payload[spi].length > 2) {
                    active_spatial_payload[spi][2] += diffZ;
                }
            }
        }

        let frame = this.state["current_frame"];
        if (build_annotation.MODES_3D.includes(spatial_type)) {
            frame = null;
        }

        (0,actions/* record_action */.h3)(this, {
            act_type: "begin_move",
            annotation_id: annotation_id,
            frame: frame,
            undo_payload: {
                diffX: -diffX,
                diffY: -diffY,
                diffZ: -diffZ,
            },
            redo_payload: {
                diffX: diffX,
                diffY: diffY,
                diffZ: diffZ,
                finished: true,
            },
        }, true);
        this.update_frame(diffZ);
    }

    /**
     * Get initial edit candidates with bounding box collisions
     * @param {*} gblx Global x coordinate
     * @param {*} gbly Global y coordinate
     * @param {*} dst_thresh Threshold to adjust boxes by
     * @returns
     */
    get_edit_candidates(gblx, gbly, dst_thresh) {
        dst_thresh /= this.get_empirical_scale();
        let ret = {
            candidate_ids: [],
            best: null,
        };
        let minsize = Infinity;
        let found_containing_annotation = false;
        // TODO(3d)
        for (let edi = 0; edi < this.get_current_subtask()["annotations"]["ordering"].length; edi++) {
            const annotation_id = this.get_current_subtask()["annotations"]["ordering"][edi];
            let annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
            if (annotation["deprecated"]) continue;
            let cbox = annotation["containing_box"];
            let frame = annotation["frame"];
            const spatial_type = annotation["spatial_type"];
            if (cbox) {
                cbox["tlz"] = this.state["current_frame"];
                cbox["brz"] = this.state["current_frame"];
                if (frame != null) {
                    cbox["tlz"] = frame;
                    cbox["brz"] = frame;
                } else {
                    if (spatial_type === "bbox3") {
                        let pts = annotation["spatial_payload"];
                        cbox["tlz"] = Math.min(pts[0][2], pts[1][2]);
                        cbox["brz"] = Math.max(pts[0][2], pts[1][2]);
                    }
                }
            }
            // TODO(new3d) bbox3 will have different rules here
            if (
                cbox &&
                (gblx >= cbox["tlx"] - dst_thresh) &&
                (gblx <= cbox["brx"] + dst_thresh) &&
                (gbly >= cbox["tly"] - dst_thresh) &&
                (gbly <= cbox["bry"] + dst_thresh) &&
                (this.state["current_frame"] >= cbox["tlz"]) &&
                (this.state["current_frame"] <= cbox["brz"])
            ) {
                let is_a_containing_annotation = false;
                let boxsize = (cbox["brx"] - cbox["tlx"]) * (cbox["bry"] - cbox["tly"]);
                switch (spatial_type) {
                    case "polygon":
                        // Check if the mouse is within the polygon
                        if (geometric_utils.GeometricUtils.point_is_within_polygon_annotation([gblx, gbly], annotation)) {
                            is_a_containing_annotation = true;
                        }
                        break;
                    case "bbox":
                    case "point":
                        if (
                            gblx >= cbox["tlx"] &&
                            gblx <= cbox["brx"] &&
                            gbly >= cbox["tly"] &&
                            gbly <= cbox["bry"]
                        ) {
                            is_a_containing_annotation = true;
                        }
                        break;
                    default:

                        break;
                }

                // First time we find a containing annotation, clear previous candidates
                if (is_a_containing_annotation && !found_containing_annotation) {
                    found_containing_annotation = true;
                    minsize = Infinity;
                    ret["candidate_ids"] = [];
                }

                if (found_containing_annotation) {
                    if (is_a_containing_annotation) {
                        // Prefer containing annotations
                        if (boxsize < minsize) {
                            minsize = boxsize;
                            ret["candidate_ids"] = [annotation_id];
                            ret["best"] = {
                                annid: annotation_id,
                            };
                        }
                    }
                } else if (boxsize < minsize) {
                    ret["candidate_ids"].push(annotation_id);
                    minsize = boxsize;
                    ret["best"] = {
                        annid: annotation_id,
                    };
                }
            }
        }
        return ret;
    }

    /**
     * Suggest edit candidates based on mouse position
     * Workflow is as follows:
     * Find annotations where cursor is within bounding box
     * Find closest keypoints (ends of polygons/polylines etc) within a range defined by the edit handle
     * If no endpoints, search along segments with infinite range
     */
    suggest_edits(mouse_event = null, nonspatial_id = null, force_refresh = false) {
        const current_subtask = this.get_current_subtask();
        // Don't show any dialogs when currently drawing/editing an annotation,
        // And hide just edit dialogs when moving
        if (
            current_subtask["state"]["is_in_progress"] ||
            current_subtask["state"]["starting_complex_polygon"] ||
            current_subtask["state"]["is_in_brush_mode"] ||
            current_subtask["state"]["is_in_edit"]
        ) {
            return this.hide_edits();
        } else if (
            current_subtask["state"]["is_in_move"]
        ) {
            return this.hide_edit_suggestion_during_move();
        }

        let best_candidate = null;
        if (nonspatial_id !== null) {
            best_candidate = {
                annid: nonspatial_id,
            };
        }

        if (best_candidate === null) {
            // Get mouse event from last move if not provided
            if (mouse_event === null) {
                if (this.state["last_move"] !== null) {
                    mouse_event = this.state["last_move"];
                } else {
                    return;
                }
            }

            const dst_thresh = this.config["edit_handle_size"] / 2;
            const global_x = this.get_global_mouse_x(mouse_event);
            const global_y = this.get_global_mouse_y(mouse_event);

            // Ignore when we're already hovering an edit
            if (
                !force_refresh &&
                jquery_default()(mouse_event.target).hasClass("gedit-target")
            ) {
                return;
            }

            const edit_candidates = this.get_edit_candidates(
                global_x,
                global_y,
                dst_thresh,
            );

            if (edit_candidates["best"] === null) {
                return this.hide_and_clear_action_candidates();
            }

            // Show global edit dialogs for "best" candidate
            best_candidate = edit_candidates["best"];

            // Look for an existing point that's close enough to suggest editing it
            const nearest_active_keypoint = this.get_nearest_active_keypoint(global_x, global_y, dst_thresh, edit_candidates["candidate_ids"]);
            if (nearest_active_keypoint != null && nearest_active_keypoint.point != null) {
                this.show_edit_suggestion(nearest_active_keypoint, true);
                best_candidate = nearest_active_keypoint;
            } else {
                // If none are found, look for a point along a segment that's close enough
                // else, we should hide the suggestion
                const nearest_segment_point = this.get_nearest_segment_point(global_x, global_y, Infinity, edit_candidates["candidate_ids"]);
                if (nearest_segment_point != null && nearest_segment_point.point != null) {
                    this.show_edit_suggestion(nearest_segment_point, false);
                    best_candidate = nearest_segment_point;
                } else {
                    this.hide_edit_suggestion();
                }
            }

            // Only spatial annotations can be moved
            current_subtask["state"]["move_candidate"] = best_candidate;
        }

        // Both spatial/non-spatial can have the global suggestions
        this.show_global_edit_suggestion(best_candidate.annid, null, nonspatial_id);
        current_subtask["state"]["edit_candidate"] = best_candidate;

        // Must be called after active_annotation is updated
        this.update_confidence_dialog();
    }

    hide_edits() {
        this.hide_global_edit_suggestion();
        this.hide_edit_suggestion();
    }

    hide_and_clear_action_candidates() {
        this.hide_edits();
        this.get_current_subtask()["state"]["edit_candidate"] = null;
        this.get_current_subtask()["state"]["move_candidate"] = null;
    }

    hide_edit_suggestion_during_move() {
        // Hide edit suggestions
        this.hide_edit_suggestion();
        // Render annotation dialogs with offset
        this.show_global_edit_suggestion(
            this.get_current_subtask()["state"]["move_candidate"]["annid"],
            this.get_current_subtask()["state"]["move_candidate"]["offset"],
        );
    }

    // ================= Mouse event interpreters =================

    // Get the mouse position on the screen
    get_global_mouse_x(mouse_event) {
        const scale = this.get_empirical_scale();
        const annbox = jquery_default()("#" + this.config["annbox_id"]);
        const raw = (mouse_event.pageX - annbox.offset().left + annbox.scrollLeft()) / scale;
        return raw;
    }

    get_global_mouse_y(mouse_event) {
        const scale = this.get_empirical_scale();
        const annbox = jquery_default()("#" + this.config["annbox_id"]);
        const raw = (mouse_event.pageY - annbox.offset().top + annbox.scrollTop()) / scale;
        return raw;
    }

    /**
     * Get the mouse position, clamped to the image bounds if `allow_annotations_outside_image` is false.
     *
     * @param {*} mouse_event The mouse event to get the position from
     * @returns {[number, number]} The (x, y) coordinates of the mouse, clamped to the image bounds if required
     */
    get_image_aware_mouse_x_y(mouse_event) {
        const x = this.get_global_mouse_x(mouse_event);
        const y = this.get_global_mouse_y(mouse_event);
        let ret = [x, y];

        // Fit inside image bounds
        if (
            !this.config.allow_annotations_outside_image &&
            !build_annotation.DELETE_MODES.includes(this.get_current_subtask()["state"]["annotation_mode"])
        ) {
            ret = geometric_utils.GeometricUtils.clamp_point_to_image(ret, this.config["image_width"], this.config["image_height"]);
        }

        return ret;
    }

    get_global_element_center_x(jqel) {
        const scale = this.get_empirical_scale();
        const annbox = jquery_default()("#" + this.config["annbox_id"]);
        const raw = (jqel.offset().left + jqel.width() / 2 - annbox.offset().left + annbox.scrollLeft()) / scale;
        // return Math.round(raw);
        return raw;
    }

    get_global_element_center_y(jqel) {
        const scale = this.get_empirical_scale();
        const annbox = jquery_default()("#" + this.config["annbox_id"]);
        const raw = (jqel.offset().top + jqel.height() / 2 - annbox.offset().top + annbox.scrollTop()) / scale;
        // return Math.round();
        return raw;
    }

    // ================= Dialog Interaction Handlers =================

    // ----------------- ID Dialog -----------------

    lookup_id_dialog_mouse_pos(mouse_event, front) {
        let idd = jquery_default()("#" + this.get_current_subtask()["state"]["idd_id"]);
        if (front) {
            idd = jquery_default()("#" + this.get_current_subtask()["state"]["idd_id_front"]);
        }

        // Get mouse position relative to center of div
        const idd_x = mouse_event.pageX - idd.offset().left - idd.width() / 2;
        const idd_y = mouse_event.pageY - idd.offset().top - idd.height() / 2;

        // Useful for interpreting mouse loc
        const inner_rad = this.config["inner_prop"] * this.config["outer_diameter"] / 2;
        const outer_rad = 0.5 * this.config["outer_diameter"];

        // Get radius
        const mouse_rad = Math.sqrt(Math.pow(idd_x, 2) + Math.pow(idd_y, 2));

        // If not inside, return
        if (mouse_rad > outer_rad) {
            return null;
        }

        // If in the core, return
        if (mouse_rad < inner_rad) {
            return null;
        }

        // Get array of classes by name in the dialog
        //    TODO handle nesting case
        //    TODO this is not efficient
        let class_ids = this.get_current_subtask()["class_ids"];

        // Get the index of that class currently hovering over
        const class_ind = (
            -1 * Math.floor(
                Math.atan2(idd_y, idd_x) / (2 * Math.PI) * class_ids.length,
            ) + class_ids.length
        ) % class_ids.length;

        // Get the distance proportion of the hover
        let dist_prop = (mouse_rad - inner_rad) / (outer_rad - inner_rad);

        return {
            class_ind: class_ind,
            dist_prop: dist_prop,
        };
    }

    set_id_dialog_payload_nopin(class_ind, dist_prop) {
        let class_ids = this.get_current_subtask()["class_ids"];
        // Recompute and render opaque pie slices
        for (var i = 0; i < class_ids.length; i++) {
            if (i === class_ind) {
                this.get_current_subtask()["state"]["id_payload"][i] = {
                    class_id: class_ids[i],
                    confidence: dist_prop,
                };
            } else {
                this.get_current_subtask()["state"]["id_payload"][i] = {
                    class_id: class_ids[i],
                    confidence: (1 - dist_prop) / (class_ids.length - 1),
                };
            }
        }
    }

    // Grab the active class id from the toolbox
    get_active_class_id() {
        const pfx = "div#tb-id-app--" + this.get_current_subtask_key();
        const idarr = jquery_default()(pfx + " a.tbid-opt.sel").attr("id").split("_");
        return parseInt(idarr[idarr.length - 1]);
    }

    get_active_class_id_idx() {
        const class_ids = this.get_current_subtask()["class_ids"];
        return class_ids.indexOf(this.get_active_class_id());
    }

    set_id_dialog_payload_to_init(annid, pyld = null) {
        // TODO(3D)
        if (pyld != null) {
            this.get_current_subtask()["state"]["id_payload"] = JSON.parse(JSON.stringify(pyld));
            this.update_id_toolbox_display();
        } else {
            if (annid != null) {
                let anpyld = this.get_current_subtask()["annotations"]["access"][annid]["classification_payloads"];
                if (anpyld != null) {
                    this.get_current_subtask()["state"]["id_payload"] = JSON.parse(JSON.stringify(anpyld));
                    return;
                }
            }
            // TODO currently assumes soft
            if (!this.config["allow_soft_id"]) {
                const dist_prop = 1.0;
                const class_ids = this.get_current_subtask()["class_ids"];
                const class_ind = this.get_active_class_id_idx();
                // Recompute and render opaque pie slices
                for (var i = 0; i < class_ids.length; i++) {
                    if (i === class_ind) {
                        this.get_current_subtask()["state"]["id_payload"][i] = {
                            class_id: class_ids[i],
                            confidence: dist_prop,
                        };
                    } else {
                        this.get_current_subtask()["state"]["id_payload"][i] = {
                            class_id: class_ids[i],
                            confidence: (1 - dist_prop) / (class_ids.length - 1),
                        };
                    }
                }
            } else {
                // Not currently supported
            }
        }
    }

    update_id_dialog_display(front = false) {
        const inner_rad = this.config["inner_prop"] * this.config["outer_diameter"] / 2;
        const outer_rad = 0.5 * this.config["outer_diameter"];
        let class_ids = this.get_current_subtask()["class_ids"];
        for (var i = 0; i < class_ids.length; i++) {
            // Skip
            let srt_prop = this.get_current_subtask()["state"]["id_payload"][i]["confidence"];

            let cum_prop = i / class_ids.length;
            let srk_prop = 1 / class_ids.length;
            let gap_prop = 1.0 - srk_prop;

            let rad_frnt = inner_rad + srt_prop * (outer_rad - inner_rad) / 2;

            let wdt_frnt = srt_prop * (outer_rad - inner_rad);

            let srk_frnt = 2 * Math.PI * rad_frnt * srk_prop;
            let gap_frnt = 2 * Math.PI * rad_frnt * gap_prop;
            let off_frnt = 2 * Math.PI * rad_frnt * cum_prop;

            // TODO this is kind of a mess. If it works as is, the commented region below should be deleted
            // var circ = document.getElementById("circ_" + class_ids[i]);
            // circ.setAttribute("r", rad_frnt);
            // circ.setAttribute("stroke-dasharray", `${srk_frnt} ${gap_frnt}`);
            // circ.setAttribute("stroke-dashoffset", off_frnt);
            // circ.setAttribute("stroke-width", wdt_frnt);
            let idd_id;
            if (!front) {
                idd_id = this.get_current_subtask()["state"]["idd_id"];
            } else {
                idd_id = this.get_current_subtask()["state"]["idd_id_front"];
            }
            var circ = jquery_default()(`#${idd_id}__circ_` + class_ids[i]);
            // circ.attr("r", rad_frnt);
            // circ.attr("stroke-dasharray", `${srk_frnt} ${gap_frnt}`)
            // circ.attr("stroke-dashoffset", off_frnt)
            // circ.attr("stroke-width", wdt_frnt)
            // circ = $(`#${idd_id}__circ_` + class_ids[i])
            circ.attr("r", rad_frnt);
            circ.attr("stroke-dasharray", `${srk_frnt} ${gap_frnt}`);
            circ.attr("stroke-dashoffset", off_frnt);
            circ.attr("stroke-width", wdt_frnt);
        }
        this.redraw_demo();
    }

    // Toolbox Annotation ID Update
    update_id_toolbox_display(new_class_idx = null) {
        if (this.config["allow_soft_id"]) {
            // Not supported yet
        } else {
            let class_ids = this.get_current_subtask()["class_ids"];
            if (new_class_idx === null) {
                let id_payload = this.get_current_subtask()["state"]["id_payload"];
                // Get the id payload with the highest confidence
                let max_conf = 0;
                let new_class_id = null;
                for (var i = 0; i < id_payload.length; i++) {
                    // Select the class with the highest confidence
                    if (id_payload[i]["confidence"] > max_conf) {
                        max_conf = id_payload[i]["confidence"];
                        new_class_id = id_payload[i]["class_id"];
                        if (max_conf === 1.0) {
                            break;
                        }
                    }
                }
                // Get the index of the new class
                new_class_idx = class_ids.indexOf(new_class_id);
            }

            // Select the desired class by clicking on the toolbox selector
            jquery_default()(`#toolbox_sel_${class_ids[new_class_idx]}`).trigger("click");
        }
    }

    handle_id_dialog_hover(mouse_event, pos_evt = null) {
        // Grab current subtask
        const current_subtask = this.subtasks[this.state.current_subtask];

        // Determine which dialog
        let front = current_subtask.state.idd_which === "front";
        if (pos_evt === null) {
            pos_evt = this.lookup_id_dialog_mouse_pos(mouse_event, front);
        }

        if (pos_evt !== null) {
            if (!this.config["allow_soft_id"]) {
                pos_evt.dist_prop = 1.0;
            }
            // TODO This assumes no pins
            this.set_id_dialog_payload_nopin(pos_evt.class_ind, pos_evt.dist_prop);
            this.update_id_dialog_display(front);
        }
    }

    assign_annotation_id(annotation_id = null, redo_payload = null) {
        const current_subtask = this.get_current_subtask();
        let new_payload, old_payload;
        let redoing = false;
        // TODO(3d)
        if (redo_payload === null) {
            if (annotation_id === null) {
                annotation_id = current_subtask["state"]["idd_associated_annotation"];
            }
            old_payload = current_subtask["annotations"]["access"][annotation_id]["classification_payloads"];
            new_payload = current_subtask["state"]["id_payload"];
        } else {
            redoing = true;
            old_payload = redo_payload.old_id_payload;
            new_payload = redo_payload.new_id_payload;
        }

        // Perform assignment
        current_subtask["annotations"]["access"][annotation_id]["classification_payloads"] = JSON.parse(JSON.stringify(new_payload));

        // Explicit changes are undoable
        // First assignments are treated as though they were done all along
        if (current_subtask["state"]["first_explicit_assignment"]) {
            let n = current_subtask["actions"]["stream"].length;
            for (var i = 0; i < n; i++) {
                if (current_subtask["actions"]["stream"][n - i - 1].act_type === "begin_annotation") {
                    // Parse the payload, edit, and then stringify
                    let redo_payload = JSON.parse(current_subtask["actions"]["stream"][n - i - 1].redo_payload);
                    redo_payload.init_payload = new_payload;
                    current_subtask["actions"]["stream"][n - i - 1].redo_payload = JSON.stringify(redo_payload);
                    break;
                }
            }
        } else {
            (0,actions/* record_action */.h3)(this, {
                act_type: "assign_annotation_id",
                annotation_id: annotation_id,
                undo_payload: {
                    old_id_payload: old_payload,
                },
                redo_payload: {
                    old_id_payload: old_payload,
                    new_id_payload: new_payload,
                },
            }, redoing);
        }
    }

    assign_annotation_id__undo(annotation_id, undo_payload) {
        // Restore the old payload
        this.get_current_subtask()["annotations"]["access"][annotation_id]["classification_payloads"] = undo_payload.old_id_payload;
    }

    handle_id_dialog_click(mouse_event, annotation_id = null, new_class_idx = null) {
        const current_subtask = this.get_current_subtask();

        // Handle explicitly setting the class
        if (new_class_idx !== null) {
            const pos_evt = { class_ind: new_class_idx, dist_prop: 1.0 };
            this.handle_id_dialog_hover(mouse_event, pos_evt);
        }
        // TODO need to differentiate between first click and a reassign -- potentially with global state
        this.assign_annotation_id(annotation_id);
        current_subtask["state"]["first_explicit_assignment"] = false;
    }

    // Update the displayed annotation confidence
    update_confidence_dialog() {
        // Whenever the mouse makes the dialogs show up, update the displayed annotation confidence.
        const current_subtask = this.get_current_subtask();
        const active_annotation_id = current_subtask["state"]["edit_candidate"]["annid"];
        const active_annotation = current_subtask["annotations"]["access"][active_annotation_id];
        /** The active annotation's classification payloads. */
        const aacp = active_annotation["classification_payloads"];

        // Keep track of highest payload confidence
        let confidence = 0;
        aacp.forEach((payload) => {
            if (payload.confidence > confidence) {
                confidence = payload.confidence;
            }
        });

        // Update the display dialog with the annotation's confidence
        jquery_default()(".annotation-confidence-value").text(confidence);
    }

    // ================= Viewer/Annotation Interaction Handlers  =================

    handle_mouse_down(mouse_event) {
        const drag_key = ULabel.get_drag_key_start(mouse_event, this);
        if (drag_key != null) {
            // Don't start new drag while id_dialog is visible
            if (this.get_current_subtask()["state"]["idd_visible"] && !this.get_current_subtask()["state"]["idd_thumbnail"]) {
                return;
            }
            mouse_event.preventDefault();
            if (this.drag_state["active_key"] === null) {
                this.start_drag(drag_key, mouse_event.button, mouse_event);
            }
        }
    }

    handle_mouse_move(mouse_event) {
        const annotation_mode = this.get_current_subtask()["state"]["annotation_mode"];
        const idd_visible = this.get_current_subtask()["state"]["idd_visible"];
        const idd_thumbnail = this.get_current_subtask()["state"]["idd_thumbnail"];
        const edit_candidate = this.get_current_subtask()["state"]["edit_candidate"];
        this.state["last_move"] = mouse_event;
        // If the ID dialog is visible, let it's own handler take care of this
        // If not dragging...
        if (this.drag_state["active_key"] === null) {
            if (idd_visible && !idd_thumbnail) {
                return;
            }
            // If polygon is in progress, redirect last segment
            if (this.get_current_subtask()["state"]["is_in_progress"]) {
                if (
                    (annotation_mode === "polygon") ||
                    (annotation_mode === "polyline") ||
                    (annotation_mode === "delete_polygon")
                ) {
                    this.continue_annotation(mouse_event);
                }
            } else if (this.get_current_subtask()["state"]["is_in_brush_mode"]) {
                // If brush mode is in progress, move the brush
                let gmx = this.get_global_mouse_x(mouse_event);
                let gmy = this.get_global_mouse_y(mouse_event);
                this.move_brush_circle(gmx, gmy);
            } else if (mouse_event.shiftKey && annotation_mode === "polygon" && idd_visible && edit_candidate != null) {
                // If shift key is held while hovering a polygon, we want to start a new complex payload

                // set annotation as active, in_progress, and starting_complex_polygon
                this.get_current_subtask()["state"]["active_id"] = edit_candidate["annid"];
                this.start_complex_polygon();
            } else { // Nothing in progress. Maybe show editable queues
                this.suggest_edits(mouse_event);
            }
        } else { // Dragging
            switch (this.drag_state["active_key"]) {
                case "pan":
                    this.drag_repan(mouse_event);
                    break;
                case "zoom":
                    this.drag_rezoom(mouse_event);
                    break;
                case "annotation":
                    if (!idd_visible || idd_thumbnail) {
                        this.continue_annotation(mouse_event);
                    }
                    break;
                case "brush":
                    // If currently brushing, continue
                    if (this.get_current_subtask()["state"]["is_in_progress"]) {
                        this.continue_brush(mouse_event);
                    } else {
                        // If not, see if we should start
                        this.begin_brush(mouse_event);
                    }
                    break;
                case "edit":
                    if (!idd_visible || idd_thumbnail) {
                        this.continue_edit(mouse_event);
                    }
                    break;
                case "move":
                    if (!idd_visible || idd_thumbnail) {
                        this.continue_move(mouse_event);
                    }
                    break;
            }
        }
    }

    handle_mouse_up(mouse_event) {
        if (mouse_event.button === this.drag_state["release_button"]) {
            mouse_event.preventDefault();
            this.end_drag(mouse_event);
        }
    }

    handle_aux_click(mouse_event) {
        // Prevent default
        mouse_event.preventDefault();
    }

    /**
     * Handler for "wheel" event listener
     *
     * @param {*} wheel_event
     */
    handle_wheel(wheel_event) {
        // Prevent scroll-zoom
        wheel_event.preventDefault();
        let fms = this.config["image_data"].frames.length > 1;
        if (wheel_event.altKey) {
            // When in brush mode, change the brush size
            if (this.get_current_subtask()["state"]["is_in_brush_mode"]) {
                this.change_brush_size(wheel_event.deltaY < 0 ? 1.1 : 1 / 1.1);
            }
        } else if (fms && (wheel_event.ctrlKey || wheel_event.shiftKey || wheel_event.metaKey)) {
            // Get direction of wheel
            const dlta = Math.sign(wheel_event.deltaY);
            this.update_frame(dlta);
        } else {
            // Don't scroll if id dialog is visible
            if (this.get_current_subtask()["state"]["idd_visible"] && !this.get_current_subtask()["state"]["idd_thumbnail"]) {
                return;
            }

            // Get direction of wheel
            const dlta = Math.sign(wheel_event.deltaY);

            // Apply new zoom
            this.state["zoom_val"] *= (1 - dlta / 5);
            this.rezoom(wheel_event.clientX, wheel_event.clientY);

            // Only try to update the overlay if it exists
            this.filter_distance_overlay?.draw_overlay();
        }
    }

    // Start dragging to pan around image
    // Called when mousedown fires within annbox
    start_drag(drag_key, release_button, mouse_event) {
        // Convenience
        const annbox = jquery_default()("#" + this.config["annbox_id"]);

        this.drag_state["active_key"] = drag_key;
        this.drag_state["release_button"] = release_button;
        this.drag_state[drag_key]["mouse_start"] = [
            mouse_event.clientX,
            mouse_event.clientY,
            this.state["current_frame"],
        ];
        this.drag_state[drag_key]["zoom_val_start"] = this.state["zoom_val"];
        this.drag_state[drag_key]["offset_start"] = [
            annbox.scrollLeft(),
            annbox.scrollTop(),
        ];
        jquery_default()(`textarea`).trigger("blur");
        jquery_default()("div.permopen").removeClass("permopen");
        // TODO handle this drag start
        let annmd;
        switch (drag_key) {
            case "annotation":
                annmd = this.get_current_subtask()["state"]["annotation_mode"];
                if (!build_annotation.NONSPATIAL_MODES.includes(annmd) && !this.get_current_subtask()["state"]["is_in_progress"]) {
                    this.begin_annotation(mouse_event);
                }
                break;
            case "brush":
                this.begin_brush(mouse_event);
                break;
            case "edit":
                this.begin_edit(mouse_event);
                break;
            case "move":
                this.begin_move(mouse_event);
                break;
            default:
                // No handling necessary for pan and zoom until mousemove
                break;
        }
    }

    end_drag(mouse_event) {
        const annotation_mode = this.get_current_subtask()["state"]["annotation_mode"];
        const active_id = this.get_current_subtask()["state"]["active_id"];
        let spatial_payload, n_points, active_spatial_payload;
        switch (this.drag_state["active_key"]) {
            case "annotation":
                if (active_id != null) {
                    spatial_payload = this.get_current_subtask()["annotations"]["access"][active_id]["spatial_payload"];
                    if (
                        (annotation_mode != "polygon") &&
                        (annotation_mode != "polyline") &&
                        (annotation_mode != "delete_polygon")
                    ) {
                        this.finish_annotation(mouse_event);
                    } else {
                        active_spatial_payload = spatial_payload.at(-1);
                        n_points = annotation_mode === "polygon" ? active_spatial_payload.length : spatial_payload.length;
                        if (
                            // We can finish a polygon by clicking on the ender
                            // however, we don't want this to trigger immediately after starting an annotation
                            // so we check that the polygon has more than 2 points
                            !this.get_current_subtask()["state"]["starting_complex_polygon"] &&
                            n_points > 2 &&
                            (
                                (mouse_event.target.id === "ender_" + active_id) ||
                                (mouse_event.target.id === "ender_" + active_id + "_inner")
                            )
                        ) {
                            this.finish_annotation(mouse_event);
                        } else {
                            // If not at the ender OR if we're placing the start of a new complex polygon, continue
                            this.continue_annotation(mouse_event, true);
                        }
                    }
                }
                break;
            case "brush":
                if (active_id != null) {
                    this.finish_annotation(mouse_event);
                }
                break;
            case "right":
                if (active_id != null) {
                    if (annotation_mode === "polyline") {
                        this.finish_annotation(mouse_event);
                    }
                }
                break;
            case "edit":
                this.finish_edit();
                break;
            case "move":
                this.finish_move(mouse_event);
                break;
            default:
                // No handling necessary for pan and zoom until mousemove
                break;
        }

        this.drag_state["active_key"] = null;
        this.drag_state["release_button"] = null;
    }

    // Pan to correct location given mouse dragging
    drag_repan(mouse_event) {
        // Convenience
        var annbox = jquery_default()("#" + this.config["annbox_id"]);

        // Pan based on mouse position
        const aX = mouse_event.clientX;
        const aY = mouse_event.clientY;
        annbox.scrollLeft(
            this.drag_state["pan"]["offset_start"][0] + (this.drag_state["pan"]["mouse_start"][0] - aX),
        );
        annbox.scrollTop(
            this.drag_state["pan"]["offset_start"][1] + (this.drag_state["pan"]["mouse_start"][1] - aY),
        );
    }

    // Handle zooming by click-drag
    drag_rezoom(mouse_event) {
        const aY = mouse_event.clientY;
        this.set_zoom_val(
            this.drag_state["zoom"]["zoom_val_start"] * Math.pow(
                1.1, -(aY - this.drag_state["zoom"]["mouse_start"][1]) / 10,
            ),
        );
        this.rezoom(this.drag_state["zoom"]["mouse_start"][0], this.drag_state["zoom"]["mouse_start"][1]);
    }

    // Set the zoom value in state and render accordingly
    set_zoom_val(zoom_val) {
        // Prevent zoom val <= 0
        this.state["zoom_val"] = Math.max(zoom_val, 0.01);
    }

    // Handle zooming at a certain focus
    rezoom(foc_x = null, foc_y = null, abs = false) {
        // JQuery convenience
        var imwrap = jquery_default()("#" + this.config["imwrap_id"]);
        var annbox = jquery_default()("#" + this.config["annbox_id"]);

        if (foc_x === null) {
            foc_x = annbox.width() / 2;
        }
        if (foc_y === null) {
            foc_y = annbox.height() / 2;
        }

        // Get old size and position
        let old_width = imwrap.width();
        let old_height = imwrap.height();
        let old_left = annbox.scrollLeft();
        let old_top = annbox.scrollTop();
        if (abs) {
            old_width = this.config["image_width"];
            old_height = this.config["image_height"];
        }

        const viewport_width = annbox.width();
        const viewport_height = annbox.height();

        // Compute new size
        const new_width = Math.round(this.config["image_width"] * this.state["zoom_val"]);
        const new_height = Math.round(this.config["image_height"] * this.state["zoom_val"]);

        // Apply new size
        var toresize = jquery_default()("." + this.config["imgsz_class"]);
        toresize.css("width", new_width + "px");
        toresize.css("height", new_height + "px");

        // Apply new size to overlay if overlay exists
        this.filter_distance_overlay?.resize_canvas(new_width, new_height);

        // Apply new size to an active polygon ender
        this.resize_active_polygon_ender();

        // Compute and apply new position
        let new_left, new_top;
        if (abs) {
            new_left = foc_x * new_width / old_width - viewport_width / 2;
            new_top = foc_y * new_height / old_height - viewport_height / 2;
        } else {
            new_left = (old_left + foc_x) * new_width / old_width - foc_x;
            new_top = (old_top + foc_y) * new_height / old_height - foc_y;
        }
        annbox.scrollLeft(new_left);
        annbox.scrollTop(new_top);

        // Redraw demo annotation
        this.redraw_demo();

        // Redraw all annotations if size mode is not "fixed" to render them at their new size
        if (this.state.anno_scaling_mode === "inverse-zoom" || this.state.anno_scaling_mode === "match-zoom") {
            this.redraw_all_annotations();
        }
    }

    // Zoom to the next annotation in the ordering
    fly_to_next_annotation(increment = 1, max_zoom = 10) {
        const current_subtask = this.get_current_subtask();
        const ordering = current_subtask["annotations"]["ordering"];
        // Don't interrupt if currently editing an annotation
        if (ordering.length === 0 || current_subtask["state"]["active_id"] !== null) {
            return false;
        }

        // Find the next non-deprecated, spatial annotation
        let start_idx = current_subtask["state"]["fly_to_idx"];
        const single_increment = increment > 0 ? 1 : -1;
        if (start_idx === null) {
            start_idx = increment > 0 ? -1 : 0;
        }

        // Start with the full increment amount
        let next_idx = (start_idx + increment + ordering.length) % ordering.length;
        const first_checked_idx = next_idx;

        // Continue until the fly-to succeeds or we've checked all annotations
        do {
            const next_ann = current_subtask["annotations"]["access"][ordering[next_idx]];
            if (this.fly_to_annotation(next_ann, null, max_zoom)) {
                current_subtask["state"]["fly_to_idx"] = next_idx;
                return true;
            }
            // Increment by a single step and try again
            next_idx = (next_idx + single_increment + ordering.length) % ordering.length;
        } while (next_idx !== first_checked_idx);

        return false;
    }

    fly_to_annotation_id(annotation_id, subtask_key = null, max_zoom = 10) {
        if (subtask_key !== null && subtask_key !== this.state.current_subtask) {
            this.set_subtask(subtask_key);
        }
        const annotation = this.get_current_subtask()["annotations"]["access"][annotation_id];
        return this.fly_to_annotation(annotation, null, max_zoom);
    }

    fly_to_annotation(annotation, subtask_key = null, max_zoom = 10) {
        // Handle null, deprecated, and non-spatial annotations
        if (
            annotation === null ||
            annotation === undefined ||
            annotation["deprecated"] ||
            build_annotation.NONSPATIAL_MODES.includes(annotation["spatial_type"])
        ) {
            return false;
        }

        // Set the current subtask if necessary
        if (subtask_key !== null && subtask_key !== this.state.current_subtask) {
            this.set_subtask(subtask_key);
        }

        // Zoom based on the containing box of the annotation
        const bbox = annotation["containing_box"];
        const annbox = jquery_default()("#" + this.config["annbox_id"]);

        // Get viewport dimensions
        const viewport_width = annbox.width();
        const viewport_height = annbox.height();

        // Get annotation dimensions in image coordinates
        const bbox_width = bbox["brx"] - bbox["tlx"];
        const bbox_height = bbox["bry"] - bbox["tly"];

        // Calculate zoom to fit annotation with some padding
        const padding_factor = 0.9;
        const zoom_x = (viewport_width * padding_factor) / bbox_width;
        const zoom_y = (viewport_height * padding_factor) / bbox_height;

        // Use the smaller zoom to ensure annotation fits in both dimensions
        this.set_zoom_val(Math.min(zoom_x, zoom_y, max_zoom));

        // Center on the annotation
        this.rezoom((bbox["tlx"] + bbox["brx"]) / 2, (bbox["tly"] + bbox["bry"]) / 2, true);

        // Suggest edits at the centered annotation
        this.suggest_edits({
            pageX: annbox.width() / 2,
            pageY: annbox.height() / 2,
        });

        // Show navigation toast
        this.show_annotation_navigation_toast(annotation["id"]);

        // Highlight annotation in the list if AnnotationList toolbox item exists
        const annotation_list_item = this.toolbox.items.find((item) => item.get_toolbox_item_type() === "AnnotationList");
        if (annotation_list_item && typeof annotation_list_item.highlight_annotation === "function") {
            annotation_list_item.highlight_annotation(annotation["id"]);
        }

        return true;
    }

    // Show navigation toast indicating which annotation is being viewed
    show_annotation_navigation_toast(annotation_id) {
        const current_subtask = this.get_current_subtask();
        if (!current_subtask) return;

        // Find the index of this annotation in the ordering
        const ordering = current_subtask["annotations"]["ordering"];
        const annotation_idx = ordering.indexOf(annotation_id);

        if (annotation_idx === -1) return;

        // Count non-deprecated annotations up to and including this one
        let visible_count = 0;
        let current_visible_idx = -1;
        for (let i = 0; i < ordering.length; i++) {
            const ann = current_subtask["annotations"]["access"][ordering[i]];
            if (!ann["deprecated"]) {
                if (ordering[i] === annotation_id) {
                    current_visible_idx = visible_count;
                }
                visible_count++;
            }
        }

        if (current_visible_idx === -1) return;

        // Create or get existing toast element
        let toast = document.getElementById("annotation-navigation-toast");

        if (!toast) {
            toast = document.createElement("div");
            toast.id = "annotation-navigation-toast";
            toast.className = "annotation-navigation-toast";
            document.body.appendChild(toast);
        }

        // Update the text - add 1 to show human-readable numbering (1-based instead of 0-based)
        toast.textContent = `${current_visible_idx + 1} / ${visible_count}`;

        // Clear any existing timeout to reset the timer
        if (this.annotation_navigation_toast_timeout !== null) {
            clearTimeout(this.annotation_navigation_toast_timeout);
            this.annotation_navigation_toast_timeout = null;
        }

        // Show the toast
        // Use a small delay to ensure the opacity transition works
        setTimeout(() => {
            toast.classList.add("show");
        }, 10);

        // Hide the toast after a delay
        this.annotation_navigation_toast_timeout = setTimeout(() => {
            toast.classList.remove("show");
            this.annotation_navigation_toast_timeout = null;
        }, 1000);
    }

    // Shake the screen
    shake_screen() {
        if (!this.is_shaking) {
            const annbox = jquery_default()("#" + this.config["annbox_id"]);
            const old_top = annbox.scrollTop();
            const shake_distance = 10; // pixels
            const shake_duration = 150; // milliseconds
            const shake_interval = 25; // milliseconds
            let shake_count = 0;
            this.is_shaking = true;
            const shake = setInterval(() => {
                if (shake_count < shake_duration / shake_interval) {
                    // Alternate between shaking up and down
                    if (shake_count % 2 === 0) {
                        annbox.scrollTop(old_top + shake_distance);
                    } else {
                        annbox.scrollTop(old_top - shake_distance);
                    }
                } else {
                    // Stop shaking and reset position
                    clearInterval(shake);
                    annbox.scrollTop(old_top);
                    this.is_shaking = false;
                }
                shake_count++;
            }, shake_interval);
        }
    }

    swap_frame_image(new_src, frame = 0) {
        const ret = jquery_default()(`img#${this.config["image_id_pfx"]}__${frame}`).attr("src");
        jquery_default()(`img#${this.config["image_id_pfx"]}__${frame}`).attr("src", new_src);
        return ret;
    }

    // Swap annotation box background color
    swap_anno_bg_color(new_bg_color) {
        const annbox = jquery_default()("#" + this.config["annbox_id"]);
        const ret = annbox.css("background-color");
        annbox.css("background-color", new_bg_color);
        return ret;
    }

    reset_interaction_state(subtask = null) {
        let q = [];
        if (subtask === null) {
            for (let st in this.subtasks) {
                q.push(st);
            }
        } else {
            q.push(subtask);
        }
        for (let i = 0; i < q.length; i++) {
            if (this.subtasks[q[i]]["state"]["active_id"] != null) {
                // Delete polygon ender if exists
                jquery_default()("#ender_" + this.subtasks[q[i]]["state"]["active_id"]).remove();
            }
            this.subtasks[q[i]]["state"]["is_in_edit"] = false;
            this.subtasks[q[i]]["state"]["is_in_move"] = false;
            this.subtasks[q[i]]["state"]["is_in_progress"] = false;
            this.subtasks[q[i]]["state"]["active_id"] = null;
            // TODO (joshua-dean): this line was probably a mistake
            // It's at least 3 years old, and is a nop as far as I can tell
            // this.show
        }
        this.drag_state = {
            active_key: null,
            release_button: null,
            annotation: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            edit: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            pan: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            zoom: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            move: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
            right: {
                mouse_start: null, // Screen coordinates where the current mouse drag started
                offset_start: null, // Scroll values where the current mouse drag started
                zoom_val_start: null, // zoom_val when the dragging interaction started
            },
        };
    }

    // Allow for external access and modification of annotations within a subtask
    get_annotations(subtask) {
        let ret = [];
        for (let i = 0; i < this.subtasks[subtask]["annotations"]["ordering"].length; i++) {
            let id = this.subtasks[subtask]["annotations"]["ordering"][i];
            if (id != this.get_current_subtask()["state"]["active_id"]) {
                ret.push(this.subtasks[subtask]["annotations"]["access"][id]);
            }
        }
        return JSON.parse(JSON.stringify(ret));
    }

    set_annotations(new_annotations, subtask) {
        // Undo/redo won't work through a get/set
        this.reset_interaction_state();
        this.subtasks[subtask]["actions"]["stream"] = [];
        this.subtasks[subtask]["actions"]["undo_stack"] = [];

        // Remove canvases for spatial annotations
        for (let i = 0; i < this.subtasks[subtask]["annotations"]["ordering"].length; i++) {
            // If a spatial annotation, delete the canvas
            let id = this.subtasks[subtask]["annotations"]["ordering"][i];
            if (!build_annotation.NONSPATIAL_MODES.includes(this.subtasks[subtask]["annotations"]["access"][id]["spatial_type"])) {
                this.destroy_annotation_context(id, subtask);
            }
        }
        // Set new annotations and initialize canvases
        ULabel.process_resume_from(this, subtask, { resume_from: new_annotations });
        (0,canvas_utils.initialize_annotation_canvases)(this, subtask);
        // Redraw all annotations to render them
        this.redraw_all_annotations(subtask);
        // Calculate distances for all annotations if FilterDistance is present
        this.update_filter_distance(null, false, true);
        // Update class counter in toolbox
        this.toolbox.redraw_update_items(this);
    }

    // Change frame
    update_frame(delta = null, new_frame = null) {
        if (this.config["image_data"]["frames"].length === 1) {
            return;
        }
        let actid = this.get_current_subtask()["state"]["active_id"];
        if (actid != null) {
            if (!build_annotation.MODES_3D.includes(this.get_current_subtask()["annotations"]["access"][actid]["spatial_type"])) {
                return;
            }
        }
        if (new_frame === null) {
            new_frame = parseInt(jquery_default()(`div#${this.config["toolbox_id"]} input.frame_input`).val());
            if (delta != null) {
                new_frame = Math.min(Math.max(new_frame + delta, 0), this.config["image_data"].frames.length - 1);
            }
        } else {
            new_frame = Math.min(Math.max(new_frame, 0), this.config["image_data"].frames.length - 1);
        }
        // Change the val above
        jquery_default()(`div#${this.config["toolbox_id"]} input.frame_input`).val(new_frame);
        let old_frame = this.state["current_frame"];
        this.state["current_frame"] = new_frame;
        // $(`img#${this.config["image_id_pfx"]}__${old_frame}`).css("z-index", "initial");
        jquery_default()(`img#${this.config["image_id_pfx"]}__${old_frame}`).css("display", "none");
        // $(`img#${this.config["image_id_pfx"]}__${new_frame}`).css("z-index", 50);
        jquery_default()(`img#${this.config["image_id_pfx"]}__${new_frame}`).css("display", "block");
        if (
            actid &&
            build_annotation.MODES_3D.includes(
                this.get_current_subtask()["annotations"]["access"][actid]["spatial_type"],
            )
        ) {
            if (this.get_current_subtask()["state"]["is_in_edit"]) {
                this.continue_edit(this.state["last_move"]);
            } else if (this.get_current_subtask()["state"]["is_in_move"]) {
                this.continue_move(this.state["last_move"]);
            } else if (this.get_current_subtask()["state"]["is_in_progress"]) {
                this.continue_annotation(this.state["last_move"]);
            } else {
                this.redraw_all_annotations();
            }
        } else {
            this.redraw_all_annotations();
        }

        this.suggest_edits();
    }

    // Generic Callback Support
    on(fn, callback) {
        var old_fn = fn.bind(this);
        this[fn.name] = (...args) => {
            old_fn(...args);
            callback();
        };
    }
}

window.ULabel = ULabel;
/* harmony default export */ const src = (ULabel);


/***/ }),

/***/ 7112:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var boolean_intersects_1 = __importDefault(__webpack_require__(1734));
var distance_1 = __importDefault(__webpack_require__(9391));
var helpers_1 = __webpack_require__(8967);
/**
 * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.
 *
 * @name rectangleGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellWidth of each cell, in units
 * @param {number} cellHeight of each cell, in units
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] units ("degrees", "radians", "miles", "kilometers") that the given cellWidth
 * and cellHeight are expressed in. Converted at the southern border.
 * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,
 * the grid Points will be created only inside it
 * @param {Object} [options.properties={}] passed to each point of the grid
 * @returns {FeatureCollection<Polygon>} a grid of polygons
 * @example
 * var bbox = [-95, 30 ,-85, 40];
 * var cellWidth = 50;
 * var cellHeight = 20;
 * var options = {units: 'miles'};
 *
 * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);
 *
 * //addToMap
 * var addToMap = [rectangleGrid]
 */
function rectangleGrid(bbox, cellWidth, cellHeight, options) {
    if (options === void 0) { options = {}; }
    // Containers
    var results = [];
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var xFraction = cellWidth / distance_1.default([west, south], [east, south], options);
    var cellWidthDeg = xFraction * (east - west);
    var yFraction = cellHeight / distance_1.default([west, south], [west, north], options);
    var cellHeightDeg = yFraction * (north - south);
    // rows & columns
    var bboxWidth = east - west;
    var bboxHeight = north - south;
    var columns = Math.floor(bboxWidth / cellWidthDeg);
    var rows = Math.floor(bboxHeight / cellHeightDeg);
    // if the grid does not fill the bbox perfectly, center it.
    var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
    var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
    // iterate over columns & rows
    var currentX = west + deltaX;
    for (var column = 0; column < columns; column++) {
        var currentY = south + deltaY;
        for (var row = 0; row < rows; row++) {
            var cellPoly = helpers_1.polygon([
                [
                    [currentX, currentY],
                    [currentX, currentY + cellHeightDeg],
                    [currentX + cellWidthDeg, currentY + cellHeightDeg],
                    [currentX + cellWidthDeg, currentY],
                    [currentX, currentY],
                ],
            ], options.properties);
            if (options.mask) {
                if (boolean_intersects_1.default(options.mask, cellPoly)) {
                    results.push(cellPoly);
                }
            }
            else {
                results.push(cellPoly);
            }
            currentY += cellHeightDeg;
        }
        currentX += cellWidthDeg;
    }
    return helpers_1.featureCollection(results);
}
exports["default"] = rectangleGrid;


/***/ }),

/***/ 7119:
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 7153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://en.wikipedia.org/wiki/Rhumb_line
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the
 * origin Point with the (varant) given bearing.
 *
 * @name rhumbDestination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the starting point
 * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @param {Object} [options.properties={}] translate properties to destination point
 * @returns {Feature<Point>} Destination point.
 * @example
 * var pt = turf.point([-75.343, 39.984], {"marker-color": "F00"});
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.rhumbDestination(pt, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [pt, destination]
 * destination.properties['marker-color'] = '#00F';
 */
function rhumbDestination(origin, distance, bearing, options) {
    if (options === void 0) { options = {}; }
    var wasNegativeDistance = distance < 0;
    var distanceInMeters = helpers_1.convertLength(Math.abs(distance), options.units, "meters");
    if (wasNegativeDistance)
        distanceInMeters = -Math.abs(distanceInMeters);
    var coords = invariant_1.getCoord(origin);
    var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
    destination[0] +=
        destination[0] - coords[0] > 180
            ? -360
            : coords[0] - destination[0] > 180
                ? 360
                : 0;
    return helpers_1.point(destination, options.properties);
}
/**
 * Returns the destination point having travelled along a rhumb line from origin point the given
 * distance on the  given bearing.
 * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines
 *
 * @private
 * @param   {Array<number>} origin - point
 * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).
 * @param   {number} bearing - Bearing in degrees from north.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {Array<number>} Destination point.
 */
function calculateRhumbDestination(origin, distance, bearing, radius) {
    //  => phi
    //  => lambda
    //  => psi
    //  => Delta
    //  => delta
    //  => theta
    radius = radius === undefined ? helpers_1.earthRadius : Number(radius);
    var delta = distance / radius; // angular distance in radians
    var lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 
    var phi1 = helpers_1.degreesToRadians(origin[1]);
    var theta = helpers_1.degreesToRadians(bearing);
    var DeltaPhi = delta * Math.cos(theta);
    var phi2 = phi1 + DeltaPhi;
    // check for some daft bugger going past the pole, normalise latitude if so
    if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
    }
    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    // E-W course becomes ill-conditioned with 0/0
    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    var DeltaLambda = (delta * Math.sin(theta)) / q;
    var lambda2 = lambda1 + DeltaLambda;
    return [
        (((lambda2 * 180) / Math.PI + 540) % 360) - 180,
        (phi2 * 180) / Math.PI,
    ]; // normalise to 180..+180
}
exports["default"] = rhumbDestination;


/***/ }),

/***/ 7176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(3126);
var gOPD = __webpack_require__(5795);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 7244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(9092)();
var callBound = __webpack_require__(8075);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 7262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var center = __webpack_require__(6649);
var turfJsts = __webpack_require__(39);
var meta = __webpack_require__(8421);
var d3Geo = __webpack_require__(1715);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var center__default = /*#__PURE__*/_interopDefaultLegacy(center);

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * When using a negative radius, the resulting geometry may be invalid if
 * it's too small compared to the radius magnitude. If the input is a
 * FeatureCollection, only valid members will be returned in the output
 * FeatureCollection - i.e., the output collection may have fewer members than
 * the input, or even be empty.
 *
 * @name buffer
 * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered
 * @param {number} radius distance to draw the buffer (negative values are allowed)
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units="kilometers"] any of the options supported by turf units
 * @param {number} [options.steps=8] number of steps
 * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features
 * @example
 * var point = turf.point([-90.548630, 14.616599]);
 * var buffered = turf.buffer(point, 500, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [point, buffered]
 */
function buffer(geojson, radius, options) {
  // Optional params
  options = options || {};

  // use user supplied options or default values
  var units = options.units || "kilometers";
  var steps = options.steps || 8;

  // validation
  if (!geojson) throw new Error("geojson is required");
  if (typeof options !== "object") throw new Error("options must be an object");
  if (typeof steps !== "number") throw new Error("steps must be an number");

  // Allow negative buffers ("erosion") or zero-sized buffers ("repair geometry")
  if (radius === undefined) throw new Error("radius is required");
  if (steps <= 0) throw new Error("steps must be greater than 0");

  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      meta.geomEach(geojson, function (geometry) {
        var buffered = bufferFeature(geometry, radius, units, steps);
        if (buffered) results.push(buffered);
      });
      return helpers.featureCollection(results);
    case "FeatureCollection":
      meta.featureEach(geojson, function (feature) {
        var multiBuffered = bufferFeature(feature, radius, units, steps);
        if (multiBuffered) {
          meta.featureEach(multiBuffered, function (buffered) {
            if (buffered) results.push(buffered);
          });
        }
      });
      return helpers.featureCollection(results);
  }
  return bufferFeature(geojson, radius, units, steps);
}

/**
 * Buffer single Feature/Geometry
 *
 * @private
 * @param {Feature<any>} geojson input to be buffered
 * @param {number} radius distance to draw the buffer
 * @param {string} [units='kilometers'] any of the options supported by turf units
 * @param {number} [steps=8] number of steps
 * @returns {Feature<Polygon|MultiPolygon>} buffered feature
 */
function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;

  // Geometry Types faster than jsts
  if (geometry.type === "GeometryCollection") {
    var results = [];
    meta.geomEach(geojson, function (geometry) {
      var buffered = bufferFeature(geometry, radius, units, steps);
      if (buffered) results.push(buffered);
    });
    return helpers.featureCollection(results);
  }

  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)
  var projection = defineProjection(geometry);
  var projected = {
    type: geometry.type,
    coordinates: projectCoords(geometry.coordinates, projection),
  };

  // JSTS buffer operation
  var reader = new turfJsts.GeoJSONReader();
  var geom = reader.read(projected);
  var distance = helpers.radiansToLength(helpers.lengthToRadians(radius, units), "meters");
  var buffered = turfJsts.BufferOp.bufferOp(geom, distance, steps);
  var writer = new turfJsts.GeoJSONWriter();
  buffered = writer.write(buffered);

  // Detect if empty geometries
  if (coordsIsNaN(buffered.coordinates)) return undefined;

  // Unproject coordinates (convert to Degrees)
  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection),
  };

  return helpers.feature(result, properties);
}

/**
 * Coordinates isNaN
 *
 * @private
 * @param {Array<any>} coords GeoJSON Coordinates
 * @returns {boolean} if NaN exists
 */
function coordsIsNaN(coords) {
  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}

/**
 * Project coordinates to projection
 *
 * @private
 * @param {Array<any>} coords to project
 * @param {GeoProjection} proj D3 Geo Projection
 * @returns {Array<any>} projected coordinates
 */
function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj(coords);
  return coords.map(function (coord) {
    return projectCoords(coord, proj);
  });
}

/**
 * Un-Project coordinates to projection
 *
 * @private
 * @param {Array<any>} coords to un-project
 * @param {GeoProjection} proj D3 Geo Projection
 * @returns {Array<any>} un-projected coordinates
 */
function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj.invert(coords);
  return coords.map(function (coord) {
    return unprojectCoords(coord, proj);
  });
}

/**
 * Define Azimuthal Equidistant projection
 *
 * @private
 * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON
 * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection
 */
function defineProjection(geojson) {
  var coords = center__default['default'](geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return d3Geo.geoAzimuthalEquidistant().rotate(rotation).scale(helpers.earthRadius);
}

module.exports = buffer;
module.exports["default"] = buffer;


/***/ }),

/***/ 7300:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var helpers = __webpack_require__(8967);
var polygonClipping = __webpack_require__(9004);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var polygonClipping__default = /*#__PURE__*/_interopDefaultLegacy(polygonClipping);

/**
 * Takes any type of {@link Polygon|polygon} and an optional mask and returns a {@link Polygon|polygon} exterior ring with holes.
 *
 * @name mask
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} polygon GeoJSON Polygon used as interior rings or holes.
 * @param {Feature<Polygon>} [mask] GeoJSON Polygon used as the exterior ring (if undefined, the world extent is used)
 * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes).
 * @example
 * var polygon = turf.polygon([[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]);
 * var mask = turf.polygon([[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]);
 *
 * var masked = turf.mask(polygon, mask);
 *
 * //addToMap
 * var addToMap = [masked]
 */
function mask(polygon, mask) {
  // Define mask
  var maskPolygon = createMask(mask);

  var polygonOuters = null;
  if (polygon.type === "FeatureCollection") polygonOuters = unionFc(polygon);
  else
    polygonOuters = createGeomFromPolygonClippingOutput(
      polygonClipping__default['default'].union(polygon.geometry.coordinates)
    );

  polygonOuters.geometry.coordinates.forEach(function (contour) {
    maskPolygon.geometry.coordinates.push(contour[0]);
  });

  return maskPolygon;
}

function unionFc(fc) {
  var unioned =
    fc.features.length === 2
      ? polygonClipping__default['default'].union(
          fc.features[0].geometry.coordinates,
          fc.features[1].geometry.coordinates
        )
      : polygonClipping__default['default'].union.apply(
          polygonClipping__default['default'],
          fc.features.map(function (f) {
            return f.geometry.coordinates;
          })
        );
  return createGeomFromPolygonClippingOutput(unioned);
}

function createGeomFromPolygonClippingOutput(unioned) {
  return helpers.multiPolygon(unioned);
}

/**
 * Create Mask Coordinates
 *
 * @private
 * @param {Feature<Polygon>} [mask] default to world if undefined
 * @returns {Feature<Polygon>} mask coordinate
 */
function createMask(mask) {
  var world = [
    [
      [180, 90],
      [-180, 90],
      [-180, -90],
      [180, -90],
      [180, 90],
    ],
  ];
  var coordinates = (mask && mask.geometry.coordinates) || world;
  return helpers.polygon(coordinates);
}

module.exports = mask;
module.exports["default"] = mask;


/***/ }),

/***/ 7314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = rbush;
module.exports["default"] = rbush;

var quickselect = __webpack_require__(7342);

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ 7333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var invariant_1 = __webpack_require__(8506);
/**
 * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.
 *
 * @name booleanClockwise
 * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated
 * @returns {boolean} true/false
 * @example
 * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);
 * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);
 *
 * turf.booleanClockwise(clockwiseRing)
 * //=true
 * turf.booleanClockwise(counterClockwiseRing)
 * //=false
 */
function booleanClockwise(line) {
    var ring = invariant_1.getCoords(line);
    var sum = 0;
    var i = 1;
    var prev;
    var cur;
    while (i < ring.length) {
        prev = cur || ring[0];
        cur = ring[i];
        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
        i++;
    }
    return sum > 0;
}
exports["default"] = booleanClockwise;


/***/ }),

/***/ 7342:
/***/ (function(module) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ 7420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var helpers = __webpack_require__(8967);
var rhumbDestination = __webpack_require__(7153);
var transformRotate = __webpack_require__(7948);
var invariant = __webpack_require__(8506);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var rhumbDestination__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDestination);
var transformRotate__default = /*#__PURE__*/_interopDefaultLegacy(transformRotate);

/**
 * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.
 *
 * @param {Coord} center center point
 * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis
 * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise
 * @param {Coord} [options.pivot='origin'] point around which the rotation will be performed
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] unit of measurement for axes
 * @param {Object} [options.properties={}] properties
 * @returns {Feature<Polygon>} ellipse polygon
 * @example
 * var center = [-75, 40];
 * var xSemiAxis = 5;
 * var ySemiAxis = 2;
 * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);
 *
 * //addToMap
 * var addToMap = [turf.point(center), ellipse]
 */
function ellipse(center, xSemiAxis, ySemiAxis, options) {
  // Optional params
  options = options || {};
  var steps = options.steps || 64;
  var units = options.units || "kilometers";
  var angle = options.angle || 0;
  var pivot = options.pivot || center;
  var properties = options.properties || center.properties || {};

  // validation
  if (!center) throw new Error("center is required");
  if (!xSemiAxis) throw new Error("xSemiAxis is required");
  if (!ySemiAxis) throw new Error("ySemiAxis is required");
  if (!helpers.isObject(options)) throw new Error("options must be an object");
  if (!helpers.isNumber(steps)) throw new Error("steps must be a number");
  if (!helpers.isNumber(angle)) throw new Error("angle must be a number");

  var centerCoords = invariant.getCoord(center);
  if (units === "degrees") {
    var angleRad = helpers.degreesToRadians(angle);
  } else {
    xSemiAxis = rhumbDestination__default['default'](center, xSemiAxis, 90, { units: units });
    ySemiAxis = rhumbDestination__default['default'](center, ySemiAxis, 0, { units: units });
    xSemiAxis = invariant.getCoord(xSemiAxis)[0] - centerCoords[0];
    ySemiAxis = invariant.getCoord(ySemiAxis)[1] - centerCoords[1];
  }

  var coordinates = [];
  for (var i = 0; i < steps; i += 1) {
    var stepAngle = (i * -360) / steps;
    var x =
      (xSemiAxis * ySemiAxis) /
      Math.sqrt(
        Math.pow(ySemiAxis, 2) +
          Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
      );
    var y =
      (xSemiAxis * ySemiAxis) /
      Math.sqrt(
        Math.pow(xSemiAxis, 2) +
          Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
      );

    if (stepAngle < -90 && stepAngle >= -270) x = -x;
    if (stepAngle < -180 && stepAngle >= -360) y = -y;
    if (units === "degrees") {
      var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
      var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
      x = newx;
      y = newy;
    }

    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);
  }
  coordinates.push(coordinates[0]);
  if (units === "degrees") {
    return helpers.polygon([coordinates], properties);
  } else {
    return transformRotate__default['default'](helpers.polygon([coordinates], properties), angle, {
      pivot: pivot,
    });
  }
}

/**
 * Get Tan Degrees
 *
 * @private
 * @param {number} deg Degrees
 * @returns {number} Tan Degrees
 */
function getTanDeg(deg) {
  var rad = (deg * Math.PI) / 180;
  return Math.tan(rad);
}

module.exports = ellipse;
module.exports["default"] = ellipse;


/***/ }),

/***/ 7447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var geojson_equality_1 = __importDefault(__webpack_require__(8635));
var clean_coords_1 = __importDefault(__webpack_require__(2086));
var invariant_1 = __webpack_require__(8506);
/**
 * Determine whether two geometries of the same type have identical X,Y coordinate values.
 * See http://edndoc.esri.com/arcsde/9.0/general_topics/understand_spatial_relations.htm
 *
 * @name booleanEqual
 * @param {Geometry|Feature} feature1 GeoJSON input
 * @param {Geometry|Feature} feature2 GeoJSON input
 * @returns {boolean} true if the objects are equal, false otherwise
 * @example
 * var pt1 = turf.point([0, 0]);
 * var pt2 = turf.point([0, 0]);
 * var pt3 = turf.point([1, 1]);
 *
 * turf.booleanEqual(pt1, pt2);
 * //= true
 * turf.booleanEqual(pt2, pt3);
 * //= false
 */
function booleanEqual(feature1, feature2) {
    var type1 = invariant_1.getGeom(feature1).type;
    var type2 = invariant_1.getGeom(feature2).type;
    if (type1 !== type2)
        return false;
    var equality = new geojson_equality_1.default({ precision: 6 });
    return equality.compare(clean_coords_1.default(feature1), clean_coords_1.default(feature2));
}
exports["default"] = booleanEqual;


/***/ }),

/***/ 7484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var centroid_1 = __importDefault(__webpack_require__(4408));
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
/**
 * calcualte the Minkowski p-norm distance between two features.
 * @param feature1 point feature
 * @param feature2 point feature
 * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance
 */
function pNormDistance(feature1, feature2, p) {
    if (p === void 0) { p = 2; }
    var coordinate1 = invariant_1.getCoord(feature1);
    var coordinate2 = invariant_1.getCoord(feature2);
    var xDiff = coordinate1[0] - coordinate2[0];
    var yDiff = coordinate1[1] - coordinate2[1];
    if (p === 1) {
        return Math.abs(xDiff) + Math.abs(yDiff);
    }
    return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
exports.pNormDistance = pNormDistance;
/**
 *
 *
 * @name distanceWeight
 * @param {FeatureCollection<any>} fc FeatureCollection.
 * @param {Object} [options] option object.
 * @param {number} [options.threshold=10000] If the distance between neighbor and
 * target features is greater than threshold, the weight of that neighbor is 0.
 * @param {number} [options.p=2] Minkowski p-norm distance parameter.
 * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.
 * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.
 *  If false, weight=Math.pow(d, alpha).
 * @param {number} [options.alpha=-1] distance decay parameter.
 * A big value means the weight decay quickly as distance increases.
 * @param {boolean} [options.standardization=false] row standardization.
 * @returns {Array<Array<number>>} distance weight matrix.
 * @example
 *
 * var bbox = [-65, 40, -63, 42];
 * var dataset = turf.randomPoint(100, { bbox: bbox });
 * var result = turf.distanceWeight(dataset);
 */
function distanceWeight(fc, options) {
    options = options || {};
    var threshold = options.threshold || 10000;
    var p = options.p || 2;
    var binary = options.binary || false;
    var alpha = options.alpha || -1;
    var rowTransform = options.standardization || false;
    var features = [];
    meta_1.featureEach(fc, function (feature) {
        features.push(centroid_1.default(feature));
    });
    // computing the distance between the features
    var weights = [];
    for (var i = 0; i < features.length; i++) {
        weights[i] = [];
    }
    for (var i = 0; i < features.length; i++) {
        for (var j = i; j < features.length; j++) {
            if (i === j) {
                weights[i][j] = 0;
            }
            var dis = pNormDistance(features[i], features[j], p);
            weights[i][j] = dis;
            weights[j][i] = dis;
        }
    }
    // binary or distance decay
    for (var i = 0; i < features.length; i++) {
        for (var j = 0; j < features.length; j++) {
            var dis = weights[i][j];
            if (dis === 0) {
                continue;
            }
            if (binary) {
                if (dis <= threshold) {
                    weights[i][j] = 1.0;
                }
                else {
                    weights[i][j] = 0.0;
                }
            }
            else {
                if (dis <= threshold) {
                    weights[i][j] = Math.pow(dis, alpha);
                }
                else {
                    weights[i][j] = 0.0;
                }
            }
        }
    }
    if (rowTransform) {
        for (var i = 0; i < features.length; i++) {
            var rowSum = weights[i].reduce(function (sum, currentVal) {
                return sum + currentVal;
            }, 0);
            for (var j = 0; j < features.length; j++) {
                weights[i][j] = weights[i][j] / rowSum;
            }
        }
    }
    return weights;
}
exports["default"] = distanceWeight;


/***/ }),

/***/ 7497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var boolean_within_1 = __importDefault(__webpack_require__(4960));
var distance_1 = __importDefault(__webpack_require__(9391));
var helpers_1 = __webpack_require__(8967);
/**
 * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.
 *
 * @name pointGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide the distance between points, in units
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers
 * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
 * @param {Object} [options.properties={}] passed to each point of the grid
 * @returns {FeatureCollection<Point>} grid of points
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var cellSide = 3;
 * var options = {units: 'miles'};
 *
 * var grid = turf.pointGrid(extent, cellSide, options);
 *
 * //addToMap
 * var addToMap = [grid];
 */
function pointGrid(bbox, cellSide, options) {
    if (options === void 0) { options = {}; }
    // Default parameters
    if (options.mask && !options.units)
        options.units = "kilometers";
    // Containers
    var results = [];
    // Typescript handles the Type Validation
    // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');
    // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');
    // if (!bbox) throw new Error('bbox is required');
    // if (!Array.isArray(bbox)) throw new Error('bbox must be array');
    // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');
    // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var xFraction = cellSide / distance_1.default([west, south], [east, south], options);
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSide / distance_1.default([west, south], [west, north], options);
    var cellHeight = yFraction * (north - south);
    var bboxWidth = east - west;
    var bboxHeight = north - south;
    var columns = Math.floor(bboxWidth / cellWidth);
    var rows = Math.floor(bboxHeight / cellHeight);
    // adjust origin of the grid
    var deltaX = (bboxWidth - columns * cellWidth) / 2;
    var deltaY = (bboxHeight - rows * cellHeight) / 2;
    var currentX = west + deltaX;
    while (currentX <= east) {
        var currentY = south + deltaY;
        while (currentY <= north) {
            var cellPt = helpers_1.point([currentX, currentY], options.properties);
            if (options.mask) {
                if (boolean_within_1.default(cellPt, options.mask))
                    results.push(cellPt);
            }
            else {
                results.push(cellPt);
            }
            currentY += cellHeight;
        }
        currentX += cellWidth;
    }
    return helpers_1.featureCollection(results);
}
exports["default"] = pointGrid;


/***/ }),

/***/ 7521:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var meta_1 = __webpack_require__(8421);
var skmeans_1 = __importDefault(__webpack_require__(1756));
/**
 * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .
 * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)
 *
 * @name clustersKmeans
 * @param {FeatureCollection<Point>} points to be clustered
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:
 * - {number} cluster - the associated clusterId
 * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]
 * @example
 * // create random points with random z-values in their properties
 * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});
 * var options = {numberOfClusters: 7};
 * var clustered = turf.clustersKmeans(points, options);
 *
 * //addToMap
 * var addToMap = [clustered];
 */
function clustersKmeans(points, options) {
    if (options === void 0) { options = {}; }
    // Default Params
    var count = points.features.length;
    options.numberOfClusters =
        options.numberOfClusters || Math.round(Math.sqrt(count / 2));
    // numberOfClusters can't be greater than the number of points
    // fallbacks to count
    if (options.numberOfClusters > count)
        options.numberOfClusters = count;
    // Clone points to prevent any mutations (enabled by default)
    if (options.mutate !== true)
        points = clone_1.default(points);
    // collect points coordinates
    var data = meta_1.coordAll(points);
    // create seed to avoid skmeans to drift
    var initialCentroids = data.slice(0, options.numberOfClusters);
    // create skmeans clusters
    var skmeansResult = skmeans_1.default(data, options.numberOfClusters, initialCentroids);
    // store centroids {clusterId: [number, number]}
    var centroids = {};
    skmeansResult.centroids.forEach(function (coord, idx) {
        centroids[idx] = coord;
    });
    // add associated cluster number
    meta_1.featureEach(points, function (point, index) {
        var clusterId = skmeansResult.idxs[index];
        point.properties.cluster = clusterId;
        point.properties.centroid = centroids[clusterId];
    });
    return points;
}
exports["default"] = clustersKmeans;


/***/ }),

/***/ 7564:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var distance_1 = __importDefault(__webpack_require__(9391));
var intersect_1 = __importDefault(__webpack_require__(9627));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a bounding box and the diameter of the cell and returns a {@link FeatureCollection} of flat-topped
 * hexagons or triangles ({@link Polygon} features) aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
 *
 * @name hexGrid
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide length of the side of the the hexagons or triangles, in units. It will also coincide with the
 * radius of the circumcircle of the hexagons.
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cell size, can be degrees, radians, miles, or kilometers
 * @param {Object} [options.properties={}] passed to each hexagon or triangle of the grid
 * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
 * @param {boolean} [options.triangles=false] whether to return as triangles instead of hexagons
 * @returns {FeatureCollection<Polygon>} a hexagonal grid
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellSide = 50;
 * var options = {units: 'miles'};
 *
 * var hexgrid = turf.hexGrid(bbox, cellSide, options);
 *
 * //addToMap
 * var addToMap = [hexgrid];
 */
function hexGrid(bbox, cellSide, options) {
    if (options === void 0) { options = {}; }
    // Issue => https://github.com/Turfjs/turf/issues/1284
    var clonedProperties = JSON.stringify(options.properties || {});
    var west = bbox[0], south = bbox[1], east = bbox[2], north = bbox[3];
    var centerY = (south + north) / 2;
    var centerX = (west + east) / 2;
    // https://github.com/Turfjs/turf/issues/758
    var xFraction = (cellSide * 2) / distance_1.default([west, centerY], [east, centerY], options);
    var cellWidth = xFraction * (east - west);
    var yFraction = (cellSide * 2) / distance_1.default([centerX, south], [centerX, north], options);
    var cellHeight = yFraction * (north - south);
    var radius = cellWidth / 2;
    var hex_width = radius * 2;
    var hex_height = (Math.sqrt(3) / 2) * cellHeight;
    var box_width = east - west;
    var box_height = north - south;
    var x_interval = (3 / 4) * hex_width;
    var y_interval = hex_height;
    // adjust box_width so all hexagons will be inside the bbox
    var x_span = (box_width - hex_width) / (hex_width - radius / 2);
    var x_count = Math.floor(x_span);
    var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 -
        radius / 2 +
        x_interval / 2;
    // adjust box_height so all hexagons will be inside the bbox
    var y_count = Math.floor((box_height - hex_height) / hex_height);
    var y_adjust = (box_height - y_count * hex_height) / 2;
    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }
    // Precompute cosines and sines of angles used in hexagon creation for performance gain
    var cosines = [];
    var sines = [];
    for (var i = 0; i < 6; i++) {
        var angle = ((2 * Math.PI) / 6) * i;
        cosines.push(Math.cos(angle));
        sines.push(Math.sin(angle));
    }
    var results = [];
    for (var x = 0; x <= x_count; x++) {
        for (var y = 0; y <= y_count; y++) {
            var isOdd = x % 2 === 1;
            if (y === 0 && isOdd)
                continue;
            if (y === 0 && hasOffsetY)
                continue;
            var center_x = x * x_interval + west - x_adjust;
            var center_y = y * y_interval + south + y_adjust;
            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (options.triangles === true) {
                hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function (triangle) {
                    if (options.mask) {
                        if (intersect_1.default(options.mask, triangle))
                            results.push(triangle);
                    }
                    else {
                        results.push(triangle);
                    }
                });
            }
            else {
                var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
                if (options.mask) {
                    if (intersect_1.default(options.mask, hex))
                        results.push(hex);
                }
                else {
                    results.push(hex);
                }
            }
        }
    }
    return helpers_1.featureCollection(results);
}
/**
 * Creates hexagon
 *
 * @private
 * @param {Array<number>} center of the hexagon
 * @param {number} rx half hexagon width
 * @param {number} ry half hexagon height
 * @param {Object} properties passed to each hexagon
 * @param {Array<number>} cosines precomputed
 * @param {Array<number>} sines precomputed
 * @returns {Feature<Polygon>} hexagon
 */
function hexagon(center, rx, ry, properties, cosines, sines) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
    }
    //first and last vertex must be the same
    vertices.push(vertices[0].slice());
    return helpers_1.polygon([vertices], properties);
}
/**
 * Creates triangles composing an hexagon
 *
 * @private
 * @param {Array<number>} center of the hexagon
 * @param {number} rx half triangle width
 * @param {number} ry half triangle height
 * @param {Object} properties passed to each triangle
 * @param {Array<number>} cosines precomputed
 * @param {Array<number>} sines precomputed
 * @returns {Array<Feature<Polygon>>} triangles
 */
function hexTriangles(center, rx, ry, properties, cosines, sines) {
    var triangles = [];
    for (var i = 0; i < 6; i++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6],
        ]);
        vertices.push(center);
        triangles.push(helpers_1.polygon([vertices], properties));
    }
    return triangles;
}
exports["default"] = hexGrid;


/***/ }),

/***/ 7653:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(8452);
var callBind = __webpack_require__(487);

var implementation = __webpack_require__(9211);
var getPolyfill = __webpack_require__(9394);
var shim = __webpack_require__(6576);

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 7675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var setFunctionName = __webpack_require__(3206);

var $Object = Object;
var $TypeError = TypeError;

module.exports = setFunctionName(function flags() {
	if (this != null && this !== $Object(this)) {
		throw new $TypeError('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.hasIndices) {
		result += 'd';
	}
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.unicodeSets) {
		result += 'v';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
}, 'get flags', true);



/***/ }),

/***/ 7696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bearing_1 = __importDefault(__webpack_require__(1288));
var distance_1 = __importDefault(__webpack_require__(9391));
var destination_1 = __importDefault(__webpack_require__(4202));
var line_intersect_1 = __importDefault(__webpack_require__(3154));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
 *
 * @name nearestPointOnLine
 * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
 * @param {Geometry|Feature<Point>|number[]} pt point to snap from
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
 * @example
 * var line = turf.lineString([
 *     [-77.031669, 38.878605],
 *     [-77.029609, 38.881946],
 *     [-77.020339, 38.884084],
 *     [-77.025661, 38.885821],
 *     [-77.021884, 38.889563],
 *     [-77.019824, 38.892368]
 * ]);
 * var pt = turf.point([-77.037076, 38.884017]);
 *
 * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line, pt, snapped];
 * snapped.properties['marker-color'] = '#00f';
 */
function nearestPointOnLine(lines, pt, options) {
    if (options === void 0) { options = {}; }
    var closestPt = helpers_1.point([Infinity, Infinity], {
        dist: Infinity,
    });
    var length = 0.0;
    meta_1.flattenEach(lines, function (line) {
        var coords = invariant_1.getCoords(line);
        for (var i = 0; i < coords.length - 1; i++) {
            //start
            var start = helpers_1.point(coords[i]);
            start.properties.dist = distance_1.default(pt, start, options);
            //stop
            var stop_1 = helpers_1.point(coords[i + 1]);
            stop_1.properties.dist = distance_1.default(pt, stop_1, options);
            // sectionLength
            var sectionLength = distance_1.default(start, stop_1, options);
            //perpendicular
            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
            var direction = bearing_1.default(start, stop_1);
            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);
            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);
            var intersect = line_intersect_1.default(helpers_1.lineString([
                perpendicularPt1.geometry.coordinates,
                perpendicularPt2.geometry.coordinates,
            ]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
            var intersectPt = null;
            if (intersect.features.length > 0) {
                intersectPt = intersect.features[0];
                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);
                intersectPt.properties.location =
                    length + distance_1.default(start, intersectPt, options);
            }
            if (start.properties.dist < closestPt.properties.dist) {
                closestPt = start;
                closestPt.properties.index = i;
                closestPt.properties.location = length;
            }
            if (stop_1.properties.dist < closestPt.properties.dist) {
                closestPt = stop_1;
                closestPt.properties.index = i + 1;
                closestPt.properties.location = length + sectionLength;
            }
            if (intersectPt &&
                intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = intersectPt;
                closestPt.properties.index = i;
            }
            // update length
            length += sectionLength;
        }
    });
    return closestPt;
}
exports["default"] = nearestPointOnLine;


/***/ }),

/***/ 7804:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var Graph_1 = __importDefault(__webpack_require__(8828));
var EdgeRing_1 = __importDefault(__webpack_require__(9977));
/**
 * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.
 *
 * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).
 *
 * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly
 * noded, i.e., they must only meet at their endpoints.
 *
 * The implementation correctly handles:
 *
 * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.
 * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.
 *
 * @name polygonize
 * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize
 * @returns {FeatureCollection<Polygon>} Polygons created
 * @throws {Error} if geoJson is invalid.
 */
function polygonize(geoJson) {
    var graph = Graph_1.default.fromGeoJson(geoJson);
    // 1. Remove dangle node
    graph.deleteDangles();
    // 2. Remove cut-edges (bridge edges)
    graph.deleteCutEdges();
    // 3. Get all holes and shells
    var holes = [], shells = [];
    graph
        .getEdgeRings()
        .filter(function (edgeRing) { return edgeRing.isValid(); })
        .forEach(function (edgeRing) {
        if (edgeRing.isHole())
            holes.push(edgeRing);
        else
            shells.push(edgeRing);
    });
    // 4. Assign Holes to Shells
    holes.forEach(function (hole) {
        if (EdgeRing_1.default.findEdgeRingContaining(hole, shells))
            shells.push(hole);
    });
    // 5. EdgeRings to Polygons
    return helpers_1.featureCollection(shells.map(function (shell) { return shell.toPolygon(); }));
}
exports["default"] = polygonize;


/***/ }),

/***/ 7849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
// Note: change RADIUS => earthRadius
var RADIUS = 6378137;
/**
 * Takes one or more features and returns their area in square meters.
 *
 * @name area
 * @param {GeoJSON} geojson input GeoJSON feature(s)
 * @returns {number} area in square meters
 * @example
 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
 *
 * var area = turf.area(polygon);
 *
 * //addToMap
 * var addToMap = [polygon]
 * polygon.properties.area = area
 */
function area(geojson) {
    return meta_1.geomReduce(geojson, function (value, geom) {
        return value + calculateArea(geom);
    }, 0);
}
exports["default"] = area;
/**
 * Calculate Area
 *
 * @private
 * @param {Geometry} geom GeoJSON Geometries
 * @returns {number} area
 */
function calculateArea(geom) {
    var total = 0;
    var i;
    switch (geom.type) {
        case "Polygon":
            return polygonArea(geom.coordinates);
        case "MultiPolygon":
            for (i = 0; i < geom.coordinates.length; i++) {
                total += polygonArea(geom.coordinates[i]);
            }
            return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
            return 0;
    }
    return 0;
}
function polygonArea(coords) {
    var total = 0;
    if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            total -= Math.abs(ringArea(coords[i]));
        }
    }
    return total;
}
/**
 * @private
 * Calculate the approximate area of the polygon were it projected onto the earth.
 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere",
 * JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409
 *
 * @param {Array<Array<number>>} coords Ring Coordinates
 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
 */
function ringArea(coords) {
    var p1;
    var p2;
    var p3;
    var lowerIndex;
    var middleIndex;
    var upperIndex;
    var i;
    var total = 0;
    var coordsLength = coords.length;
    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {
                // i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength - 1;
                upperIndex = 0;
            }
            else if (i === coordsLength - 1) {
                // i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            }
            else {
                // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i + 1;
                upperIndex = i + 2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
        }
        total = (total * RADIUS * RADIUS) / 2;
    }
    return total;
}
function rad(num) {
    return (num * Math.PI) / 180;
}


/***/ }),

/***/ 7911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);
var rbush = __webpack_require__(7314);
var area = __webpack_require__(7849);
var booleanPointInPolygon = __webpack_require__(2446);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var rbush__default = /*#__PURE__*/_interopDefaultLegacy(rbush);
var area__default = /*#__PURE__*/_interopDefaultLegacy(area);
var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);

// Find self-intersections in geojson polygon (possibly with interior rings)

function isects (feature, filterFn, useSpatialIndex) {
  if (feature.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  if (useSpatialIndex === undefined) useSpatialIndex = 1;

  var coord = feature.geometry.coordinates;

  var output = [];
  var seen = {};

  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
      }
    }
    var tree = rbush__default['default']();
    tree.load(allEdgesAsRbushTreeItems);
  }

  for (var ringA = 0; ringA < coord.length; ringA++) {
    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
        bboxOverlaps.forEach(function (bboxIsect) {
          var ring1 = bboxIsect.ring;
          var edge1 = bboxIsect.edge;
          ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
        });
      } else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
            // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1
            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
          }
        }
      }
    }
  }

  if (!filterFn)
    output = {
      type: "Feature",
      geometry: { type: "MultiPoint", coordinates: output },
    };
  return output;

  // Function to check if two edges intersect and add the intersection to the output
  function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {
    var start0 = coord[ring0][edge0];
    var end0 = coord[ring0][edge0 + 1];
    var start1 = coord[ring1][edge1];
    var end1 = coord[ring1][edge1 + 1];

    var isect = intersect(start0, end0, start1, end1);

    if (isect === null) return; // discard parallels and coincidence
    var frac0;
    var frac1;
    if (end0[0] !== start0[0]) {
      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
    } else {
      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
    }
    if (end1[0] !== start1[0]) {
      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
    } else {
      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
    }
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection

    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }

    if (filterFn) {
      output.push(
        filterFn(
          isect,
          ring0,
          edge0,
          start0,
          end0,
          frac0,
          ring1,
          edge1,
          start1,
          end1,
          frac1,
          unique
        )
      );
    } else {
      output.push(isect);
    }
  }

  // Function to return a rbush tree item given an ring and edge number
  function rbushTreeItem(ring, edge) {
    var start = coord[ring][edge];
    var end = coord[ring][edge + 1];
    var minX;
    var maxX;
    var minY;
    var maxY;
    if (start[0] < end[0]) {
      minX = start[0];
      maxX = end[0];
    } else {
      minX = end[0];
      maxX = start[0];
    }
    if (start[1] < end[1]) {
      minY = start[1];
      maxY = end[1];
    } else {
      minY = end[1];
      maxY = start[1];
    }
    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      ring: ring,
      edge: edge,
    };
  }
}

// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
function intersect(start0, end0, start1, end1) {
  if (
    equalArrays(start0, start1) ||
    equalArrays(start0, end1) ||
    equalArrays(end0, start1) ||
    equalArrays(end1, start1)
  )
    return null;
  var x0 = start0[0],
    y0 = start0[1],
    x1 = end0[0],
    y1 = end0[1],
    x2 = start1[0],
    y2 = start1[1],
    x3 = end1[0],
    y3 = end1[1];
  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
  if (denom === 0) return null;
  var x4 =
    ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
  var y4 =
    ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}

// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
function equalArrays(array1, array2) {
  // if the other array is a falsy value, return
  if (!array1 || !array2) return false;

  // compare lengths - can save a lot of time
  if (array1.length !== array2.length) return false;

  for (var i = 0, l = array1.length; i < l; i++) {
    // Check if we have nested arrays
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      // recurse into the nested arrays
      if (!equalArrays(array1[i], array2[i])) return false;
    } else if (array1[i] !== array2[i]) {
      // Warning - two different object instances will never be equal: {x:20} !== {x:20}
      return false;
    }
  }
  return true;
}

/**
 * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.
 *
 * @module simplepolygon
 * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.
 * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.
 *
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]
 *   }
 * };
 *
 * var result = simplepolygon(poly);
 *
 * // =result
 * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1
 */
function simplepolygon (feature) {
  // Check input
  if (feature.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (feature.geometry === undefined || feature.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (feature.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");

  // Process input
  var numRings = feature.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature.geometry.coordinates[i];
    if (!equalArrays$1(ring[0], ring[ring.length - 1])) {
      ring.push(ring[0]); // Close input ring if it is not
    }
    vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
  }
  if (!isUnique(vertices))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted

  // Compute self-intersections
  var selfIsectsData = isects(
    feature,
    function filterFn(
      isect,
      ring0,
      edge0,
      start0,
      end0,
      frac0,
      ring1,
      edge1,
      start1,
      end1,
      frac1,
      unique
    ) {
      return [
        isect,
        ring0,
        edge0,
        start0,
        end0,
        frac0,
        ring1,
        edge1,
        start1,
        end1,
        frac1,
        unique,
      ];
    }
  );
  var numSelfIsect = selfIsectsData.length;

  // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for (var i = 0; i < numRings; i++) {
      outputFeatureArray.push(
        helpers.polygon([feature.geometry.coordinates[i]], {
          parent: -1,
          winding: windingOfRing(feature.geometry.coordinates[i]),
        })
      );
    }
    var output = helpers.featureCollection(outputFeatureArray);
    determineParents();
    setNetWinding();

    return output;
  }

  // If self-intersections are found, we will compute the output rings with the help of two intermediate variables
  // First, we build the pseudo vertex list and intersection list
  // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.
  var pseudoVtxListByRingAndEdge = [];
  // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.
  var isectList = [];
  // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
      // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.
      pseudoVtxListByRingAndEdge[i].push([
        new PseudoVtx(
          feature.geometry.coordinates[i][
            modulo(j + 1, feature.geometry.coordinates[i].length - 1)
          ],
          1,
          [i, j],
          [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)],
          undefined
        ),
      ]);
      // The first numvertices elements in isectList correspond to the ring-vertex-intersections
      isectList.push(
        new Isect(
          feature.geometry.coordinates[i][j],
          [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)],
          [i, j],
          undefined,
          undefined,
          false,
          true
        )
      );
    }
  }
  // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList
  for (var i = 0; i < numSelfIsect; i++) {
    // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
      new PseudoVtx(
        selfIsectsData[i][0],
        selfIsectsData[i][5],
        [selfIsectsData[i][1], selfIsectsData[i][2]],
        [selfIsectsData[i][6], selfIsectsData[i][7]],
        undefined
      )
    );
    // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList
    if (selfIsectsData[i][11])
      isectList.push(
        new Isect(
          selfIsectsData[i][0],
          [selfIsectsData[i][1], selfIsectsData[i][2]],
          [selfIsectsData[i][6], selfIsectsData[i][7]],
          undefined,
          undefined,
          true,
          true
        )
      );
  }
  var numIsect = isectList.length;
  // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {
        return a.param < b.param ? -1 : 1;
      });
    }
  }

  // Make a spatial index of intersections, in preperation for the following two steps
  var allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({
      minX: isectList[i].coord[0],
      minY: isectList[i].coord[1],
      maxX: isectList[i].coord[0],
      maxY: isectList[i].coord[1],
      index: i,
    }); // could pass isect: isectList[i], but not necessary
  }
  var isectRbushTree = rbush__default['default']();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);

  // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.
  // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:
  // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
          // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.
          coordToFind =
            pseudoVtxListByRingAndEdge[i][
              modulo(j + 1, feature.geometry.coordinates[i].length - 1)
            ][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1],
        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn =
          IsectRbushTreeItemFound.index;
      }
    }
  }

  // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1],
        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) {
          // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.
          isectList[l].nxtIsectAlongRingAndEdge2 =
            pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else {
          // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.
          if (
            equalArrays$1(
              isectList[l].ringAndEdge1,
              pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
            )
          ) {
            isectList[l].nxtIsectAlongRingAndEdge1 =
              pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 =
              pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!

  // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.
  // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).
  var queue = [];
  // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.
    // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if (
        isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect ||
        isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect
      ) {
        var isectBeforeLeftIsect = k;
        break;
      }
    }
    var windingAtIsect = isConvex(
      [
        isectList[isectBeforeLeftIsect].coord,
        isectList[leftIsect].coord,
        isectList[isectAfterLeftIsect].coord,
      ],
      true
    )
      ? 1
      : -1;

    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
  }
  // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.
  queue.sort(function (a, b) {
    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
  });

  // Initialise output
  var outputFeatureArray = [];

  // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.
  while (queue.length > 0) {
    // Get the last object out of the queue
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    // Make new output ring and add vertex from starting intersection
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    // While we have not arrived back at the same intersection, keep walking
    while (
      !equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)
    ) {
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      // If the next intersection is queued, we can remove it, because we will go there now.
      var nxtIsectInQueue = undefined;
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].isect == nxtIsect) {
          nxtIsectInQueue = i;
          break;
        }
      }
      if (nxtIsectInQueue != undefined) {
        queue.splice(nxtIsectInQueue, 1);
      }
      // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),
      // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it
      // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue
      // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)
      // We then update the other two walking variables.
      if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          var pushing = { isect: nxtIsect };
          if (
            isConvex(
              [
                isectList[currentIsect].coord,
                isectList[nxtIsect].coord,
                isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord,
              ],
              currentOutputRingWinding == 1
            )
          ) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          var pushing = { isect: nxtIsect };
          if (
            isConvex(
              [
                isectList[currentIsect].coord,
                isectList[nxtIsect].coord,
                isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord,
              ],
              currentOutputRingWinding == 1
            )
          ) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
    }
    // Close output ring
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    // Push output ring to output
    outputFeatureArray.push(
      helpers.polygon([currentOutputRingCoords], {
        index: currentOutputRing,
        parent: currentOutputRingParent,
        winding: currentOutputRingWinding,
        netWinding: undefined,
      })
    );
  }

  var output = helpers.featureCollection(outputFeatureArray);

  determineParents();

  setNetWinding();

  // These functions are also used if no intersections are found
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i = 0; i < output.features.length; i++) {
      if (output.features[i].properties.parent == -1)
        featuresWithoutParent.push(i);
    }
    if (featuresWithoutParent.length > 1) {
      for (var i = 0; i < featuresWithoutParent.length; i++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j = 0; j < output.features.length; j++) {
          if (featuresWithoutParent[i] == j) continue;
          if (
            booleanPointInPolygon__default['default'](
              output.features[featuresWithoutParent[i]].geometry
                .coordinates[0][0],
              output.features[j],
              { ignoreBoundary: true }
            )
          ) {
            if (area__default['default'](output.features[j]) < parentArea) {
              parent = j;
            }
          }
        }
        output.features[featuresWithoutParent[i]].properties.parent = parent;
      }
    }
  }

  function setNetWinding() {
    for (var i = 0; i < output.features.length; i++) {
      if (output.features[i].properties.parent == -1) {
        var netWinding = output.features[i].properties.winding;
        output.features[i].properties.netWinding = netWinding;
        setNetWindingOfChildren(i, netWinding);
      }
    }
  }

  function setNetWindingOfChildren(parent, ParentNetWinding) {
    for (var i = 0; i < output.features.length; i++) {
      if (output.features[i].properties.parent == parent) {
        var netWinding =
          ParentNetWinding + output.features[i].properties.winding;
        output.features[i].properties.netWinding = netWinding;
        setNetWindingOfChildren(i, netWinding);
      }
    }
  }

  return output;
}

// Constructor for (ring- or intersection-) pseudo-vertices.
var PseudoVtx = function (
  coord,
  param,
  ringAndEdgeIn,
  ringAndEdgeOut,
  nxtIsectAlongEdgeIn
) {
  this.coord = coord; // [x,y] of this pseudo-vertex
  this.param = param; // fractional distance of this intersection on incomming edge
  this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge
  this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)
};

// Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.
var Isect = function (
  coord,
  ringAndEdge1,
  ringAndEdge2,
  nxtIsectAlongRingAndEdge1,
  nxtIsectAlongRingAndEdge2,
  ringAndEdge1Walkable,
  ringAndEdge2Walkable
) {
  this.coord = coord; // [x,y] of this intersection
  this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection
  this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2
  this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?
  this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?
};

// Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded
function isConvex(pts, righthanded) {
  // 'pts' is an [x,y] pair
  // 'righthanded' is a boolean
  if (typeof righthanded === "undefined") righthanded = true;
  if (pts.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var d =
    (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) -
    (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return d >= 0 == righthanded;
}

// Function to compute winding of simple, non-self-intersecting ring
function windingOfRing(ring) {
  // 'ring' is an array of [x,y] pairs with the last equal to the first
  // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong
  var leftVtx = 0;
  for (var i = 0; i < ring.length - 1; i++) {
    if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
  }
  if (
    isConvex(
      [
        ring[modulo(leftVtx - 1, ring.length - 1)],
        ring[leftVtx],
        ring[modulo(leftVtx + 1, ring.length - 1)],
      ],
      true
    )
  ) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding;
}

// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
function equalArrays$1(array1, array2) {
  // if the other array is a falsy value, return
  if (!array1 || !array2) return false;

  // compare lengths - can save a lot of time
  if (array1.length != array2.length) return false;

  for (var i = 0, l = array1.length; i < l; i++) {
    // Check if we have nested arrays
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      // recurse into the nested arrays
      if (!equalArrays$1(array1[i], array2[i])) return false;
    } else if (array1[i] != array2[i]) {
      // Warning - two different object instances will never be equal: {x:20} != {x:20}
      return false;
    }
  }
  return true;
}

// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
function modulo(n, m) {
  return ((n % m) + m) % m;
}

// Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)
function isUnique(array) {
  var u = {};
  var isUnique = 1;
  for (var i = 0, l = array.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(u, array[i])) {
      isUnique = 0;
      break;
    }
    u[array[i]] = 1;
  }
  return isUnique;
}

/**
 * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.
 * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.
 *
 * @name unkinkPolygon
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon
 * @returns {FeatureCollection<Polygon>} Unkinked polygons
 * @example
 * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);
 *
 * var result = turf.unkinkPolygon(poly);
 *
 * //addToMap
 * var addToMap = [poly, result]
 */
function unkinkPolygon(geojson) {
  var features = [];
  meta.flattenEach(geojson, function (feature) {
    if (feature.geometry.type !== "Polygon") return;
    meta.featureEach(simplepolygon(feature), function (poly) {
      features.push(helpers.polygon(poly.geometry.coordinates, feature.properties));
    });
  });
  return helpers.featureCollection(features);
}

module.exports = unkinkPolygon;
module.exports["default"] = unkinkPolygon;


/***/ }),

/***/ 7938:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var distance_weight_1 = __importDefault(__webpack_require__(7484));
var meta_1 = __webpack_require__(8421);
/**
 * Moran's I measures patterns of attribute values associated with features.
 * The method reveal whether similar values tend to occur near each other,
 * or whether high or low values are interspersed.
 *
 * Moran's I > 0 means a clusterd pattern.
 * Moran's I < 0 means a dispersed pattern.
 * Moran's I = 0 means a random pattern.
 *
 * In order to test the significance of the result. The z score is calculated.
 * A positive enough z-score (ex. >1.96) indicates clustering,
 * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.
 *
 * the z-score can be calculated based on a normal or random assumption.
 *
 * **Bibliography***
 *
 * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)
 *
 * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)
 *
 * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.
 *
 * @name moranIndex
 * @param {FeatureCollection<any>} fc
 * @param {Object} options
 * @param {string} options.inputField the property name, must contain numeric values
 * @param {number} [options.threshold=100000] the distance threshold
 * @param {number} [options.p=2] the Minkowski p-norm distance parameter
 * @param {boolean} [options.binary=false] whether transfrom the distance to binary
 * @param {number} [options.alpha=-1] the distance decay parameter
 * @param {boolean} [options.standardization=true] wheter row standardization the distance
 * @returns {MoranIndex}
 * @example
 *
 * const bbox = [-65, 40, -63, 42];
 * const dataset = turf.randomPoint(100, { bbox: bbox });
 *
 * const result = turf.moranIndex(dataset, {
 *   inputField: 'CRIME',
 * });
 */
function default_1(fc, options) {
    var inputField = options.inputField;
    var threshold = options.threshold || 100000;
    var p = options.p || 2;
    var binary = options.binary || false;
    var alpha = options.alpha || -1;
    var standardization = options.standardization || true;
    var weight = distance_weight_1.default(fc, {
        alpha: alpha,
        binary: binary,
        p: p,
        standardization: standardization,
        threshold: threshold,
    });
    var y = [];
    meta_1.featureEach(fc, function (feature) {
        var feaProperties = feature.properties || {};
        // validate inputField exists
        y.push(feaProperties[inputField]);
    });
    var yMean = mean(y);
    var yVar = variance(y);
    var weightSum = 0;
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var n = weight.length;
    // validate y.length is the same as weight.length
    for (var i = 0; i < n; i++) {
        var subS2 = 0;
        for (var j = 0; j < n; j++) {
            weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);
            s0 += weight[i][j];
            s1 += Math.pow(weight[i][j] + weight[j][i], 2);
            subS2 += weight[i][j] + weight[j][i];
        }
        s2 += Math.pow(subS2, 2);
    }
    s1 = 0.5 * s1;
    var moranIndex = weightSum / s0 / yVar;
    var expectedMoranIndex = -1 / (n - 1);
    var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
    var vDen = (n - 1) * (n + 1) * (s0 * s0);
    var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
    var stdNorm = Math.sqrt(vNorm);
    var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;
    return {
        expectedMoranIndex: expectedMoranIndex,
        moranIndex: moranIndex,
        stdNorm: stdNorm,
        zNorm: zNorm,
    };
}
exports["default"] = default_1;
/**
 * get mean of a list
 * @param {number[]} y
 * @returns {number}
 *
 */
function mean(y) {
    var sum = 0;
    for (var _i = 0, y_1 = y; _i < y_1.length; _i++) {
        var item = y_1[_i];
        sum += item;
    }
    return sum / y.length;
}
/**
 * get variance of a list
 * @param {number[]} y
 * @returns {number}
 *
 */
function variance(y) {
    var yMean = mean(y);
    var sum = 0;
    for (var _i = 0, y_2 = y; _i < y_2.length; _i++) {
        var item = y_2[_i];
        sum += Math.pow(item - yMean, 2);
    }
    return sum / y.length;
}
/**
 * @typedef {Object} MoranIndex
 * @property {number} moranIndex the moran's Index of the observed feature set
 * @property {number} expectedMoranIndex the moran's Index of the random distribution
 * @property {number} stdNorm the standard devitaion of the random distribution
 * @property {number} zNorm the z-score of the observe samples with regard to the random distribution
 */


/***/ }),

/***/ 7941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * ULabel cookie utilities.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NightModeCookie = void 0;
var NightModeCookie = /** @class */ (function () {
    function NightModeCookie() {
    }
    /**
     * Return whether the document has a night mode cookie.
     */
    NightModeCookie.exists_in_document = function () {
        var cookie_components = document.cookie.split(";");
        var night_mode_comp = cookie_components.find(function (row) { return row.trim().startsWith("".concat(NightModeCookie.COOKIE_NAME, "=true")); });
        return night_mode_comp !== undefined;
    };
    /**
     * Set the night mode cookie.
     */
    NightModeCookie.set_cookie = function () {
        var d = new Date();
        d.setTime(d.getTime() + (10000 * 24 * 60 * 60 * 1000));
        document.cookie = [
            NightModeCookie.COOKIE_NAME + "=true",
            "expires=" + d.toUTCString(),
            "path=/",
        ].join(";");
    };
    /**
     * Destroy the night mode cookie.
     */
    NightModeCookie.destroy_cookie = function () {
        document.cookie = [
            NightModeCookie.COOKIE_NAME + "=true",
            "expires=Thu, 01 Jan 1970 00:00:00 UTC",
            "path=/",
        ].join(";");
    };
    /**
     * The name of the cookie that stores the night mode preference.
     */
    NightModeCookie.COOKIE_NAME = "nightmode";
    return NightModeCookie;
}());
exports.NightModeCookie = NightModeCookie;


/***/ }),

/***/ 7948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var centroid = __webpack_require__(4408);
var rhumbBearing = __webpack_require__(2307);
var rhumbDistance = __webpack_require__(9778);
var rhumbDestination = __webpack_require__(7153);
var clone = __webpack_require__(3711);
var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var centroid__default = /*#__PURE__*/_interopDefaultLegacy(centroid);
var rhumbBearing__default = /*#__PURE__*/_interopDefaultLegacy(rhumbBearing);
var rhumbDistance__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDistance);
var rhumbDestination__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDestination);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);

/**
 * Rotates any geojson Feature or Geometry of a specified angle, around its `centroid` or a given `pivot` point.
 *
 * @name transformRotate
 * @param {GeoJSON} geojson object to be rotated
 * @param {number} angle of rotation in decimal degrees, positive clockwise
 * @param {Object} [options={}] Optional parameters
 * @param {Coord} [options.pivot='centroid'] point around which the rotation will be performed
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} the rotated GeoJSON feature
 * @example
 * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
 * var options = {pivot: [0, 25]};
 * var rotatedPoly = turf.transformRotate(poly, 10, options);
 *
 * //addToMap
 * var addToMap = [poly, rotatedPoly];
 * rotatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};
 */
function transformRotate(geojson, angle, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var pivot = options.pivot;
  var mutate = options.mutate;

  // Input validation
  if (!geojson) throw new Error("geojson is required");
  if (angle === undefined || angle === null || isNaN(angle))
    throw new Error("angle is required");

  // Shortcut no-rotation
  if (angle === 0) return geojson;

  // Use centroid of GeoJSON if pivot is not provided
  if (!pivot) pivot = centroid__default['default'](geojson);

  // Clone geojson to avoid side effects
  if (mutate === false || mutate === undefined) geojson = clone__default['default'](geojson);

  // Rotate each coordinate
  meta.coordEach(geojson, function (pointCoords) {
    var initialAngle = rhumbBearing__default['default'](pivot, pointCoords);
    var finalAngle = initialAngle + angle;
    var distance = rhumbDistance__default['default'](pivot, pointCoords);
    var newCoords = invariant.getCoords(rhumbDestination__default['default'](pivot, distance, finalAngle));
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
  });
  return geojson;
}

module.exports = transformRotate;
module.exports["default"] = transformRotate;


/***/ }),

/***/ 7969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);
var nearestPointOnLine = __webpack_require__(7696);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var nearestPointOnLine__default = /*#__PURE__*/_interopDefaultLegacy(nearestPointOnLine);

/**
 * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
 * and returns a subsection of the line in-between those points.
 * The start & stop points don't need to fall exactly on the line.
 *
 * This can be useful for extracting only the part of a route between waypoints.
 *
 * @name lineSlice
 * @param {Coord} startPt starting point
 * @param {Coord} stopPt stopping point
 * @param {Feature<LineString>|LineString} line line to slice
 * @returns {Feature<LineString>} sliced line
 * @example
 * var line = turf.lineString([
 *     [-77.031669, 38.878605],
 *     [-77.029609, 38.881946],
 *     [-77.020339, 38.884084],
 *     [-77.025661, 38.885821],
 *     [-77.021884, 38.889563],
 *     [-77.019824, 38.892368]
 * ]);
 * var start = turf.point([-77.029609, 38.881946]);
 * var stop = turf.point([-77.021884, 38.889563]);
 *
 * var sliced = turf.lineSlice(start, stop, line);
 *
 * //addToMap
 * var addToMap = [start, stop, line]
 */
function lineSlice(startPt, stopPt, line) {
  // Validation
  var coords = invariant.getCoords(line);
  if (invariant.getType(line) !== "LineString")
    throw new Error("line must be a LineString");

  var startVertex = nearestPointOnLine__default['default'](line, startPt);
  var stopVertex = nearestPointOnLine__default['default'](line, stopPt);
  var ends;
  if (startVertex.properties.index <= stopVertex.properties.index) {
    ends = [startVertex, stopVertex];
  } else {
    ends = [stopVertex, startVertex];
  }
  var clipCoords = [ends[0].geometry.coordinates];
  for (
    var i = ends[0].properties.index + 1;
    i < ends[1].properties.index + 1;
    i++
  ) {
    clipCoords.push(coords[i]);
  }
  clipCoords.push(ends[1].geometry.coordinates);
  return helpers.lineString(clipCoords, line.properties);
}

module.exports = lineSlice;
module.exports["default"] = lineSlice;


/***/ }),

/***/ 7971:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var line_intersect_1 = __importDefault(__webpack_require__(3154));
var polygon_to_line_1 = __webpack_require__(4527);
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
var invariant_1 = __webpack_require__(8506);
var helpers_1 = __webpack_require__(8967);
/**
 * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than
 * the maximum dimension of the two source geometries and the intersection set is interior to
 * both source geometries.
 *
 * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.
 *
 * @name booleanCrosses
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var line1 = turf.lineString([[-2, 2], [4, 2]]);
 * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 *
 * var cross = turf.booleanCrosses(line1, line2);
 * //=true
 */
function booleanCrosses(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch (type1) {
        case "MultiPoint":
            switch (type2) {
                case "LineString":
                    return doMultiPointAndLineStringCross(geom1, geom2);
                case "Polygon":
                    return doesMultiPointCrossPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch (type2) {
                case "MultiPoint": // An inverse operation
                    return doMultiPointAndLineStringCross(geom2, geom1);
                case "LineString":
                    return doLineStringsCross(geom1, geom2);
                case "Polygon":
                    return doLineStringAndPolygonCross(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch (type2) {
                case "MultiPoint": // An inverse operation
                    return doesMultiPointCrossPoly(geom2, geom1);
                case "LineString": // An inverse operation
                    return doLineStringAndPolygonCross(geom2, geom1);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function doMultiPointAndLineStringCross(multiPoint, lineString) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    var i = 0;
    while (i < pointLength && !foundIntPoint && !foundExtPoint) {
        for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {
            var incEndVertices = true;
            if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
                incEndVertices = false;
            }
            if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {
                foundIntPoint = true;
            }
            else {
                foundExtPoint = true;
            }
        }
        i++;
    }
    return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
    var doLinesIntersect = line_intersect_1.default(lineString1, lineString2);
    if (doLinesIntersect.features.length > 0) {
        for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
            for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
                var incEndVertices = true;
                if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
                    incEndVertices = false;
                }
                if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function doLineStringAndPolygonCross(lineString, polygon) {
    var line = polygon_to_line_1.polygonToLine(polygon);
    var doLinesIntersect = line_intersect_1.default(lineString, line);
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function doesMultiPointCrossPoly(multiPoint, polygon) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
        if (boolean_point_in_polygon_1.default(helpers_1.point(multiPoint.coordinates[i]), polygon)) {
            foundIntPoint = true;
        }
        else {
            foundExtPoint = true;
        }
    }
    return foundExtPoint && foundIntPoint;
}
/**
 * Is a point on a line segment
 * Only takes into account outer rings
 * See http://stackoverflow.com/a/4833823/1979085
 *
 * @private
 * @param {number[]} lineSegmentStart coord pair of start of line
 * @param {number[]} lineSegmentEnd coord pair of end of line
 * @param {number[]} pt coord pair of point to check
 * @param {boolean} incEnd whether the point is allowed to fall on the line ends
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
    var dxc = pt[0] - lineSegmentStart[0];
    var dyc = pt[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (incEnd) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0
                ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0]
                : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
        return dyl > 0
            ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1]
            : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
    else {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0
                ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0]
                : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
        }
        return dyl > 0
            ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1]
            : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
    }
}
exports["default"] = booleanCrosses;


/***/ }),

/***/ 7974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var booleanPointInPolygon = __webpack_require__(2446);
var clone = __webpack_require__(3711);
var meta = __webpack_require__(8421);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and/or {@link MultiPolygon|multipolygons} and performs a spatial join.
 *
 * @name tag
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon|MultiPolygon>} polygons input (multi)polygons
 * @param {string} field property in `polygons` to add to joined {<Point>} features
 * @param {string} outField property in `points` in which to store joined property from `polygons`
 * @returns {FeatureCollection<Point>} points with `containingPolyId` property containing values from `polyId`
 * @example
 * var pt1 = turf.point([-77, 44]);
 * var pt2 = turf.point([-77, 38]);
 * var poly1 = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]], {pop: 3000});
 * var poly2 = turf.polygon([[
 *   [-81, 35],
 *   [-81, 41],
 *   [-72, 41],
 *   [-72, 35],
 *   [-81, 35]
 * ]], {pop: 1000});
 *
 * var points = turf.featureCollection([pt1, pt2]);
 * var polygons = turf.featureCollection([poly1, poly2]);
 *
 * var tagged = turf.tag(points, polygons, 'pop', 'population');
 *
 * //addToMap
 * var addToMap = [tagged, polygons]
 */
function tag(points, polygons, field, outField) {
  // prevent mutations
  points = clone__default['default'](points);
  polygons = clone__default['default'](polygons);
  meta.featureEach(points, function (pt) {
    if (!pt.properties) pt.properties = {};
    meta.featureEach(polygons, function (poly) {
      if (pt.properties[outField] === undefined) {
        if (booleanPointInPolygon__default['default'](pt, poly))
          pt.properties[outField] = poly.properties[field];
      }
    });
  });
  return points;
}

module.exports = tag;
module.exports["default"] = tag;


/***/ }),

/***/ 8002:
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 8035:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubmitButtons = void 0;
var annotation_1 = __webpack_require__(5573);
var toolbox_1 = __webpack_require__(3045);
var error_logging_1 = __webpack_require__(5638);
var SubmitButtons = /** @class */ (function (_super) {
    __extends(SubmitButtons, _super);
    function SubmitButtons(ulabel) {
        var _a;
        var _this = _super.call(this) || this;
        // Grab the submit buttons from ulabel
        _this.submit_buttons = ulabel.config.submit_buttons;
        // For legacy reasons submit_buttons may be a function, in that case convert it to the right format
        if (typeof _this.submit_buttons == "function") {
            _this.submit_buttons = [{
                    name: "Submit",
                    hook: _this.submit_buttons,
                    row_number: 0,
                    set_saved: false,
                }];
        }
        // Set `set_saved` to false if not provided
        for (var _i = 0, _b = _this.submit_buttons; _i < _b.length; _i++) {
            var button = _b[_i];
            button.set_saved = (_a = button.set_saved) !== null && _a !== void 0 ? _a : false;
        }
        _this.add_styles();
        _this.add_event_listeners();
        _this.submit_buttons_by_row = _this.sort_buttons_by_row_number();
        var _loop_1 = function (idx) {
            // Create a unique event listener for each submit button in the submit buttons array.
            var submit_button_id = SubmitButtons.submit_button_id(this_1.submit_buttons[idx]);
            $(document).on("click.ulabel", "#" + submit_button_id, function () { return __awaiter(_this, void 0, void 0, function () {
                var button, submit_button_elements, i, animation, submit_payload, stkey, annotation, temp_annotation, i, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            button = document.getElementById(submit_button_id);
                            submit_button_elements = Array.from(document.getElementsByClassName("submit-button"));
                            // Make all the buttons look disabled
                            for (i in submit_button_elements) {
                                submit_button_elements[i].disabled = true;
                                submit_button_elements[i].style.filter = "opacity(0.7)";
                            }
                            // Give the clicked button a loading animation
                            button.innerText = "";
                            animation = document.createElement("div");
                            animation.className = "lds-dual-ring";
                            button.appendChild(animation);
                            submit_payload = {
                                task_meta: ulabel.config["task_meta"],
                                annotations: {},
                            };
                            // Loop through all of the subtasks
                            for (stkey in ulabel.subtasks) {
                                submit_payload["annotations"][stkey] = [];
                                annotation = void 0;
                                temp_annotation = void 0;
                                for (i = 0; i < ulabel.subtasks[stkey]["annotations"]["ordering"].length; i++) {
                                    temp_annotation = ulabel.subtasks[stkey]["annotations"]["access"][ulabel.subtasks[stkey]["annotations"]["ordering"][i]];
                                    // Validate the annotation
                                    if (typeof temp_annotation === "object") {
                                        try {
                                            annotation = annotation_1.ULabelAnnotation.from_json(temp_annotation);
                                        }
                                        catch (e) {
                                            (0, error_logging_1.log_message)("Error validating annotation ".concat(temp_annotation, " during submit: ").concat(e, "."), error_logging_1.LogLevel.ERROR, true);
                                            continue;
                                        }
                                    }
                                    // Handle null
                                    if (annotation === null) {
                                        continue;
                                    }
                                    // Skip any delete modes
                                    if (annotation_1.DELETE_MODES.includes(annotation.spatial_type)) {
                                        continue;
                                    }
                                    // Skip spatial annotations that have an empty spatial payload
                                    if (annotation_1.NONSPATIAL_MODES.includes(annotation.spatial_type) ||
                                        annotation.spatial_payload.length === 0) {
                                        continue;
                                    }
                                    // Ensure annotation is within the image if required
                                    if (!ulabel.config.allow_annotations_outside_image) {
                                        annotation.clamp_annotation_to_image_bounds(ulabel.config["image_width"], ulabel.config["image_height"]);
                                    }
                                    submit_payload["annotations"][stkey].push(annotation);
                                }
                            }
                            // Set set_saved if it was provided
                            if (this.submit_buttons[idx].set_saved) {
                                ulabel.set_saved(true);
                            }
                            return [4 /*yield*/, this.submit_buttons[idx].hook(submit_payload)];
                        case 1:
                            _a.sent();
                            // Give the button back its name
                            button.innerText = this.submit_buttons[idx].name;
                            // Re-enable the buttons
                            for (i in submit_button_elements) {
                                submit_button_elements[i].disabled = false;
                                submit_button_elements[i].style.filter = "opacity(1)";
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        };
        var this_1 = this;
        for (var idx in _this.submit_buttons) {
            _loop_1(idx);
        }
        return _this;
    }
    /**
     * Group submit buttons by row number
     *
     * @returns {ULabelSubmitButton[][]} Array of submit buttons grouped by row number
     */
    SubmitButtons.prototype.sort_buttons_by_row_number = function () {
        var submit_buttons_by_row = [];
        // First, get all the unique row numbers.
        // If a button doesn't have a row number, it will be placed in row 0.
        var row_numbers = new Set(this.submit_buttons.map(function (button) { return button.row_number ? button.row_number : 0; }));
        // Sort the row numbers
        var sorted_row_numbers = Array.from(row_numbers).sort(function (a, b) { return a - b; });
        var _loop_2 = function (row_number) {
            submit_buttons_by_row.push(this_2.submit_buttons.filter(function (button) {
                // If the button doesn't have a row number, it will be placed in row 0
                if (button.row_number === undefined) {
                    return row_number === 0;
                }
                // Otherwise, place the button in the row that matches its row number
                return button.row_number === row_number;
            }));
        };
        var this_2 = this;
        // Group the buttons by row number in ascending order
        for (var _i = 0, sorted_row_numbers_1 = sorted_row_numbers; _i < sorted_row_numbers_1.length; _i++) {
            var row_number = sorted_row_numbers_1[_i];
            _loop_2(row_number);
        }
        return submit_buttons_by_row;
    };
    /**
     * Produce a valid ID for the given submit button.
     * Achieved by removing special characters from the `name` property.
     *
     * @param submit_button Submit button to generate ID for
     */
    SubmitButtons.submit_button_id = function (submit_button) {
        // Remove everything except alphanumeric, dash, underscore, space
        var submit_button_id = submit_button.name.replace(/[^a-zA-Z0-9-_ ]/g, "");
        submit_button_id = submit_button_id.trim().toLowerCase().replace(" ", "-");
        return submit_button_id;
    };
    /**
     * Create the css for this ToolboxItem and append it to the page.
     */
    SubmitButtons.prototype.add_styles = function () {
        // Styles defined in blobs.js and get_html()
    };
    SubmitButtons.prototype.add_event_listeners = function () {
        $(document).on("keypress.ulabel", function (event) {
            var ctrl = event.ctrlKey || event.metaKey;
            if (ctrl && (event.key === "s" || event.key === "S")) {
                event.preventDefault();
                $(".submit-button")[0].click(); // Click the first submit button
            }
        });
    };
    SubmitButtons.prototype.get_html = function () {
        var toolboxitem_html = "<div class=\"submit-button-container\">";
        for (var _i = 0, _a = this.submit_buttons_by_row; _i < _a.length; _i++) {
            var submit_buttons = _a[_i];
            // Create a row for each row of submit buttons
            toolboxitem_html += "<div class=\"submit-button-row\">";
            // Create each button in the row
            for (var _b = 0, submit_buttons_1 = submit_buttons; _b < submit_buttons_1.length; _b++) {
                var submit_button = submit_buttons_1[_b];
                var button_color = "rgba(255, 166, 0, 0.739)";
                if (submit_button.color !== undefined) {
                    button_color = submit_button.color;
                }
                // Get the size factor
                var size_factor = 1;
                if (submit_button.size_factor !== undefined) {
                    size_factor = submit_button.size_factor;
                }
                toolboxitem_html += "\n                <button \n                    id=\"".concat(SubmitButtons.submit_button_id(submit_button), "\" \n                    class=\"submit-button\" \n                    style=\"\n                        background-color: ").concat(button_color, ";\n                        border: ").concat(1 * size_factor, "px solid ").concat(button_color, ";\n                        border-radius: ").concat(0.5 * size_factor, "em;\n                        height: ").concat(1.2 * size_factor, "em;\n                        width: ").concat(6 * size_factor, "em;\n                        font-size: ").concat(1.5 * size_factor, "em;\n                        padding: ").concat(1 * size_factor, "em;\n                \">\n                    ").concat(submit_button.name, "\n                </button>\n                ");
            }
            // Close the row div
            toolboxitem_html += "</div>";
        }
        // Close the container div
        toolboxitem_html += "</div>";
        return toolboxitem_html;
    };
    SubmitButtons.prototype.after_init = function () {
        // This toolbox item doesn't need to do anything after initialization
    };
    SubmitButtons.prototype.get_toolbox_item_type = function () {
        return "SubmitButtons";
    };
    return SubmitButtons;
}(toolbox_1.ToolboxItem));
exports.SubmitButtons = SubmitButtons;


/***/ }),

/***/ 8068:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 8075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(453);

var callBind = __webpack_require__(487);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 8118:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
var turf_line_dissolve_1 = __importDefault(__webpack_require__(5335));
var turf_polygon_dissolve_1 = __importDefault(__webpack_require__(9099));
/**
 * Transform function: attempts to dissolve geojson objects where possible
 * [GeoJSON] -> GeoJSON geometry
 *
 * @private
 * @param {FeatureCollection<LineString|MultiLineString|Polygon|MultiPolygon>} geojson Features to dissolved
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] Prevent input mutation
 * @returns {Feature<MultiLineString|MultiPolygon>} Dissolved Features
 */
function dissolve(geojson, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
    }
    var mutate = options.mutate;
    // Validation
    if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    // Clone geojson to avoid side effects
    // Topojson modifies in place, so we need to deep clone first
    if (mutate === false || mutate === undefined) {
        geojson = clone_1.default(geojson);
    }
    // Assert homogenity
    var type = getHomogenousType(geojson);
    if (!type) {
        throw new Error("geojson must be homogenous");
    }
    // Data => Typescript hack
    var data = geojson;
    switch (type) {
        case "LineString":
            return turf_line_dissolve_1.default(data, options);
        case "Polygon":
            return turf_polygon_dissolve_1.default(data, options);
        default:
            throw new Error(type + " is not supported");
    }
}
/**
 * Checks if GeoJSON is Homogenous
 *
 * @private
 * @param {GeoJSON} geojson GeoJSON
 * @returns {string|null} Homogenous type or null if multiple types
 */
function getHomogenousType(geojson) {
    var types = {};
    meta_1.flattenEach(geojson, function (feature) {
        types[feature.geometry.type] = true;
    });
    var keys = Object.keys(types);
    if (keys.length === 1) {
        return keys[0];
    }
    return null;
}
exports["default"] = dissolve;


/***/ }),

/***/ 8220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var invariant = __webpack_require__(8506);

/**
 * Takes a triangular plane as a {@link Polygon}
 * and a {@link Point} within that triangle and returns the z-value
 * at that point. The Polygon should have properties `a`, `b`, and `c`
 * that define the values at its three corners. Alternatively, the z-values
 * of each triangle point can be provided by their respective 3rd coordinate
 * if their values are not provided as properties.
 *
 * @name planepoint
 * @param {Coord} point the Point for which a z-value will be calculated
 * @param {Feature<Polygon>} triangle a Polygon feature with three vertices
 * @returns {number} the z-value for `interpolatedPoint`
 * @example
 * var point = turf.point([-75.3221, 39.529]);
 * // "a", "b", and "c" values represent the values of the coordinates in order.
 * var triangle = turf.polygon([[
 *   [-75.1221, 39.57],
 *   [-75.58, 39.18],
 *   [-75.97, 39.86],
 *   [-75.1221, 39.57]
 * ]], {
 *   "a": 11,
 *   "b": 122,
 *   "c": 44
 * });
 *
 * var zValue = turf.planepoint(point, triangle);
 * point.properties.zValue = zValue;
 *
 * //addToMap
 * var addToMap = [triangle, point];
 */
function planepoint(point, triangle) {
  // Normalize input
  var coord = invariant.getCoord(point);
  var geom = invariant.getGeom(triangle);
  var coords = geom.coordinates;
  var outer = coords[0];
  if (outer.length < 4)
    throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
  var properties = triangle.properties || {};
  var a = properties.a;
  var b = properties.b;
  var c = properties.c;

  // Planepoint
  var x = coord[0];
  var y = coord[1];
  var x1 = outer[0][0];
  var y1 = outer[0][1];
  var z1 = a !== undefined ? a : outer[0][2];
  var x2 = outer[1][0];
  var y2 = outer[1][1];
  var z2 = b !== undefined ? b : outer[1][2];
  var x3 = outer[2][0];
  var y3 = outer[2][1];
  var z3 = c !== undefined ? c : outer[2][2];
  var z =
    (z3 * (x - x1) * (y - y2) +
      z1 * (x - x2) * (y - y3) +
      z2 * (x - x3) * (y - y1) -
      z2 * (x - x1) * (y - y3) -
      z3 * (x - x2) * (y - y1) -
      z1 * (x - x3) * (y - y2)) /
    ((x - x1) * (y - y2) +
      (x - x2) * (y - y3) +
      (x - x3) * (y - y1) -
      (x - x1) * (y - y3) -
      (x - x2) * (y - y1) -
      (x - x3) * (y - y2));

  return z;
}

module.exports = planepoint;
module.exports["default"] = planepoint;


/***/ }),

/***/ 8286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * File for storing useful utilities that are not strictly ULabel related.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.is_object_and_not_array = is_object_and_not_array;
exports.time_function = time_function;
exports.get_active_class_id = get_active_class_id;
exports.set_local_storage_item = set_local_storage_item;
exports.get_local_storage_item = get_local_storage_item;
var annotation_1 = __webpack_require__(5573);
/**
 * Checks if something is an object, not an array, and not null
 *
 * @param object
 * @returns {boolean} Whether or not the passed in value is an object that is neither null or an array
 */
function is_object_and_not_array(object) {
    return (typeof object === "object" && // Make sure the object is indeed an object
        !Array.isArray(object) && // Ensure the object is not an array
        object !== null // null is an object, so make sure the object isn't null
    );
}
/**
 * Wraps a function and logs how long the function takes to run.
 *
 * @param original_function
 * @param function_name String to be added to the beginning of the log. Useful for stating which function was wrapped.
 * @returns
 */
function time_function(original_function, function_name, log_all) {
    if (function_name === void 0) { function_name = ""; }
    if (log_all === void 0) { log_all = false; }
    function replacement_method() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var time_before = Date.now();
        var result = original_function.apply(void 0, args);
        var total_time = Date.now() - time_before;
        if (log_all || total_time > 2)
            console.log("".concat(function_name, " took ").concat(total_time, "ms to complete."));
        return result;
    }
    return replacement_method;
}
function get_active_class_id(ulabel) {
    // Grab the current subtask from the ulabel object
    var current_subtask_key = ulabel.state.current_subtask;
    var current_subtask = ulabel.subtasks[current_subtask_key];
    // If in single_class_mode return the only valid class id
    if (current_subtask.single_class_mode)
        return current_subtask.class_ids[0];
    // If currently in a delete mode, return the DELETE_CLASS_ID
    if (annotation_1.DELETE_MODES.includes(current_subtask.state.annotation_mode))
        return annotation_1.DELETE_CLASS_ID;
    // If the current subtask has more than one valid class id, loop through the id_payloads
    for (var _i = 0, _a = current_subtask.state.id_payload; _i < _a.length; _i++) {
        var payload = _a[_i];
        // If the payload is a number then the user hasn't selected a class yet, so the first class id is the current one
        if (typeof payload === "number")
            return current_subtask.class_ids[0];
        // If the payload is an object then return its id if its confidence is > 0
        if (payload.confidence > 0) {
            console.log("payload: ".concat(payload));
            return payload.class_id;
        }
    }
    console.error("get_active_class_id was unable to determine an active class id.\n    current_subtask: ".concat(JSON.stringify(current_subtask)));
}
/**
 * Save an item to local storage
 *
 * @param key item key
 * @param value value to store
 */
function set_local_storage_item(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
}
/**
 * Retrieve an item from local storage
 *
 * @param key item key
 * @returns value stored at key
 */
function get_local_storage_item(key) {
    var item = localStorage.getItem(key);
    if (item === null)
        return null;
    // Try to parse the item
    // Catch syntax errors from invalid JSON
    try {
        return JSON.parse(item);
    }
    catch (error) {
        console.error("Error parsing item from local storage: ".concat(error));
        return null;
    }
}


/***/ }),

/***/ 8421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var helpers = __webpack_require__(8967);

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
    k,
    l,
    geometry,
    stopG,
    coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    coordIndex = 0,
    isGeometryCollection,
    type = geojson.type,
    isFeatureCollection = type === "FeatureCollection",
    isFeature = type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[featureIndex].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[geomIndex]
        : geometryMaybeCollection;

      // Handles null Geometry -- Skips this geometry
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;

      wrapShrink =
        excludeWrapCoord &&
        (geomType === "Polygon" || geomType === "MultiPolygon")
          ? 1
          : 0;

      switch (geomType) {
        case null:
          break;
        case "Point":
          if (
            callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (
              callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false
            )
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (
                callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (
                  callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false
                )
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (
              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===
              false
            )
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function (
      currentCoord,
      coordIndex,
      featureIndex,
      multiFeatureIndex,
      geometryIndex
    ) {
      if (coordIndex === 0 && initialValue === undefined)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}

/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentFeature;
    else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
  var i,
    j,
    g,
    geometry,
    stopG,
    geometryMaybeCollection,
    isGeometryCollection,
    featureProperties,
    featureBBox,
    featureId,
    featureIndex = 0,
    isFeatureCollection = geojson.type === "FeatureCollection",
    isFeature = geojson.type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[i].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    featureProperties = isFeatureCollection
      ? geojson.features[i].properties
      : isFeature
      ? geojson.properties
      : {};
    featureBBox = isFeatureCollection
      ? geojson.features[i].bbox
      : isFeature
      ? geojson.bbox
      : undefined;
    featureId = isFeatureCollection
      ? geojson.features[i].id
      : isFeature
      ? geojson.id
      : undefined;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[g]
        : geometryMaybeCollection;

      // Handle null Geometry
      if (geometry === null) {
        if (
          callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false
        )
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (
            callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false
          )
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (
              callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    // Only increase `featureIndex` per each feature
    featureIndex++;
  }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function (
      currentGeometry,
      featureIndex,
      featureProperties,
      featureBBox,
      featureId
    ) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (
          callback(
            helpers.feature(geometry, properties, { bbox: bbox, id: id }),
            featureIndex,
            0
          ) === false
        )
          return false;
        return;
    }

    var geomType;

    // Callback for multi-geometry
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }

    for (
      var multiFeatureIndex = 0;
      multiFeatureIndex < geometry.coordinates.length;
      multiFeatureIndex++
    ) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate,
      };
      if (
        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===
        false
      )
        return false;
    }
  });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function (currentFeature, featureIndex, multiFeatureIndex) {
      if (
        featureIndex === 0 &&
        multiFeatureIndex === 0 &&
        initialValue === undefined
      )
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;

    // Exclude null Geometries
    if (!feature.geometry) return;
    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
    var type = feature.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;

    // Generate 2-vertex line segments
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (
      coordEach(
        feature,
        function (
          currentCoord,
          coordIndex,
          featureIndexCoord,
          multiPartIndexCoord,
          geometryIndex
        ) {
          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
          if (
            previousCoords === undefined ||
            featureIndex > previousFeatureIndex ||
            multiPartIndexCoord > previousMultiIndex ||
            geometryIndex > prevGeomIndex
          ) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = helpers.lineString(
            [previousCoords, currentCoord],
            feature.properties
          );
          if (
            callback(
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            ) === false
          )
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false
    )
      return false;
  });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentIndex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function (
      currentSegment,
      featureIndex,
      multiFeatureIndex,
      geometryIndex,
      segmentIndex
    ) {
      if (started === false && initialValue === undefined)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error("geojson is required");

  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (
          var geometryIndex = 0;
          geometryIndex < coords.length;
          geometryIndex++
        ) {
          if (
            callback(
              helpers.lineString(coords[geometryIndex], feature.properties),
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
        }
        break;
    }
  });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find SegmentIndex
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return helpers.lineString(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return helpers.lineString(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return helpers.lineString(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex =
          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return helpers.lineString(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find Coord Index
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
      return helpers.point(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return helpers.point(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return helpers.point(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return helpers.point(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex =
          coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return helpers.point(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

exports.coordAll = coordAll;
exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.findPoint = findPoint;
exports.findSegment = findSegment;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;


/***/ }),

/***/ 8436:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var meta_1 = __webpack_require__(8421);
var invariant_1 = __webpack_require__(8506);
var line_overlap_1 = __importDefault(__webpack_require__(4300));
var line_intersect_1 = __importDefault(__webpack_require__(3154));
var geojson_equality_1 = __importDefault(__webpack_require__(8635));
/**
 * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry
 * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,
 * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.
 *
 * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.
 *
 * @name booleanOverlap
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input
 * @returns {boolean} true/false
 * @example
 * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);
 * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);
 * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);
 *
 * turf.booleanOverlap(poly1, poly2)
 * //=true
 * turf.booleanOverlap(poly2, poly3)
 * //=false
 */
function booleanOverlap(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    if ((type1 === "MultiPoint" && type2 !== "MultiPoint") ||
        ((type1 === "LineString" || type1 === "MultiLineString") &&
            type2 !== "LineString" &&
            type2 !== "MultiLineString") ||
        ((type1 === "Polygon" || type1 === "MultiPolygon") &&
            type2 !== "Polygon" &&
            type2 !== "MultiPolygon")) {
        throw new Error("features must be of the same type");
    }
    if (type1 === "Point")
        throw new Error("Point geometry not supported");
    // features must be not equal
    var equality = new geojson_equality_1.default({ precision: 6 });
    if (equality.compare(feature1, feature2))
        return false;
    var overlap = 0;
    switch (type1) {
        case "MultiPoint":
            for (var i = 0; i < geom1.coordinates.length; i++) {
                for (var j = 0; j < geom2.coordinates.length; j++) {
                    var coord1 = geom1.coordinates[i];
                    var coord2 = geom2.coordinates[j];
                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
                        return true;
                    }
                }
            }
            return false;
        case "LineString":
        case "MultiLineString":
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_overlap_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
        case "Polygon":
        case "MultiPolygon":
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_intersect_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
    }
    return overlap > 0;
}
exports["default"] = booleanOverlap;


/***/ }),

/***/ 8452:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(1189);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(41);

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__(592)();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ 8505:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterDistanceOverlay = void 0;
var annotation_operators_1 = __webpack_require__(2571);
/**
 * Basic class to hold generic methods useful for creating overlays.
 */
var ULabelOverlay = /** @class */ (function () {
    function ULabelOverlay(canvas_width, canvas_height, px_per_px) {
        this.create_canvas(canvas_width, canvas_height);
        this.context = this.canvas.getContext("2d");
        this.px_per_px = px_per_px;
        this.add_styles();
    }
    ULabelOverlay.prototype.add_styles = function () {
        var css = "\n        /* Very Important. Annotation interaction breaks without this property when overlays are present */\n        .ulabel-overlay {\n            pointer-events: none; \n        }";
        // Create an id so this specific style tag can be referenced
        var style_id = "overlay-styles";
        // Don't add the style tag if its already been added once
        if (document.getElementById(style_id))
            return;
        // Grab the document's head and create a style tag
        var head = document.head || document.querySelector("head");
        var style = document.createElement("style");
        // Add the css and id to the style tag
        style.appendChild(document.createTextNode(css));
        style.id = style_id;
        // Add the style tag to the document's head
        head.appendChild(style);
    };
    ULabelOverlay.prototype.create_canvas = function (canvas_width, canvas_height) {
        // Create the canvas element
        this.canvas = document.createElement("canvas");
        // Add a class to identify created overlays
        this.canvas.setAttribute("class", "ulabel-overlay");
        // Set the overlay to be behind the active subtask canvas, but in front of everything else
        this.canvas.style.zIndex = "95";
        this.canvas.style.position = "relative";
        // Set the width and height
        this.canvas.width = canvas_width;
        this.canvas.height = canvas_height;
    };
    /**
     * Resets the true size of the canvas. Should be set to the size of the underlying image.
     *
     * @param new_width Width of the canvas
     * @param new_height Height of the cavas
     */
    ULabelOverlay.prototype.set_canvas_size = function (new_width, new_height) {
        this.canvas.width = new_width;
        this.canvas.height = new_height;
    };
    /**
     * Uses css to resize the canvas. Called when ulabel is rezoomed. Much faster than resizing the actual canvas size.
     *
     * @param new_width Width of the canvas
     * @param new_height Height of the canvas
     */
    ULabelOverlay.prototype.resize_canvas = function (new_width, new_height) {
        this.canvas.style.width = new_width + "px";
        this.canvas.style.height = new_height + "px";
    };
    /**
     * Clears everything drawn to the canvas. Useful for re-drawing.
     */
    ULabelOverlay.prototype.clear_canvas = function () {
        // Clear everything
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    /**
     * Draws a circle centered at (x_position, y_position) with a radius of the passed in radius.
     * Circle is filled in.
     *
     * @param x_position x-position of the circle
     * @param y_position y-position of the circle
     * @param radius The radius of the circle
     */
    ULabelOverlay.prototype.draw_circle = function (point, radius) {
        // Start the shape
        this.context.beginPath();
        // Draw the outline of a circle around the x and y positions with a radius of radius scaled by px_per_px
        this.context.arc(point.x, point.y, radius * this.px_per_px, 0, 2 * Math.PI);
        // Fill the circle
        this.context.fill();
        // Actually apply the shape to the canvas
        this.context.stroke();
    };
    /**
     * A method to get a reference to this object's canvas
     *
     * @returns A reference to this object's canvas
     */
    ULabelOverlay.prototype.get_canvas = function () {
        return this.canvas;
    };
    return ULabelOverlay;
}());
var FilterDistanceOverlay = /** @class */ (function (_super) {
    __extends(FilterDistanceOverlay, _super);
    function FilterDistanceOverlay(canvas_width, canvas_height, polyline_annotations, px_per_px) {
        var _this = _super.call(this, canvas_width, canvas_height, px_per_px) || this;
        _this.distances = { closest_row: undefined }; // The current distance from a line annotation
        // Set the canvas id so it can be referenced easily outside this class
        _this.canvas.setAttribute("id", "ulabel-filter-distance-overlay");
        // Set the annotations that will be used when drawing the overlay
        _this.polyline_annotations = polyline_annotations;
        return _this;
    }
    /**
     * Given the x and y coordinate of two points, this returns a vector that is perpendicular to
     * the line between the two points and has a magnitude of 1.
     *
     * @param endpoint_1
     * @param endpoint_2
     * @returns A normal vector
     */
    FilterDistanceOverlay.prototype.calculate_normal_vector = function (endpoint_1, endpoint_2) {
        // Calculate the x and y of the normal vector
        var normal_x = endpoint_1.y - endpoint_2.y;
        var normal_y = endpoint_2.x - endpoint_1.x;
        // Create a constant scalar value to divide the normal vector by to make its magnitude 1
        var scalar = Math.sqrt((Math.pow(normal_x, 2)) + (Math.pow(normal_y, 2)));
        // Prevent divide by 0 error
        if (scalar === 0) {
            // This will happen when point 1 and point 2 are the same point
            // In which case the concept of a normal vector doesn't really apply
            console.error("claculateNormalVector divide by 0 error");
            return null;
        }
        // Set the magnitude equal to 1
        normal_x /= scalar;
        normal_y /= scalar;
        return {
            x: normal_x,
            y: normal_y,
        };
    };
    /**
     * Given the x and y values of two points, a normal vector, and a distance value, draws a parrallelogram
     * "parallel" to the line segment formed between the two points with a width in each direction of distance.
     *
     * @param endpoint_1 One of the line segment's endpoints
     * @param endpoint_2 One of the line segment's endpoints
     * @param normal_vector Line segment's normal vector
     * @param distance The distance in each direction around the line segment
     */
    FilterDistanceOverlay.prototype.draw_parallelogram_around_line_segment = function (endpoint_1, endpoint_2, normal_vector, distance) {
        // Calculate the change in x and y
        var dx = normal_vector.x * distance * this.px_per_px;
        var dy = normal_vector.y * distance * this.px_per_px;
        // Calculate the 4 corners of the parallelogram
        var corner1 = [endpoint_1.x - dx, endpoint_1.y - dy];
        var corner2 = [endpoint_1.x + dx, endpoint_1.y + dy];
        var corner3 = [endpoint_2.x + dx, endpoint_2.y + dy];
        var corner4 = [endpoint_2.x - dx, endpoint_2.y - dy];
        // Tell the context to begin a new path
        this.context.beginPath();
        this.context.moveTo(corner1[0], corner1[1]);
        this.context.lineTo(corner2[0], corner2[1]);
        this.context.lineTo(corner3[0], corner3[1]);
        this.context.lineTo(corner4[0], corner4[1]);
        this.context.fill();
    };
    FilterDistanceOverlay.prototype.update_annotations = function (polyline_annotations) {
        this.polyline_annotations = polyline_annotations;
    };
    FilterDistanceOverlay.prototype.update_distances = function (distances) {
        this.distances = distances;
    };
    FilterDistanceOverlay.prototype.update_mode = function (multi_class_mode) {
        this.multi_class_mode = multi_class_mode;
    };
    FilterDistanceOverlay.prototype.update_display_overlay = function (display_overlay) {
        this.display_overlay = display_overlay;
    };
    FilterDistanceOverlay.prototype.get_display_overlay = function () {
        return this.display_overlay;
    };
    /**
     * Update the overlay to obscure the parts of the image that fall outside of the distance filter.
     *
     * @param offset Used when an annotation is currently being moved. Offset to be added to the annotation with the matching id to the id inside of the Offset object
     */
    FilterDistanceOverlay.prototype.draw_overlay = function (offset) {
        var _this = this;
        if (offset === void 0) { offset = null; }
        // Clear the canvas in order to have a clean slate to re-draw from
        this.clear_canvas();
        // If the overlay shouldn't be displayed then return after clearing the canvas
        if (!this.display_overlay)
            return;
        // Fill the entire canvas with the overlay that we'll subtract from
        this.context.globalCompositeOperation = "source-over"; // Resetting default
        this.context.fillStyle = "#000000";
        this.context.globalAlpha = 0.5; // So you can slightly see through the overlay
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); // Draws the overlay
        // Set it so that all future shapes we draw subtract from the overlay
        this.context.globalCompositeOperation = "destination-out";
        // Reset default alpha
        this.context.globalAlpha = 1;
        // Subtract the appropriate area from the overlay around each annotation
        this.polyline_annotations.forEach(function (annotation) {
            // Grab the annotation's spatial payload and id
            var spatial_payload = annotation.spatial_payload;
            var annotation_class_id = (0, annotation_operators_1.get_annotation_class_id)(annotation);
            // Use the class id if in multi-class mode, otherwise use the single class distance
            var distance = _this.multi_class_mode ? _this.distances[annotation_class_id].distance : _this.distances.closest_row.distance;
            // length - 1 because the final endpoint doesn't have another endpoint to form a pair with
            for (var idx = 0; idx < spatial_payload.length - 1; idx++) {
                // Look at segment endpoints in pairs
                var endpoint_1 = {
                    x: spatial_payload[idx][0] * _this.px_per_px,
                    y: spatial_payload[idx][1] * _this.px_per_px,
                };
                var endpoint_2 = {
                    x: spatial_payload[idx + 1][0] * _this.px_per_px,
                    y: spatial_payload[idx + 1][1] * _this.px_per_px,
                };
                // If the offset exists and the current annotation id matches the offset id, then scale the each endpoint by the offset diff
                if ((offset !== undefined && offset !== null) && (annotation.id === offset.id)) {
                    endpoint_1.x += (offset.diffX * _this.px_per_px);
                    endpoint_1.y += (offset.diffY * _this.px_per_px);
                    endpoint_2.x += (offset.diffX * _this.px_per_px);
                    endpoint_2.y += (offset.diffY * _this.px_per_px);
                }
                // Get a vector that's perpendicular to endpoint_1 and endpoint_2 and has a magnitude of 1
                var normal_vector = _this.calculate_normal_vector(endpoint_1, endpoint_2);
                /* In the case the endpoint_1 === endpoint_2 the normal vector will be null
                   In which case draw a circle around one endpoint and skip to the next annotation. */
                if (normal_vector === null) {
                    _this.draw_circle(endpoint_1, distance);
                    continue;
                }
                // Only on the first time through draw a circle around the first endpoint
                if (idx === 0)
                    _this.draw_circle(endpoint_1, distance);
                // Draw an endpoint around the second endpoint
                _this.draw_circle(endpoint_2, distance);
                // Draw a parallelogram around the polyline segment
                _this.draw_parallelogram_around_line_segment(endpoint_1, endpoint_2, normal_vector, distance);
            }
        });
    };
    return FilterDistanceOverlay;
}(ULabelOverlay));
exports.FilterDistanceOverlay = FilterDistanceOverlay;


/***/ }),

/***/ 8506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" &&
            coord.geometry !== null &&
            coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) &&
        coord.length >= 2 &&
        !Array.isArray(coord[0]) &&
        !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        helpers_1.isNumber(coordinates[0]) &&
        helpers_1.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;


/***/ }),

/***/ 8509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);
var invariant = __webpack_require__(8506);
var clone = __webpack_require__(3711);
var rhumbDestination = __webpack_require__(7153);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var rhumbDestination__default = /*#__PURE__*/_interopDefaultLegacy(rhumbDestination);

/**
 * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line
 * on the provided direction angle.
 *
 * @name transformTranslate
 * @param {GeoJSON} geojson object to be translated
 * @param {number} distance length of the motion; negative values determine motion in opposite direction
 * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians
 * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} the translated GeoJSON object
 * @example
 * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
 * var translatedPoly = turf.transformTranslate(poly, 100, 35);
 *
 * //addToMap
 * var addToMap = [poly, translatedPoly];
 * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};
 */
function transformTranslate(geojson, distance, direction, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var units = options.units;
  var zTranslation = options.zTranslation;
  var mutate = options.mutate;

  // Input validation
  if (!geojson) throw new Error("geojson is required");
  if (distance === undefined || distance === null || isNaN(distance))
    throw new Error("distance is required");
  if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
    throw new Error("zTranslation is not a number");

  // Shortcut no-motion
  zTranslation = zTranslation !== undefined ? zTranslation : 0;
  if (distance === 0 && zTranslation === 0) return geojson;

  if (direction === undefined || direction === null || isNaN(direction))
    throw new Error("direction is required");

  // Invert with negative distances
  if (distance < 0) {
    distance = -distance;
    direction = direction + 180;
  }

  // Clone geojson to avoid side effects
  if (mutate === false || mutate === undefined) geojson = clone__default['default'](geojson);

  // Translate each coordinate
  meta.coordEach(geojson, function (pointCoords) {
    var newCoords = invariant.getCoords(
      rhumbDestination__default['default'](pointCoords, distance, direction, { units: units })
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
    if (zTranslation && pointCoords.length === 3)
      pointCoords[2] += zTranslation;
  });
  return geojson;
}

module.exports = transformTranslate;
module.exports["default"] = transformTranslate;


/***/ }),

/***/ 8635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//index.js
var deepEqual = __webpack_require__(4982);

var Equality = function(opt) {
  this.precision = opt && opt.precision ? opt.precision : 17;
  this.direction = opt && opt.direction ? opt.direction : false;
  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
};

Equality.prototype.compare = function(g1,g2) {
  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;

  switch(g1.type) {
  case 'Point':
    return this.compareCoord(g1.coordinates, g2.coordinates);
    // removed by dead control flow

  case 'LineString':
    return this.compareLine(g1.coordinates, g2.coordinates,0,false);
    // removed by dead control flow

  case 'Polygon':
    return this.comparePolygon(g1,g2);
    // removed by dead control flow

  case 'Feature':
    return this.compareFeature(g1, g2);
  default:
    if (g1.type.indexOf('Multi') === 0) {
      var context = this;
      var g1s = explode(g1);
      var g2s = explode(g2);
      return g1s.every(function(g1part) {
        return this.some(function(g2part) {
          return context.compare(g1part,g2part);
        });
      },g2s);
    }
  }
  return false;
};

function explode(g) {
  return g.coordinates.map(function(part) {
    return {
      type: g.type.replace('Multi', ''),
      coordinates: part}
  });
}
//compare length of coordinates/array
function sameLength(g1,g2) {
   return g1.hasOwnProperty('coordinates') ?
    g1.coordinates.length === g2.coordinates.length
    : g1.length === g2.length;
}

// compare the two coordinates [x,y]
Equality.prototype.compareCoord = function(c1,c2) {
  if (c1.length !== c2.length) {
    return false;
  }

  for (var i=0; i < c1.length; i++) {
    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
      return false;
    }
  }
  return true;
};

Equality.prototype.compareLine = function(path1,path2,ind,isPoly) {
  if (!sameLength(path1,path2)) return false;
  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
  if (isPoly && !this.compareCoord(p1[0],p2[0])) {
    // fix start index of both to same point
    p2 = this.fixStartIndex(p2,p1);
    if(!p2) return;
  }
  // for linestring ind =0 and for polygon ind =1
  var sameDirection = this.compareCoord(p1[ind],p2[ind]);
  if (this.direction || sameDirection
  ) {
    return this.comparePath(p1, p2);
  } else {
    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])
    ) {
      return this.comparePath(p1.slice().reverse(), p2);
    }
    return false;
  }
};
Equality.prototype.fixStartIndex = function(sourcePath,targetPath) {
  //make sourcePath first point same as of targetPath
  var correctPath,ind = -1;
  for (var i=0; i< sourcePath.length; i++) {
    if(this.compareCoord(sourcePath[i],targetPath[0])) {
      ind = i;
      break;
    }
  }
  if (ind >= 0) {
    correctPath = [].concat(
      sourcePath.slice(ind,sourcePath.length),
      sourcePath.slice(1,ind+1));
  }
  return correctPath;
};
Equality.prototype.comparePath = function (p1,p2) {
  var cont = this;
  return p1.every(function(c,i) {
    return cont.compareCoord(c,this[i]);
  },p2);
};

Equality.prototype.comparePolygon = function(g1,g2) {
  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {
    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);
    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);
    var cont = this;
    return holes1.every(function(h1) {
      return this.some(function(h2) {
        return cont.compareLine(h1,h2,1,true);
      });
    },holes2);
  } else {
    return false;
  }
};

Equality.prototype.compareFeature = function(g1,g2) {
  if (
    g1.id !== g2.id ||
    !this.objectComparator(g1.properties, g2.properties) ||
    !this.compareBBox(g1,g2)
  ) {
    return false;
  }
  return this.compare(g1.geometry, g2.geometry);
};

Equality.prototype.compareBBox = function(g1,g2) {
  if (
    (!g1.bbox && !g2.bbox) || 
    (
      g1.bbox && g2.bbox &&
      this.compareCoord(g1.bbox, g2.bbox)
    )
  )  {
    return true;
  }
  return false;
};
Equality.prototype.removePseudo = function(path) {
  //TODO to be implement
  return path;
};

function objectComparator(obj1, obj2) {
  return deepEqual(obj1, obj2, {strict: true});
}

module.exports = Equality;


/***/ }),

/***/ 8648:
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 8703:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var distance_1 = __importDefault(__webpack_require__(9391));
var meta_1 = __webpack_require__(8421);
var helpers_1 = __webpack_require__(8967);
var density_clustering_1 = __importDefault(__webpack_require__(6112));
/**
 * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.
 *
 * @name clustersDbscan
 * @param {FeatureCollection<Point>} points to be clustered
 * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units="kilometers"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers
 * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated
 * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,
 * points which do not meet this requirement will be classified as an 'edge' or 'noise'.
 * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:
 * - {number} cluster - the associated clusterId
 * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')
 * @example
 * // create random points with random z-values in their properties
 * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});
 * var maxDistance = 100;
 * var clustered = turf.clustersDbscan(points, maxDistance);
 *
 * //addToMap
 * var addToMap = [clustered];
 */
function clustersDbscan(points, maxDistance, options) {
    // Input validation being handled by Typescript
    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');
    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');
    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');
    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');
    if (options === void 0) { options = {}; }
    // Clone points to prevent any mutations
    if (options.mutate !== true)
        points = clone_1.default(points);
    // Defaults
    options.minPoints = options.minPoints || 3;
    // create clustered ids
    var dbscan = new density_clustering_1.default.DBSCAN();
    var clusteredIds = dbscan.run(meta_1.coordAll(points), helpers_1.convertLength(maxDistance, options.units), options.minPoints, distance_1.default);
    // Tag points to Clusters ID
    var clusterId = -1;
    clusteredIds.forEach(function (clusterIds) {
        clusterId++;
        // assign cluster ids to input points
        clusterIds.forEach(function (idx) {
            var clusterPoint = points.features[idx];
            if (!clusterPoint.properties)
                clusterPoint.properties = {};
            clusterPoint.properties.cluster = clusterId;
            clusterPoint.properties.dbscan = "core";
        });
    });
    // handle noise points, if any
    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can "reach" less than 'minPoints' number of points
    dbscan.noise.forEach(function (noiseId) {
        var noisePoint = points.features[noiseId];
        if (!noisePoint.properties)
            noisePoint.properties = {};
        if (noisePoint.properties.cluster)
            noisePoint.properties.dbscan = "edge";
        else
            noisePoint.properties.dbscan = "noise";
    });
    return points;
}
exports["default"] = clustersDbscan;


/***/ }),

/***/ 8748:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bearing = __webpack_require__(1288);
var destination = __webpack_require__(4202);
var distance = __webpack_require__(9391);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bearing__default = /*#__PURE__*/_interopDefaultLegacy(bearing);
var destination__default = /*#__PURE__*/_interopDefaultLegacy(destination);
var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);

/**
 * Takes two {@link Point|points} and returns a point midway between them.
 * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
 *
 * @name midpoint
 * @param {Coord} point1 first point
 * @param {Coord} point2 second point
 * @returns {Feature<Point>} a point midway between `pt1` and `pt2`
 * @example
 * var point1 = turf.point([144.834823, -37.771257]);
 * var point2 = turf.point([145.14244, -37.830937]);
 *
 * var midpoint = turf.midpoint(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2, midpoint];
 * midpoint.properties['marker-color'] = '#f00';
 */
function midpoint(point1, point2) {
  var dist = distance__default['default'](point1, point2);
  var heading = bearing__default['default'](point1, point2);
  var midpoint = destination__default['default'](point1, dist / 2, heading);

  return midpoint;
}

module.exports = midpoint;
module.exports["default"] = midpoint;


/***/ }),

/***/ 8785:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bbox_1 = __importDefault(__webpack_require__(4383));
var invariant_1 = __webpack_require__(8506);
var helpers_1 = __webpack_require__(8967);
var clone_1 = __importDefault(__webpack_require__(3711));
/**
 * Converts (Multi)LineString(s) to Polygon(s).
 *
 * @name lineToPolygon
 * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert
 * @param {Object} [options={}] Optional parameters
 * @param {Object} [options.properties={}] translates GeoJSON properties to Feature
 * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)
 * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates
 * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)
 * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons
 * @example
 * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);
 *
 * var polygon = turf.lineToPolygon(line);
 *
 * //addToMap
 * var addToMap = [polygon];
 */
function lineToPolygon(lines, options) {
    if (options === void 0) { options = {}; }
    var _a, _b, _c;
    // Optional parameters
    var properties = options.properties;
    var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;
    var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;
    var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;
    if (!mutate) {
        lines = clone_1.default(lines);
    }
    switch (lines.type) {
        case "FeatureCollection":
            var coords = [];
            lines.features.forEach(function (line) {
                coords.push(invariant_1.getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
            });
            return helpers_1.multiPolygon(coords, properties);
        default:
            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
    }
}
/**
 * LineString to Polygon
 *
 * @private
 * @param {Feature<LineString|MultiLineString>} line line
 * @param {Object} [properties] translates GeoJSON properties to Feature
 * @param {boolean} [autoComplete=true] auto complete linestrings
 * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates
 * @returns {Feature<Polygon>} line converted to Polygon
 */
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
    properties = properties
        ? properties
        : line.type === "Feature"
            ? line.properties
            : {};
    var geom = invariant_1.getGeom(line);
    var coords = geom.coordinates;
    var type = geom.type;
    if (!coords.length)
        throw new Error("line must contain coordinates");
    switch (type) {
        case "LineString":
            if (autoComplete)
                coords = autoCompleteCoords(coords);
            return helpers_1.polygon([coords], properties);
        case "MultiLineString":
            var multiCoords = [];
            var largestArea = 0;
            coords.forEach(function (coord) {
                if (autoComplete)
                    coord = autoCompleteCoords(coord);
                // Largest LineString to be placed in the first position of the coordinates array
                if (orderCoords) {
                    var area = calculateArea(bbox_1.default(helpers_1.lineString(coord)));
                    if (area > largestArea) {
                        multiCoords.unshift(coord);
                        largestArea = area;
                    }
                    else
                        multiCoords.push(coord);
                }
                else {
                    multiCoords.push(coord);
                }
            });
            return helpers_1.polygon(multiCoords, properties);
        default:
            throw new Error("geometry type " + type + " is not supported");
    }
}
/**
 * Auto Complete Coords - matches first & last coordinates
 *
 * @private
 * @param {Array<Array<number>>} coords Coordinates
 * @returns {Array<Array<number>>} auto completed coordinates
 */
function autoCompleteCoords(coords) {
    var first = coords[0];
    var x1 = first[0];
    var y1 = first[1];
    var last = coords[coords.length - 1];
    var x2 = last[0];
    var y2 = last[1];
    if (x1 !== x2 || y1 !== y2) {
        coords.push(first);
    }
    return coords;
}
/**
 * area - quick approximate area calculation (used to sort)
 *
 * @private
 * @param {Array<number>} bbox BBox [west, south, east, north]
 * @returns {number} very quick area calculation
 */
function calculateArea(bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    return Math.abs(west - east) * Math.abs(south - north);
}
exports["default"] = lineToPolygon;


/***/ }),

/***/ 8828:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Node_1 = __importDefault(__webpack_require__(6518));
var Edge_1 = __importDefault(__webpack_require__(6088));
var EdgeRing_1 = __importDefault(__webpack_require__(9977));
var meta_1 = __webpack_require__(8421);
var invariant_1 = __webpack_require__(8506);
/**
 * Validates the geoJson.
 *
 * @param {GeoJSON} geoJson - input geoJson.
 * @throws {Error} if geoJson is invalid.
 */
function validateGeoJson(geoJson) {
    if (!geoJson)
        throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" &&
        geoJson.type !== "GeometryCollection" &&
        geoJson.type !== "MultiLineString" &&
        geoJson.type !== "LineString" &&
        geoJson.type !== "Feature")
        throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
}
/**
 * Represents a planar graph of edges and nodes that can be used to compute a polygonization.
 *
 * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,
 * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it
 * isn't a javascript transcription of the C++ source.
 *
 * This graph is directed (both directions are created)
 */
var Graph = /** @class */ (function () {
    function Graph() {
        this.edges = []; //< {Edge[]} dirEdges
        // The key is the `id` of the Node (ie: coordinates.join(','))
        this.nodes = {};
    }
    /**
     * Creates a graph from a GeoJSON.
     *
     * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index
     * @returns {Graph} - The newly created graph
     * @throws {Error} if geoJson is invalid.
     */
    Graph.fromGeoJson = function (geoJson) {
        validateGeoJson(geoJson);
        var graph = new Graph();
        meta_1.flattenEach(geoJson, function (feature) {
            invariant_1.featureOf(feature, "LineString", "Graph::fromGeoJson");
            // When a LineString if formed by many segments, split them
            meta_1.coordReduce(feature, function (prev, cur) {
                if (prev) {
                    var start = graph.getNode(prev), end = graph.getNode(cur);
                    graph.addEdge(start, end);
                }
                return cur;
            });
        });
        return graph;
    };
    /**
     * Creates or get a Node.
     *
     * @param {number[]} coordinates - Coordinates of the node
     * @returns {Node} - The created or stored node
     */
    Graph.prototype.getNode = function (coordinates) {
        var id = Node_1.default.buildId(coordinates);
        var node = this.nodes[id];
        if (!node)
            node = this.nodes[id] = new Node_1.default(coordinates);
        return node;
    };
    /**
     * Adds an Edge and its symetricall.
     *
     * Edges are added symetrically, i.e.: we also add its symetric
     *
     * @param {Node} from - Node which starts the Edge
     * @param {Node} to - Node which ends the Edge
     */
    Graph.prototype.addEdge = function (from, to) {
        var edge = new Edge_1.default(from, to), symetricEdge = edge.getSymetric();
        this.edges.push(edge);
        this.edges.push(symetricEdge);
    };
    /**
     * Removes Dangle Nodes (nodes with grade 1).
     */
    Graph.prototype.deleteDangles = function () {
        var _this = this;
        Object.keys(this.nodes)
            .map(function (id) { return _this.nodes[id]; })
            .forEach(function (node) { return _this._removeIfDangle(node); });
    };
    /**
     * Check if node is dangle, if so, remove it.
     *
     * It calls itself recursively, removing a dangling node might cause another dangling node
     *
     * @param {Node} node - Node to check if it's a dangle
     */
    Graph.prototype._removeIfDangle = function (node) {
        var _this = this;
        // As edges are directed and symetrical, we count only innerEdges
        if (node.innerEdges.length <= 1) {
            var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });
            this.removeNode(node);
            outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });
        }
    };
    /**
     * Delete cut-edges (bridge edges).
     *
     * The graph will be traversed, all the edges will be labeled according the ring
     * in which they are. (The label is a number incremented by 1). Edges with the same
     * label are cut-edges.
     */
    Graph.prototype.deleteCutEdges = function () {
        var _this = this;
        this._computeNextCWEdges();
        this._findLabeledEdgeRings();
        // Cut-edges (bridges) are edges where both edges have the same label
        this.edges.forEach(function (edge) {
            if (edge.label === edge.symetric.label) {
                _this.removeEdge(edge.symetric);
                _this.removeEdge(edge);
            }
        });
    };
    /**
     * Set the `next` property of each Edge.
     *
     * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.
     * OuterEdges are sorted CCW.
     *
     * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph
     */
    Graph.prototype._computeNextCWEdges = function (node) {
        var _this = this;
        if (typeof node === "undefined") {
            Object.keys(this.nodes).forEach(function (id) {
                return _this._computeNextCWEdges(_this.nodes[id]);
            });
        }
        else {
            node.getOuterEdges().forEach(function (edge, i) {
                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
            });
        }
    };
    /**
     * Computes the next edge pointers going CCW around the given node, for the given edgering label.
     *
     * This algorithm has the effect of converting maximal edgerings into minimal edgerings
     *
     * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,
     * could be written in a more javascript way.
     *
     * @param {Node} node - Node
     * @param {number} label - Ring's label
     */
    Graph.prototype._computeNextCCWEdges = function (node, label) {
        var edges = node.getOuterEdges();
        var firstOutDE, prevInDE;
        for (var i = edges.length - 1; i >= 0; --i) {
            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;
            if (de.label === label)
                outDE = de;
            if (sym.label === label)
                inDE = sym;
            if (!outDE || !inDE)
                // This edge is not in edgering
                continue;
            if (inDE)
                prevInDE = inDE;
            if (outDE) {
                if (prevInDE) {
                    prevInDE.next = outDE;
                    prevInDE = undefined;
                }
                if (!firstOutDE)
                    firstOutDE = outDE;
            }
        }
        if (prevInDE)
            prevInDE.next = firstOutDE;
    };
    /**
     * Finds rings and labels edges according to which rings are.
     *
     * The label is a number which is increased for each ring.
     *
     * @returns {Edge[]} edges that start rings
     */
    Graph.prototype._findLabeledEdgeRings = function () {
        var edgeRingStarts = [];
        var label = 0;
        this.edges.forEach(function (edge) {
            if (edge.label >= 0)
                return;
            edgeRingStarts.push(edge);
            var e = edge;
            do {
                e.label = label;
                e = e.next;
            } while (!edge.isEqual(e));
            label++;
        });
        return edgeRingStarts;
    };
    /**
     * Computes the EdgeRings formed by the edges in this graph.
     *
     * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.
     */
    Graph.prototype.getEdgeRings = function () {
        var _this = this;
        this._computeNextCWEdges();
        // Clear labels
        this.edges.forEach(function (edge) {
            edge.label = undefined;
        });
        this._findLabeledEdgeRings().forEach(function (edge) {
            // convertMaximalToMinimalEdgeRings
            _this._findIntersectionNodes(edge).forEach(function (node) {
                _this._computeNextCCWEdges(node, edge.label);
            });
        });
        var edgeRingList = [];
        // find all edgerings
        this.edges.forEach(function (edge) {
            if (edge.ring)
                return;
            edgeRingList.push(_this._findEdgeRing(edge));
        });
        return edgeRingList;
    };
    /**
     * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.
     *
     * @param {Node} startEdge - Start Edge of the Ring
     * @returns {Node[]} - intersection nodes
     */
    Graph.prototype._findIntersectionNodes = function (startEdge) {
        var intersectionNodes = [];
        var edge = startEdge;
        var _loop_1 = function () {
            // getDegree
            var degree = 0;
            edge.from.getOuterEdges().forEach(function (e) {
                if (e.label === startEdge.label)
                    ++degree;
            });
            if (degree > 1)
                intersectionNodes.push(edge.from);
            edge = edge.next;
        };
        do {
            _loop_1();
        } while (!startEdge.isEqual(edge));
        return intersectionNodes;
    };
    /**
     * Get the edge-ring which starts from the provided Edge.
     *
     * @param {Edge} startEdge - starting edge of the edge ring
     * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.
     */
    Graph.prototype._findEdgeRing = function (startEdge) {
        var edge = startEdge;
        var edgeRing = new EdgeRing_1.default();
        do {
            edgeRing.push(edge);
            edge.ring = edgeRing;
            edge = edge.next;
        } while (!startEdge.isEqual(edge));
        return edgeRing;
    };
    /**
     * Removes a node from the Graph.
     *
     * It also removes edges asociated to that node
     * @param {Node} node - Node to be removed
     */
    Graph.prototype.removeNode = function (node) {
        var _this = this;
        node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });
        node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });
        delete this.nodes[node.id];
    };
    /**
     * Remove edge from the graph and deletes the edge.
     *
     * @param {Edge} edge - Edge to be removed
     */
    Graph.prototype.removeEdge = function (edge) {
        this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });
        edge.deleteEdge();
    };
    return Graph;
}());
exports["default"] = Graph;


/***/ }),

/***/ 8840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var distance_1 = __importDefault(__webpack_require__(9391));
var meta_1 = __webpack_require__(8421);
/**
 * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.
 *
 * @name length
 * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {number} length of GeoJSON
 * @example
 * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);
 * var length = turf.length(line, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line];
 * line.properties.distance = length;
 */
function length(geojson, options) {
    if (options === void 0) { options = {}; }
    // Calculate distance from 2-vertex line segments
    return meta_1.segmentReduce(geojson, function (previousValue, segment) {
        var coords = segment.geometry.coordinates;
        return previousValue + distance_1.default(coords[0], coords[1], options);
    }, 0);
}
exports["default"] = length;


/***/ }),

/***/ 8875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(1093); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ 8967:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.37,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius * 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1.0936133,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    hectares: 0.0001,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, _options) {
    if (_options === void 0) { _options = {}; }
    switch (type) {
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return (degrees * 180) / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return (radians * Math.PI) / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return !!input && input.constructor === Object;
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;


/***/ }),

/***/ 8968:
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 9004:
/***/ (function(module) {

(function (global, factory) {
     true ? module.exports = factory() :
    0;
})(this, (function () { 'use strict';

    /**
     * splaytree v3.1.2
     * Fast Splay tree for Node and browser
     *
     * @author Alexander Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __generator(thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }
    var Node = /** @class */function () {
      function Node(key, data) {
        this.next = null;
        this.key = key;
        this.data = data;
        this.left = null;
        this.right = null;
      }
      return Node;
    }();

    /* follows "An implementation of top-down splaying"
     * by D. Sleator <sleator@cs.cmu.edu> March 1992
     */
    function DEFAULT_COMPARE(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * Simple top down splay, not requiring i to be in the tree t.
     */
    function splay(i, t, comparator) {
      var N = new Node(null, null);
      var l = N;
      var r = N;
      while (true) {
        var cmp = comparator(i, t.key);
        //if (i < t.key) {
        if (cmp < 0) {
          if (t.left === null) break;
          //if (i < t.left.key) {
          if (comparator(i, t.left.key) < 0) {
            var y = t.left; /* rotate right */
            t.left = y.right;
            y.right = t;
            t = y;
            if (t.left === null) break;
          }
          r.left = t; /* link right */
          r = t;
          t = t.left;
          //} else if (i > t.key) {
        } else if (cmp > 0) {
          if (t.right === null) break;
          //if (i > t.right.key) {
          if (comparator(i, t.right.key) > 0) {
            var y = t.right; /* rotate left */
            t.right = y.left;
            y.left = t;
            t = y;
            if (t.right === null) break;
          }
          l.right = t; /* link left */
          l = t;
          t = t.right;
        } else break;
      }
      /* assemble */
      l.right = t.left;
      r.left = t.right;
      t.left = N.right;
      t.right = N.left;
      return t;
    }
    function insert(i, data, t, comparator) {
      var node = new Node(i, data);
      if (t === null) {
        node.left = node.right = null;
        return node;
      }
      t = splay(i, t, comparator);
      var cmp = comparator(i, t.key);
      if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp >= 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      return node;
    }
    function split(key, v, comparator) {
      var left = null;
      var right = null;
      if (v) {
        v = splay(key, v, comparator);
        var cmp = comparator(v.key, key);
        if (cmp === 0) {
          left = v.left;
          right = v.right;
        } else if (cmp < 0) {
          right = v.right;
          v.right = null;
          left = v;
        } else {
          left = v.left;
          v.left = null;
          right = v;
        }
      }
      return {
        left: left,
        right: right
      };
    }
    function merge(left, right, comparator) {
      if (right === null) return left;
      if (left === null) return right;
      right = splay(left.key, right, comparator);
      right.left = left;
      return right;
    }
    /**
     * Prints level of the tree
     */
    function printRow(root, prefix, isTail, out, printNode) {
      if (root) {
        out("" + prefix + (isTail ? ' ' : ' ') + printNode(root) + "\n");
        var indent = prefix + (isTail ? '    ' : '   ');
        if (root.left) printRow(root.left, indent, false, out, printNode);
        if (root.right) printRow(root.right, indent, true, out, printNode);
      }
    }
    var Tree = /** @class */function () {
      function Tree(comparator) {
        if (comparator === void 0) {
          comparator = DEFAULT_COMPARE;
        }
        this._root = null;
        this._size = 0;
        this._comparator = comparator;
      }
      /**
       * Inserts a key, allows duplicates
       */
      Tree.prototype.insert = function (key, data) {
        this._size++;
        return this._root = insert(key, data, this._root, this._comparator);
      };
      /**
       * Adds a key, if it is not present in the tree
       */
      Tree.prototype.add = function (key, data) {
        var node = new Node(key, data);
        if (this._root === null) {
          node.left = node.right = null;
          this._size++;
          this._root = node;
        }
        var comparator = this._comparator;
        var t = splay(key, this._root, comparator);
        var cmp = comparator(key, t.key);
        if (cmp === 0) this._root = t;else {
          if (cmp < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp > 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          this._size++;
          this._root = node;
        }
        return this._root;
      };
      /**
       * @param  {Key} key
       * @return {Node|null}
       */
      Tree.prototype.remove = function (key) {
        this._root = this._remove(key, this._root, this._comparator);
      };
      /**
       * Deletes i from the tree if it's there
       */
      Tree.prototype._remove = function (i, t, comparator) {
        var x;
        if (t === null) return null;
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp === 0) {
          /* found it */
          if (t.left === null) {
            x = t.right;
          } else {
            x = splay(i, t.left, comparator);
            x.right = t.right;
          }
          this._size--;
          return x;
        }
        return t; /* It wasn't there */
      };
      /**
       * Removes and returns the node with smallest key
       */
      Tree.prototype.pop = function () {
        var node = this._root;
        if (node) {
          while (node.left) node = node.left;
          this._root = splay(node.key, this._root, this._comparator);
          this._root = this._remove(node.key, this._root, this._comparator);
          return {
            key: node.key,
            data: node.data
          };
        }
        return null;
      };
      /**
       * Find without splaying
       */
      Tree.prototype.findStatic = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
          var cmp = compare(key, current.key);
          if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;
        }
        return null;
      };
      Tree.prototype.find = function (key) {
        if (this._root) {
          this._root = splay(key, this._root, this._comparator);
          if (this._comparator(key, this._root.key) !== 0) return null;
        }
        return this._root;
      };
      Tree.prototype.contains = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
          var cmp = compare(key, current.key);
          if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;
        }
        return false;
      };
      Tree.prototype.forEach = function (visitor, ctx) {
        var current = this._root;
        var Q = []; /* Initialize stack s */
        var done = false;
        while (!done) {
          if (current !== null) {
            Q.push(current);
            current = current.left;
          } else {
            if (Q.length !== 0) {
              current = Q.pop();
              visitor.call(ctx, current);
              current = current.right;
            } else done = true;
          }
        }
        return this;
      };
      /**
       * Walk key range from `low` to `high`. Stops if `fn` returns a value.
       */
      Tree.prototype.range = function (low, high, fn, ctx) {
        var Q = [];
        var compare = this._comparator;
        var node = this._root;
        var cmp;
        while (Q.length !== 0 || node) {
          if (node) {
            Q.push(node);
            node = node.left;
          } else {
            node = Q.pop();
            cmp = compare(node.key, high);
            if (cmp > 0) {
              break;
            } else if (compare(node.key, low) >= 0) {
              if (fn.call(ctx, node)) return this; // stop if smth is returned
            }
            node = node.right;
          }
        }
        return this;
      };
      /**
       * Returns array of keys
       */
      Tree.prototype.keys = function () {
        var keys = [];
        this.forEach(function (_a) {
          var key = _a.key;
          return keys.push(key);
        });
        return keys;
      };
      /**
       * Returns array of all the data in the nodes
       */
      Tree.prototype.values = function () {
        var values = [];
        this.forEach(function (_a) {
          var data = _a.data;
          return values.push(data);
        });
        return values;
      };
      Tree.prototype.min = function () {
        if (this._root) return this.minNode(this._root).key;
        return null;
      };
      Tree.prototype.max = function () {
        if (this._root) return this.maxNode(this._root).key;
        return null;
      };
      Tree.prototype.minNode = function (t) {
        if (t === void 0) {
          t = this._root;
        }
        if (t) while (t.left) t = t.left;
        return t;
      };
      Tree.prototype.maxNode = function (t) {
        if (t === void 0) {
          t = this._root;
        }
        if (t) while (t.right) t = t.right;
        return t;
      };
      /**
       * Returns node at given index
       */
      Tree.prototype.at = function (index) {
        var current = this._root;
        var done = false;
        var i = 0;
        var Q = [];
        while (!done) {
          if (current) {
            Q.push(current);
            current = current.left;
          } else {
            if (Q.length > 0) {
              current = Q.pop();
              if (i === index) return current;
              i++;
              current = current.right;
            } else done = true;
          }
        }
        return null;
      };
      Tree.prototype.next = function (d) {
        var root = this._root;
        var successor = null;
        if (d.right) {
          successor = d.right;
          while (successor.left) successor = successor.left;
          return successor;
        }
        var comparator = this._comparator;
        while (root) {
          var cmp = comparator(d.key, root.key);
          if (cmp === 0) break;else if (cmp < 0) {
            successor = root;
            root = root.left;
          } else root = root.right;
        }
        return successor;
      };
      Tree.prototype.prev = function (d) {
        var root = this._root;
        var predecessor = null;
        if (d.left !== null) {
          predecessor = d.left;
          while (predecessor.right) predecessor = predecessor.right;
          return predecessor;
        }
        var comparator = this._comparator;
        while (root) {
          var cmp = comparator(d.key, root.key);
          if (cmp === 0) break;else if (cmp < 0) root = root.left;else {
            predecessor = root;
            root = root.right;
          }
        }
        return predecessor;
      };
      Tree.prototype.clear = function () {
        this._root = null;
        this._size = 0;
        return this;
      };
      Tree.prototype.toList = function () {
        return toList(this._root);
      };
      /**
       * Bulk-load items. Both array have to be same size
       */
      Tree.prototype.load = function (keys, values, presort) {
        if (values === void 0) {
          values = [];
        }
        if (presort === void 0) {
          presort = false;
        }
        var size = keys.length;
        var comparator = this._comparator;
        // sort if needed
        if (presort) sort(keys, values, 0, size - 1, comparator);
        if (this._root === null) {
          // empty tree
          this._root = loadRecursive(keys, values, 0, size);
          this._size = size;
        } else {
          // that re-builds the whole tree from two in-order traversals
          var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
          size = this._size + size;
          this._root = sortedListToBST({
            head: mergedList
          }, 0, size);
        }
        return this;
      };
      Tree.prototype.isEmpty = function () {
        return this._root === null;
      };
      Object.defineProperty(Tree.prototype, "size", {
        get: function () {
          return this._size;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Tree.prototype, "root", {
        get: function () {
          return this._root;
        },
        enumerable: true,
        configurable: true
      });
      Tree.prototype.toString = function (printNode) {
        if (printNode === void 0) {
          printNode = function (n) {
            return String(n.key);
          };
        }
        var out = [];
        printRow(this._root, '', true, function (v) {
          return out.push(v);
        }, printNode);
        return out.join('');
      };
      Tree.prototype.update = function (key, newKey, newData) {
        var comparator = this._comparator;
        var _a = split(key, this._root, comparator),
          left = _a.left,
          right = _a.right;
        if (comparator(key, newKey) < 0) {
          right = insert(newKey, newData, right, comparator);
        } else {
          left = insert(newKey, newData, left, comparator);
        }
        this._root = merge(left, right, comparator);
      };
      Tree.prototype.split = function (key) {
        return split(key, this._root, this._comparator);
      };
      Tree.prototype[Symbol.iterator] = function () {
        var current, Q, done;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              current = this._root;
              Q = [];
              done = false;
              _a.label = 1;
            case 1:
              if (!!done) return [3 /*break*/, 6];
              if (!(current !== null)) return [3 /*break*/, 2];
              Q.push(current);
              current = current.left;
              return [3 /*break*/, 5];
            case 2:
              if (!(Q.length !== 0)) return [3 /*break*/, 4];
              current = Q.pop();
              return [4 /*yield*/, current];
            case 3:
              _a.sent();
              current = current.right;
              return [3 /*break*/, 5];
            case 4:
              done = true;
              _a.label = 5;
            case 5:
              return [3 /*break*/, 1];
            case 6:
              return [2 /*return*/];
          }
        });
      };
      return Tree;
    }();
    function loadRecursive(keys, values, start, end) {
      var size = end - start;
      if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var key = keys[middle];
        var data = values[middle];
        var node = new Node(key, data);
        node.left = loadRecursive(keys, values, start, middle);
        node.right = loadRecursive(keys, values, middle + 1, end);
        return node;
      }
      return null;
    }
    function createList(keys, values) {
      var head = new Node(null, null);
      var p = head;
      for (var i = 0; i < keys.length; i++) {
        p = p.next = new Node(keys[i], values[i]);
      }
      p.next = null;
      return head.next;
    }
    function toList(root) {
      var current = root;
      var Q = [];
      var done = false;
      var head = new Node(null, null);
      var p = head;
      while (!done) {
        if (current) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length > 0) {
            current = p = p.next = Q.pop();
            current = current.right;
          } else done = true;
        }
      }
      p.next = null; // that'll work even if the tree was empty
      return head.next;
    }
    function sortedListToBST(list, start, end) {
      var size = end - start;
      if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var left = sortedListToBST(list, start, middle);
        var root = list.head;
        root.left = left;
        list.head = list.head.next;
        root.right = sortedListToBST(list, middle + 1, end);
        return root;
      }
      return null;
    }
    function mergeLists(l1, l2, compare) {
      var head = new Node(null, null); // dummy
      var p = head;
      var p1 = l1;
      var p2 = l2;
      while (p1 !== null && p2 !== null) {
        if (compare(p1.key, p2.key) < 0) {
          p.next = p1;
          p1 = p1.next;
        } else {
          p.next = p2;
          p2 = p2.next;
        }
        p = p.next;
      }
      if (p1 !== null) {
        p.next = p1;
      } else if (p2 !== null) {
        p.next = p2;
      }
      return head.next;
    }
    function sort(keys, values, left, right, compare) {
      if (left >= right) return;
      var pivot = keys[left + right >> 1];
      var i = left - 1;
      var j = right + 1;
      while (true) {
        do i++; while (compare(keys[i], pivot) < 0);
        do j--; while (compare(keys[j], pivot) > 0);
        if (i >= j) break;
        var tmp = keys[i];
        keys[i] = keys[j];
        keys[j] = tmp;
        tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
      }
      sort(keys, values, left, j, compare);
      sort(keys, values, j + 1, right, compare);
    }

    /**
     * A bounding box has the format:
     *
     *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
     *
     */

    const isInBbox = (bbox, point) => {
      return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
    };

    /* Returns either null, or a bbox (aka an ordered pair of points)
     * If there is only one point of overlap, a bbox with identical points
     * will be returned */
    const getBboxOverlap = (b1, b2) => {
      // check if the bboxes overlap at all
      if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;

      // find the middle two X values
      const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
      const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;

      // find the middle two Y values
      const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
      const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;

      // put those middle values together to get the overlap
      return {
        ll: {
          x: lowerX,
          y: lowerY
        },
        ur: {
          x: upperX,
          y: upperY
        }
      };
    };

    /* Javascript doesn't do integer math. Everything is
     * floating point with percision Number.EPSILON.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
     */

    let epsilon$1 = Number.EPSILON;

    // IE Polyfill
    if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);
    const EPSILON_SQ = epsilon$1 * epsilon$1;

    /* FLP comparator */
    const cmp = (a, b) => {
      // check if they're both 0
      if (-epsilon$1 < a && a < epsilon$1) {
        if (-epsilon$1 < b && b < epsilon$1) {
          return 0;
        }
      }

      // check if they're flp equal
      const ab = a - b;
      if (ab * ab < EPSILON_SQ * a * b) {
        return 0;
      }

      // normal comparison
      return a < b ? -1 : 1;
    };

    /**
     * This class rounds incoming values sufficiently so that
     * floating points problems are, for the most part, avoided.
     *
     * Incoming points are have their x & y values tested against
     * all previously seen x & y values. If either is 'too close'
     * to a previously seen value, it's value is 'snapped' to the
     * previously seen value.
     *
     * All points should be rounded by this class before being
     * stored in any data structures in the rest of this algorithm.
     */

    class PtRounder {
      constructor() {
        this.reset();
      }
      reset() {
        this.xRounder = new CoordRounder();
        this.yRounder = new CoordRounder();
      }
      round(x, y) {
        return {
          x: this.xRounder.round(x),
          y: this.yRounder.round(y)
        };
      }
    }
    class CoordRounder {
      constructor() {
        this.tree = new Tree();
        // preseed with 0 so we don't end up with values < Number.EPSILON
        this.round(0);
      }

      // Note: this can rounds input values backwards or forwards.
      //       You might ask, why not restrict this to just rounding
      //       forwards? Wouldn't that allow left endpoints to always
      //       remain left endpoints during splitting (never change to
      //       right). No - it wouldn't, because we snap intersections
      //       to endpoints (to establish independence from the segment
      //       angle for t-intersections).
      round(coord) {
        const node = this.tree.add(coord);
        const prevNode = this.tree.prev(node);
        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
          this.tree.remove(coord);
          return prevNode.key;
        }
        const nextNode = this.tree.next(node);
        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
          this.tree.remove(coord);
          return nextNode.key;
        }
        return coord;
      }
    }

    // singleton available by import
    const rounder = new PtRounder();

    const epsilon = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon) * epsilon;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum(elen, e, flen, f, h) {
      let Q, Qnew, hh, bvirt;
      let enow = e[0];
      let fnow = f[0];
      let eindex = 0;
      let findex = 0;
      if (fnow > enow === fnow > -enow) {
        Q = enow;
        enow = e[++eindex];
      } else {
        Q = fnow;
        fnow = f[++findex];
      }
      let hindex = 0;
      if (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = enow + Q;
          hh = Q - (Qnew - enow);
          enow = e[++eindex];
        } else {
          Qnew = fnow + Q;
          hh = Q - (Qnew - fnow);
          fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
        while (eindex < elen && findex < flen) {
          if (fnow > enow === fnow > -enow) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
          } else {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
          }
          Q = Qnew;
          if (hh !== 0) {
            h[hindex++] = hh;
          }
        }
      }
      while (eindex < elen) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
      while (findex < flen) {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
      if (Q !== 0 || hindex === 0) {
        h[hindex++] = Q;
      }
      return hindex;
    }
    function estimate(elen, e) {
      let Q = e[0];
      for (let i = 1; i < elen; i++) Q += e[i];
      return Q;
    }
    function vec(n) {
      return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    const ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);
    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
      let acxtail, acytail, bcxtail, bcytail;
      let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
      const acx = ax - cx;
      const bcx = bx - cx;
      const acy = ay - cy;
      const bcy = by - cy;
      s1 = acx * bcy;
      c = splitter * acx;
      ahi = c - (c - acx);
      alo = acx - ahi;
      c = splitter * bcy;
      bhi = c - (c - bcy);
      blo = bcy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = acy * bcx;
      c = splitter * acy;
      ahi = c - (c - acy);
      alo = acy - ahi;
      c = splitter * bcx;
      bhi = c - (c - bcx);
      blo = bcx - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      B[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      B[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      B[2] = _j - (u3 - bvirt) + (_i - bvirt);
      B[3] = u3;
      let det = estimate(4, B);
      let errbound = ccwerrboundB * detsum;
      if (det >= errbound || -det >= errbound) {
        return det;
      }
      bvirt = ax - acx;
      acxtail = ax - (acx + bvirt) + (bvirt - cx);
      bvirt = bx - bcx;
      bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
      bvirt = ay - acy;
      acytail = ay - (acy + bvirt) + (bvirt - cy);
      bvirt = by - bcy;
      bcytail = by - (bcy + bvirt) + (bvirt - cy);
      if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
        return det;
      }
      errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
      det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
      if (det >= errbound || -det >= errbound) return det;
      s1 = acxtail * bcy;
      c = splitter * acxtail;
      ahi = c - (c - acxtail);
      alo = acxtail - ahi;
      c = splitter * bcy;
      bhi = c - (c - bcy);
      blo = bcy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = acytail * bcx;
      c = splitter * acytail;
      ahi = c - (c - acytail);
      alo = acytail - ahi;
      c = splitter * bcx;
      bhi = c - (c - bcx);
      blo = bcx - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const C1len = sum(4, B, 4, u, C1);
      s1 = acx * bcytail;
      c = splitter * acx;
      ahi = c - (c - acx);
      alo = acx - ahi;
      c = splitter * bcytail;
      bhi = c - (c - bcytail);
      blo = bcytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = acy * bcxtail;
      c = splitter * acy;
      ahi = c - (c - acy);
      alo = acy - ahi;
      c = splitter * bcxtail;
      bhi = c - (c - bcxtail);
      blo = bcxtail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const C2len = sum(C1len, C1, 4, u, C2);
      s1 = acxtail * bcytail;
      c = splitter * acxtail;
      ahi = c - (c - acxtail);
      alo = acxtail - ahi;
      c = splitter * bcytail;
      bhi = c - (c - bcytail);
      blo = bcytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = acytail * bcxtail;
      c = splitter * acytail;
      ahi = c - (c - acytail);
      alo = acytail - ahi;
      c = splitter * bcxtail;
      bhi = c - (c - bcxtail);
      blo = bcxtail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const Dlen = sum(C2len, C2, 4, u, D);
      return D[Dlen - 1];
    }
    function orient2d(ax, ay, bx, by, cx, cy) {
      const detleft = (ay - cy) * (bx - cx);
      const detright = (ax - cx) * (by - cy);
      const det = detleft - detright;
      const detsum = Math.abs(detleft + detright);
      if (Math.abs(det) >= ccwerrboundA * detsum) return det;
      return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    /* Cross Product of two vectors with first point at origin */
    const crossProduct = (a, b) => a.x * b.y - a.y * b.x;

    /* Dot Product of two vectors with first point at origin */
    const dotProduct = (a, b) => a.x * b.x + a.y * b.y;

    /* Comparator for two vectors with same starting point */
    const compareVectorAngles = (basePt, endPt1, endPt2) => {
      const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
      if (res > 0) return -1;
      if (res < 0) return 1;
      return 0;
    };
    const length = v => Math.sqrt(dotProduct(v, v));

    /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */
    const sineOfAngle = (pShared, pBase, pAngle) => {
      const vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      const vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };

    /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */
    const cosineOfAngle = (pShared, pBase, pAngle) => {
      const vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      const vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };

    /* Get the x coordinate where the given line (defined by a point and vector)
     * crosses the horizontal line with the given y coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */
    const horizontalIntersection = (pt, v, y) => {
      if (v.y === 0) return null;
      return {
        x: pt.x + v.x / v.y * (y - pt.y),
        y: y
      };
    };

    /* Get the y coordinate where the given line (defined by a point and vector)
     * crosses the vertical line with the given x coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */
    const verticalIntersection = (pt, v, x) => {
      if (v.x === 0) return null;
      return {
        x: x,
        y: pt.y + v.y / v.x * (x - pt.x)
      };
    };

    /* Get the intersection of two lines, each defined by a base point and a vector.
     * In the case of parrallel lines (including overlapping ones) returns null. */
    const intersection$1 = (pt1, v1, pt2, v2) => {
      // take some shortcuts for vertical and horizontal lines
      // this also ensures we don't calculate an intersection and then discover
      // it's actually outside the bounding box of the line
      if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
      if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
      if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
      if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);

      // General case for non-overlapping segments.
      // This algorithm is based on Schneider and Eberly.
      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

      const kross = crossProduct(v1, v2);
      if (kross == 0) return null;
      const ve = {
        x: pt2.x - pt1.x,
        y: pt2.y - pt1.y
      };
      const d1 = crossProduct(ve, v1) / kross;
      const d2 = crossProduct(ve, v2) / kross;

      // take the average of the two calculations to minimize rounding error
      const x1 = pt1.x + d2 * v1.x,
        x2 = pt2.x + d1 * v2.x;
      const y1 = pt1.y + d2 * v1.y,
        y2 = pt2.y + d1 * v2.y;
      const x = (x1 + x2) / 2;
      const y = (y1 + y2) / 2;
      return {
        x: x,
        y: y
      };
    };

    class SweepEvent {
      // for ordering sweep events in the sweep event queue
      static compare(a, b) {
        // favor event with a point that the sweep line hits first
        const ptCmp = SweepEvent.comparePoints(a.point, b.point);
        if (ptCmp !== 0) return ptCmp;

        // the points are the same, so link them if needed
        if (a.point !== b.point) a.link(b);

        // favor right events over left
        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;

        // we have two matching left or right endpoints
        // ordering of this case is the same as for their segments
        return Segment.compare(a.segment, b.segment);
      }

      // for ordering points in sweep line order
      static comparePoints(aPt, bPt) {
        if (aPt.x < bPt.x) return -1;
        if (aPt.x > bPt.x) return 1;
        if (aPt.y < bPt.y) return -1;
        if (aPt.y > bPt.y) return 1;
        return 0;
      }

      // Warning: 'point' input will be modified and re-used (for performance)
      constructor(point, isLeft) {
        if (point.events === undefined) point.events = [this];else point.events.push(this);
        this.point = point;
        this.isLeft = isLeft;
        // this.segment, this.otherSE set by factory
      }
      link(other) {
        if (other.point === this.point) {
          throw new Error("Tried to link already linked events");
        }
        const otherEvents = other.point.events;
        for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
          const evt = otherEvents[i];
          this.point.events.push(evt);
          evt.point = this.point;
        }
        this.checkForConsuming();
      }

      /* Do a pass over our linked events and check to see if any pair
       * of segments match, and should be consumed. */
      checkForConsuming() {
        // FIXME: The loops in this method run O(n^2) => no good.
        //        Maintain little ordered sweep event trees?
        //        Can we maintaining an ordering that avoids the need
        //        for the re-sorting with getLeftmostComparator in geom-out?

        // Compare each pair of events to see if other events also match
        const numEvents = this.point.events.length;
        for (let i = 0; i < numEvents; i++) {
          const evt1 = this.point.events[i];
          if (evt1.segment.consumedBy !== undefined) continue;
          for (let j = i + 1; j < numEvents; j++) {
            const evt2 = this.point.events[j];
            if (evt2.consumedBy !== undefined) continue;
            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
            evt1.segment.consume(evt2.segment);
          }
        }
      }
      getAvailableLinkedEvents() {
        // point.events is always of length 2 or greater
        const events = [];
        for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
          const evt = this.point.events[i];
          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
            events.push(evt);
          }
        }
        return events;
      }

      /**
       * Returns a comparator function for sorting linked events that will
       * favor the event that will give us the smallest left-side angle.
       * All ring construction starts as low as possible heading to the right,
       * so by always turning left as sharp as possible we'll get polygons
       * without uncessary loops & holes.
       *
       * The comparator function has a compute cache such that it avoids
       * re-computing already-computed values.
       */
      getLeftmostComparator(baseEvent) {
        const cache = new Map();
        const fillCache = linkedEvent => {
          const nextEvent = linkedEvent.otherSE;
          cache.set(linkedEvent, {
            sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
            cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
          });
        };
        return (a, b) => {
          if (!cache.has(a)) fillCache(a);
          if (!cache.has(b)) fillCache(b);
          const {
            sine: asine,
            cosine: acosine
          } = cache.get(a);
          const {
            sine: bsine,
            cosine: bcosine
          } = cache.get(b);

          // both on or above x-axis
          if (asine >= 0 && bsine >= 0) {
            if (acosine < bcosine) return 1;
            if (acosine > bcosine) return -1;
            return 0;
          }

          // both below x-axis
          if (asine < 0 && bsine < 0) {
            if (acosine < bcosine) return -1;
            if (acosine > bcosine) return 1;
            return 0;
          }

          // one above x-axis, one below
          if (bsine < asine) return -1;
          if (bsine > asine) return 1;
          return 0;
        };
      }
    }

    // Give segments unique ID's to get consistent sorting of
    // segments and sweep events when all else is identical
    let segmentId = 0;
    class Segment {
      /* This compare() function is for ordering segments in the sweep
       * line tree, and does so according to the following criteria:
       *
       * Consider the vertical line that lies an infinestimal step to the
       * right of the right-more of the two left endpoints of the input
       * segments. Imagine slowly moving a point up from negative infinity
       * in the increasing y direction. Which of the two segments will that
       * point intersect first? That segment comes 'before' the other one.
       *
       * If neither segment would be intersected by such a line, (if one
       * or more of the segments are vertical) then the line to be considered
       * is directly on the right-more of the two left inputs.
       */
      static compare(a, b) {
        const alx = a.leftSE.point.x;
        const blx = b.leftSE.point.x;
        const arx = a.rightSE.point.x;
        const brx = b.rightSE.point.x;

        // check if they're even in the same vertical plane
        if (brx < alx) return 1;
        if (arx < blx) return -1;
        const aly = a.leftSE.point.y;
        const bly = b.leftSE.point.y;
        const ary = a.rightSE.point.y;
        const bry = b.rightSE.point.y;

        // is left endpoint of segment B the right-more?
        if (alx < blx) {
          // are the two segments in the same horizontal plane?
          if (bly < aly && bly < ary) return 1;
          if (bly > aly && bly > ary) return -1;

          // is the B left endpoint colinear to segment A?
          const aCmpBLeft = a.comparePoint(b.leftSE.point);
          if (aCmpBLeft < 0) return 1;
          if (aCmpBLeft > 0) return -1;

          // is the A right endpoint colinear to segment B ?
          const bCmpARight = b.comparePoint(a.rightSE.point);
          if (bCmpARight !== 0) return bCmpARight;

          // colinear segments, consider the one with left-more
          // left endpoint to be first (arbitrary?)
          return -1;
        }

        // is left endpoint of segment A the right-more?
        if (alx > blx) {
          if (aly < bly && aly < bry) return -1;
          if (aly > bly && aly > bry) return 1;

          // is the A left endpoint colinear to segment B?
          const bCmpALeft = b.comparePoint(a.leftSE.point);
          if (bCmpALeft !== 0) return bCmpALeft;

          // is the B right endpoint colinear to segment A?
          const aCmpBRight = a.comparePoint(b.rightSE.point);
          if (aCmpBRight < 0) return 1;
          if (aCmpBRight > 0) return -1;

          // colinear segments, consider the one with left-more
          // left endpoint to be first (arbitrary?)
          return 1;
        }

        // if we get here, the two left endpoints are in the same
        // vertical plane, ie alx === blx

        // consider the lower left-endpoint to come first
        if (aly < bly) return -1;
        if (aly > bly) return 1;

        // left endpoints are identical
        // check for colinearity by using the left-more right endpoint

        // is the A right endpoint more left-more?
        if (arx < brx) {
          const bCmpARight = b.comparePoint(a.rightSE.point);
          if (bCmpARight !== 0) return bCmpARight;
        }

        // is the B right endpoint more left-more?
        if (arx > brx) {
          const aCmpBRight = a.comparePoint(b.rightSE.point);
          if (aCmpBRight < 0) return 1;
          if (aCmpBRight > 0) return -1;
        }
        if (arx !== brx) {
          // are these two [almost] vertical segments with opposite orientation?
          // if so, the one with the lower right endpoint comes first
          const ay = ary - aly;
          const ax = arx - alx;
          const by = bry - bly;
          const bx = brx - blx;
          if (ay > ax && by < bx) return 1;
          if (ay < ax && by > bx) return -1;
        }

        // we have colinear segments with matching orientation
        // consider the one with more left-more right endpoint to be first
        if (arx > brx) return 1;
        if (arx < brx) return -1;

        // if we get here, two two right endpoints are in the same
        // vertical plane, ie arx === brx

        // consider the lower right-endpoint to come first
        if (ary < bry) return -1;
        if (ary > bry) return 1;

        // right endpoints identical as well, so the segments are idential
        // fall back on creation order as consistent tie-breaker
        if (a.id < b.id) return -1;
        if (a.id > b.id) return 1;

        // identical segment, ie a === b
        return 0;
      }

      /* Warning: a reference to ringWindings input will be stored,
       *  and possibly will be later modified */
      constructor(leftSE, rightSE, rings, windings) {
        this.id = ++segmentId;
        this.leftSE = leftSE;
        leftSE.segment = this;
        leftSE.otherSE = rightSE;
        this.rightSE = rightSE;
        rightSE.segment = this;
        rightSE.otherSE = leftSE;
        this.rings = rings;
        this.windings = windings;
        // left unset for performance, set later in algorithm
        // this.ringOut, this.consumedBy, this.prev
      }
      static fromRing(pt1, pt2, ring) {
        let leftPt, rightPt, winding;

        // ordering the two points according to sweep line ordering
        const cmpPts = SweepEvent.comparePoints(pt1, pt2);
        if (cmpPts < 0) {
          leftPt = pt1;
          rightPt = pt2;
          winding = 1;
        } else if (cmpPts > 0) {
          leftPt = pt2;
          rightPt = pt1;
          winding = -1;
        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
        const leftSE = new SweepEvent(leftPt, true);
        const rightSE = new SweepEvent(rightPt, false);
        return new Segment(leftSE, rightSE, [ring], [winding]);
      }

      /* When a segment is split, the rightSE is replaced with a new sweep event */
      replaceRightSE(newRightSE) {
        this.rightSE = newRightSE;
        this.rightSE.segment = this;
        this.rightSE.otherSE = this.leftSE;
        this.leftSE.otherSE = this.rightSE;
      }
      bbox() {
        const y1 = this.leftSE.point.y;
        const y2 = this.rightSE.point.y;
        return {
          ll: {
            x: this.leftSE.point.x,
            y: y1 < y2 ? y1 : y2
          },
          ur: {
            x: this.rightSE.point.x,
            y: y1 > y2 ? y1 : y2
          }
        };
      }

      /* A vector from the left point to the right */
      vector() {
        return {
          x: this.rightSE.point.x - this.leftSE.point.x,
          y: this.rightSE.point.y - this.leftSE.point.y
        };
      }
      isAnEndpoint(pt) {
        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
      }

      /* Compare this segment with a point.
       *
       * A point P is considered to be colinear to a segment if there
       * exists a distance D such that if we travel along the segment
       * from one * endpoint towards the other a distance D, we find
       * ourselves at point P.
       *
       * Return value indicates:
       *
       *   1: point lies above the segment (to the left of vertical)
       *   0: point is colinear to segment
       *  -1: point lies below the segment (to the right of vertical)
       */
      comparePoint(point) {
        if (this.isAnEndpoint(point)) return 0;
        const lPt = this.leftSE.point;
        const rPt = this.rightSE.point;
        const v = this.vector();

        // Exactly vertical segments.
        if (lPt.x === rPt.x) {
          if (point.x === lPt.x) return 0;
          return point.x < lPt.x ? 1 : -1;
        }

        // Nearly vertical segments with an intersection.
        // Check to see where a point on the line with matching Y coordinate is.
        const yDist = (point.y - lPt.y) / v.y;
        const xFromYDist = lPt.x + yDist * v.x;
        if (point.x === xFromYDist) return 0;

        // General case.
        // Check to see where a point on the line with matching X coordinate is.
        const xDist = (point.x - lPt.x) / v.x;
        const yFromXDist = lPt.y + xDist * v.y;
        if (point.y === yFromXDist) return 0;
        return point.y < yFromXDist ? -1 : 1;
      }

      /**
       * Given another segment, returns the first non-trivial intersection
       * between the two segments (in terms of sweep line ordering), if it exists.
       *
       * A 'non-trivial' intersection is one that will cause one or both of the
       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
       *
       *   * endpoint of segA with endpoint of segB --> trivial
       *   * endpoint of segA with point along segB --> non-trivial
       *   * endpoint of segB with point along segA --> non-trivial
       *   * point along segA with point along segB --> non-trivial
       *
       * If no non-trivial intersection exists, return null
       * Else, return null.
       */
      getIntersection(other) {
        // If bboxes don't overlap, there can't be any intersections
        const tBbox = this.bbox();
        const oBbox = other.bbox();
        const bboxOverlap = getBboxOverlap(tBbox, oBbox);
        if (bboxOverlap === null) return null;

        // We first check to see if the endpoints can be considered intersections.
        // This will 'snap' intersections to endpoints if possible, and will
        // handle cases of colinearity.

        const tlp = this.leftSE.point;
        const trp = this.rightSE.point;
        const olp = other.leftSE.point;
        const orp = other.rightSE.point;

        // does each endpoint touch the other segment?
        // note that we restrict the 'touching' definition to only allow segments
        // to touch endpoints that lie forward from where we are in the sweep line pass
        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;

        // do left endpoints match?
        if (touchesThisLSE && touchesOtherLSE) {
          // these two cases are for colinear segments with matching left
          // endpoints, and one segment being longer than the other
          if (touchesThisRSE && !touchesOtherRSE) return trp;
          if (!touchesThisRSE && touchesOtherRSE) return orp;
          // either the two segments match exactly (two trival intersections)
          // or just on their left endpoint (one trivial intersection
          return null;
        }

        // does this left endpoint matches (other doesn't)
        if (touchesThisLSE) {
          // check for segments that just intersect on opposing endpoints
          if (touchesOtherRSE) {
            if (tlp.x === orp.x && tlp.y === orp.y) return null;
          }
          // t-intersection on left endpoint
          return tlp;
        }

        // does other left endpoint matches (this doesn't)
        if (touchesOtherLSE) {
          // check for segments that just intersect on opposing endpoints
          if (touchesThisRSE) {
            if (trp.x === olp.x && trp.y === olp.y) return null;
          }
          // t-intersection on left endpoint
          return olp;
        }

        // trivial intersection on right endpoints
        if (touchesThisRSE && touchesOtherRSE) return null;

        // t-intersections on just one right endpoint
        if (touchesThisRSE) return trp;
        if (touchesOtherRSE) return orp;

        // None of our endpoints intersect. Look for a general intersection between
        // infinite lines laid over the segments
        const pt = intersection$1(tlp, this.vector(), olp, other.vector());

        // are the segments parrallel? Note that if they were colinear with overlap,
        // they would have an endpoint intersection and that case was already handled above
        if (pt === null) return null;

        // is the intersection found between the lines not on the segments?
        if (!isInBbox(bboxOverlap, pt)) return null;

        // round the the computed point if needed
        return rounder.round(pt.x, pt.y);
      }

      /**
       * Split the given segment into multiple segments on the given points.
       *  * Each existing segment will retain its leftSE and a new rightSE will be
       *    generated for it.
       *  * A new segment will be generated which will adopt the original segment's
       *    rightSE, and a new leftSE will be generated for it.
       *  * If there are more than two points given to split on, new segments
       *    in the middle will be generated with new leftSE and rightSE's.
       *  * An array of the newly generated SweepEvents will be returned.
       *
       * Warning: input array of points is modified
       */
      split(point) {
        const newEvents = [];
        const alreadyLinked = point.events !== undefined;
        const newLeftSE = new SweepEvent(point, true);
        const newRightSE = new SweepEvent(point, false);
        const oldRightSE = this.rightSE;
        this.replaceRightSE(newRightSE);
        newEvents.push(newRightSE);
        newEvents.push(newLeftSE);
        const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());

        // when splitting a nearly vertical downward-facing segment,
        // sometimes one of the resulting new segments is vertical, in which
        // case its left and right events may need to be swapped
        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
          newSeg.swapEvents();
        }
        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
          this.swapEvents();
        }

        // in the point we just used to create new sweep events with was already
        // linked to other events, we need to check if either of the affected
        // segments should be consumed
        if (alreadyLinked) {
          newLeftSE.checkForConsuming();
          newRightSE.checkForConsuming();
        }
        return newEvents;
      }

      /* Swap which event is left and right */
      swapEvents() {
        const tmpEvt = this.rightSE;
        this.rightSE = this.leftSE;
        this.leftSE = tmpEvt;
        this.leftSE.isLeft = true;
        this.rightSE.isLeft = false;
        for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
          this.windings[i] *= -1;
        }
      }

      /* Consume another segment. We take their rings under our wing
       * and mark them as consumed. Use for perfectly overlapping segments */
      consume(other) {
        let consumer = this;
        let consumee = other;
        while (consumer.consumedBy) consumer = consumer.consumedBy;
        while (consumee.consumedBy) consumee = consumee.consumedBy;
        const cmp = Segment.compare(consumer, consumee);
        if (cmp === 0) return; // already consumed
        // the winner of the consumption is the earlier segment
        // according to sweep line ordering
        if (cmp > 0) {
          const tmp = consumer;
          consumer = consumee;
          consumee = tmp;
        }

        // make sure a segment doesn't consume it's prev
        if (consumer.prev === consumee) {
          const tmp = consumer;
          consumer = consumee;
          consumee = tmp;
        }
        for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
          const ring = consumee.rings[i];
          const winding = consumee.windings[i];
          const index = consumer.rings.indexOf(ring);
          if (index === -1) {
            consumer.rings.push(ring);
            consumer.windings.push(winding);
          } else consumer.windings[index] += winding;
        }
        consumee.rings = null;
        consumee.windings = null;
        consumee.consumedBy = consumer;

        // mark sweep events consumed as to maintain ordering in sweep event queue
        consumee.leftSE.consumedBy = consumer.leftSE;
        consumee.rightSE.consumedBy = consumer.rightSE;
      }

      /* The first segment previous segment chain that is in the result */
      prevInResult() {
        if (this._prevInResult !== undefined) return this._prevInResult;
        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
        return this._prevInResult;
      }
      beforeState() {
        if (this._beforeState !== undefined) return this._beforeState;
        if (!this.prev) this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };else {
          const seg = this.prev.consumedBy || this.prev;
          this._beforeState = seg.afterState();
        }
        return this._beforeState;
      }
      afterState() {
        if (this._afterState !== undefined) return this._afterState;
        const beforeState = this.beforeState();
        this._afterState = {
          rings: beforeState.rings.slice(0),
          windings: beforeState.windings.slice(0),
          multiPolys: []
        };
        const ringsAfter = this._afterState.rings;
        const windingsAfter = this._afterState.windings;
        const mpsAfter = this._afterState.multiPolys;

        // calculate ringsAfter, windingsAfter
        for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
          const ring = this.rings[i];
          const winding = this.windings[i];
          const index = ringsAfter.indexOf(ring);
          if (index === -1) {
            ringsAfter.push(ring);
            windingsAfter.push(winding);
          } else windingsAfter[index] += winding;
        }

        // calcualte polysAfter
        const polysAfter = [];
        const polysExclude = [];
        for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
          if (windingsAfter[i] === 0) continue; // non-zero rule
          const ring = ringsAfter[i];
          const poly = ring.poly;
          if (polysExclude.indexOf(poly) !== -1) continue;
          if (ring.isExterior) polysAfter.push(poly);else {
            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
            const index = polysAfter.indexOf(ring.poly);
            if (index !== -1) polysAfter.splice(index, 1);
          }
        }

        // calculate multiPolysAfter
        for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
          const mp = polysAfter[i].multiPoly;
          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
        }
        return this._afterState;
      }

      /* Is this segment part of the final result? */
      isInResult() {
        // if we've been consumed, we're not in the result
        if (this.consumedBy) return false;
        if (this._isInResult !== undefined) return this._isInResult;
        const mpsBefore = this.beforeState().multiPolys;
        const mpsAfter = this.afterState().multiPolys;
        switch (operation.type) {
          case "union":
            {
              // UNION - included iff:
              //  * On one side of us there is 0 poly interiors AND
              //  * On the other side there is 1 or more.
              const noBefores = mpsBefore.length === 0;
              const noAfters = mpsAfter.length === 0;
              this._isInResult = noBefores !== noAfters;
              break;
            }
          case "intersection":
            {
              // INTERSECTION - included iff:
              //  * on one side of us all multipolys are rep. with poly interiors AND
              //  * on the other side of us, not all multipolys are repsented
              //    with poly interiors
              let least;
              let most;
              if (mpsBefore.length < mpsAfter.length) {
                least = mpsBefore.length;
                most = mpsAfter.length;
              } else {
                least = mpsAfter.length;
                most = mpsBefore.length;
              }
              this._isInResult = most === operation.numMultiPolys && least < most;
              break;
            }
          case "xor":
            {
              // XOR - included iff:
              //  * the difference between the number of multipolys represented
              //    with poly interiors on our two sides is an odd number
              const diff = Math.abs(mpsBefore.length - mpsAfter.length);
              this._isInResult = diff % 2 === 1;
              break;
            }
          case "difference":
            {
              // DIFFERENCE included iff:
              //  * on exactly one side, we have just the subject
              const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;
              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
              break;
            }
          default:
            throw new Error(`Unrecognized operation type found ${operation.type}`);
        }
        return this._isInResult;
      }
    }

    class RingIn {
      constructor(geomRing, poly, isExterior) {
        if (!Array.isArray(geomRing) || geomRing.length === 0) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.poly = poly;
        this.isExterior = isExterior;
        this.segments = [];
        if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
        this.bbox = {
          ll: {
            x: firstPoint.x,
            y: firstPoint.y
          },
          ur: {
            x: firstPoint.x,
            y: firstPoint.y
          }
        };
        let prevPoint = firstPoint;
        for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
          if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          let point = rounder.round(geomRing[i][0], geomRing[i][1]);
          // skip repeated points
          if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
          this.segments.push(Segment.fromRing(prevPoint, point, this));
          if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
          if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
          if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
          if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
          prevPoint = point;
        }
        // add segment from last to first if last is not the same as first
        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
          this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
      }
      getSweepEvents() {
        const sweepEvents = [];
        for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
          const segment = this.segments[i];
          sweepEvents.push(segment.leftSE);
          sweepEvents.push(segment.rightSE);
        }
        return sweepEvents;
      }
    }
    class PolyIn {
      constructor(geomPoly, multiPoly) {
        if (!Array.isArray(geomPoly)) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.exteriorRing = new RingIn(geomPoly[0], this, true);
        // copy by value
        this.bbox = {
          ll: {
            x: this.exteriorRing.bbox.ll.x,
            y: this.exteriorRing.bbox.ll.y
          },
          ur: {
            x: this.exteriorRing.bbox.ur.x,
            y: this.exteriorRing.bbox.ur.y
          }
        };
        this.interiorRings = [];
        for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
          const ring = new RingIn(geomPoly[i], this, false);
          if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
          if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
          if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
          if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
          this.interiorRings.push(ring);
        }
        this.multiPoly = multiPoly;
      }
      getSweepEvents() {
        const sweepEvents = this.exteriorRing.getSweepEvents();
        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
          const ringSweepEvents = this.interiorRings[i].getSweepEvents();
          for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
            sweepEvents.push(ringSweepEvents[j]);
          }
        }
        return sweepEvents;
      }
    }
    class MultiPolyIn {
      constructor(geom, isSubject) {
        if (!Array.isArray(geom)) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        try {
          // if the input looks like a polygon, convert it to a multipolygon
          if (typeof geom[0][0][0] === "number") geom = [geom];
        } catch (ex) {
          // The input is either malformed or has empty arrays.
          // In either case, it will be handled later on.
        }
        this.polys = [];
        this.bbox = {
          ll: {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
          },
          ur: {
            x: Number.NEGATIVE_INFINITY,
            y: Number.NEGATIVE_INFINITY
          }
        };
        for (let i = 0, iMax = geom.length; i < iMax; i++) {
          const poly = new PolyIn(geom[i], this);
          if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
          if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
          if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
          if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
          this.polys.push(poly);
        }
        this.isSubject = isSubject;
      }
      getSweepEvents() {
        const sweepEvents = [];
        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
          const polySweepEvents = this.polys[i].getSweepEvents();
          for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
            sweepEvents.push(polySweepEvents[j]);
          }
        }
        return sweepEvents;
      }
    }

    class RingOut {
      /* Given the segments from the sweep line pass, compute & return a series
       * of closed rings from all the segments marked to be part of the result */
      static factory(allSegments) {
        const ringsOut = [];
        for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
          const segment = allSegments[i];
          if (!segment.isInResult() || segment.ringOut) continue;
          let prevEvent = null;
          let event = segment.leftSE;
          let nextEvent = segment.rightSE;
          const events = [event];
          const startingPoint = event.point;
          const intersectionLEs = [];

          /* Walk the chain of linked events to form a closed ring */
          while (true) {
            prevEvent = event;
            event = nextEvent;
            events.push(event);

            /* Is the ring complete? */
            if (event.point === startingPoint) break;
            while (true) {
              const availableLEs = event.getAvailableLinkedEvents();

              /* Did we hit a dead end? This shouldn't happen.
               * Indicates some earlier part of the algorithm malfunctioned. */
              if (availableLEs.length === 0) {
                const firstPt = events[0].point;
                const lastPt = events[events.length - 1].point;
                throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);
              }

              /* Only one way to go, so cotinue on the path */
              if (availableLEs.length === 1) {
                nextEvent = availableLEs[0].otherSE;
                break;
              }

              /* We must have an intersection. Check for a completed loop */
              let indexLE = null;
              for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                if (intersectionLEs[j].point === event.point) {
                  indexLE = j;
                  break;
                }
              }
              /* Found a completed loop. Cut that off and make a ring */
              if (indexLE !== null) {
                const intersectionLE = intersectionLEs.splice(indexLE)[0];
                const ringEvents = events.splice(intersectionLE.index);
                ringEvents.unshift(ringEvents[0].otherSE);
                ringsOut.push(new RingOut(ringEvents.reverse()));
                continue;
              }
              /* register the intersection */
              intersectionLEs.push({
                index: events.length,
                point: event.point
              });
              /* Choose the left-most option to continue the walk */
              const comparator = event.getLeftmostComparator(prevEvent);
              nextEvent = availableLEs.sort(comparator)[0].otherSE;
              break;
            }
          }
          ringsOut.push(new RingOut(events));
        }
        return ringsOut;
      }
      constructor(events) {
        this.events = events;
        for (let i = 0, iMax = events.length; i < iMax; i++) {
          events[i].segment.ringOut = this;
        }
        this.poly = null;
      }
      getGeom() {
        // Remove superfluous points (ie extra points along a straight line),
        let prevPt = this.events[0].point;
        const points = [prevPt];
        for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
          const pt = this.events[i].point;
          const nextPt = this.events[i + 1].point;
          if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;
          points.push(pt);
          prevPt = pt;
        }

        // ring was all (within rounding error of angle calc) colinear points
        if (points.length === 1) return null;

        // check if the starting point is necessary
        const pt = points[0];
        const nextPt = points[1];
        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
        points.push(points[0]);
        const step = this.isExteriorRing() ? 1 : -1;
        const iStart = this.isExteriorRing() ? 0 : points.length - 1;
        const iEnd = this.isExteriorRing() ? points.length : -1;
        const orderedPoints = [];
        for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);
        return orderedPoints;
      }
      isExteriorRing() {
        if (this._isExteriorRing === undefined) {
          const enclosing = this.enclosingRing();
          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
        }
        return this._isExteriorRing;
      }
      enclosingRing() {
        if (this._enclosingRing === undefined) {
          this._enclosingRing = this._calcEnclosingRing();
        }
        return this._enclosingRing;
      }

      /* Returns the ring that encloses this one, if any */
      _calcEnclosingRing() {
        // start with the ealier sweep line event so that the prevSeg
        // chain doesn't lead us inside of a loop of ours
        let leftMostEvt = this.events[0];
        for (let i = 1, iMax = this.events.length; i < iMax; i++) {
          const evt = this.events[i];
          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
        }
        let prevSeg = leftMostEvt.segment.prevInResult();
        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        while (true) {
          // no segment found, thus no ring can enclose us
          if (!prevSeg) return null;

          // no segments below prev segment found, thus the ring of the prev
          // segment must loop back around and enclose us
          if (!prevPrevSeg) return prevSeg.ringOut;

          // if the two segments are of different rings, the ring of the prev
          // segment must either loop around us or the ring of the prev prev
          // seg, which would make us and the ring of the prev peers
          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
              return prevSeg.ringOut;
            } else return prevSeg.ringOut.enclosingRing();
          }

          // two segments are from the same ring, so this was a penisula
          // of that ring. iterate downward, keep searching
          prevSeg = prevPrevSeg.prevInResult();
          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        }
      }
    }
    class PolyOut {
      constructor(exteriorRing) {
        this.exteriorRing = exteriorRing;
        exteriorRing.poly = this;
        this.interiorRings = [];
      }
      addInterior(ring) {
        this.interiorRings.push(ring);
        ring.poly = this;
      }
      getGeom() {
        const geom = [this.exteriorRing.getGeom()];
        // exterior ring was all (within rounding error of angle calc) colinear points
        if (geom[0] === null) return null;
        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
          const ringGeom = this.interiorRings[i].getGeom();
          // interior ring was all (within rounding error of angle calc) colinear points
          if (ringGeom === null) continue;
          geom.push(ringGeom);
        }
        return geom;
      }
    }
    class MultiPolyOut {
      constructor(rings) {
        this.rings = rings;
        this.polys = this._composePolys(rings);
      }
      getGeom() {
        const geom = [];
        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
          const polyGeom = this.polys[i].getGeom();
          // exterior ring was all (within rounding error of angle calc) colinear points
          if (polyGeom === null) continue;
          geom.push(polyGeom);
        }
        return geom;
      }
      _composePolys(rings) {
        const polys = [];
        for (let i = 0, iMax = rings.length; i < iMax; i++) {
          const ring = rings[i];
          if (ring.poly) continue;
          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
            const enclosingRing = ring.enclosingRing();
            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
            enclosingRing.poly.addInterior(ring);
          }
        }
        return polys;
      }
    }

    /**
     * NOTE:  We must be careful not to change any segments while
     *        they are in the SplayTree. AFAIK, there's no way to tell
     *        the tree to rebalance itself - thus before splitting
     *        a segment that's in the tree, we remove it from the tree,
     *        do the split, then re-insert it. (Even though splitting a
     *        segment *shouldn't* change its correct position in the
     *        sweep line tree, the reality is because of rounding errors,
     *        it sometimes does.)
     */

    class SweepLine {
      constructor(queue) {
        let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;
        this.queue = queue;
        this.tree = new Tree(comparator);
        this.segments = [];
      }
      process(event) {
        const segment = event.segment;
        const newEvents = [];

        // if we've already been consumed by another segment,
        // clean up our body parts and get out
        if (event.consumedBy) {
          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
          return newEvents;
        }
        const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
        if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + "in SweepLine tree.");
        let prevNode = node;
        let nextNode = node;
        let prevSeg = undefined;
        let nextSeg = undefined;

        // skip consumed segments still in tree
        while (prevSeg === undefined) {
          prevNode = this.tree.prev(prevNode);
          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
        }

        // skip consumed segments still in tree
        while (nextSeg === undefined) {
          nextNode = this.tree.next(nextNode);
          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
        }
        if (event.isLeft) {
          // Check for intersections against the previous segment in the sweep line
          let prevMySplitter = null;
          if (prevSeg) {
            const prevInter = prevSeg.getIntersection(segment);
            if (prevInter !== null) {
              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
              if (!prevSeg.isAnEndpoint(prevInter)) {
                const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
            }
          }

          // Check for intersections against the next segment in the sweep line
          let nextMySplitter = null;
          if (nextSeg) {
            const nextInter = nextSeg.getIntersection(segment);
            if (nextInter !== null) {
              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
              if (!nextSeg.isAnEndpoint(nextInter)) {
                const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
            }
          }

          // For simplicity, even if we find more than one intersection we only
          // spilt on the 'earliest' (sweep-line style) of the intersections.
          // The other intersection will be handled in a future process().
          if (prevMySplitter !== null || nextMySplitter !== null) {
            let mySplitter = null;
            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
              const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
            }

            // Rounding errors can cause changes in ordering,
            // so remove afected segments and right sweep events before splitting
            this.queue.remove(segment.rightSE);
            newEvents.push(segment.rightSE);
            const newEventsFromSplit = segment.split(mySplitter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (newEvents.length > 0) {
            // We found some intersections, so re-do the current event to
            // make sure sweep line ordering is totally consistent for later
            // use with the segment 'prev' pointers
            this.tree.remove(segment);
            newEvents.push(event);
          } else {
            // done with left event
            this.segments.push(segment);
            segment.prev = prevSeg;
          }
        } else {
          // event.isRight

          // since we're about to be removed from the sweep line, check for
          // intersections between our previous and next segments
          if (prevSeg && nextSeg) {
            const inter = prevSeg.getIntersection(nextSeg);
            if (inter !== null) {
              if (!prevSeg.isAnEndpoint(inter)) {
                const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
              if (!nextSeg.isAnEndpoint(inter)) {
                const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
            }
          }
          this.tree.remove(segment);
        }
        return newEvents;
      }

      /* Safely split a segment that is currently in the datastructures
       * IE - a segment other than the one that is currently being processed. */
      _splitSafely(seg, pt) {
        // Rounding errors can cause changes in ordering,
        // so remove afected segments and right sweep events before splitting
        // removeNode() doesn't work, so have re-find the seg
        // https://github.com/w8r/splay-tree/pull/5
        this.tree.remove(seg);
        const rightSE = seg.rightSE;
        this.queue.remove(rightSE);
        const newEvents = seg.split(pt);
        newEvents.push(rightSE);
        // splitting can trigger consumption
        if (seg.consumedBy === undefined) this.tree.add(seg);
        return newEvents;
      }
    }

    // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.
    const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
    const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
    class Operation {
      run(type, geom, moreGeoms) {
        operation.type = type;
        rounder.reset();

        /* Convert inputs to MultiPoly objects */
        const multipolys = [new MultiPolyIn(geom, true)];
        for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
          multipolys.push(new MultiPolyIn(moreGeoms[i], false));
        }
        operation.numMultiPolys = multipolys.length;

        /* BBox optimization for difference operation
         * If the bbox of a multipolygon that's part of the clipping doesn't
         * intersect the bbox of the subject at all, we can just drop that
         * multiploygon. */
        if (operation.type === "difference") {
          // in place removal
          const subject = multipolys[0];
          let i = 1;
          while (i < multipolys.length) {
            if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);
          }
        }

        /* BBox optimization for intersection operation
         * If we can find any pair of multipolygons whose bbox does not overlap,
         * then the result will be empty. */
        if (operation.type === "intersection") {
          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
          //       it could be optimized to O(n * ln(n))
          for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
            const mpA = multipolys[i];
            for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
            }
          }
        }

        /* Put segment endpoints in a priority queue */
        const queue = new Tree(SweepEvent.compare);
        for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
          const sweepEvents = multipolys[i].getSweepEvents();
          for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
            queue.insert(sweepEvents[j]);
            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
              // prevents an infinite loop, an otherwise common manifestation of bugs
              throw new Error("Infinite loop when putting segment endpoints in a priority queue " + "(queue size too big).");
            }
          }
        }

        /* Pass the sweep line over those endpoints */
        const sweepLine = new SweepLine(queue);
        let prevQueueSize = queue.size;
        let node = queue.pop();
        while (node) {
          const evt = node.key;
          if (queue.size === prevQueueSize) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            const seg = evt.segment;
            throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
          }
          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            throw new Error("Infinite loop when passing sweep line over endpoints " + "(queue size too big).");
          }
          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            throw new Error("Infinite loop when passing sweep line over endpoints " + "(too many sweep line segments).");
          }
          const newEvents = sweepLine.process(evt);
          for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
            const evt = newEvents[i];
            if (evt.consumedBy === undefined) queue.insert(evt);
          }
          prevQueueSize = queue.size;
          node = queue.pop();
        }

        // free some memory we don't need anymore
        rounder.reset();

        /* Collect and compile segments we're keeping into a multipolygon */
        const ringsOut = RingOut.factory(sweepLine.segments);
        const result = new MultiPolyOut(ringsOut);
        return result.getGeom();
      }
    }

    // singleton available by import
    const operation = new Operation();

    const union = function (geom) {
      for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        moreGeoms[_key - 1] = arguments[_key];
      }
      return operation.run("union", geom, moreGeoms);
    };
    const intersection = function (geom) {
      for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        moreGeoms[_key2 - 1] = arguments[_key2];
      }
      return operation.run("intersection", geom, moreGeoms);
    };
    const xor = function (geom) {
      for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        moreGeoms[_key3 - 1] = arguments[_key3];
      }
      return operation.run("xor", geom, moreGeoms);
    };
    const difference = function (subjectGeom) {
      for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        clippingGeoms[_key4 - 1] = arguments[_key4];
      }
      return operation.run("difference", subjectGeom, clippingGeoms);
    };
    var index = {
      union: union,
      intersection: intersection,
      xor: xor,
      difference: difference
    };

    return index;

}));


/***/ }),

/***/ 9092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(1333);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 9099:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var meta_1 = __webpack_require__(8421);
var topojson_client_1 = __webpack_require__(5681);
var topojson_server_1 = __webpack_require__(6888);
/**
 * Dissolves all overlapping (Multi)Polygon
 *
 * @param {FeatureCollection<Polygon|MultiPolygon>} geojson Polygons to dissolve
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] Prevent input mutation
 * @returns {Feature<Polygon|MultiPolygon>} Dissolved Polygons
 */
function polygonDissolve(geojson, options) {
    if (options === void 0) { options = {}; }
    // Validation
    if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    // Clone geojson to avoid side effects
    // Topojson modifies in place, so we need to deep clone first
    if (options.mutate === false || options.mutate === undefined) {
        geojson = clone_1.default(geojson);
    }
    var geoms = [];
    meta_1.flattenEach(geojson, function (feature) {
        geoms.push(feature.geometry);
    });
    var topo = topojson_server_1.topology({ geoms: helpers_1.geometryCollection(geoms).geometry });
    var merged = topojson_client_1.merge(topo, topo.objects.geoms.geometries);
    return merged;
}
exports["default"] = polygonDissolve;


/***/ }),

/***/ 9164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * BezierSpline
 * https://github.com/leszekr/bezier-spline-js
 *
 * @private
 * @copyright
 * Copyright (c) 2013 Leszek Rybicki
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var Spline = /** @class */ (function () {
    function Spline(options) {
        this.points = options.points || [];
        this.duration = options.duration || 10000;
        this.sharpness = options.sharpness || 0.85;
        this.centers = [];
        this.controls = [];
        this.stepLength = options.stepLength || 60;
        this.length = this.points.length;
        this.delay = 0;
        // this is to ensure compatibility with the 2d version
        for (var i = 0; i < this.length; i++) {
            this.points[i].z = this.points[i].z || 0;
        }
        for (var i = 0; i < this.length - 1; i++) {
            var p1 = this.points[i];
            var p2 = this.points[i + 1];
            this.centers.push({
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
                z: (p1.z + p2.z) / 2,
            });
        }
        this.controls.push([this.points[0], this.points[0]]);
        for (var i = 0; i < this.centers.length - 1; i++) {
            var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
            var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
            var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
            this.controls.push([
                {
                    x: (1.0 - this.sharpness) * this.points[i + 1].x +
                        this.sharpness * (this.centers[i].x + dx),
                    y: (1.0 - this.sharpness) * this.points[i + 1].y +
                        this.sharpness * (this.centers[i].y + dy),
                    z: (1.0 - this.sharpness) * this.points[i + 1].z +
                        this.sharpness * (this.centers[i].z + dz),
                },
                {
                    x: (1.0 - this.sharpness) * this.points[i + 1].x +
                        this.sharpness * (this.centers[i + 1].x + dx),
                    y: (1.0 - this.sharpness) * this.points[i + 1].y +
                        this.sharpness * (this.centers[i + 1].y + dy),
                    z: (1.0 - this.sharpness) * this.points[i + 1].z +
                        this.sharpness * (this.centers[i + 1].z + dz),
                },
            ]);
        }
        this.controls.push([
            this.points[this.length - 1],
            this.points[this.length - 1],
        ]);
        this.steps = this.cacheSteps(this.stepLength);
        return this;
    }
    /**
     * Caches an array of equidistant (more or less) points on the curve.
     */
    Spline.prototype.cacheSteps = function (mindist) {
        var steps = [];
        var laststep = this.pos(0);
        steps.push(0);
        for (var t = 0; t < this.duration; t += 10) {
            var step = this.pos(t);
            var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) +
                (step.y - laststep.y) * (step.y - laststep.y) +
                (step.z - laststep.z) * (step.z - laststep.z));
            if (dist > mindist) {
                steps.push(t);
                laststep = step;
            }
        }
        return steps;
    };
    /**
     * returns angle and speed in the given point in the curve
     */
    Spline.prototype.vector = function (t) {
        var p1 = this.pos(t + 10);
        var p2 = this.pos(t - 10);
        return {
            angle: (180 * Math.atan2(p1.y - p2.y, p1.x - p2.x)) / 3.14,
            speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) +
                (p2.y - p1.y) * (p2.y - p1.y) +
                (p2.z - p1.z) * (p2.z - p1.z)),
        };
    };
    /**
     * Gets the position of the point, given time.
     *
     * WARNING: The speed is not constant. The time it takes between control points is constant.
     *
     * For constant speed, use Spline.steps[i];
     */
    Spline.prototype.pos = function (time) {
        var t = time - this.delay;
        if (t < 0) {
            t = 0;
        }
        if (t > this.duration) {
            t = this.duration - 1;
        }
        // t = t-this.delay;
        var t2 = t / this.duration;
        if (t2 >= 1) {
            return this.points[this.length - 1];
        }
        var n = Math.floor((this.points.length - 1) * t2);
        var t1 = (this.length - 1) * t2 - n;
        return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    return Spline;
}());
exports["default"] = Spline;
function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
        x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
        y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
        z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3],
    };
    return pos;
}
function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
        t3,
        3 * t2 * (1 - t),
        3 * t * (1 - t) * (1 - t),
        (1 - t) * (1 - t) * (1 - t),
    ];
}


/***/ }),

/***/ 9211:
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ 9219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

/*
This file is designed to hold helper functions for drawing to the canvas
*/
__webpack_unused_export__ = ({ value: true });
exports.SA = get_gradient;
__webpack_unused_export__ = color_to_hex;
var colors_1 = __webpack_require__(4392);
/**
 * Applies a linear gradient to a color channel based on its confidence.
 *
 * @param {number} color_channel Color channel
 * @param {number} gradient_strength How strong the gradient is
 * @param {number} confidence Confidence of this particular color channel
 * @param {number} maximum_confidence Maximum confidence to apply the gradient up to
 * @returns {string} A color channel in hexadecimal
 */
function apply_gradient_math(color_channel, gradient_strength, // How strong the gradient is. Number between 0-1
confidence, maximum_confidence) {
    // Calculate the value of the gradient channel
    var gradient_channel = Math.round(((1 - gradient_strength) * (color_channel)) + gradient_strength * 255);
    /* Apply the gradient to the color based on linear gradient from 0 - maximum_confidence, where if the confidence = 0 then the
       color channel will be 100% the gradient_channel, if the confidence is >= the maximum_confidence the color channel won't
       have any gradient applied. The confidence values between 0 - maximum_confidence will have the gradient applied linearly. */
    var new_color = Math.round((1 - (confidence / maximum_confidence)) * gradient_channel + (confidence / maximum_confidence) * color_channel);
    // Convert the color channel to a hexadecimal string
    var new_color_hex = new_color.toString(16);
    // If the value is one digit, pad the front with a 0
    if (new_color_hex.length == 1) {
        new_color_hex = "0" + new_color_hex;
    }
    return new_color_hex;
}
/**
 * Takes in a hex color i.e. "#D973EA", and applies a gradient to it based on a confidence value.
 * @param color_hex
 * @param gradient_strength
 * @param confidence
 * @param maximum_confidence
 * @returns
 */
function apply_gradient(color_hex, gradient_strength, confidence, maximum_confidence) {
    // Grab individual r g b values from the hex string and convert them to decimal
    var r = parseInt(color_hex.slice(1, 3), 16);
    var g = parseInt(color_hex.slice(3, 5), 16);
    var b = parseInt(color_hex.slice(5, 7), 16);
    // Apply the gradient to the rgb values
    var r_with_gradient = apply_gradient_math(r, gradient_strength, confidence, maximum_confidence);
    var g_with_gradient = apply_gradient_math(g, gradient_strength, confidence, maximum_confidence);
    var b_with_gradient = apply_gradient_math(b, gradient_strength, confidence, maximum_confidence);
    // Concatenate the channels together to form the hex
    return "#" + r_with_gradient + g_with_gradient + b_with_gradient;
}
/**
 * Applies a gradient to an annotation_object based on its confidence from the get_annotation_confidence function. If the confidence = 0,
 * the color will be the gradient color. If the confience is >= maximum_confidence, the color won't be changed. The color will change
 * linearly between 0 and maximum_confidence
 *
 * @param {ULabelAnnotation} annotation_object
 * @param {string} base_color
 * @param {Function} get_annotation_confidence
 * @param {number} maximum_confidence
 * @returns
 */
function get_gradient(annotation_object, base_color, get_annotation_confidence, maximum_confidence) {
    // If the gradient toggle is checked off, then don't apply a gradient
    if ($("#gradient-toggle").prop("checked") === false)
        return base_color;
    // Error checking
    if (annotation_object.classification_payloads === null)
        return base_color;
    // Get the annotation confidence
    var confidence = get_annotation_confidence(annotation_object);
    // Only apply a gradient when the confidence is less than the maximum_confidence
    if (confidence >= maximum_confidence)
        return base_color;
    // Convert css color keywords to hex strings
    var base_color_hex = color_to_hex(base_color);
    // Strength of the gradient
    var gradient_strength = 0.85;
    var final_hex = apply_gradient(base_color_hex, gradient_strength, confidence, maximum_confidence);
    // Since hex values should always be a string with length 7, if its not then return the base color just in case.
    if (final_hex.length !== 7)
        return base_color_hex;
    return final_hex;
}
/**
 * Takes in a CSS keyword and returns its corresponding color hex.
 *
 * @param {string} color CSS color keyword or color hex
 * @returns {string} Color hex
 */
function color_to_hex(color) {
    if (color.toLowerCase() in colors_1.VALID_HTML_COLORS)
        return colors_1.VALID_HTML_COLORS[color.toLowerCase()];
    return color;
}


/***/ }),

/***/ 9269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var distance_1 = __importDefault(__webpack_require__(9391));
var intersect_1 = __importDefault(__webpack_require__(9627));
var helpers_1 = __webpack_require__(8967);
/**
 * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
 *
 * @name triangleGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide dimension of each cell
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers
 * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
 * @param {Object} [options.properties={}] passed to each point of the grid
 * @returns {FeatureCollection<Polygon>} grid of polygons
 * @example
 * var bbox = [-95, 30 ,-85, 40];
 * var cellSide = 50;
 * var options = {units: 'miles'};
 *
 * var triangleGrid = turf.triangleGrid(bbox, cellSide, options);
 *
 * //addToMap
 * var addToMap = [triangleGrid];
 */
function triangleGrid(bbox, cellSide, options) {
    if (options === void 0) { options = {}; }
    // Containers
    var results = [];
    // Input Validation is being handled by Typescript
    // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');
    // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');
    // if (!bbox) throw new Error('bbox is required');
    // if (!Array.isArray(bbox)) throw new Error('bbox must be array');
    // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');
    // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');
    // Main
    var xFraction = cellSide / distance_1.default([bbox[0], bbox[1]], [bbox[2], bbox[1]], options);
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSide / distance_1.default([bbox[0], bbox[1]], [bbox[0], bbox[3]], options);
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var xi = 0;
    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            var cellTriangle1 = null;
            var cellTriangle2 = null;
            if (xi % 2 === 0 && yi % 2 === 0) {
                cellTriangle1 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY],
                    ],
                ], options.properties);
                cellTriangle2 = helpers_1.polygon([
                    [
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY + cellHeight],
                    ],
                ], options.properties);
            }
            else if (xi % 2 === 0 && yi % 2 === 1) {
                cellTriangle1 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY],
                    ],
                ], options.properties);
                cellTriangle2 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX, currentY],
                    ],
                ], options.properties);
            }
            else if (yi % 2 === 0 && xi % 2 === 1) {
                cellTriangle1 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX, currentY],
                    ],
                ], options.properties);
                cellTriangle2 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY],
                    ],
                ], options.properties);
            }
            else if (yi % 2 === 1 && xi % 2 === 1) {
                cellTriangle1 = helpers_1.polygon([
                    [
                        [currentX, currentY],
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY],
                    ],
                ], options.properties);
                cellTriangle2 = helpers_1.polygon([
                    [
                        [currentX, currentY + cellHeight],
                        [currentX + cellWidth, currentY + cellHeight],
                        [currentX + cellWidth, currentY],
                        [currentX, currentY + cellHeight],
                    ],
                ], options.properties);
            }
            if (options.mask) {
                if (intersect_1.default(options.mask, cellTriangle1))
                    results.push(cellTriangle1);
                if (intersect_1.default(options.mask, cellTriangle2))
                    results.push(cellTriangle2);
            }
            else {
                results.push(cellTriangle1);
                results.push(cellTriangle2);
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return helpers_1.featureCollection(results);
}
exports["default"] = triangleGrid;


/***/ }),

/***/ 9290:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 9353:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 9383:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 9387:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var meta = __webpack_require__(8421);
var helpers = __webpack_require__(8967);
var clone = __webpack_require__(3711);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);

/**
 * Takes input features and flips all of their coordinates from `[x, y]` to `[y, x]`.
 *
 * @name flip
 * @param {GeoJSON} geojson input features
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
 * @returns {GeoJSON} a feature or set of features of the same type as `input` with flipped coordinates
 * @example
 * var serbia = turf.point([20.566406, 43.421008]);
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //addToMap
 * var addToMap = [serbia, saudiArabia];
 */
function flip(geojson, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var mutate = options.mutate;

  if (!geojson) throw new Error("geojson is required");
  // ensure that we don't modify features in-place and changes to the
  // output do not change the previous feature, including changes to nested
  // properties.
  if (mutate === false || mutate === undefined) geojson = clone__default['default'](geojson);

  meta.coordEach(geojson, function (coord) {
    var x = coord[0];
    var y = coord[1];
    coord[0] = y;
    coord[1] = x;
  });
  return geojson;
}

module.exports = flip;
module.exports["default"] = flip;


/***/ }),

/***/ 9391:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var invariant_1 = __webpack_require__(8506);
var helpers_1 = __webpack_require__(8967);
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord | Point} from origin point or coordinate
 * @param {Coord | Point} to destination point or coordinate
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
    if (options === void 0) { options = {}; }
    var coordinates1 = invariant_1.getCoord(from);
    var coordinates2 = invariant_1.getCoord(to);
    var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);
    var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) +
        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
exports["default"] = distance;


/***/ }),

/***/ 9394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(9211);

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ 9399:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bearing_1 = __importDefault(__webpack_require__(1288));
var destination_1 = __importDefault(__webpack_require__(4202));
var distance_1 = __importDefault(__webpack_require__(9391));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.
 *
 * @name along
 * @param {Feature<LineString>} line input line
 * @param {number} distance distance along the line
 * @param {Object} [options] Optional parameters
 * @param {string} [options.units="kilometers"] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} Point `distance` `units` along the line
 * @example
 * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);
 * var options = {units: 'miles'};
 *
 * var along = turf.along(line, 200, options);
 *
 * //addToMap
 * var addToMap = [along, line]
 */
function along(line, distance, options) {
    if (options === void 0) { options = {}; }
    // Get Coords
    var geom = invariant_1.getGeom(line);
    var coords = geom.coordinates;
    var travelled = 0;
    for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) {
            break;
        }
        else if (travelled >= distance) {
            var overshot = distance - travelled;
            if (!overshot) {
                return helpers_1.point(coords[i]);
            }
            else {
                var direction = bearing_1.default(coords[i], coords[i - 1]) - 180;
                var interpolated = destination_1.default(coords[i], overshot, direction, options);
                return interpolated;
            }
        }
        else {
            travelled += distance_1.default(coords[i], coords[i + 1], options);
        }
    }
    return helpers_1.point(coords[coords.length - 1]);
}
exports["default"] = along;


/***/ }),

/***/ 9538:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 9612:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 9627:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
var polygon_clipping_1 = __importDefault(__webpack_require__(9004));
/**
 * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and
 * finds their polygonal intersection. If they don't intersect, returns null.
 *
 * @name intersect
 * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon
 * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon
 * @param {Object} [options={}] Optional Parameters
 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature
 * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or
 * {@link MultiPolygon}). If they do not share any area, returns `null`.
 * @example
 * var poly1 = turf.polygon([[
 *   [-122.801742, 45.48565],
 *   [-122.801742, 45.60491],
 *   [-122.584762, 45.60491],
 *   [-122.584762, 45.48565],
 *   [-122.801742, 45.48565]
 * ]]);
 *
 * var poly2 = turf.polygon([[
 *   [-122.520217, 45.535693],
 *   [-122.64038, 45.553967],
 *   [-122.720031, 45.526554],
 *   [-122.669906, 45.507309],
 *   [-122.723464, 45.446643],
 *   [-122.532577, 45.408574],
 *   [-122.487258, 45.477466],
 *   [-122.520217, 45.535693]
 * ]]);
 *
 * var intersection = turf.intersect(poly1, poly2);
 *
 * //addToMap
 * var addToMap = [poly1, poly2, intersection];
 */
function intersect(poly1, poly2, options) {
    if (options === void 0) { options = {}; }
    var geom1 = invariant_1.getGeom(poly1);
    var geom2 = invariant_1.getGeom(poly2);
    var intersection = polygon_clipping_1.default.intersection(geom1.coordinates, geom2.coordinates);
    if (intersection.length === 0)
        return null;
    if (intersection.length === 1)
        return helpers_1.polygon(intersection[0], options.properties);
    return helpers_1.multiPolygon(intersection, options.properties);
}
exports["default"] = intersect;


/***/ }),

/***/ 9675:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 9730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var helpers = __webpack_require__(8967);

// http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array

/**
 * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
 *
 * @name sample
 * @param {FeatureCollection} featurecollection set of input features
 * @param {number} num number of features to select
 * @returns {FeatureCollection} a FeatureCollection with `n` features
 * @example
 * var points = turf.randomPoint(100, {bbox: [-80, 30, -60, 60]});
 *
 * var sample = turf.sample(points, 5);
 *
 * //addToMap
 * var addToMap = [points, sample]
 * turf.featureEach(sample, function (currentFeature) {
 *   currentFeature.properties['marker-size'] = 'large';
 *   currentFeature.properties['marker-color'] = '#000';
 * });
 */
function sample(featurecollection, num) {
  if (!featurecollection) throw new Error("featurecollection is required");
  if (num === null || num === undefined) throw new Error("num is required");
  if (typeof num !== "number") throw new Error("num must be a number");

  var outFC = helpers.featureCollection(
    getRandomSubarray(featurecollection.features, num)
  );
  return outFC;
}

function getRandomSubarray(arr, size) {
  var shuffled = arr.slice(0),
    i = arr.length,
    min = i - size,
    temp,
    index;
  while (i-- > min) {
    index = Math.floor((i + 1) * Math.random());
    temp = shuffled[index];
    shuffled[index] = shuffled[i];
    shuffled[i] = temp;
  }
  return shuffled.slice(min);
}

module.exports = sample;
module.exports["default"] = sample;


/***/ }),

/***/ 9736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bbox = __webpack_require__(4383);
var booleanPointInPolygon = __webpack_require__(2446);
var distance = __webpack_require__(9391);
var scale = __webpack_require__(1925);
var cleanCoords = __webpack_require__(2086);
var bboxPolygon = __webpack_require__(3932);
var invariant = __webpack_require__(8506);
var helpers = __webpack_require__(8967);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var booleanPointInPolygon__default = /*#__PURE__*/_interopDefaultLegacy(booleanPointInPolygon);
var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);
var scale__default = /*#__PURE__*/_interopDefaultLegacy(scale);
var cleanCoords__default = /*#__PURE__*/_interopDefaultLegacy(cleanCoords);
var bboxPolygon__default = /*#__PURE__*/_interopDefaultLegacy(bboxPolygon);

// javascript-astar 0.4.1
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

function pathTo(node) {
  var curr = node,
    path = [];
  while (curr.parent) {
    path.unshift(curr);
    curr = curr.parent;
  }
  return path;
}

function getHeap() {
  return new BinaryHeap(function (node) {
    return node.f;
  });
}

/**
 * Astar
 * @private
 */
var astar = {
  /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */
  search: function (graph, start, end, options) {
    graph.cleanDirty();
    options = options || {};
    var heuristic = options.heuristic || astar.heuristics.manhattan,
      closest = options.closest || false;

    var openHeap = getHeap(),
      closestNode = start; // set the start node to be the closest if required

    start.h = heuristic(start, end);

    openHeap.push(start);

    while (openHeap.size() > 0) {
      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
      var currentNode = openHeap.pop();

      // End case -- result has been found, return the traced path.
      if (currentNode === end) {
        return pathTo(currentNode);
      }

      // Normal case -- move currentNode from open to closed, process each of its neighbors.
      currentNode.closed = true;

      // Find all neighbors for the current node.
      var neighbors = graph.neighbors(currentNode);

      for (var i = 0, il = neighbors.length; i < il; ++i) {
        var neighbor = neighbors[i];

        if (neighbor.closed || neighbor.isWall()) {
          // Not a valid node to process, skip to next neighbor.
          continue;
        }

        // The g score is the shortest distance from start to current node.
        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
        var gScore = currentNode.g + neighbor.getCost(currentNode),
          beenVisited = neighbor.visited;

        if (!beenVisited || gScore < neighbor.g) {
          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
          neighbor.visited = true;
          neighbor.parent = currentNode;
          neighbor.h = neighbor.h || heuristic(neighbor, end);
          neighbor.g = gScore;
          neighbor.f = neighbor.g + neighbor.h;
          graph.markDirty(neighbor);
          if (closest) {
            // If the neighbour is closer than the current closestNode or if it's equally close but has
            // a cheaper path than the current closest node then it becomes the closest node
            if (
              neighbor.h < closestNode.h ||
              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)
            ) {
              closestNode = neighbor;
            }
          }

          if (!beenVisited) {
            // Pushing to heap will put it in proper place based on the 'f' value.
            openHeap.push(neighbor);
          } else {
            // Already seen the node, but since it has been rescored we need to reorder it in the heap
            openHeap.rescoreElement(neighbor);
          }
        }
      }
    }

    if (closest) {
      return pathTo(closestNode);
    }

    // No result was found - empty array signifies failure to find path.
    return [];
  },
  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
  heuristics: {
    manhattan: function (pos0, pos1) {
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return d1 + d2;
    },
    diagonal: function (pos0, pos1) {
      var D = 1;
      var D2 = Math.sqrt(2);
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
    },
  },
  cleanNode: function (node) {
    node.f = 0;
    node.g = 0;
    node.h = 0;
    node.visited = false;
    node.closed = false;
    node.parent = null;
  },
};

/**
 * A graph memory structure
 *
 * @private
 * @param {Array} gridIn 2D array of input weights
 * @param {Object} [options] Options
 * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed
 * @returns {void} Graph
 */
function Graph(gridIn, options) {
  options = options || {};
  this.nodes = [];
  this.diagonal = !!options.diagonal;
  this.grid = [];
  for (var x = 0; x < gridIn.length; x++) {
    this.grid[x] = [];

    for (var y = 0, row = gridIn[x]; y < row.length; y++) {
      var node = new GridNode(x, y, row[y]);
      this.grid[x][y] = node;
      this.nodes.push(node);
    }
  }
  this.init();
}

Graph.prototype.init = function () {
  this.dirtyNodes = [];
  for (var i = 0; i < this.nodes.length; i++) {
    astar.cleanNode(this.nodes[i]);
  }
};

Graph.prototype.cleanDirty = function () {
  for (var i = 0; i < this.dirtyNodes.length; i++) {
    astar.cleanNode(this.dirtyNodes[i]);
  }
  this.dirtyNodes = [];
};

Graph.prototype.markDirty = function (node) {
  this.dirtyNodes.push(node);
};

Graph.prototype.neighbors = function (node) {
  var ret = [],
    x = node.x,
    y = node.y,
    grid = this.grid;

  // West
  if (grid[x - 1] && grid[x - 1][y]) {
    ret.push(grid[x - 1][y]);
  }

  // East
  if (grid[x + 1] && grid[x + 1][y]) {
    ret.push(grid[x + 1][y]);
  }

  // South
  if (grid[x] && grid[x][y - 1]) {
    ret.push(grid[x][y - 1]);
  }

  // North
  if (grid[x] && grid[x][y + 1]) {
    ret.push(grid[x][y + 1]);
  }

  if (this.diagonal) {
    // Southwest
    if (grid[x - 1] && grid[x - 1][y - 1]) {
      ret.push(grid[x - 1][y - 1]);
    }

    // Southeast
    if (grid[x + 1] && grid[x + 1][y - 1]) {
      ret.push(grid[x + 1][y - 1]);
    }

    // Northwest
    if (grid[x - 1] && grid[x - 1][y + 1]) {
      ret.push(grid[x - 1][y + 1]);
    }

    // Northeast
    if (grid[x + 1] && grid[x + 1][y + 1]) {
      ret.push(grid[x + 1][y + 1]);
    }
  }

  return ret;
};

Graph.prototype.toString = function () {
  var graphString = [],
    nodes = this.grid, // when using grid
    rowDebug,
    row,
    y,
    l;
  for (var x = 0, len = nodes.length; x < len; x++) {
    rowDebug = [];
    row = nodes[x];
    for (y = 0, l = row.length; y < l; y++) {
      rowDebug.push(row[y].weight);
    }
    graphString.push(rowDebug.join(" "));
  }
  return graphString.join("\n");
};

function GridNode(x, y, weight) {
  this.x = x;
  this.y = y;
  this.weight = weight;
}

GridNode.prototype.toString = function () {
  return "[" + this.x + " " + this.y + "]";
};

GridNode.prototype.getCost = function (fromNeighbor) {
  // Take diagonal weight into consideration.
  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
    return this.weight * 1.41421;
  }
  return this.weight;
};

GridNode.prototype.isWall = function () {
  return this.weight === 0;
};

function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
  push: function (element) {
    // Add the new element to the end of the array.
    this.content.push(element);

    // Allow it to sink down.
    this.sinkDown(this.content.length - 1);
  },
  pop: function () {
    // Store the first element so we can return it later.
    var result = this.content[0];
    // Get the element at the end of the array.
    var end = this.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it bubble up.
    if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
    }
    return result;
  },
  remove: function (node) {
    var i = this.content.indexOf(node);

    // When it is found, the process seen in 'pop' is repeated
    // to fill up the hole.
    var end = this.content.pop();

    if (i !== this.content.length - 1) {
      this.content[i] = end;

      if (this.scoreFunction(end) < this.scoreFunction(node)) {
        this.sinkDown(i);
      } else {
        this.bubbleUp(i);
      }
    }
  },
  size: function () {
    return this.content.length;
  },
  rescoreElement: function (node) {
    this.sinkDown(this.content.indexOf(node));
  },
  sinkDown: function (n) {
    // Fetch the element that has to be sunk.
    var element = this.content[n];

    // When at 0, an element can not sink any further.
    while (n > 0) {
      // Compute the parent element's index, and fetch it.
      var parentN = ((n + 1) >> 1) - 1,
        parent = this.content[parentN];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        // Update 'n' to continue at the new position.
        n = parentN;
        // Found a parent that is less, no need to sink any further.
      } else {
        break;
      }
    }
  },
  bubbleUp: function (n) {
    // Look up the target element and its score.
    var length = this.content.length,
      element = this.content[n],
      elemScore = this.scoreFunction(element);

    while (true) {
      // Compute the indices of the child elements.
      var child2N = (n + 1) << 1,
        child1N = child2N - 1;
      // This is used to store the new position of the element, if any.
      var swap = null,
        child1Score;
      // If the first child exists (is inside the array)...
      if (child1N < length) {
        // Look it up and compute its score.
        var child1 = this.content[child1N];
        child1Score = this.scoreFunction(child1);

        // If the score is less than our element's, we need to swap.
        if (child1Score < elemScore) {
          swap = child1N;
        }
      }

      // Do the same checks for the other child.
      if (child2N < length) {
        var child2 = this.content[child2N],
          child2Score = this.scoreFunction(child2);
        if (child2Score < (swap === null ? elemScore : child1Score)) {
          swap = child2N;
        }
      }

      // If the element needs to be moved, swap it, and continue.
      if (swap !== null) {
        this.content[n] = this.content[swap];
        this.content[swap] = element;
        n = swap;
        // Otherwise, we are done.
      } else {
        break;
      }
    }
  },
};

/**
 * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with
 * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}
 *
 * @name shortestPath
 * @param {Coord} start point
 * @param {Coord} end point
 * @param {Object} [options={}] optional parameters
 * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel
 * @param {number} [options.minDistance] minimum distance between shortest path and obstacles
 * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...
 * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated
 * @returns {Feature<LineString>} shortest path between start and end
 * @example
 * var start = [-5, -6];
 * var end = [9, -6];
 * var options = {
 *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])
 * };
 *
 * var path = turf.shortestPath(start, end, options);
 *
 * //addToMap
 * var addToMap = [start, end, options.obstacles, path];
 */
function shortestPath(start, end, options) {
  // Optional parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error("options is invalid");
  var resolution = options.resolution;
  var minDistance = options.minDistance;
  var obstacles = options.obstacles || helpers.featureCollection([]);

  // validation
  if (!start) throw new Error("start is required");
  if (!end) throw new Error("end is required");
  if ((resolution && !helpers.isNumber(resolution)) || resolution <= 0)
    throw new Error("options.resolution must be a number, greater than 0");
  if (minDistance)
    throw new Error("options.minDistance is not yet implemented");

  // Normalize Inputs
  var startCoord = invariant.getCoord(start);
  var endCoord = invariant.getCoord(end);
  start = helpers.point(startCoord);
  end = helpers.point(endCoord);

  // Handle obstacles
  switch (invariant.getType(obstacles)) {
    case "FeatureCollection":
      if (obstacles.features.length === 0)
        return helpers.lineString([startCoord, endCoord]);
      break;
    case "Polygon":
      obstacles = helpers.featureCollection([helpers.feature(invariant.getGeom(obstacles))]);
      break;
    default:
      throw new Error("invalid obstacles");
  }

  // define path grid area
  var collection = obstacles;
  collection.features.push(start);
  collection.features.push(end);
  var box = bbox__default['default'](scale__default['default'](bboxPolygon__default['default'](bbox__default['default'](collection)), 1.15)); // extend 15%
  if (!resolution) {
    var width = distance__default['default']([box[0], box[1]], [box[2], box[1]], options);
    resolution = width / 100;
  }
  collection.features.pop();
  collection.features.pop();

  var west = box[0];
  var south = box[1];
  var east = box[2];
  var north = box[3];

  var xFraction = resolution / distance__default['default']([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = resolution / distance__default['default']([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);

  var bboxHorizontalSide = east - west;
  var bboxVerticalSide = north - south;
  var columns = Math.floor(bboxHorizontalSide / cellWidth);
  var rows = Math.floor(bboxVerticalSide / cellHeight);
  // adjust origin of the grid
  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;

  // loop through points only once to speed up process
  // define matrix grid for A-star algorithm
  var pointMatrix = [];
  var matrix = [];

  var closestToStart = [];
  var closestToEnd = [];
  var minDistStart = Infinity;
  var minDistEnd = Infinity;
  var currentY = north - deltaY;
  var r = 0;
  while (currentY >= south) {
    // var currentY = south + deltaY;
    var matrixRow = [];
    var pointMatrixRow = [];
    var currentX = west + deltaX;
    var c = 0;
    while (currentX <= east) {
      var pt = helpers.point([currentX, currentY]);
      var isInsideObstacle = isInside(pt, obstacles);
      // feed obstacles matrix
      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar
      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea
      // map point's coords
      pointMatrixRow.push(currentX + "|" + currentY);
      // set closest points
      var distStart = distance__default['default'](pt, start);
      // if (distStart < minDistStart) {
      if (!isInsideObstacle && distStart < minDistStart) {
        minDistStart = distStart;
        closestToStart = { x: c, y: r };
      }
      var distEnd = distance__default['default'](pt, end);
      // if (distEnd < minDistEnd) {
      if (!isInsideObstacle && distEnd < minDistEnd) {
        minDistEnd = distEnd;
        closestToEnd = { x: c, y: r };
      }
      currentX += cellWidth;
      c++;
    }
    matrix.push(matrixRow);
    pointMatrix.push(pointMatrixRow);
    currentY -= cellHeight;
    r++;
  }

  // find path on matrix grid

  // javascript-astar ----------------------
  var graph = new Graph(matrix, { diagonal: true });
  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
  var result = astar.search(graph, startOnMatrix, endOnMatrix);

  var path = [startCoord];
  result.forEach(function (coord) {
    var coords = pointMatrix[coord.x][coord.y].split("|");
    path.push([+coords[0], +coords[1]]); // make sure coords are numbers
  });
  path.push(endCoord);
  // ---------------------------------------

  // astar-andrea ------------------------
  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');
  // var path = [start.geometry.coordinates];
  // result.forEach(function (coord) {
  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');
  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers
  // });
  // path.push(end.geometry.coordinates);
  // ---------------------------------------

  return cleanCoords__default['default'](helpers.lineString(path));
}

/**
 * Checks if Point is inside any of the Polygons
 *
 * @private
 * @param {Feature<Point>} pt to check
 * @param {FeatureCollection<Polygon>} polygons features
 * @returns {boolean} if inside or not
 */
function isInside(pt, polygons) {
  for (var i = 0; i < polygons.features.length; i++) {
    if (booleanPointInPolygon__default['default'](pt, polygons.features[i])) {
      return true;
    }
  }
  return false;
}

module.exports = shortestPath;
module.exports["default"] = shortestPath;


/***/ }),

/***/ 9739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = __webpack_require__(9092)();

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),

/***/ 9778:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://en.wikipedia.org/wiki/Rhumb_line
var helpers_1 = __webpack_require__(8967);
var invariant_1 = __webpack_require__(8506);
/**
 * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,
 * miles, or kilometers.
 *
 * @name rhumbDistance
 * @param {Coord} from origin point
 * @param {Coord} to destination point
 * @param {Object} [options] Optional parameters
 * @param {string} [options.units="kilometers"] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.rhumbDistance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function rhumbDistance(from, to, options) {
    if (options === void 0) { options = {}; }
    var origin = invariant_1.getCoord(from);
    var destination = invariant_1.getCoord(to);
    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
    destination[0] +=
        destination[0] - origin[0] > 180
            ? -360
            : origin[0] - destination[0] > 180
                ? 360
                : 0;
    var distanceInMeters = calculateRhumbDistance(origin, destination);
    var distance = helpers_1.convertLength(distanceInMeters, "meters", options.units);
    return distance;
}
/**
 * Returns the distance travelling from this point to destination point along a rhumb line.
 * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js
 *
 * @private
 * @param   {Array<number>} origin point.
 * @param   {Array<number>} destination point.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {number} Distance in km between this point and destination point (same units as radius).
 *
 * @example
 *     var p1 = new LatLon(51.127, 1.338);
 *     var p2 = new LatLon(50.964, 1.853);
 *     var d = p1.distanceTo(p2); // 40.31 km
 */
function calculateRhumbDistance(origin, destination, radius) {
    //  => phi
    //  => lambda
    //  => psi
    //  => Delta
    //  => delta
    //  => theta
    radius = radius === undefined ? helpers_1.earthRadius : Number(radius);
    // see www.edwilliams.org/avform.htm#Rhumb
    var R = radius;
    var phi1 = (origin[1] * Math.PI) / 180;
    var phi2 = (destination[1] * Math.PI) / 180;
    var DeltaPhi = phi2 - phi1;
    var DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;
    // if dLon over 180 take shorter rhumb line across the anti-meridian:
    if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
    }
    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'
    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it
    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    // distance is pythagoras on 'stretched' Mercator projection
    var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians
    var dist = delta * R;
    return dist;
}
exports["default"] = rhumbDistance;


/***/ }),

/***/ 9791:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clone_1 = __importDefault(__webpack_require__(3711));
var distance_1 = __importDefault(__webpack_require__(9391));
var meta_1 = __webpack_require__(8421);
/**
 * Takes a reference {@link Point|point} and a FeatureCollection of Features
 * with Point geometries and returns the
 * point from the FeatureCollection closest to the reference. This calculation
 * is geodesic.
 *
 * @name nearestPoint
 * @param {Coord} targetPoint the reference point
 * @param {FeatureCollection<Point>} points against input point set
 * @returns {Feature<Point>} the closest point in the set to the reference point
 * @example
 * var targetPoint = turf.point([28.965797, 41.010086], {"marker-color": "#0F0"});
 * var points = turf.featureCollection([
 *     turf.point([28.973865, 41.011122]),
 *     turf.point([28.948459, 41.024204]),
 *     turf.point([28.938674, 41.013324])
 * ]);
 *
 * var nearest = turf.nearestPoint(targetPoint, points);
 *
 * //addToMap
 * var addToMap = [targetPoint, points, nearest];
 * nearest.properties['marker-color'] = '#F00';
 */
function nearestPoint(targetPoint, points) {
    // Input validation
    if (!targetPoint)
        throw new Error("targetPoint is required");
    if (!points)
        throw new Error("points is required");
    var nearest;
    var minDist = Infinity;
    var bestFeatureIndex = 0;
    meta_1.featureEach(points, function (pt, featureIndex) {
        var distanceToPoint = distance_1.default(targetPoint, pt);
        if (distanceToPoint < minDist) {
            bestFeatureIndex = featureIndex;
            minDist = distanceToPoint;
        }
    });
    nearest = clone_1.default(points.features[bestFeatureIndex]);
    nearest.properties.featureIndex = bestFeatureIndex;
    nearest.properties.distanceToPoint = minDist;
    return nearest;
}
exports["default"] = nearestPoint;


/***/ }),

/***/ 9929:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.D = void 0;
var ULabelSubtask = /** @class */ (function () {
    function ULabelSubtask(display_name, classes, allowed_modes, resume_from, 
    // TODO (joshua-dean): Is `task_meta` even used?
    task_meta, 
    /**
     * TODO (joshua-dean): Is `annotation_meta` even used?
     * It gets loaded/saved, but I don't see it being used anywhere
     * If it's specifically for user-defined meta that we shouldn't touch,
     * Then that should be documented
     */
    annotation_meta, read_only, inactive_opacity) {
        if (inactive_opacity === void 0) { inactive_opacity = 0.4; }
        this.display_name = display_name;
        this.classes = classes;
        this.allowed_modes = allowed_modes;
        this.resume_from = resume_from;
        this.task_meta = task_meta;
        this.annotation_meta = annotation_meta;
        this.read_only = read_only;
        this.inactive_opacity = inactive_opacity;
        this.class_ids = [];
        this.actions = {
            stream: [],
            undone_stack: [],
        };
    }
    ULabelSubtask.from_json = function (subtask_key, subtask_json) {
        var ret = new ULabelSubtask(subtask_json["display_name"], subtask_json["classes"], subtask_json["allowed_modes"], subtask_json["resume_from"], subtask_json["task_meta"], subtask_json["annotation_meta"]);
        ret.read_only = ("read_only" in subtask_json) && (subtask_json["read_only"] === true);
        if ("inactive_opacity" in subtask_json && typeof subtask_json["inactive_opacity"] == "number") {
            ret.inactive_opacity = Math.min(Math.max(subtask_json["inactive_opacity"], 0.0), 1.0);
        }
        return ret;
    };
    return ULabelSubtask;
}());
exports.D = ULabelSubtask;
// export type ULabelSubtasks = { [key: string]: ULabelSubtask };


/***/ }),

/***/ 9933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bbox = __webpack_require__(4383);
var hexGrid = __webpack_require__(7564);
var pointGrid = __webpack_require__(7497);
var distance = __webpack_require__(9391);
var centroid = __webpack_require__(4408);
var squareGrid = __webpack_require__(4512);
var triangleGrid = __webpack_require__(9269);
var clone = __webpack_require__(3711);
var helpers = __webpack_require__(8967);
var meta = __webpack_require__(8421);
var invariant = __webpack_require__(8506);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bbox__default = /*#__PURE__*/_interopDefaultLegacy(bbox);
var hexGrid__default = /*#__PURE__*/_interopDefaultLegacy(hexGrid);
var pointGrid__default = /*#__PURE__*/_interopDefaultLegacy(pointGrid);
var distance__default = /*#__PURE__*/_interopDefaultLegacy(distance);
var centroid__default = /*#__PURE__*/_interopDefaultLegacy(centroid);
var squareGrid__default = /*#__PURE__*/_interopDefaultLegacy(squareGrid);
var triangleGrid__default = /*#__PURE__*/_interopDefaultLegacy(triangleGrid);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);

/**
 * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).
 *
 * @name interpolate
 * @param {FeatureCollection<Point>} points with known value
 * @param {number} cellSize the distance across each grid point
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')
 * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.
 * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @param {number} [options.weight=1] exponent regulating the distance-decay weighting
 * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'
 * @example
 * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});
 *
 * // add a random property to each point
 * turf.featureEach(points, function(point) {
 *     point.properties.solRad = Math.random() * 50;
 * });
 * var options = {gridType: 'points', property: 'solRad', units: 'miles'};
 * var grid = turf.interpolate(points, 100, options);
 *
 * //addToMap
 * var addToMap = [grid];
 */
function interpolate(points, cellSize, options) {
  // Optional parameters
  options = options || {};
  if (typeof options !== "object") throw new Error("options is invalid");
  var gridType = options.gridType;
  var property = options.property;
  var weight = options.weight;

  // validation
  if (!points) throw new Error("points is required");
  invariant.collectionOf(points, "Point", "input must contain Points");
  if (!cellSize) throw new Error("cellSize is required");
  if (weight !== undefined && typeof weight !== "number")
    throw new Error("weight must be a number");

  // default values
  property = property || "elevation";
  gridType = gridType || "square";
  weight = weight || 1;

  var box = bbox__default['default'](points);
  var grid;
  switch (gridType) {
    case "point":
    case "points":
      grid = pointGrid__default['default'](box, cellSize, options);
      break;
    case "square":
    case "squares":
      grid = squareGrid__default['default'](box, cellSize, options);
      break;
    case "hex":
    case "hexes":
      grid = hexGrid__default['default'](box, cellSize, options);
      break;
    case "triangle":
    case "triangles":
      grid = triangleGrid__default['default'](box, cellSize, options);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var results = [];
  meta.featureEach(grid, function (gridFeature) {
    var zw = 0;
    var sw = 0;
    // calculate the distance from each input point to the grid points
    meta.featureEach(points, function (point) {
      var gridPoint =
        gridType === "point" ? gridFeature : centroid__default['default'](gridFeature);
      var d = distance__default['default'](gridPoint, point, options);
      var zValue;
      // property has priority for zValue, fallbacks to 3rd coordinate from geometry
      if (property !== undefined) zValue = point.properties[property];
      if (zValue === undefined) zValue = point.geometry.coordinates[2];
      if (zValue === undefined) throw new Error("zValue is missing");
      if (d === 0) zw = zValue;
      var w = 1.0 / Math.pow(d, weight);
      sw += w;
      zw += w * zValue;
    });
    // write interpolated value for each grid point
    var newFeature = clone__default['default'](gridFeature);
    newFeature.properties[property] = zw / sw;
    results.push(newFeature);
  });
  return helpers.featureCollection(results);
}

module.exports = interpolate;
module.exports["default"] = interpolate;


/***/ }),

/***/ 9957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(6743);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 9977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __webpack_require__(4898);
var helpers_1 = __webpack_require__(8967);
var envelope_1 = __importDefault(__webpack_require__(2120));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(2446));
/**
 * Ring of edges which form a polygon.
 *
 * The ring may be either an outer shell or a hole.
 *
 * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing
 */
var EdgeRing = /** @class */ (function () {
    function EdgeRing() {
        this.edges = [];
        this.polygon = undefined; //< Caches Polygon representation
        this.envelope = undefined; //< Caches Envelope representation
    }
    /**
     * Add an edge to the ring, inserting it in the last position.
     *
     * @memberof EdgeRing
     * @param {Edge} edge - Edge to be inserted
     */
    EdgeRing.prototype.push = function (edge) {
        this.edges.push(edge);
        this.polygon = this.envelope = undefined;
    };
    /**
     * Get Edge.
     *
     * @memberof EdgeRing
     * @param {number} i - Index
     * @returns {Edge} - Edge in the i position
     */
    EdgeRing.prototype.get = function (i) {
        return this.edges[i];
    };
    Object.defineProperty(EdgeRing.prototype, "length", {
        /**
         * Getter of length property.
         *
         * @memberof EdgeRing
         * @returns {number} - Length of the edge ring.
         */
        get: function () {
            return this.edges.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
     *
     * @memberof EdgeRing
     * @param {Function} f - The same function to be passed to Array.prototype.forEach
     */
    EdgeRing.prototype.forEach = function (f) {
        this.edges.forEach(f);
    };
    /**
     * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
     *
     * @memberof EdgeRing
     * @param {Function} f - The same function to be passed to Array.prototype.map
     * @returns {Array} - The mapped values in the function
     */
    EdgeRing.prototype.map = function (f) {
        return this.edges.map(f);
    };
    /**
     * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
     *
     * @memberof EdgeRing
     * @param {Function} f - The same function to be passed to Array.prototype.some
     * @returns {boolean} - True if an Edge check the condition
     */
    EdgeRing.prototype.some = function (f) {
        return this.edges.some(f);
    };
    /**
     * Check if the ring is valid in geomtry terms.
     *
     * A ring must have either 0 or 4 or more points. The first and the last must be
     * equal (in 2D)
     * geos::geom::LinearRing::validateConstruction
     *
     * @memberof EdgeRing
     * @returns {boolean} - Validity of the EdgeRing
     */
    EdgeRing.prototype.isValid = function () {
        // TODO: stub
        return true;
    };
    /**
     * Tests whether this ring is a hole.
     *
     * A ring is a hole if it is oriented counter-clockwise.
     * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
     *
     * @memberof EdgeRing
     * @returns {boolean} - true: if it is a hole
     */
    EdgeRing.prototype.isHole = function () {
        var _this = this;
        // XXX: Assuming Ring is valid
        // Find highest point
        var hiIndex = this.edges.reduce(function (high, edge, i) {
            if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
                high = i;
            return high;
        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = util_1.orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
        if (disc === 0)
            return (this.edges[iPrev].from.coordinates[0] >
                this.edges[iNext].from.coordinates[0]);
        return disc > 0;
    };
    /**
     * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
     *
     * @memberof EdgeRing
     * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
     */
    EdgeRing.prototype.toMultiPoint = function () {
        return helpers_1.multiPoint(this.edges.map(function (edge) { return edge.from.coordinates; }));
    };
    /**
     * Creates a Polygon representing the EdgeRing.
     *
     * @memberof EdgeRing
     * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
     */
    EdgeRing.prototype.toPolygon = function () {
        if (this.polygon)
            return this.polygon;
        var coordinates = this.edges.map(function (edge) { return edge.from.coordinates; });
        coordinates.push(this.edges[0].from.coordinates);
        return (this.polygon = helpers_1.polygon([coordinates]));
    };
    /**
     * Calculates the envelope of the EdgeRing.
     *
     * @memberof EdgeRing
     * @returns {Feature<Polygon>} - envelope
     */
    EdgeRing.prototype.getEnvelope = function () {
        if (this.envelope)
            return this.envelope;
        return (this.envelope = envelope_1.default(this.toPolygon()));
    };
    /**
     * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
     *
     * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
     * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
     *
     * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
     */
    EdgeRing.findEdgeRingContaining = function (testEdgeRing, shellList) {
        var testEnvelope = testEdgeRing.getEnvelope();
        var minEnvelope, minShell;
        shellList.forEach(function (shell) {
            var tryEnvelope = shell.getEnvelope();
            if (minShell)
                minEnvelope = minShell.getEnvelope();
            // the hole envelope cannot equal the shell envelope
            if (util_1.envelopeIsEqual(tryEnvelope, testEnvelope))
                return;
            if (util_1.envelopeContains(tryEnvelope, testEnvelope)) {
                var testEdgeRingCoordinates = testEdgeRing.map(function (edge) { return edge.from.coordinates; });
                var testPoint = void 0;
                var _loop_1 = function (pt) {
                    if (!shell.some(function (edge) { return util_1.coordinatesEqual(pt, edge.from.coordinates); })) {
                        testPoint = pt;
                    }
                };
                for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
                    var pt = testEdgeRingCoordinates_1[_i];
                    _loop_1(pt);
                }
                if (testPoint && shell.inside(helpers_1.point(testPoint))) {
                    if (!minShell || util_1.envelopeContains(minEnvelope, tryEnvelope))
                        minShell = shell;
                }
            }
        });
        return minShell;
    };
    /**
     * Checks if the point is inside the edgeRing
     *
     * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
     * @returns {boolean} - True if it is inside, False otherwise
     */
    EdgeRing.prototype.inside = function (pt) {
        return boolean_point_in_polygon_1.default(pt, this.toPolygon());
    };
    return EdgeRing;
}());
exports["default"] = EdgeRing;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(7105);
/******/ 	exports.ULabel = __webpack_exports__["default"];
/******/ 	
/******/ })()
;